PC     Output      Line
040000             0001        assume adl=1
040000             0002        org 0x040000
040000 C3 45 00 04 0003        jp start
040004             0004        align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0005        db "MOS"
040043 00          0006        db 00h
040044 01          0007        db 01h
040045             0008    
040045             0009    start:
040045 F5          0010        push af
040046 C5          0011        push bc
040047 D5          0012        push de
040048 DD E5       0013        push ix
04004A FD E5       0014        push iy
04004C             0015    
04004C CD 1A 2A 04 0016        call init
040050 CD 59 2A 04 0017        call main
040054             0018    
040054             0019    exit:
040054 FD E1       0020        pop iy
040056 DD E1       0021        pop ix
040058 D1          0022        pop de
040059 C1          0023        pop bc
04005A F1          0024        pop af
04005B 21 00 00 00 0025        ld hl,0
04005F             0026    
04005F C9          0027        ret
040060             0028    
040060             0029    ; API INCLUDES
040060             0030        include "mos_api.inc"
040060             0001*   ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.inc
040060             0002*   ; Title:	AGON MOS - API for user projects
040060             0003*   ; Author:	Dean Belfield
040060             0004*   ;			Adapted for agon-ez80asm by Jeroen Venema
040060             0005*   ;			Added MOS error codes for return in HL
040060             0006*   ; Created:	03/08/2022
040060             0007*   ; Last Updated:	10/08/2023
040060             0008*   ;
040060             0009*   ; Modinfo:
040060             0010*   ; 05/08/2022:	Added mos_feof
040060             0011*   ; 09/08/2022:	Added system variables: cursorX, cursorY
040060             0012*   ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040060             0013*   ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040060             0014*   ; 24/09/2022:	Added mos_getError, mos_mkdir
040060             0015*   ; 13/10/2022:	Added mos_oscli
040060             0016*   ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040060             0017*   ; 04/03/2023:	Added sysvar_scrpixelIndex
040060             0018*   ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040060             0019*   ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040060             0020*   ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040060             0021*   ; 22/03/2023:	The VDP commands are now indexed from 0x80
040060             0022*   ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040060             0023*   ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040060             0024*   ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040060             0025*   ; 19/05/2023:	Added sysvar_scrMode
040060             0026*   ; 05/06/2023:	Added sysvar_rtcEnable
040060             0027*   ; 03/08/2023:	Added mos_setkbvector
040060             0028*   ; 10/08/2023:	Added mos_getkbmap
040060             0029*   
040060             0030*   ; VDP control (VDU 23, 0, n)
040060             0031*   ;
040060             0032*   vdp_gp:				EQU 80h
040060             0033*   vdp_keycode:		EQU 81h
040060             0034*   vdp_cursor:			EQU	82h
040060             0035*   vdp_scrchar:		EQU	83h
040060             0036*   vdp_scrpixel:		EQU	84h
040060             0037*   vdp_audio:			EQU	85h
040060             0038*   vdp_mode:			EQU	86h
040060             0039*   vdp_rtc:			EQU	87h
040060             0040*   vdp_keystate:		EQU	88h
040060             0041*   vdp_logicalcoords:	EQU	C0h
040060             0042*   vdp_terminalmode:	EQU	FFh
040060             0043*   
040060             0044*   ; MOS high level functions
040060             0045*   ;
040060             0046*   mos_getkey:			EQU	00h
040060             0047*   mos_load:			EQU	01h
040060             0048*   mos_save:			EQU	02h
040060             0049*   mos_cd:				EQU	03h
040060             0050*   mos_dir:			EQU	04h
040060             0051*   mos_del:			EQU	05h
040060             0052*   mos_ren:			EQU	06h
040060             0053*   mos_mkdir:			EQU	07h
040060             0054*   mos_sysvars:		EQU	08h
040060             0055*   mos_editline:		EQU	09h
040060             0056*   mos_fopen:			EQU	0Ah
040060             0057*   mos_fclose:			EQU	0Bh
040060             0058*   mos_fgetc:			EQU	0Ch
040060             0059*   mos_fputc:			EQU	0Dh
040060             0060*   mos_feof:			EQU	0Eh
040060             0061*   mos_getError:		EQU	0Fh
040060             0062*   mos_oscli:			EQU	10h
040060             0063*   mos_copy:			EQU	11h
040060             0064*   mos_getrtc:			EQU	12h
040060             0065*   mos_setrtc:			EQU	13h
040060             0066*   mos_setintvector:	EQU	14h
040060             0067*   mos_uopen:			EQU	15h
040060             0068*   mos_uclose:			EQU	16h
040060             0069*   mos_ugetc:			EQU	17h
040060             0070*   mos_uputc:			EQU	18h
040060             0071*   mos_getfil:			EQU	19h
040060             0072*   mos_fread:			EQU	1Ah
040060             0073*   mos_fwrite:			EQU	1Bh
040060             0074*   mos_flseek:			EQU	1Ch
040060             0075*   mos_setkbvector:	EQU	1Dh
040060             0076*   mos_getkbmap:		EQU	1Eh
040060             0077*   
040060             0078*   ; MOS program exit codes
040060             0079*   ;
040060             0080*   EXIT_OK:				EQU  0;	"OK",
040060             0081*   EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
040060             0082*   EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
040060             0083*   EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
040060             0084*   EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
040060             0085*   EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
040060             0086*   EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
040060             0087*   EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
040060             0088*   EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
040060             0089*   EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
040060             0090*   EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
040060             0091*   EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
040060             0092*   EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
040060             0093*   EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
040060             0094*   EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
040060             0095*   EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
040060             0096*   EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
040060             0097*   EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
040060             0098*   EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
040060             0099*   EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
040060             0100*   EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
040060             0101*   EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
040060             0102*   ; FatFS file access functions
040060             0103*   ;
040060             0104*   ffs_fopen:			EQU	80h
040060             0105*   ffs_fclose:			EQU	81h
040060             0106*   ffs_fread:			EQU	82h
040060             0107*   ffs_fwrite:			EQU	83h
040060             0108*   ffs_flseek:			EQU	84h
040060             0109*   ffs_ftruncate:		EQU	85h
040060             0110*   ffs_fsync:			EQU	86h
040060             0111*   ffs_fforward:		EQU	87h
040060             0112*   ffs_fexpand:		EQU	88h
040060             0113*   ffs_fgets:			EQU	89h
040060             0114*   ffs_fputc:			EQU	8Ah
040060             0115*   ffs_fputs:			EQU	8Bh
040060             0116*   ffs_fprintf:		EQU	8Ch
040060             0117*   ffs_ftell:			EQU	8Dh
040060             0118*   ffs_feof:			EQU	8Eh
040060             0119*   ffs_fsize:			EQU	8Fh
040060             0120*   ffs_ferror:			EQU	90h
040060             0121*   
040060             0122*   ; FatFS directory access functions
040060             0123*   ;
040060             0124*   ffs_dopen:			EQU	91h
040060             0125*   ffs_dclose:			EQU	92h
040060             0126*   ffs_dread:			EQU	93h
040060             0127*   ffs_dfindfirst:		EQU	94h
040060             0128*   ffs_dfindnext:		EQU	95h
040060             0129*   
040060             0130*   ; FatFS file and directory management functions
040060             0131*   ;
040060             0132*   ffs_stat:			EQU	96h
040060             0133*   ffs_unlink:			EQU	97h
040060             0134*   ffs_rename:			EQU	98h
040060             0135*   ffs_chmod:			EQU	99h
040060             0136*   ffs_utime:			EQU	9Ah
040060             0137*   ffs_mkdir:			EQU	9Bh
040060             0138*   ffs_chdir:			EQU	9Ch
040060             0139*   ffs_chdrive:		EQU	9Dh
040060             0140*   ffs_getcwd:			EQU	9Eh
040060             0141*   
040060             0142*   ; FatFS volume management and system configuration functions
040060             0143*   ;
040060             0144*   ffs_mount:			EQU	9Fh
040060             0145*   ffs_mkfs:			EQU	A0h
040060             0146*   ffs_fdisk:			EQU	A1h
040060             0147*   ffs_getfree:		EQU	A2h
040060             0148*   ffs_getlabel:		EQU	A3h
040060             0149*   ffs_setlabel:		EQU	A4h
040060             0150*   ffs_setcp:			EQU	A5h
040060             0151*   
040060             0152*   ; File access modes
040060             0153*   ;
040060             0154*   fa_read:			EQU	01h
040060             0155*   fa_write:			EQU	02h
040060             0156*   fa_open_existing:	EQU	00h
040060             0157*   fa_create_new:		EQU	04h
040060             0158*   fa_create_always:	EQU	08h
040060             0159*   fa_open_always:		EQU	10h
040060             0160*   fa_open_append:		EQU	30h
040060             0161*   
040060             0162*   ; System variable indexes for api_sysvars
040060             0163*   ; Index into _sysvars in globals.inc
040060             0164*   ;
040060             0165*   sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040060             0166*   sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
040060             0167*   sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040060             0168*   sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
040060             0169*   sysvar_cursorX:			EQU	07h	; 1: Cursor X position
040060             0170*   sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
040060             0171*   sysvar_scrchar:			EQU	09h	; 1: Character read from screen
040060             0172*   sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040060             0173*   sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040060             0174*   sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040060             0175*   sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
040060             0176*   sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
040060             0177*   sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
040060             0178*   sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
040060             0179*   sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
040060             0180*   sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040060             0181*   sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
040060             0182*   sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040060             0183*   sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
040060             0184*   sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
040060             0185*   sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
040060             0186*   sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
040060             0187*   sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
040060             0188*   sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
040060             0189*   sysvar_scrMode:			EQU	27h	; 1: Screen mode
040060             0190*   sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040060             0191*   
040060             0192*   ; Flags for the VPD protocol
040060             0193*   ;
040060             0194*   vdp_pflag_cursor:		EQU	00000001b
040060             0195*   vdp_pflag_scrchar:		EQU	00000010b
040060             0196*   vdp_pflag_point:		EQU	00000100b
040060             0197*   vdp_pflag_audio:		EQU	00001000b
040060             0198*   vdp_pflag_mode:			EQU	00010000b
040060             0199*   vdp_pflag_rtc:			EQU	00100000b
040060             0200*   
040060             0201*   ;
040060             0202*   ; FatFS structures
040060             0203*   ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040060             0204*   ;
040060             0205*   ; Object ID and allocation information (FFOBJID)
040060             0206*   ;
040060             0207*   ; Indexes into FFOBJID structure
040060             0208*   ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
040060             0209*   ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
040060             0210*   ffobjid_attr:		EQU	5	; 1: Object attribute
040060             0211*   ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040060             0212*   ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
040060             0213*   ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
040060             0214*   ;
040060             0215*   ; File object structure (FIL)
040060             0216*   ;
040060             0217*   ; Indexes into FIL structure
040060             0218*   fil_obj:		EQU 0	; 15: Object identifier
040060             0219*   fil_flag:		EQU	15 	;  1: File status flags
040060             0220*   fil_err:		EQU	16	;  1: Abort flag (error code)
040060             0221*   fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
040060             0222*   fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
040060             0223*   fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
040060             0224*   fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
040060             0225*   fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
040060             0226*   ;
040060             0227*   ; Directory object structure (DIR)
040060             0228*   ; Indexes into DIR structure
040060             0229*   dir_obj:		EQU  0	; 15: Object identifier
040060             0230*   dir_dptr:		EQU	15	;  4: Current read/write offset
040060             0231*   dir_clust:		EQU	19	;  4: Current cluster
040060             0232*   dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
040060             0233*   dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
040060             0234*   dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
040060             0235*   dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040060             0236*   ;
040060             0237*   ; File information structure (FILINFO)
040060             0238*   ;
040060             0239*   ; Indexes into FILINFO structure
040060             0240*   filinfo_fsize:		EQU 0	;   4: File size
040060             0241*   filinfo_fdate:		EQU	4	;   2: Modified date
040060             0242*   filinfo_ftime:		EQU	6	;   2: Modified time
040060             0243*   filinfo_fattrib:	EQU	8	;   1: File attribute
040060             0244*   filinfo_altname:	EQU	9	;  13: Alternative file name
040060             0245*   filinfo_fname:		EQU	22	; 256: Primary file name
040060             0246*   filinfo_struct_size: EQU filinfo_fname+256 ; size of the FILINFO structure
040060             0247*   
040060             0248*   ; /* File attribute bits for directory entry (FILINFO.fattrib) */
040060             0249*   AM_RDO: equ 0x01 ; Read only
040060             0250*   AM_HID: equ 0x02 ; Hidden
040060             0251*   AM_SYS: equ 0x04 ; System
040060             0252*   AM_DIR: equ 0x10 ; Directory
040060             0253*   AM_ARC: equ 0x20 ; Archive
040060             0254*   ;
040060             0255*   ; Macro for calling the API
040060             0256*   ; Parameters:
040060             0257*   ; - function: One of the function numbers listed above
040060             0258*   ;
040060             0259*   	MACRO	MOSCALL	function
040060             0260*   			LD	A, function
040060             0261*   			RST.LIL	08h
040060             0262*   	ENDMACRO
040060             0031        include "macros.inc"
040060             0001*   
040060             0002*   ; test the sign of HL
040060             0003*   ; inputs: HL obviously
040060             0004*   ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
040060             0005*   ; destroys: flags
040060             0006*       MACRO SIGN_HLU
040060             0007*       add hl,de ; 1 cycle
040060             0008*       or a ; clear flags ; 1 cycle
040060             0009*       sbc hl,de ; 2 cycles
040060             0010*       ; 4 cycles total
040060             0011*       ENDMACRO
040060             0012*   
040060             0013*   ; put the value in A into HLU
040060             0014*   ; affects: HLU
040060             0015*   ; destroys: nothing
040060             0016*   ; note: $ instead of @@ b/c anon labels deprecated in ez80asm
040060             0017*       MACRO A_TO_HLU
040060             0018*       xor a ; 1 cycle
040060             0019*       ld ($+8+1),hl ; 7 cycles
040060             0020*       ld ($+4+3),a ; 5 cycles
040060             0021*       ld hl,0x000000 ; 4 cycles
040060             0022*       ; 17 cycles total
040060             0023*       ENDMACRO
040060             0024*   
040060             0025*   ; alternative: https://discord.com/channels/1158535358624039014/1282290921815408681/1318315567102300220
040060             0026*   ; one cycle less but burns flags
040060             0027*       MACRO A_TO_HLU_ALT
040060             0028*       push hl ; 4 cycles
040060             0029*       ld hl,2 ; 4 cycles
040060             0030*       add hl,sp ; 1 cycle
040060             0031*       ld (hl),a ; 2 cycles
040060             0032*       pop hl ; 4 cycles
040060             0033*       ; 15 cycles total
040060             0034*       ENDMACRO
040060             0035*   
040060             0036*       MACRO hlu_mul256
040060             0037*       add hl,hl ; * 2
040060             0038*       add hl,hl ; * 4
040060             0039*       add hl,hl ; * 8
040060             0040*       add hl,hl ; * 16
040060             0041*       add hl,hl ; * 32
040060             0042*       add hl,hl ; * 64
040060             0043*       add hl,hl ; * 128
040060             0044*       add hl,hl ; * 256
040060             0045*       ENDMACRO
040060             0046*   
040060             0047*   ; https://discord.com/channels/1158535358624039014/1282290921815408681/1317793870070812715
040060             0048*       MACRO SRL_UHL
040060             0049*       dec sp ; 1 cycle
040060             0050*       push hl ; 4 cycles
040060             0051*       inc sp ; 1 cycle
040060             0052*       pop hl ; 4 cycles
040060             0053*       inc hl ; 1 cycle
040060             0054*       dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
040060             0055*       ; 13 cycles total
040060             0056*       ENDMACRO
040060             0057*   
040060             0058*       MACRO printChar char
040060             0059*       LD A, char
040060             0060*       RST.LIL 10h
040060             0061*       ENDMACRO
040060             0062*   
040060             0063*   ; Simulated call to subroutine at HL
040060             0064*   ; inputs: HL pointing to the subroutine address plus whatever the called function expects
040060             0065*   ; outputs: whatever the subroutine does, including HL and BC
040060             0066*   ; destroys: only what the subroutine does, but always BC
040060             0067*       MACRO CALL_HL
040060             0068*       ld bc,$+6 ; Address of first instruction after the jump
040060             0069*       push bc ; which constitutes the return address
040060             0070*       jp (hl) ; Jump to the address in HL
040060             0071*       ENDMACRO
040060             0072*   
040060             0073*   ; Simulated call to subroutine at IX
040060             0074*   ; inputs: IX pointing to the subroutine address plus whatever the called function expects
040060             0075*   ; outputs: whatever the subroutine does, including IX and BC
040060             0076*   ; destroys: only what the subroutine does, but always BC
040060             0077*       MACRO CALL_IX
040060             0078*       ld bc,$+6 ; Address of first instruction after the jump
040060             0079*       push bc ; which constitutes the return address
040060             0080*       jp (ix) ; Jump to the address in IX
040060             0081*       ENDMACRO
040060             0082*   
040060             0083*   ; Simulated call to soubroutinte at IY
040060             0084*   ; inputs: IY pointing to the subroutine address plus whatever the called function expects
040060             0085*   ; outputs: whatever the subroutine does, including IY and BC
040060             0086*   ; destroys: only what the subroutine does, but always BC
040060             0087*       MACRO CALL_IY
040060             0088*       ld bc,$+6 ; Address of first instruction after the jump
040060             0089*       push bc ; which constitutes the return address
040060             0090*       jp (iy) ; Jump to the address in IY
040060             0091*       ENDMACRO
040060             0092*   
040060             0093*   ; put the value in HLU into A
040060             0094*   ; destroys: af
040060             0095*       MACRO HLU_TO_A
040060             0096*       dec sp ; 1 cycle
040060             0097*       push hl ; 4 cycles
040060             0098*       inc sp ; 1 cycle
040060             0099*       pop af ; 4 cycles
040060             0100*       ; 10 cycles total
040060             0101*       ENDMACRO
040060             0102*   
040060             0103*       MACRO PUSH_ALL
040060             0104*       ex af,af'
040060             0105*       exx
040060             0106*       push af
040060             0107*       push hl
040060             0108*       push bc
040060             0109*       push de
040060             0110*   
040060             0111*       ex af,af'
040060             0112*       exx
040060             0113*       push af
040060             0114*       push hl
040060             0115*       push bc
040060             0116*       push de
040060             0117*       push ix
040060             0118*       push iy
040060             0119*       ENDMACRO
040060             0120*   
040060             0121*       MACRO POP_ALL
040060             0122*       pop iy
040060             0123*       pop ix
040060             0124*       pop de
040060             0125*       pop bc
040060             0126*       pop hl
040060             0127*       pop af
040060             0128*       ex af,af'
040060             0129*       exx
040060             0130*   
040060             0131*       pop de
040060             0132*       pop bc
040060             0133*       pop hl
040060             0134*       pop af
040060             0135*       ex af,af'
040060             0136*       exx
040060             0137*       ENDMACRO
040060             0032        include "functions.inc"
040060             0001*   ; Print a zero-terminated string inline with code, e.g.:
040060             0002*   ;
040060             0003*   ;    call printInline
040060             0004*   ;    ASCIZ "Hello, world!\r\n"
040060             0005*   ;
040060             0006*   ; Destroys: HL,AF
040060             0007*   printInline:
040060 E1          0008*       pop hl ; get the return address = pointer to start of string
040061 CD 67 00 04 0009*       call printString ; HL advances to end of string
040065 E5          0010*       push hl ; restore the return address = pointer to end of string
040066 C9          0011*       ret
040067             0012*   
040067             0013*   ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
040067             0014*   ; Print a zero-terminated string
040067             0015*   ; HL: Pointer to string
040067             0016*   ; returns: hl pointed to character after string terminator
040067             0017*   ; destroys: af, hl
040067             0018*   printString:
040067 C5          0019*       PUSH BC
040068 01 00 00 00 0020*       LD BC,0
04006C 3E 00       0021*       LD A,0
04006E 5B DF       0022*       RST.LIL 18h
040070 C1          0023*       POP BC
040071 C9          0024*       RET
040072             0025*   ; print a VDU sequence
040072             0026*   ; HL: Pointer to VDU sequence - <1 byte length> <data>
040072             0027*   sendVDUsequence:
040072 C5          0028*       PUSH BC
040073 01 00 00 00 0029*       LD BC, 0
040077 4E          0030*       LD C, (HL)
040078 5B DF       0031*       RST.LIL 18h
04007A C1          0032*       POP BC
04007B C9          0033*       RET
04007C             0034*   ; Print Newline sequence to VDP
04007C             0035*   ; destroys: nothing
04007C             0036*   printNewLine:
04007C F5          0037*       push af ; for some reason rst.lil 10h sets carry flag
04007D 3E 0D       0038*       LD A, '\r'
04007F 5B D7       0039*       RST.LIL 10h
040081 3E 0A       0040*       LD A, '\n'
040083 5B D7       0041*       RST.LIL 10h
040085 F1          0042*       pop af
040086 C9          0043*       RET
040087             0044*   
040087             0045*   ; print a zero-terminated string at a graphics coordinate
040087             0046*   ; Inputs: HL Pointer to string, BC,DE x,y position (in pixels)
040087             0047*   printStringGfx:
040087 E5          0048*       push hl ; preserve string pointer
040088             0049*   ; move graphics cursor to x,y location
040088 3E 44       0050*       ld a,plot_pt+mv_abs
04008A CD 60 17 04 0051*       call vdu_plot
04008E             0052*   ; print string
04008E E1          0053*       pop hl ; restore string pointer
04008F             0054*   @print_loop:
04008F 7E          0055*       ld a,(hl)
040090 B7          0056*       or a ; check for end of string
040091 C8          0057*       ret z ; if zero, we're done
040092 08          0058*       ex af,af' ; preserve character
040093 3E 05       0059*       ld a,5 ; VDU 5 char to gfx cursor
040095 5B D7       0060*       rst.lil 10h ; send it
040097 08          0061*       ex af,af' ; restore character
040098 5B D7       0062*       rst.lil 10h ; print character
04009A 23          0063*       inc hl
04009B C3 8F 00 04 0064*       jp @print_loop
04009F C9          0065*       ret
0400A0             0066*   ; end printStringGfx
0400A0             0067*   
0400A0             0068*   ; Print a 24-bit HEX number
0400A0             0069*   ; HLU: Number to print
0400A0             0070*   printHex24:
0400A0             0071*       HLU_TO_A
                       M1 Args: none
0400A0 3B          0001*M1     dec sp ; 1 cycle
0400A1 E5          0002*M1     push hl ; 4 cycles
0400A2 33          0003*M1     inc sp ; 1 cycle
0400A3 F1          0004*M1     pop af ; 4 cycles
0400A4             0005*M1     ; 10 cycles total
0400A4 CD AE 00 04 0072*       CALL printHex8
0400A8             0073*   ; Print a 16-bit HEX number
0400A8             0074*   ; HL: Number to print
0400A8             0075*   printHex16:
0400A8 7C          0076*       LD A,H
0400A9 CD AE 00 04 0077*       CALL printHex8
0400AD 7D          0078*       LD A,L
0400AE             0079*   ; Print an 8-bit HEX number
0400AE             0080*   ; A: Number to print
0400AE             0081*   printHex8:
0400AE 4F          0082*       LD C,A
0400AF 1F          0083*       RRA
0400B0 1F          0084*       RRA
0400B1 1F          0085*       RRA
0400B2 1F          0086*       RRA
0400B3 CD B8 00 04 0087*       CALL @F
0400B7 79          0088*       LD A,C
0400B8             0089*   @@:
0400B8 E6 0F       0090*       AND 0Fh
0400BA C6 90       0091*       ADD A,90h
0400BC 27          0092*       DAA
0400BD CE 40       0093*       ADC A,40h
0400BF 27          0094*       DAA
0400C0 5B D7       0095*       RST.LIL 10h
0400C2 C9          0096*       RET
0400C3             0097*   
0400C3             0098*   ; Print a 0x HEX prefix
0400C3             0099*   DisplayHexPrefix:
0400C3 3E 30       0100*       LD A, '0'
0400C5 5B D7       0101*       RST.LIL 10h
0400C7 3E 78       0102*       LD A, 'x'
0400C9 5B D7       0103*       RST.LIL 10h
0400CB C9          0104*       RET
0400CC             0105*   
0400CC             0106*       MACRO printDecBC
0400CC             0107*       push hl
0400CC             0108*       push bc
0400CC             0109*       pop hl
0400CC             0110*       call printDec
0400CC             0111*       pop hl
0400CC             0112*       ENDMACRO
0400CC             0113*   
0400CC             0114*       MACRO printDecDE
0400CC             0115*       push hl
0400CC             0116*       push de
0400CC             0117*       pop hl
0400CC             0118*       call printDec
0400CC             0119*       pop hl
0400CC             0120*       ENDMACRO
0400CC             0121*   
0400CC             0122*       MACRO printDecHL
0400CC             0123*       call printDec
0400CC             0124*       ENDMACRO
0400CC             0125*   
0400CC             0126*       MACRO printDecIX
0400CC             0127*       push hl
0400CC             0128*       push ix
0400CC             0129*       pop hl
0400CC             0130*       call printDec
0400CC             0131*       pop hl
0400CC             0132*       ENDMACRO
0400CC             0133*   
0400CC             0134*       MACRO printDecIY
0400CC             0135*       push hl
0400CC             0136*       push iy
0400CC             0137*       pop hl
0400CC             0138*       call printDec
0400CC             0139*       pop hl
0400CC             0140*       ENDMACRO
0400CC             0141*   
0400CC             0142*   
0400CC             0143*   ; Prints the right justified decimal value in HL without leading zeroes
0400CC             0144*   ; HL : Value to print
0400CC             0145*   ; preserves all registers and flags
0400CC             0146*   printDec:
0400CC             0147*   ; BEGIN MY CODE
0400CC             0148*   ; back up all the things
0400CC F5          0149*       push af
0400CD C5          0150*       push bc
0400CE D5          0151*       push de
0400CF E5          0152*       push hl
0400D0             0153*   ; END MY CODE
0400D0 11 F8 00 04 0154*       LD DE, _printDecBuffer
0400D4 CD 08 01 04 0155*       CALL u24_to_ascii
0400D8             0156*   ; BEGIN MY CODE
0400D8             0157*   ; replace leading zeroes with spaces
0400D8 21 F8 00 04 0158*       LD HL, _printDecBuffer
0400DC 06 07       0159*       ld B, 7 ; if HL was 0, we want to keep the final zero
0400DE             0160*   @loop:
0400DE 7E          0161*       LD A, (HL)
0400DF FE 30       0162*       CP '0'
0400E1 C2 EB 00 04 0163*       JP NZ, @done
0400E5 3E 20       0164*       LD A, ' '
0400E7 77          0165*       LD (HL), A
0400E8 23          0166*       INC HL
0400E9             0167*       ; CALL vdu_cursor_forward
0400E9 10 F3       0168*       DJNZ @loop
0400EB             0169*   @done:
0400EB             0170*   ; END MY CODE
0400EB 21 F8 00 04 0171*       LD HL, _printDecBuffer
0400EF CD 67 00 04 0172*       CALL printString
0400F3             0173*   ; BEGIN MY CODE
0400F3             0174*   ; restore all the things
0400F3 E1          0175*       pop hl
0400F4 D1          0176*       pop de
0400F5 C1          0177*       pop bc
0400F6 F1          0178*       pop af
0400F7             0179*   ; END MY CODE
0400F7 C9          0180*       RET
0400F8 00 00 00 00 0181*   _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040108             0182*   
040108             0183*   ; This routine converts the unsigned 24-bit value in HLU into its ASCII representation,
040108             0184*   ; starting to memory location pointing by DE, in decimal form and with leading zeroes
040108             0185*   ; so it will allways be 8 characters length
040108             0186*   ; HL : Value to convert to string
040108             0187*   ; DE : pointer to buffer, at least 8 byte + 0
040108             0188*   u24_to_ascii:
040108 01 80 69 67 0189*       LD BC,-10000000
04010C CD 3F 01 04 0190*       CALL @one_digit
040110 01 C0 BD F0 0191*       LD BC,-1000000
040114 CD 3F 01 04 0192*       CALL @one_digit
040118 01 60 79 FE 0193*       LD BC,-100000
04011C CD 3F 01 04 0194*       CALL @one_digit
040120 01 F0 D8 FF 0195*       LD BC,-10000
040124 CD 3F 01 04 0196*       CALL @one_digit
040128 01 18 FC FF 0197*       LD BC,-1000
04012C CD 3F 01 04 0198*       CALL @one_digit
040130 01 9C FF FF 0199*       LD BC,-100
040134 CD 3F 01 04 0200*       CALL @one_digit
040138 0E F6       0201*       LD C,-10
04013A CD 3F 01 04 0202*       CALL @one_digit
04013E 48          0203*       LD C,B
04013F             0204*   @one_digit:
04013F 3E 2F       0205*       LD A,'0'-1
040141             0206*   @divide_me:
040141 3C          0207*       INC A
040142 09          0208*       ADD HL,BC
040143 38 FC       0209*       JR C,@divide_me
040145 ED 42       0210*       SBC HL,BC
040147 12          0211*       LD (DE),A
040148 13          0212*       INC DE
040149 C9          0213*       RET
04014A             0214*   
04014A             0215*   print_u24:
04014A D5          0216*       push de
04014B E5          0217*       push hl
04014C 11 F8 00 04 0218*       ld de,_printDecBuffer
040150 CD 08 01 04 0219*       call u24_to_ascii
040154 21 F8 00 04 0220*       ld hl,_printDecBuffer
040158 CD 67 00 04 0221*       call printString
04015C 3E 20       0222*       ld a,' '
04015E 5B D7       0223*       rst.lil 10h
040160 E1          0224*       pop hl
040161 D1          0225*       pop de
040162 C9          0226*       ret
040163             0227*   
040163             0228*   ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
040163             0229*   ; HL : Value to convert to string (integer part in H, fractional part in L)
040163             0230*   ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
040163             0231*   u168_to_ascii:
040163             0232*   ; add a leading space to make room for sign flag if needed
040163 3E 20       0233*       ld a,' '
040165 12          0234*       ld (de),a
040166 13          0235*       inc de
040167             0236*   ; Convert integer part
040167 E5          0237*       push hl ; Save HL (we’ll need the fractional part later)
040168             0238*       ; call hlu_udiv256 ; Shift to get integer portion in HL
040168             0239*       SRL_UHL ; Shift to get integer portion in HL
                       M1 Args: none
040168 3B          0001*M1     dec sp ; 1 cycle
040169 E5          0002*M1     push hl ; 4 cycles
04016A 33          0003*M1     inc sp ; 1 cycle
04016B E1          0004*M1     pop hl ; 4 cycles
04016C 23          0005*M1     inc hl ; 1 cycle
04016D 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
04016F             0007*M1     ; 13 cycles total
04016F 01 F0 D8 FF 0240*       ld bc, -10000
040173 CD 96 01 04 0241*       call @one_int
040177 01 18 FC FF 0242*       ld bc, -1000
04017B CD 96 01 04 0243*       call @one_int
04017F 01 9C FF FF 0244*       ld bc, -100
040183 CD 96 01 04 0245*       call @one_int
040187 0E F6       0246*       ld c, -10
040189 CD 96 01 04 0247*       call @one_int
04018D 48          0248*       ld c, b
04018E CD 96 01 04 0249*       call @one_int
040192 C3 A1 01 04 0250*       jp @frac ; Jump to fractional part conversion
040196             0251*   @one_int:
040196 3E 2F       0252*       ld a, '0' - 1 ; Start ASCII character at '0'
040198             0253*   @divide_me:
040198 3C          0254*       inc a
040199 09          0255*       add hl, bc ; Accumulate until overflow
04019A 38 FC       0256*       jr c, @divide_me
04019C ED 42       0257*       sbc hl, bc ; Remove excess after overflow
04019E 12          0258*       ld (de), a ; Store ASCII digit
04019F 13          0259*       inc de
0401A0 C9          0260*       ret
0401A1             0261*   ; Convert fractional part
0401A1             0262*   @frac:
0401A1 3E 2E       0263*       ld a, '.' ; Decimal point
0401A3 12          0264*       ld (de), a
0401A4 13          0265*       inc de
0401A5 E1          0266*       pop hl ; Restore HL with original fraction
0401A6 06 03       0267*       ld b, 3 ; Loop counter for 3 fractional digits
0401A8             0268*   @frac_loop:
0401A8 26 0A       0269*       ld h, 10 ; Load multiplier for fractional part
0401AA ED 6C       0270*       mlt hl ; Multiply by 10, result in HL (H holds the integer part)
0401AC 3E 30       0271*       ld a, '0'
0401AE 84          0272*       add a, h ; Convert integer part to ASCII
0401AF 12          0273*       ld (de), a
0401B0 13          0274*       inc de
0401B1 10 F5       0275*       djnz @frac_loop ; Repeat for each fractional digit
0401B3             0276*   ; Add null terminator
0401B3 AF          0277*       xor a ; Null terminator
0401B4 12          0278*       ld (de), a
0401B5 C9          0279*       ret
0401B6             0280*   
0401B6             0281*   print_u168:
0401B6 D5          0282*       push de
0401B7 E5          0283*       push hl
0401B8 11 F8 00 04 0284*       ld de,_printDecBuffer
0401BC CD 63 01 04 0285*       call u168_to_ascii
0401C0 21 F8 00 04 0286*       ld hl,_printDecBuffer
0401C4 CD 67 00 04 0287*       call printString
0401C8 E1          0288*       pop hl
0401C9 D1          0289*       pop de
0401CA C9          0290*       ret
0401CB             0291*   
0401CB             0292*   ; signed version of u168_to_ascii
0401CB             0293*   s168_to_ascii:
0401CB D5          0294*       push de ; save starting address of buffer
0401CC CD 70 04 04 0295*       call hlu_abs
0401D0 F5          0296*       push af ; save sign flag
0401D1 CD 63 01 04 0297*       call u168_to_ascii
0401D5 F1          0298*       pop af ; restore sign flag
0401D6 D1          0299*       pop de ; restore starting address of buffer
0401D7 F0          0300*       ret p ; hlu was positive so nothing to do
0401D8 3E 2D       0301*       ld a,'-'
0401DA 12          0302*       ld (de),a
0401DB C9          0303*       ret
0401DC             0304*   
0401DC             0305*   print_s168:
0401DC D5          0306*       push de
0401DD E5          0307*       push hl
0401DE 11 F8 00 04 0308*       ld de,_printDecBuffer
0401E2 CD CB 01 04 0309*       call s168_to_ascii
0401E6 21 F8 00 04 0310*       ld hl,_printDecBuffer
0401EA CD 67 00 04 0311*       call printString
0401EE E1          0312*       pop hl
0401EF D1          0313*       pop de
0401F0 C9          0314*       ret
0401F1             0315*   
0401F1             0316*   print_s168_hl:
0401F1 F5          0317*       push af
0401F2 E5          0318*       push hl
0401F3 CD DC 01 04 0319*       call print_s168
0401F7 3E 20       0320*       ld a,' '
0401F9 5B D7       0321*       rst.lil 10h
0401FB E1          0322*       pop hl
0401FC F1          0323*       pop af
0401FD C9          0324*       ret
0401FE             0325*   
0401FE             0326*   print_s168_bc:
0401FE F5          0327*       push af
0401FF C5          0328*       push bc
040200 E5          0329*       push hl
040201 C5          0330*       push bc
040202 E1          0331*       pop hl
040203 CD DC 01 04 0332*       call print_s168
040207 3E 20       0333*       ld a,' '
040209 5B D7       0334*       rst.lil 10h
04020B E1          0335*       pop hl
04020C C1          0336*       pop bc
04020D F1          0337*       pop af
04020E C9          0338*       ret
04020F             0339*   
04020F             0340*   print_s168_de:
04020F F5          0341*       push af
040210 D5          0342*       push de
040211 E5          0343*       push hl
040212 EB          0344*       ex de,hl
040213 CD DC 01 04 0345*       call print_s168
040217 3E 20       0346*       ld a,' '
040219 5B D7       0347*       rst.lil 10h
04021B E1          0348*       pop hl
04021C D1          0349*       pop de
04021D F1          0350*       pop af
04021E C9          0351*       ret
04021F             0352*   
04021F             0353*   print_s168_hl_bc_de:
04021F F5          0354*       push af
040220 C5          0355*       push bc
040221 D5          0356*       push de
040222 E5          0357*       push hl
040223 CD DC 01 04 0358*       call print_s168
040227 3E 20       0359*       ld a,' '
040229 5B D7       0360*       rst.lil 10h
04022B C5          0361*       push bc
04022C E1          0362*       pop hl
04022D CD DC 01 04 0363*       call print_s168
040231 3E 20       0364*       ld a,' '
040233 5B D7       0365*       rst.lil 10h
040235 EB          0366*       ex de,hl
040236 CD DC 01 04 0367*       call print_s168
04023A 3E 20       0368*       ld a,' '
04023C 5B D7       0369*       rst.lil 10h
04023E E1          0370*       pop hl
04023F D1          0371*       pop de
040240 C1          0372*       pop bc
040241 F1          0373*       pop af
040242 C9          0374*       ret
040243             0375*   
040243             0376*   print_s168_bc_de:
040243 F5          0377*       push af
040244 C5          0378*       push bc
040245 D5          0379*       push de
040246 C5          0380*       push bc
040247 E1          0381*       pop hl
040248 CD DC 01 04 0382*       call print_s168
04024C 3E 20       0383*       ld a,' '
04024E 5B D7       0384*       rst.lil 10h
040250 EB          0385*       ex de,hl
040251 CD DC 01 04 0386*       call print_s168
040255 3E 20       0387*       ld a,' '
040257 5B D7       0388*       rst.lil 10h
040259 E1          0389*       pop hl
04025A D1          0390*       pop de
04025B C1          0391*       pop bc
04025C F1          0392*       pop af
04025D C9          0393*       ret
04025E             0394*   
04025E             0395*   print_s168_a:
04025E F5          0396*       push af
04025F C5          0397*       push bc
040260 E5          0398*       push hl
040261 21 00 00 00 0399*       ld hl,0
040265 6F          0400*       ld l,a
040266 CD F1 01 04 0401*       call print_s168_hl
04026A E1          0402*       pop hl
04026B C1          0403*       pop bc
04026C F1          0404*       pop af
04026D C9          0405*       ret
04026E             0406*   
04026E             0407*   ; #### new functions added by Brandon R. Gates ####
04026E             0408*   
04026E             0409*   ; print the binary representation of the 8-bit value in a
04026E             0410*   ; destroys a, hl, bc
04026E             0411*   printBin8:
04026E 06 08       0412*       ld b,8 ; loop counter for 8 bits
040270 21 8B 02 04 0413*       ld hl,@cmd ; set hl to the low byte of the output string
040274             0414*       ; (which will be the high bit of the value in a)
040274             0415*   @loop:
040274 07          0416*       rlca ; put the next highest bit into carry
040275 38 04       0417*       jr c,@one
040277 36 30       0418*       ld (hl),'0'
040279 18 02       0419*       jr @next_bit
04027B             0420*   @one:
04027B 36 31       0421*       ld (hl),'1'
04027D             0422*   @next_bit:
04027D 23          0423*       inc hl
04027E 10 F4       0424*       djnz @loop
040280             0425*   ; print it
040280 21 8B 02 04 0426*       ld hl,@cmd
040284 01 08 00 00 0427*       ld bc,@end-@cmd
040288 5B DF       0428*       rst.lil $18
04028A C9          0429*       ret
04028B             0430*   @cmd: ds 8 ; eight bytes for eight bits
040293             0431*   @end:
040293             0432*   
040293             0433*   ; print the binary representation of the 8-bit value in a
040293             0434*   ; in reverse order (lsb first)
040293             0435*   ; destroys a, hl, bc
040293             0436*   printBin8Rev:
       FF FF FF FF 
       FF FF FF FF 
040293 06 08       0437*       ld b,8 ; loop counter for 8 bits
040295 21 B0 02 04 0438*       ld hl,@cmd ; set hl to the low byte of the output string
040299             0439*       ; (which will be the high bit of the value in a)
040299             0440*   @loop:
040299 0F          0441*       rrca ; put the next lowest bit into carry
04029A 38 04       0442*       jr c,@one
04029C 36 30       0443*       ld (hl),'0'
04029E 18 02       0444*       jr @next_bit
0402A0             0445*   @one:
0402A0 36 31       0446*       ld (hl),'1'
0402A2             0447*   @next_bit:
0402A2 23          0448*       inc hl
0402A3 10 F4       0449*       djnz @loop
0402A5             0450*   ; print it
0402A5 21 B0 02 04 0451*       ld hl,@cmd
0402A9 01 08 00 00 0452*       ld bc,@end-@cmd
0402AD 5B DF       0453*       rst.lil $18
0402AF C9          0454*       ret
0402B0             0455*   @cmd: ds 8 ; eight bytes for eight bits
0402B8             0456*   @end:
0402B8             0457*   
       FF FF FF FF 
       FF FF FF FF 
0402B8 20 61 66 3D 0458*   str_afu: db " af=",0
       00          
0402BD 20 68 6C 3D 0459*   str_hlu: db " hl=",0
       00          
0402C2 20 62 63 3D 0460*   str_bcu: db " bc=",0
       00          
0402C7 20 64 65 3D 0461*   str_deu: db " de=",0
       00          
0402CC 20 69 78 3D 0462*   str_ixu: db " ix=",0
       00          
0402D1 20 69 79 3D 0463*   str_iyu: db " iy=",0
       00          
0402D6             0464*   
0402D6             0465*   ; print udeuhl to screen in hexidecimal format
0402D6             0466*   ; inputs: none
0402D6             0467*   ; outputs: concatenated hexidecimal udeuhl
0402D6             0468*   ; destroys: nothing
0402D6             0469*   dumpUDEUHLHex:
0402D6             0470*   ; store everything in scratch
0402D6 22 35 03 04 0471*       ld (uhl),hl
0402DA ED 43 38 03 0472*       ld (ubc),bc
       04          
0402DF ED 53 3B 03 0473*       ld (ude),de
       04          
0402E4 DD 22 3E 03 0474*       ld (uix),ix
       04          
0402E9 FD 22 41 03 0475*       ld (uiy),iy
       04          
0402EE F5          0476*       push af
0402EF             0477*   
0402EF             0478*   ; print each register
0402EF             0479*   
0402EF 21 29 03 04 0480*       ld hl,str_udeuhl
0402F3 CD 67 00 04 0481*       call printString
0402F7 2A 3B 03 04 0482*       ld hl,(ude)
0402FB CD A0 00 04 0483*       call printHex24
0402FF 3E 2E       0484*       ld a,'.' ; print a dot to separate the values
040301 5B D7       0485*       rst.lil 10h
040303 2A 35 03 04 0486*       ld hl,(uhl)
040307 CD A0 00 04 0487*       call printHex24
04030B CD 7C 00 04 0488*       call printNewLine
04030F             0489*   
04030F             0490*   ; restore everything
04030F 2A 35 03 04 0491*       ld hl, (uhl)
040313 ED 4B 38 03 0492*       ld bc, (ubc)
       04          
040318 ED 5B 3B 03 0493*       ld de, (ude)
       04          
04031D DD 2A 3E 03 0494*       ld ix, (uix)
       04          
040322 FD 2A 41 03 0495*       ld iy, (uiy)
       04          
040327 F1          0496*       pop af
040328             0497*   ; all done
040328 C9          0498*       ret
040329             0499*   
040329 75 64 65 2E 0500*   str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
040332             0501*   
040332             0502*   ; global scratch memory for registers
040332 00 00 00    0503*   uaf: dl 0
040335 00 00 00    0504*   uhl: dl 0
040338 00 00 00    0505*   ubc: dl 0
04033B 00 00 00    0506*   ude: dl 0
04033E 00 00 00    0507*   uix: dl 0
040341 00 00 00    0508*   uiy: dl 0
040344 00 00 00    0509*   usp: dl 0
040347 00 00 00    0510*   upc: dl 0
04034A             0511*   
04034A             0512*   
04034A             0513*   ; set all the bits in the flag register
04034A             0514*   ; more of an academic exercise than anything useful
04034A             0515*   ; inputs; none
04034A             0516*   ; outputs; a=0,f=255
04034A             0517*   ; destroys: flags, hl
04034A             0518*   ; preserves: a, because why not
04034A             0519*   setAllFlags:
04034A 21 FF 00 00 0520*       ld hl,255
04034E 67          0521*       ld h,a ; four cycles to preserve a is cheap
04034F E5          0522*       push hl
040350 F1          0523*       pop af
040351 C9          0524*       ret
040352             0525*   
040352             0526*   ; reset all the bits in the flag register
040352             0527*   ; unlike its inverse counterpart, this may actually be useful
040352             0528*   ; inputs; none
040352             0529*   ; outputs; a=0,f=0
040352             0530*   ; destroys: flags, hl
040352             0531*   ; preserves: a, because why not
040352             0532*   resetAllFlags:
040352 21 00 00 00 0533*       ld hl,0
040356 67          0534*       ld h,a ; four cycles to preserve a is cheap
040357 E5          0535*       push hl
040358 F1          0536*       pop af
040359 C9          0537*       ret
04035A             0538*   
04035A             0539*   ; wait until user presses a key
04035A             0540*   ; inputs: none
04035A             0541*   ; outputs: ascii code of key pressed in a
04035A             0542*   ; destroys: af,ix
04035A             0543*   waitKeypress:
04035A             0544*       MOSCALL mos_getkey
                       M1 Args: function=mos_getkey 
04035A 3E 00       0001*M1 			LD	A, function
04035C 5B CF       0002*M1 			RST.LIL	08h
04035E C9          0545*       ret
04035F             0546*   
04035F             0547*   ; clear a block of memory by writing a prescribed value to each byte in the range
04035F             0548*   ; inputs: a = value to write, hl = address of first byte, bc = number of bytes
04035F             0549*   ; outputs: memory block is cleared
04035F             0550*   ; destroys: hl, de
04035F             0551*   clear_mem:
04035F 0B          0552*       dec bc ; we do this because we will increment de before writing the first byte
040360 77          0553*       ld (hl),a
040361 E5          0554*       push hl
040362 D1          0555*       pop de
040363 13          0556*       inc de ; target address
040364 ED B0       0557*       ldir
040366 C9          0558*       ret
040367             0033        include "arith24.inc"
040367             0001*   ;------------------------------------------------------------------------
040367             0002*   ;  arith24.asm
040367             0003*   ;  24-bit ez80 arithmetic routines
040367             0004*   ;  Copyright (c) Shawn Sijnstra 2024
040367             0005*   ;  MIT license
040367             0006*   ;
040367             0007*   ;  This library was created as a tool to help make ez80
040367             0008*   ;  24-bit native assembly routines for simple mathematical problems
040367             0009*   ;  more widely available.
040367             0010*   ;
040367             0011*   ;------------------------------------------------------------------------
040367             0012*   
040367             0013*   ;------------------------------------------------------------------------
040367             0014*   ; umul24:	HL = HL*DE (unsigned)
040367             0015*   ; Preserves AF, BC, DE
040367             0016*   ; Uses a fast multiply routine.
040367             0017*   ;------------------------------------------------------------------------
040367             0018*   umul24:
040367 D5          0019*   	push	DE
040368 C5          0020*   	push	BC
040369 F5          0021*   	push	AF
04036A E5          0022*   	push	HL
04036B C1          0023*   	pop		BC
04036C 3E 18       0024*       ld	 	a, 24 ; No. of bits to process
04036E 21 00 00 00 0025*       ld	 	hl, 0 ; Result
040372             0026*   umul24_lp:
040372 29          0027*   	add	hl,hl
040373 EB          0028*   	ex	de,hl
040374 29          0029*   	add	hl,hl
040375 EB          0030*   	ex	de,hl
040376 30 01       0031*   	jr	nc,umul24_nc
040378 09          0032*   	add	hl,bc
040379             0033*   umul24_nc:
040379 3D          0034*   	dec	a
04037A 20 F6       0035*   	jr	nz,umul24_lp
04037C F1          0036*   	pop	af
04037D C1          0037*   	pop	bc
04037E D1          0038*   	pop	de
04037F C9          0039*   	ret
040380             0040*   
040380             0041*   
040380             0042*   ;------------------------------------------------------------------------
040380             0043*   ; udiv24
040380             0044*   ; Unsigned 24-bit division
040380             0045*   ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
040380             0046*   ;
040380             0047*   ; Uses AF BC DE HL
040380             0048*   ; Uses Restoring Division algorithm
040380             0049*   ;------------------------------------------------------------------------
040380             0050*   
040380             0051*   udiv24:
040380 E5          0052*   	push	hl
040381 C1          0053*   	pop		bc	;move dividend to BCU
040382 21 00 00 00 0054*   	ld		hl,0	;result
040386 A7          0055*   	and		a
040387 ED 52       0056*   	sbc		hl,de	;test for div by 0
040389 C8          0057*   	ret		z		;it's zero, carry flag is clear
04038A 19          0058*   	add		hl,de	;HL is 0 again
04038B 3E 18       0059*   	ld		a,24	;number of loops through.
04038D             0060*   udiv1:
04038D C5          0061*   	push	bc	;complicated way of doing this because of lack of access to top bits
04038E E3          0062*   	ex		(sp),hl
04038F 37          0063*   	scf
040390 ED 6A       0064*   	adc	hl,hl
040392 E3          0065*   	ex	(sp),hl
040393 C1          0066*   	pop	bc		;we now have bc = (bc * 2) + 1
040394             0067*   
040394 ED 6A       0068*   	adc	hl,hl
040396 A7          0069*   	and	a		;is this the bug
040397 ED 52       0070*   	sbc	hl,de
040399 30 02       0071*   	jr	nc,udiv2
04039B 19          0072*   	add	hl,de
04039C             0073*   ;	dec	c
04039C 0B          0074*   	dec	bc
04039D             0075*   udiv2:
04039D 3D          0076*   	dec	a
04039E 20 ED       0077*   	jr	nz,udiv1
0403A0 37          0078*   	scf		;flag used for div0 error
0403A1 C5          0079*   	push	bc
0403A2 D1          0080*   	pop		de	;remainder
0403A3 C9          0081*   	ret
0403A4             0082*   
0403A4             0083*   
0403A4             0084*   
0403A4             0085*   ;------------------------------------------------------------------------
0403A4             0086*   ; neg24
0403A4             0087*   ; Returns: HLU = 0-HLU
0403A4             0088*   ; preserves all other registers
0403A4             0089*   ;------------------------------------------------------------------------
0403A4             0090*   neg24:
0403A4 D5          0091*   	push	de
0403A5 EB          0092*   	ex		de,hl
0403A6 21 00 00 00 0093*   	ld		hl,0
0403AA B7          0094*   	or		a
0403AB ED 52       0095*   	sbc		hl,de
0403AD D1          0096*   	pop		de
0403AE C9          0097*   	ret
0403AF             0098*   
0403AF             0099*   ;------------------------------------------------------------------------
0403AF             0100*   ; or_hlu_deu: 24 bit bitwise OR
0403AF             0101*   ; Returns: hlu = hlu OR deu
0403AF             0102*   ; preserves all other registers
0403AF             0103*   ;------------------------------------------------------------------------
0403AF             0104*   or_hlu_deu:
0403AF 22 38 04 04 0105*   	ld	(bitbuf1),hl
0403B3 ED 53 3B 04 0106*   	ld	(bitbuf2),de
       04          
0403B8 D5          0107*   	push	de	;preserve DEU
0403B9 C5          0108*   	push	bc	;preserve BCU
0403BA 06 03       0109*   	ld		b,3
0403BC 21 38 04 04 0110*   	ld	hl,bitbuf1
0403C0 11 38 04 04 0111*   	ld	de,bitbuf1
0403C4             0112*   orloop_24:
0403C4 1A          0113*   	ld	a,(de)
0403C5 B6          0114*   	or	(hl)
0403C6 12          0115*   	ld	(de),a
0403C7 13          0116*   	inc	de
0403C8 23          0117*   	inc	hl
0403C9 10 F9       0118*   	djnz	orloop_24
0403CB 2A 3B 04 04 0119*   	ld	hl,(bitbuf2)
0403CF C1          0120*   	pop		bc	;restore BC
0403D0 D1          0121*   	pop		de	;restore DE
0403D1             0122*   
0403D1             0123*   ;------------------------------------------------------------------------
0403D1             0124*   ; and_hlu_deu: 24 bit bitwise AND
0403D1             0125*   ; Returns: hlu = hlu AND deu
0403D1             0126*   ; preserves all other registers
0403D1             0127*   ;------------------------------------------------------------------------
0403D1             0128*   and_hlu_deu:
0403D1 22 38 04 04 0129*   	ld	(bitbuf1),hl
0403D5 ED 53 3B 04 0130*   	ld	(bitbuf2),de
       04          
0403DA D5          0131*   	push	de	;preserve DEU
0403DB C5          0132*   	push	bc	;preserve BCU
0403DC 06 03       0133*   	ld		b,3
0403DE 21 38 04 04 0134*   	ld	hl,bitbuf1
0403E2 11 38 04 04 0135*   	ld	de,bitbuf1
0403E6             0136*   andloop_24:
0403E6 1A          0137*   	ld	a,(de)
0403E7 A6          0138*   	and	(hl)
0403E8 12          0139*   	ld	(de),a
0403E9 13          0140*   	inc	de
0403EA 23          0141*   	inc	hl
0403EB 10 F9       0142*   	djnz	andloop_24
0403ED 2A 3B 04 04 0143*   	ld	hl,(bitbuf2)
0403F1 C1          0144*   	pop		bc	;restore BC
0403F2 D1          0145*   	pop		de	;restore DE
0403F3             0146*   
0403F3             0147*   ;------------------------------------------------------------------------
0403F3             0148*   ; xor_hlu_deu: 24 bit bitwise XOR
0403F3             0149*   ; Returns: hlu = hlu XOR deu
0403F3             0150*   ; preserves all other registers
0403F3             0151*   ;------------------------------------------------------------------------
0403F3             0152*   xor_hlu_deu:
0403F3 22 38 04 04 0153*   	ld	(bitbuf1),hl
0403F7 ED 53 3B 04 0154*   	ld	(bitbuf2),de
       04          
0403FC D5          0155*   	push	de	;preserve DEU
0403FD C5          0156*   	push	bc	;preserve BCU
0403FE 06 03       0157*   	ld		b,3
040400 21 38 04 04 0158*   	ld	hl,bitbuf1
040404 11 38 04 04 0159*   	ld	de,bitbuf1
040408             0160*   xorloop_24:
040408 1A          0161*   	ld	a,(de)
040409 AE          0162*   	xor	(hl)
04040A 12          0163*   	ld	(de),a
04040B 13          0164*   	inc	de
04040C 23          0165*   	inc	hl
04040D 10 F9       0166*   	djnz	xorloop_24
04040F 2A 3B 04 04 0167*   	ld	hl,(bitbuf2)
040413 C1          0168*   	pop		bc	;restore BC
040414 D1          0169*   	pop		de	;restore DE
040415             0170*   
040415             0171*   ;------------------------------------------------------------------------
040415             0172*   ; shl_hlu: 24 bit shift left hlu by a positions
040415             0173*   ; Returns: hlu = hlu << a
040415             0174*   ;		   a = 0
040415             0175*   ; NOTE: only considers a up to 16 bits.
040415             0176*   ; preserves all other registers
040415             0177*   ; modified by Brandon R. Gates to use a instead of de
040415             0178*   ;------------------------------------------------------------------------
040415             0179*   shl_hlu:
040415 B7          0180*   	or a
040416 C8          0181*   	ret		z		;we're done
040417 29          0182*   	add		hl,hl	;shift HLU left
040418 3D          0183*   	dec a
040419 18 FA       0184*   	jr		shl_hlu
04041B             0185*   
04041B             0186*   ;------------------------------------------------------------------------
04041B             0187*   ; shr_hlu: 24 bit shift right hlu by a positions
04041B             0188*   ; Returns: hlu = hlu >> a
04041B             0189*   ;		   a = 0
04041B             0190*   ; NOTE: only considers a up to 16 bits.
04041B             0191*   ; preserves all other registers
04041B             0192*   ; modified by Brandon R. Gates to use a instead of de
04041B             0193*   ;------------------------------------------------------------------------
04041B             0194*   shr_hlu:
04041B 22 38 04 04 0195*   	ld		(bitbuf1),hl
04041F 21 3A 04 04 0196*   	ld		hl,bitbuf1+2
040423             0197*   @shr_loop:
040423 B7          0198*   	or a
040424 28 0D       0199*   	jr		z,@shr_done		;we're done
040426             0200*   ;carry is clear from or instruction
040426 CB 1E       0201*   	rr		(hl)
040428 2B          0202*   	dec		hl
040429 CB 1E       0203*   	rr		(hl)
04042B 2B          0204*   	dec		hl
04042C CB 1E       0205*   	rr		(hl)
04042E 23          0206*   	inc		hl
04042F 23          0207*   	inc		hl
040430 3D          0208*   	dec a
040431 18 F0       0209*   	jr		@shr_loop
040433             0210*   @shr_done:
040433 2A 38 04 04 0211*   	ld		hl,(bitbuf1)	;collect result
040437 C9          0212*   	ret
040438             0213*   
040438             0214*   ;------------------------------------------------------------------------
040438             0215*   ; Scratch area for calculations
040438             0216*   ;------------------------------------------------------------------------
040438 00 00 00    0217*   bitbuf1:	dw24	0	;bit manipulation buffer 1
04043B 00 00 00    0218*   bitbuf2:	dw24	0	;bit manipulation buffer 2
04043E             0219*   
04043E             0220*   ; -----------------------------------------------------------------------
04043E             0221*   ; Functions added by Brandon R. Gates
04043E             0222*   ; -----------------------------------------------------------------------
04043E             0223*   
04043E             0224*   ;------------------------------------------------------------------------
04043E             0225*   ; shr_hlu_div: Quick division by powers of two based on log2 of A
04043E             0226*   ;              Determines the LSB of A and shifts HLU accordingly.
04043E             0227*   ;              HLU = HLU >> LSB(A)
04043E             0228*   ; Returns: HLU = HLU >> LSB(A)
04043E             0229*   ; Destroys: af
04043E             0230*   ;------------------------------------------------------------------------
04043E             0231*   shr_hlu_log2a:
04043E B7          0232*   	or a    ; check for zero
04043F C8          0233*   	ret z   ; nothing to shift so we're done
040440 C5          0234*   	push 	bc ; preserve
040441 06 00       0235*   	ld		b,0 ; clear b
040443             0236*   @find_bit:
040443 0F          0237*   	rrca ; bit 0 to carry
040444 DA 4D 04 04 0238*   	jp c,@found_bit
040448 04          0239*   	inc b ; next bit
040449 C3 43 04 04 0240*   	jp @find_bit
04044D             0241*   @found_bit:
04044D 78          0242*   	ld a,b
04044E CD 1B 04 04 0243*   	call shr_hlu
040452 C1          0244*   	pop 	bc ; restore
040453 C9          0245*   	ret
040454             0246*   ; end shr_hlu_log2a
040454             0247*   
040454             0248*   ;------------------------------------------------------------------------
040454             0249*   ; shl_hlu_log2a: Quick multiplication by powers of two based on log2 of A
040454             0250*   ;                Determines the LSB of A and shifts HLU accordingly.
040454             0251*   ;                HLU = HLU << LSB(A)
040454             0252*   ; Returns: HLU = HLU << LSB(A)
040454             0253*   ; Destroys: af
040454             0254*   ;------------------------------------------------------------------------
040454             0255*   shl_hlu_log2a:
040454 B7          0256*   	or a    ; check for zero
040455 C8          0257*   	ret z   ; nothing to shift so we're done
040456 C5          0258*   	push 	bc ; preserve
040457 06 00       0259*   	ld		b,0 ; clear b
040459             0260*   @find_bit:
040459 0F          0261*   	rrca ; bit 0 to carry
04045A DA 63 04 04 0262*   	jp c,@found_bit
04045E 04          0263*   	inc b ; next bit
04045F C3 59 04 04 0264*   	jp @find_bit
040463             0265*   @found_bit:
040463 78          0266*   	ld a,b
040464 CD 15 04 04 0267*   	call shl_hlu
040468 C1          0268*   	pop 	bc ; restore
040469 C9          0269*   	ret
04046A             0270*   ; end shl_hlu_log2a
04046A             0034        include "maths.inc"
04046A             0001*   ;------------------------------------------------------------------------
04046A             0002*   ; Scratch area for calculations
04046A             0003*   ;------------------------------------------------------------------------
04046A 00 00 00    0004*   scratch1: dw24 0 ;bit manipulation buffer 1
04046D 00 00 00    0005*   scratch2: dw24 0 ;bit manipulation buffer 2
040470             0006*   
040470             0007*   ; absolute value of hlu
040470             0008*   ; returns: abs(hlu), flags set according to the incoming sign of hlu:
040470             0009*   ;         s1,z0,pv0,n1,c0 if hlu was negative
040470             0010*   ;         s0,z1,pv0,n1,c0 if hlu was zero
040470             0011*   ;         s0,z0,pv0,n1,c0 if hlu was positive
040470             0012*   ; destroys: a
040470             0013*   hlu_abs:
040470 19          0014*       add hl,de
040471 B7          0015*       or a
040472 ED 52       0016*       sbc hl,de
040474 FA 79 04 04 0017*       jp m,@is_neg
040478 C9          0018*       ret ; hlu is positive or zero so we're done
040479             0019*   @is_neg:
040479 F5          0020*       push af ; otherwise, save current flags for return
04047A CD 80 04 04 0021*       call neg_hlu ; negate hlu
04047E F1          0022*       pop af ; get back flags
04047F C9          0023*       ret
040480             0024*   
040480             0025*   ; flip the sign of hlu
040480             0026*   ; inputs: hlu
040480             0027*   ; returns: 0-hlu, flags set appropriately for the result:
040480             0028*   ;         s1,z0,pv0,n1,c1 if result is negative
040480             0029*   ;         s0,z1,pv0,n1,c0 if result is zero
040480             0030*   ;         s0,z0,pv0,n1,c1 if result is positive
040480             0031*   ; destroys a
040480             0032*   neg_hlu:
040480 D5          0033*       push de ; save de
040481 EB          0034*       ex de,hl ; put hl into de
040482 21 00 00 00 0035*       ld hl,0 ; clear hl
040486 AF          0036*       xor a ; clear carry
040487 ED 52       0037*       sbc hl,de ; 0-hlu = -hlu
040489 D1          0038*       pop de ; get de back
04048A C9          0039*       ret ; easy peasy
04048B             0040*   
04048B             0041*   ;------------------------------------------------------------------------
04048B             0042*   ; divide hlu by 2, inspired by above
04048B             0043*   ;------------------------------------------------------------------------
04048B             0044*   hlu_div2:
04048B 22 6A 04 04 0045*       ld (scratch1),hl
04048F 21 6C 04 04 0046*       ld hl,scratch1+2
040493 CB 1E       0047*       rr (hl)
040495 2B          0048*       dec hl
040496 CB 1E       0049*       rr (hl)
040498 2B          0050*       dec hl
040499 CB 1E       0051*       rr (hl)
04049B 23          0052*       inc hl
04049C 23          0053*       inc hl
04049D 2A 6A 04 04 0054*       ld hl,(scratch1)
0404A1 C9          0055*       ret
0404A2             0056*   
0404A2             0057*   ; this is my little hack to divide by 16
0404A2             0058*   hlu_div16:
0404A2 AF          0059*       xor a
0404A3 29          0060*       add hl,hl
0404A4 17          0061*       rla
0404A5 29          0062*       add hl,hl
0404A6 17          0063*       rla
0404A7 29          0064*       add hl,hl
0404A8 17          0065*       rla
0404A9 29          0066*       add hl,hl
0404AA 17          0067*       rla
0404AB 22 B8 04 04 0068*       ld (@scratch),hl
0404AF 32 BB 04 04 0069*       ld (@scratch+3),a
0404B3 2A B9 04 04 0070*       ld hl,(@scratch+1)
0404B7 C9          0071*       ret
0404B8             0072*   @scratch: ds 4
0404BC             0073*   
0404BC             0074*   ; hlu signed division by 256
0404BC             0075*   ; returns: hlu / 256
0404BC             0076*   ; destroys: af
0404BC             0077*   hlu_sdiv256:
       FF FF FF FF 
0404BC AF          0078*       xor a ; assume hl is positive
0404BD 22 D3 04 04 0079*       ld (@buffer),hl
0404C1             0080*       SIGN_HLU
                       M1 Args: none
0404C1 19          0001*M1     add hl,de ; 1 cycle
0404C2 B7          0002*M1     or a ; clear flags ; 1 cycle
0404C3 ED 52       0003*M1     sbc hl,de ; 2 cycles
0404C5             0004*M1     ; 4 cycles total
0404C5 F2 CA 04 04 0081*       jp p,@hl_pos
0404C9 3D          0082*       dec a
0404CA             0083*   @hl_pos:
0404CA 32 D6 04 04 0084*       ld (@buffer+3),a
0404CE 2A D4 04 04 0085*       ld hl,(@buffer+1)
0404D2 C9          0086*       ret
0404D3             0087*   @buffer: ds 4
0404D7             0088*   
0404D7             0089*   ; hlu 1 byte right shift, unsigned
0404D7             0090*   ; returns: hlu / 256, fractional portion in a
0404D7             0091*   ; destroys: af
0404D7             0092*   hlu_udiv256:
       FF FF FF FF 
0404D7 AF          0093*       xor a
0404D8 32 E9 04 04 0094*       ld (@buffer+3),a
0404DC 7D          0095*       ld a,l ; save the fractional portion
0404DD 22 E6 04 04 0096*       ld (@buffer),hl
0404E1 2A E7 04 04 0097*       ld hl,(@buffer+1)
0404E5 C9          0098*       ret
0404E6             0099*   @buffer: ds 4
0404EA             0100*   
0404EA             0101*   ; floor(value,n)
0404EA             0102*   ; inputs: hl = value to floor, de = n
0404EA             0103*   ; outputs: hl = value floored to n
0404EA             0104*   ; destroys: af, hl, bc, de
0404EA             0105*   hlu_floor:
       FF FF FF FF 
0404EA D5          0106*       push de ; save n
0404EB CD 80 03 04 0107*       call udiv24 ; de = quotient, hl = remainder
0404EF E1          0108*       pop hl ; get n back (was de)
0404F0 CD 67 03 04 0109*       call umul24 ; hl = n * quotient
0404F4 C9          0110*       ret
0404F5             0111*   ; end hlu_floor
0404F5             0112*   
0404F5             0113*   ; ceil(value,n)
0404F5             0114*   ; inputs: hl = value to ceil, de = n
0404F5             0115*   ; outputs: hl = value ceiled to n
0404F5             0116*   ; destroys: af, hl, bc, de
0404F5             0117*   hlu_ceiling:
0404F5 D5          0118*       push de ; save n
0404F6 CD 80 03 04 0119*       call udiv24 ; de = quotient, hl = remainder
0404FA             0120*       SIGN_HLU ; test remaider for zero
                       M1 Args: none
0404FA 19          0001*M1     add hl,de ; 1 cycle
0404FB B7          0002*M1     or a ; clear flags ; 1 cycle
0404FC ED 52       0003*M1     sbc hl,de ; 2 cycles
0404FE             0004*M1     ; 4 cycles total
0404FE CA 03 05 04 0121*       jp z,@F ; if zero, nothing to add
040502 13          0122*       inc de ; add 1 to quotient for the ceiling
040503             0123*   @@:
040503 E1          0124*       pop hl ; get n back (was de)
040504 CD 67 03 04 0125*       call umul24 ; hl = n * quotient
040508 C9          0126*       ret
040509             0127*   ; end hlu_ceiling
040509             0128*   
040509 C9          0129*       ret
04050A             0130*   
04050A 00 00 00 00 0131*   add_bcd_arg1: db #00,#00,#00,#00
04050E 00 00 00 00 0132*   add_bcd_arg2: db #00,#00,#00,#00
040512             0133*   
040512             0134*   ; set bcd values in a scratch memory address from registers bcde
040512             0135*   ; input: hl; scratch address,bcde; 8-place bcd number
040512             0136*   ; destroys ; hl
040512             0137*   set_bcd:
040512 73          0138*       ld (hl),e
040513 23          0139*       inc hl
040514 72          0140*       ld (hl),d
040515 23          0141*       inc hl
040516 71          0142*       ld (hl),c
040517 23          0143*       inc hl
040518 70          0144*       ld (hl),b
040519 C9          0145*       ret
04051A             0146*   
04051A             0147*   ; load bcd values from a scratch memory address to bcde
04051A             0148*   ; input: hl; scratch address
04051A             0149*   ; output: bcde; 8-place bcd number
04051A             0150*   ; destroys: hl
04051A             0151*   get_bcd:
04051A 5E          0152*       ld e,(hl)
04051B 23          0153*       inc hl
04051C 56          0154*       ld d,(hl)
04051D 23          0155*       inc hl
04051E 4E          0156*       ld c,(hl)
04051F 23          0157*       inc hl
040520 46          0158*       ld b,(hl)
040521 C9          0159*       ret
040522             0160*   
040522             0161*   ; BCD addition
040522             0162*   ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
040522             0163*   ;       a is the number of bytes holding each number (number of places/2)
040522             0164*   ; outputs: (hl) + (de) --> (hl)
040522             0165*   ; destroys: a,b,de,hl
040522             0166*   add_bcd:
040522 47          0167*       ld b,a ; loop counter
040523 AF          0168*       xor a ; reset a, clear carry flag
040524             0169*   adcec:
040524 1A          0170*       ld a,(de) ; addend to acc
040525 8E          0171*       adc a,(hl) ; add (hl) to acc
040526 27          0172*       daa ; adjust result to bcd
040527 77          0173*       ld (hl),a ; store result
040528 23          0174*       inc hl ; advance memory pointers
040529 13          0175*       inc de
04052A 10 F8       0176*       djnz adcec ; loop until b == 0
04052C C9          0177*       ret
04052D             0178*   
04052D             0179*   ; BCD subtraction
04052D             0180*   ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
04052D             0181*   ;       a is the number of bytes holding each number (number of places/2)
04052D             0182*   ; outputs: (hl) - (de) --> (hl)
04052D             0183*   ; destroys: a,b,de,hl
04052D             0184*   sub_bcd:
04052D 47          0185*       ld b,a ; loop counter
04052E AF          0186*       xor a ; reset a,clear carry flag
04052F             0187*   subdec:
04052F 1A          0188*       ld a,(de) ; subtrahend to acc
040530 9E          0189*       sbc a,(hl) ; subtract (hl) from acc
040531 27          0190*       daa ; adjust result to bcd
040532 77          0191*       ld (hl),a ; store result
040533 23          0192*       inc hl ; advance memory pointers
040534 13          0193*       inc de
040535 10 F8       0194*       djnz subdec ; loop until b == 0
040537 C9          0195*       ret
040538             0196*   
040538             0197*   ; http://www.z80.info/pseudo-random.txt
040538             0198*   rand_8:
040538 C5          0199*       push bc
040539 3A 4C 05 04 0200*       ld a,(r_seed)
04053D 4F          0201*       ld c,a
04053E             0202*   
04053E 0F          0203*       rrca ; multiply by 32
04053F 0F          0204*       rrca
040540 0F          0205*       rrca
040541 EE 1F       0206*       xor 0x1f
040543             0207*   
040543 81          0208*       add a,c
040544 DE FF       0209*       sbc a,255 ; carry
040546             0210*   
040546 32 4C 05 04 0211*       ld (r_seed),a
04054A C1          0212*       pop bc
04054B C9          0213*       ret
04054C 50          0214*   r_seed: defb $50
04054D             0215*   
04054D             0216*   ; https://www.omnimaga.org/asm-language/ez80-optimized-routines/msg399325/#msg399325
04054D             0217*   prng24:
04054D             0218*   ;;Expects ADL mode.
04054D             0219*   ;;Output: HL
04054D             0220*   ;;50cc
04054D             0221*   ;;33 bytes
04054D             0222*   ;;cycle length: 281,474,959,933,440 (about 2.8 trillion)
04054D ED 5B 6E 05 0223*       ld de,(seed1)
       04          
040552 B7          0224*       or a
040553 ED 62       0225*       sbc hl,hl
040555 19          0226*       add hl,de
040556 29          0227*       add hl,hl
040557 29          0228*       add hl,hl
040558 2C          0229*       inc l
040559 19          0230*       add hl,de
04055A 22 6E 05 04 0231*       ld (seed1),hl
04055E 2A 71 05 04 0232*       ld hl,(seed2)
040562 29          0233*       add hl,hl
040563 9F          0234*       sbc a,a
040564 E6 1B       0235*       and %00011011
040566 AD          0236*       xor l
040567 6F          0237*       ld l,a
040568 22 71 05 04 0238*       ld (seed2),hl
04056C 19          0239*       add hl,de
04056D C9          0240*       ret
04056E 00 00 00    0241*   seed1: dl 0
040571 00 00 00    0242*   seed2: dl 0
040574             0243*   
040574             0244*   
040574             0245*   ; https://map.grauw.nl/sources/external/z80bits.html#2.1
040574             0246*   ; 2.1 Restoring 8-bit / 8-bit Unsigned
040574             0247*   ; Input: H = Dividend, L = Divisor, A = 0
040574             0248*   ; Output: H = Quotient, A = Remainder, L = Divisor (unchanged)
040574             0249*   udiv8:
040574 AF          0250*       xor a
040575 06 08       0251*       ld b,8
040577             0252*   @loop:
040577 CB 24       0253*       sla h
040579 17          0254*       rla
04057A BD          0255*       cp l
04057B 38 02       0256*       jr c,$+4
04057D 95          0257*       sub l
04057E 24          0258*       inc h
04057F 10 F6       0259*       djnz @loop
040581 C9          0260*       ret
040582             0035        include "fonts.inc"
040582             0001*   fonts_load:
040582 DD 21 B3 05 0002*       ld ix,font_list ; pointer to font list lookup
       04          
040587 06 01       0003*       ld b,num_fonts ; loop counter
040589             0004*   
040589             0005*   @load_loop:
040589 C5          0006*       push bc ; save loop counter
04058A             0007*   
04058A             0008*   ; load font into a buffer
04058A DD 27 06    0009*       ld hl,(ix+font_list_bufferId)
04058D DD 31 09    0010*       ld iy,(ix+font_list_filename)
040590 CD 94 14 04 0011*       call vdu_load_buffer_from_file
040594             0012*   
040594             0013*   ; create font from buffer
040594 DD 27 06    0014*       ld hl,(ix+font_list_bufferId)
040597 DD 5E 00    0015*       ld e,(ix+font_list_width)
04059A DD 56 03    0016*       ld d,(ix+font_list_height)
04059D 3E 00       0017*       ld a,0 ; flags
04059F CD E7 16 04 0018*       call vdu_font_create
0405A3             0019*   
0405A3             0020*   ; select font
0405A3 DD 27 06    0021*       ld hl,(ix+font_list_bufferId)
0405A6 3E 01       0022*       ld a,1 ; flags
0405A8 CD CD 16 04 0023*       call vdu_font_select
0405AC             0024*   
0405AC             0025*   ; ; debug print filename
0405AC             0026*   ;     call printNewLine
0405AC             0027*   ;     ld hl,(ix+font_list_filename)
0405AC             0028*   ;     call printString
0405AC             0029*   
0405AC             0030*   ; advance font_list pointer to next record
0405AC ED 32 0C    0031*       lea ix,ix+font_list_record_size
0405AF             0032*   
0405AF             0033*   ; restore loop counter
0405AF C1          0034*       pop bc
0405B0 10 D7       0035*       djnz @load_loop
0405B2             0036*   
0405B2             0037*   ; all done
0405B2 C9          0038*       ret
0405B3             0036        include "fonts_list.inc"
0405B3             0001*   ; Generated by asm_config_editor.py
0405B3             0002*   font_list_record_size: equ 12
0405B3             0003*   font_list_width: equ 0
0405B3             0004*   font_list_height: equ 3
0405B3             0005*   font_list_bufferId: equ 6
0405B3             0006*   font_list_filename: equ 9
0405B3             0007*   
0405B3             0008*   num_fonts: equ 1
0405B3             0009*   
0405B3             0010*   ; Index list:
0405B3             0011*   ; amiga_forever_16x16: equ 64000
0405B3             0012*   ; amiga_forever_16x24: equ 64001
0405B3             0013*   ; amiga_forever_8x16: equ 64002
0405B3             0014*   ; amiga_forever_8x8: equ 64003
0405B3             0015*   ; computer_pixel_7_10x15: equ 64004
0405B3             0016*   ; computer_pixel_7_10x24: equ 64005
0405B3             0017*   ; computer_pixel_7_8x12: equ 64006
0405B3             0018*   ; computer_pixel_7_8x14: equ 64007
0405B3             0019*   ; computer_pixel_7_8x16: equ 64008
0405B3             0020*   ; dopecre_8x8: equ 64009
0405B3             0021*   ; gamer_2_8x8: equ 64010
0405B3             0022*   ; Lat15_VGA8_8x8: equ 64011
0405B3             0023*   ; Lat2_Terminus12x6_6x12: equ 64012
0405B3             0024*   ; Lat2_TerminusBold14_8x14: equ 64013
0405B3             0025*   ; Lat2_VGA14_8x14: equ 64014
0405B3             0026*   ; Lat2_VGA16_8x16: equ 64015
0405B3             0027*   Lat2_VGA8_8x8: equ 64016
0405B3             0028*   ; Lat38_VGA8_8x8: equ 64017
0405B3             0029*   ; Lat7_Fixed13_8x13: equ 64018
0405B3             0030*   ; Lat7_Terminus12x6_6x12: equ 64019
0405B3             0031*   ; Lat7_TerminusBold16_8x16: equ 64020
0405B3             0032*   ; Lat7_VGA14_8x14: equ 64021
0405B3             0033*   ; Lat7_VGA16_8x16: equ 64022
0405B3             0034*   ; Lat7_VGA8_8x8: equ 64023
0405B3             0035*   ; planetary_contact_8x8: equ 64024
0405B3             0036*   ; scriptorium_12x14: equ 64025
0405B3             0037*   ; Squarewave_Bold_8x12: equ 64026
0405B3             0038*   ; super_mario_bros_2_8x8: equ 64027
0405B3             0039*   ; wendy_neue_6x6: equ 64028
0405B3             0040*   
0405B3             0041*   font_list: ; width; height; bufferId; filename;:
0405B3             0042*   	; dl 16, 16, 64000, fn_amiga_forever_16x16
0405B3             0043*   	; dl 16, 24, 64001, fn_amiga_forever_16x24
0405B3             0044*   	; dl 8, 16, 64002, fn_amiga_forever_8x16
0405B3             0045*   	; dl 8, 8, 64003, fn_amiga_forever_8x8
0405B3             0046*   	; dl 10, 15, 64004, fn_computer_pixel_7_10x15
0405B3             0047*   	; dl 10, 24, 64005, fn_computer_pixel_7_10x24
0405B3             0048*   	; dl 8, 12, 64006, fn_computer_pixel_7_8x12
0405B3             0049*   	; dl 8, 14, 64007, fn_computer_pixel_7_8x14
0405B3             0050*   	; dl 8, 16, 64008, fn_computer_pixel_7_8x16
0405B3             0051*   	; dl 8, 8, 64009, fn_dopecre_8x8
0405B3             0052*   	; dl 8, 8, 64010, fn_gamer_2_8x8
0405B3             0053*   	; dl 8, 8, 64011, fn_Lat15_VGA8_8x8
0405B3             0054*   	; dl 6, 12, 64012, fn_Lat2_Terminus12x6_6x12
0405B3             0055*   	; dl 8, 14, 64013, fn_Lat2_TerminusBold14_8x14
0405B3             0056*   	; dl 8, 14, 64014, fn_Lat2_VGA14_8x14
0405B3             0057*   	; dl 8, 16, 64015, fn_Lat2_VGA16_8x16
0405B3 08 00 00 08 0058*   	dl 8, 8, 64016, fn_Lat2_VGA8_8x8
       00 00 10 FA 
       00 BF 05 04 
0405BF             0059*   	; dl 8, 8, 64017, fn_Lat38_VGA8_8x8
0405BF             0060*   	; dl 8, 13, 64018, fn_Lat7_Fixed13_8x13
0405BF             0061*   	; dl 6, 12, 64019, fn_Lat7_Terminus12x6_6x12
0405BF             0062*   	; dl 8, 16, 64020, fn_Lat7_TerminusBold16_8x16
0405BF             0063*   	; dl 8, 14, 64021, fn_Lat7_VGA14_8x14
0405BF             0064*   	; dl 8, 16, 64022, fn_Lat7_VGA16_8x16
0405BF             0065*   	; dl 8, 8, 64023, fn_Lat7_VGA8_8x8
0405BF             0066*   	; dl 8, 8, 64024, fn_planetary_contact_8x8
0405BF             0067*   	; dl 12, 14, 64025, fn_scriptorium_12x14
0405BF             0068*   	; dl 8, 12, 64026, fn_Squarewave_Bold_8x12
0405BF             0069*   	; dl 8, 8, 64027, fn_super_mario_bros_2_8x8
0405BF             0070*   	; dl 6, 6, 64028, fn_wendy_neue_6x6
0405BF             0071*   
0405BF             0072*   ; files_list: ; filename:
0405BF             0073*   ; fn_amiga_forever_16x16: db "fontsamiga_forever_16x16.font",0
0405BF             0074*   ; fn_amiga_forever_16x24: db "fontsamiga_forever_16x24.font",0
0405BF             0075*   ; fn_amiga_forever_8x16: db "fontsamiga_forever_8x16.font",0
0405BF             0076*   ; fn_amiga_forever_8x8: db "fontsamiga_forever_8x8.font",0
0405BF             0077*   ; fn_computer_pixel_7_10x15: db "fontscomputer_pixel_7_10x15.font",0
0405BF             0078*   ; fn_computer_pixel_7_10x24: db "fontscomputer_pixel_7_10x24.font",0
0405BF             0079*   ; fn_computer_pixel_7_8x12: db "fontscomputer_pixel_7_8x12.font",0
0405BF             0080*   ; fn_computer_pixel_7_8x14: db "fontscomputer_pixel_7_8x14.font",0
0405BF             0081*   ; fn_computer_pixel_7_8x16: db "fontscomputer_pixel_7_8x16.font",0
0405BF             0082*   ; fn_dopecre_8x8: db "fontsdopecre_8x8.font",0
0405BF             0083*   ; fn_gamer_2_8x8: db "fontsgamer_2_8x8.font",0
0405BF             0084*   ; fn_Lat15_VGA8_8x8: db "fontsLat15-VGA8_8x8.font",0
0405BF             0085*   ; fn_Lat2_Terminus12x6_6x12: db "fontsLat2-Terminus12x6_6x12.font",0
0405BF             0086*   ; fn_Lat2_TerminusBold14_8x14: db "fontsLat2-TerminusBold14_8x14.font",0
0405BF             0087*   ; fn_Lat2_VGA14_8x14: db "fontsLat2-VGA14_8x14.font",0
0405BF             0088*   ; fn_Lat2_VGA16_8x16: db "fontsLat2-VGA16_8x16.font",0
0405BF 66 6F 6E 74 0089*   fn_Lat2_VGA8_8x8: db "fontsLat2-VGA8_8x8.font",0
       73 4C 61 74 
       32 2D 56 47 
       41 38 5F 38 
       78 38 2E 66 
       6F 6E 74 00 
0405D7             0090*   ; fn_Lat38_VGA8_8x8: db "fontsLat38-VGA8_8x8.font",0
0405D7             0091*   ; fn_Lat7_Fixed13_8x13: db "fontsLat7-Fixed13_8x13.font",0
0405D7             0092*   ; fn_Lat7_Terminus12x6_6x12: db "fontsLat7-Terminus12x6_6x12.font",0
0405D7             0093*   ; fn_Lat7_TerminusBold16_8x16: db "fontsLat7-TerminusBold16_8x16.font",0
0405D7             0094*   ; fn_Lat7_VGA14_8x14: db "fontsLat7-VGA14_8x14.font",0
0405D7             0095*   ; fn_Lat7_VGA16_8x16: db "fontsLat7-VGA16_8x16.font",0
0405D7             0096*   ; fn_Lat7_VGA8_8x8: db "fontsLat7-VGA8_8x8.font",0
0405D7             0097*   ; fn_planetary_contact_8x8: db "fontsplanetary_contact_8x8.font",0
0405D7             0098*   ; fn_scriptorium_12x14: db "fontsscriptorium_12x14.font",0
0405D7             0099*   ; fn_Squarewave_Bold_8x12: db "fontsSquarewave_Bold_8x12.font",0
0405D7             0100*   ; fn_super_mario_bros_2_8x8: db "fontssuper_mario_bros_2_8x8.font",0
0405D7             0101*   ; fn_wendy_neue_6x6: db "fontswendy_neue_6x6.font",0
0405D7             0037        include "fixed168.inc"
0405D7             0001*   ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
0405D7             0002*   ; uses EZ80 MLT instruction for speed
0405D7             0003*   ; operation: UHL * A --> UHL
0405D7             0004*   ; destroys: AF, HL
0405D7             0005*   smul24x8:
0405D7             0006*   ; make hl positive and store sign flag
0405D7 CD 70 04 04 0007*       call hlu_abs
0405DB F5          0008*       push af
0405DC             0009*   ; do the division
0405DC CD E7 05 04 0010*       call mul24x8 ; hl = product
0405E0             0011*   ; adjust sign of result
0405E0 F1          0012*       pop af ; sign de
0405E1 F0          0013*       ret p ; hl was positive, nothing to do
0405E2 CD 80 04 04 0014*       call neg_hlu ; result is negative
0405E6 C9          0015*       ret
0405E7             0016*   
0405E7             0017*   ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
0405E7             0018*   ; uses EZ80 MLT instruction for speed
0405E7             0019*   ; operation: UHL * A --> AUHL
0405E7             0020*   ; destroys: AF, HL
0405E7             0021*   mul24x8:
0405E7 D5          0022*       push de ; preserve de
0405E8             0023*   ; low byte
0405E8 5D          0024*       ld e,l
0405E9 57          0025*       ld d,a
0405EA ED 5C       0026*       mlt de
0405EC 6B          0027*       ld l,e ; product low byte
0405ED 08          0028*       ex af,af' ; save multiplier
0405EE 7A          0029*       ld a,d ; carry
0405EF 08          0030*       ex af,af' ; save carry, restore multiplier
0405F0             0031*   ; high byte
0405F0 5C          0032*       ld e,h
0405F1 57          0033*       ld d,a
0405F2 ED 5C       0034*       mlt de
0405F4 08          0035*       ex af,af' ; save multiplier, restore carry
0405F5 83          0036*       add a,e ; add carry
0405F6 67          0037*       ld h,a ; product middle byte
0405F7 7A          0038*       ld a,d ; carry
0405F8 08          0039*       ex af,af' ; save carry, restore multiplier
0405F9             0040*   ; upper byte
0405F9 22 14 06 04 0041*       ld (@scratch),hl ; 7 cycles
0405FD 5F          0042*       ld e,a
0405FE 3A 16 06 04 0043*       ld a,(@scratch+2)
040602 57          0044*       ld d,a
040603 ED 5C       0045*       mlt de
040605 08          0046*       ex af,af' ; restore carry
040606 8B          0047*       adc a,e ; add carry
040607 32 16 06 04 0048*       ld (@scratch+2),a ; 5 cycles
04060B 2A 14 06 04 0049*       ld hl,(@scratch) ; 7 cycles
04060F             0050*   ; highest byte
04060F 3E 00       0051*       ld a,0 ; preserve carry flag
040611 8A          0052*       adc a,d ; product highest byte
040612 D1          0053*       pop de ; restore de
040613 C9          0054*       ret
040614             0055*   @scratch: ds 3
040617             0056*   
       FF FF FF 
040617 00 00 00 00 0057*   mul24out: blkb 6,0
       00 00       
04061D             0058*   
04061D             0059*   ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
04061D             0060*   ; operation: UHL * UDE --> mul24out
04061D             0061*   mul24:
04061D DD E5       0062*       push ix ; preserve
04061F             0063*   ; point to output buffer and clear it
04061F DD 21 17 06 0064*       ld ix,mul24out
       04          
040624 C5          0065*       push bc
040625 01 00 00 00 0066*       ld bc,0
040629 DD 0F 00    0067*       ld (ix),bc
04062C DD 0F 03    0068*       ld (ix+3),bc
04062F C1          0069*       pop bc
040630             0070*   ; STEP 1: UHL * E
040630 7B          0071*       ld a,e
040631 E5          0072*       push hl
040632 CD E7 05 04 0073*       call mul24x8
040636 DD 2F 00    0074*       ld (ix+0),hl
040639 DD 77 03    0075*       ld (ix+3),a
04063C             0076*   ; STEP 2: UHL * D
04063C E1          0077*       pop hl
04063D E5          0078*       push hl
04063E 7A          0079*       ld a,d
04063F CD E7 05 04 0080*       call mul24x8
040643 CD 5C 06 04 0081*       call @accumulate
040647             0082*   ; STEP 3: UHL * DEU
040647 E1          0083*       pop hl
040648 ED 53 8C 06 0084*       ld (@de),de
       04          
04064D 3A 8E 06 04 0085*       ld a,(@de+2)
040651 CD E7 05 04 0086*       call mul24x8
040655 CD 5C 06 04 0087*       call @accumulate
040659             0088*   ; all done
040659 DD E1       0089*       pop ix ; restore
04065B C9          0090*       ret
04065C             0091*   @accumulate:
04065C DD 23       0092*       inc ix
04065E             0093*   ; highest byte of product to carry
04065E DD 77 03    0094*       ld (ix+3),a
040661             0095*   ; low byte of product
040661 7D          0096*       ld a,l
040662 DD 86 00    0097*       add a,(ix+0)
040665 DD 77 00    0098*       ld (ix+0),a
040668             0099*   ; high byte of product
040668 7C          0100*       ld a,h
040669 DD 8E 01    0101*       adc a,(ix+1)
04066C DD 77 01    0102*       ld (ix+1),a
04066F             0103*   ; uppper byte of product
04066F 22 89 06 04 0104*       ld (@hl),hl
040673 3A 8B 06 04 0105*       ld a,(@hl+2)
040677 DD 8E 02    0106*       adc a,(ix+2)
04067A DD 77 02    0107*       ld (ix+2),a
04067D             0108*   ; carry
04067D 3E 00       0109*       ld a,0 ; preserve flags
04067F DD 8E 03    0110*       adc a,(ix+3)
040682 DD 77 03    0111*       ld (ix+3),a
040685 C9          0112*       ret
040686             0113*   
040686 00 00 00    0114*   @ix: dl 0
040689 00 00 00    0115*   @hl: dl 0
04068C 00 00 00    0116*   @de: dl 0
04068F             0117*   
04068F             0118*   ; ; UHL * UDE --> UHL (unsigned)
04068F             0119*   ; umul24:
04068F             0120*   ;     call mul24
04068F             0121*   ;     ld hl,(mul24out)
04068F             0122*   ;     ret
04068F             0123*   
04068F             0124*   ; UH.L = UH.L*UD.E (unsigned)
04068F             0125*   umul168:
04068F CD 1D 06 04 0126*       call mul24
040693 2A 18 06 04 0127*       ld hl,(mul24out+1)
040697 C9          0128*       ret
040698             0129*   
040698             0130*   ; UH.L * UD.E --> UH.L (signed)
040698             0131*   smul168:
040698             0132*   ; make everything positive and store sign flags
040698 CD 70 04 04 0133*       call hlu_abs
04069C F5          0134*       push af
04069D EB          0135*       ex de,hl
04069E CD 70 04 04 0136*       call hlu_abs
0406A2 EB          0137*       ex de,hl
0406A3 F5          0138*       push af
0406A4             0139*   ; do the division
0406A4 CD 8F 06 04 0140*       call umul168 ; hl = product
0406A8             0141*   ; adjust sign of result
0406A8 F1          0142*       pop af ; sign de
0406A9 FA B4 06 04 0143*       jp m,@de_neg
0406AD F1          0144*       pop af ; sign hl
0406AE F0          0145*       ret p ; both positive, nothing to do
0406AF             0146*   @hl_neg:
0406AF CD 80 04 04 0147*       call neg_hlu ; de pos, hl neg, result is negative
0406B3 C9          0148*       ret
0406B4             0149*   @de_neg:
0406B4 F1          0150*       pop af
0406B5 F8          0151*       ret m ; both negative, nothing to do
0406B6 CD 80 04 04 0152*       call neg_hlu ; result is negative
0406BA C9          0153*       ret
0406BB             0154*   
0406BB             0155*   ; UH.L / UD.E --> UD.E rem UHL (unsigned)
0406BB             0156*   ; perform unsigned division of 16.8 fixed place values
0406BB             0157*   ; with an unsigned 16.8 fixed place result and 24-bit remainder
0406BB             0158*   udiv168:
0406BB             0159*   ; back up divisor
0406BB ED 53 F2 06 0160*       ld (@ude),de
       04          
0406C0             0161*   ; get the 16-bit integer part of the quotient
0406C0 CD 80 03 04 0162*       call udiv24 ; de = quotient, hl = remainder
0406C4             0163*   ; load quotient to upper three bytes of output
0406C4 ED 53 F9 06 0164*       ld (div168_out+1),de
       04          
0406C9             0165*   @div256:
0406C9             0166*   ; multiply remainder by 256
0406C9             0167*       hlu_mul256
                       M1 Args: none
0406C9 29          0001*M1     add hl,hl ; * 2
0406CA 29          0002*M1     add hl,hl ; * 4
0406CB 29          0003*M1     add hl,hl ; * 8
0406CC 29          0004*M1     add hl,hl ; * 16
0406CD 29          0005*M1     add hl,hl ; * 32
0406CE 29          0006*M1     add hl,hl ; * 64
0406CF 29          0007*M1     add hl,hl ; * 128
0406D0 29          0008*M1     add hl,hl ; * 256
0406D1             0168*   ; skip fractional computation if remainder is zero
0406D1             0169*       SIGN_HLU
                       M1 Args: none
0406D1 19          0001*M1     add hl,de ; 1 cycle
0406D2 B7          0002*M1     or a ; clear flags ; 1 cycle
0406D3 ED 52       0003*M1     sbc hl,de ; 2 cycles
0406D5             0004*M1     ; 4 cycles total
0406D5 20 03       0170*       jr nz,@div_frac
0406D7 AF          0171*       xor a
0406D8 18 0A       0172*       jr @write_frac
0406DA             0173*   ; now divide the shifted remainder by the divisor
0406DA             0174*   @div_frac:
0406DA ED 5B F2 06 0175*       ld de,(@ude) ; get back divisor
       04          
0406DF CD 80 03 04 0176*       call udiv24 ; de = quotient, hl = remainder
0406E3             0177*   ; load low byte of quotient to low byte of output
0406E3 7B          0178*       ld a,e
0406E4             0179*   @write_frac:
0406E4 32 F8 06 04 0180*       ld (div168_out),a
0406E8             0181*   ; load de with return value
0406E8 ED 5B F8 06 0182*       ld de,(div168_out)
       04          
0406ED             0183*   ; load a with any overflow
0406ED 3A FB 06 04 0184*       ld a,(div168_out+3)
0406F1 C9          0185*       ret ; ud.e is the 16.8 result
0406F2             0186*   @ude: ds 6
0406F8             0187*   div168_out: ds 4 ; the extra byte is for overflow
0406FC             0188*   
0406FC             0189*   ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
0406FC             0190*   ; perform signed division of 16.8 fixed place values
0406FC             0191*   ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
0406FC             0192*   sdiv168:
0406FC             0193*   ; make everything positive and store sign flags
       FF FF FF FF 
       FF FF FF FF 
       FF FF 
0406FC CD 70 04 04 0194*       call hlu_abs
040700 F5          0195*       push af
040701 EB          0196*       ex de,hl
040702 CD 70 04 04 0197*       call hlu_abs
040706 EB          0198*       ex de,hl
040707 F5          0199*       push af
040708             0200*   ; do the division
040708 CD BB 06 04 0201*       call udiv168 ; de = quotient, hl = remainder
04070C             0202*   ; adjust sign of result
04070C F1          0203*       pop af ; sign de
04070D FA 1A 07 04 0204*       jp m,@de_neg
040711 F1          0205*       pop af ; sign hl
040712 F0          0206*       ret p ; both positive, nothing to do
040713             0207*   @hl_neg:
040713 EB          0208*       ex de,hl ; hl = quotient, de = remainder
040714 CD 80 04 04 0209*       call neg_hlu ; de pos, hl neg, result is negative
040718 EB          0210*       ex de,hl ; de = negated quotient, hl = remainder
040719 C9          0211*       ret
04071A             0212*   @de_neg:
04071A F1          0213*       pop af
04071B F8          0214*       ret m ; both negative, nothing to do
04071C EB          0215*       ex de,hl ; hl = quotient, de = remainder
04071D CD 80 04 04 0216*       call neg_hlu ; result is negative
040721 EB          0217*       ex de,hl ; de = negated quotient, hl = remainder
040722 C9          0218*       ret
040723             0219*   
040723             0220*   ; convert signed angles from a 360 to 256 degree circle
040723             0221*   ; inputs: uh.l is the angle360 in 16.8 fixed format
040723             0222*   ; outputs: uh.l is the angle256 in 16.8 fixed format
040723             0223*   ; destroys: TODO
040723             0224*   deg_360_to_256:
040723 D5          0225*       push de ; preserve de
040724             0226*   ; make angle positive and store sign flag
040724 CD 70 04 04 0227*       call hlu_abs
040728 F5          0228*       push af
040729             0229*   ; multiply by coversion factor of 256/360
040729 11 B6 00 00 0230*       ld de,0x0000B6 ; 0.711
04072D CD 8F 06 04 0231*       call umul168 ; uh.l = uh.l * 0.711
040731             0232*   ; restore sign flag and adjust output accordingly
040731 F1          0233*       pop af
040732 F2 3A 07 04 0234*       jp p,@pos ; positive number
040736 CD 80 04 04 0235*       call neg_hlu
04073A             0236*   @pos:
04073A             0237*   ; restore de and return uh.l as the result
04073A D1          0238*       pop de
04073B C9          0239*       ret
04073C             0240*   
04073C             0241*   ; convert signed angles from a 256 to 360 degree circle
04073C             0242*   ; inputs: uh.l is the angle256 in 16.8 fixed format
04073C             0243*   ; outputs: uh.l is the angle360 in 16.8 fixed format
04073C             0244*   ; destroys: TODO
04073C             0245*   deg_256_to_360:
04073C D5          0246*       push de ; preserve de
04073D             0247*   ; make angle positive and store sign flag
04073D CD 70 04 04 0248*       call hlu_abs
040741 F5          0249*       push af
040742             0250*   ; multiply by coversion factor of 360/256
040742 11 68 01 00 0251*       ld de,0x000168 ; 1.406
040746 CD 8F 06 04 0252*       call umul168 ; uh.l = uh.l * 1.406
04074A             0253*   ; restore sign flag and adjust output accordingly
04074A F1          0254*       pop af
04074B F2 53 07 04 0255*       jp p,@pos ; positive number
04074F CD 80 04 04 0256*       call neg_hlu
040753             0257*   @pos:
040753             0258*   ; restore de and return uh.l as the result
040753 D1          0259*       pop de
040754 C9          0260*       ret
040755             0261*   
040755             0262*   ; fixed 16.8 routine
040755             0263*   ; cos(uh.l) --> uh.l
040755             0264*   ; destroys: f, hl
040755             0265*   cos168:
040755 D5          0266*       push de ; preserve de
040756             0267*   ; for cos we simply increment the angle by 90 degrees
040756             0268*   ; or 0x004000 in 16.8 degrees256
040756             0269*   ; which makes it a sin problem
040756 11 00 40 00 0270*       ld de,0x004000
04075A 19          0271*       add hl,de ; modulo 256 happens below
04075B D1          0272*       pop de ; restore de
04075C             0273*   ; fall through to sin168
04075C             0274*   
04075C             0275*   ; ---------------------
04075C             0276*   ; fixed 16.8 routine
04075C             0277*   ; sin(uh.l) --> uh.l
04075C             0278*   ; destroys: f, hl
04075C             0279*   sin168:
04075C D5          0280*       push de
04075D             0281*   ; handle negative angles appropriately
04075D CD 70 04 04 0282*       call hlu_abs
040761 F2 6A 07 04 0283*       jp p,@F
040765 11 00 00 FF 0284*       ld de,-256*256
040769 19          0285*       add hl,de
04076A             0286*   @@:
04076A 2E 03       0287*       ld l,3 ; multiply by 3 to get our lookup index
04076C ED 6C       0288*       mlt hl
04076E 11 22 0A 04 0289*       ld de,sin_lut_168 ; grab the lut address
040772 19          0290*       add hl,de ; bump hl by the index
040773 ED 27       0291*       ld hl,(hl) ; don't try this on a z80!
040775 D1          0292*       pop de
040776 C9          0293*       ret
040777             0294*   
040777             0295*   ; 16.8 fixed inputs / outputs
040777             0296*   ; takes: uh.l as angle in degrees 256
040777             0297*   ;        ud.e as radius
040777             0298*   ; returns ub.c as dx, ud.e as dy, uh.l as radius
040777             0299*   ;        displacements from origin (0,0)
040777             0300*   ; destroys: everything except indexes
040777             0301*   polar_to_cartesian:
040777             0302*   ; back up input parameters
040777 22 A6 07 04 0303*       ld (@angle), hl
04077B ED 53 A9 07 0304*       ld (@radius), de
       04          
040780             0305*   ; compute dx = sin(uh.l) * ud.e
040780 CD 5C 07 04 0306*       call sin168 ; uh.l = sin(uh.l)
040784 ED 5B A9 07 0307*       ld de,(@radius)
       04          
040789 CD 98 06 04 0308*       call smul168 ; uh.l = dx
04078D E5          0309*       push hl
04078E             0310*   ; compute dy = -cos(uh.l) * ud.e
04078E 2A A6 07 04 0311*       ld hl,(@angle)
040792 CD 55 07 04 0312*       call cos168 ; uh.l = cos(uh.l)
040796 ED 5B A9 07 0313*       ld de,(@radius)
       04          
04079B CD 98 06 04 0314*       call smul168 ; uh.l = dy
04079F CD 80 04 04 0315*       call neg_hlu ; invert dy for screen coords convention
0407A3 EB          0316*       ex de,hl ; de = dy for output
0407A4 C1          0317*       pop bc ; bc = dx for output
0407A5             0318*   ; and out
0407A5 C9          0319*       ret
0407A6             0320*   @angle: ds 3
0407A9             0321*   @radius: ds 3
0407AC             0322*   
0407AC             0323*   ; 16.8 fixed inputs / outputs
0407AC             0324*   ; inputs: ub.c as dx, ud.e as dy
0407AC             0325*   ;        displacements from origin (0,0)
0407AC             0326*   ; returns: uh.l as angle in degrees 256
0407AC             0327*   ;        ud.e as radius
0407AC             0328*   ; destroys: everything except indexes
0407AC             0329*   cartesian_to_polar:
       FF FF FF FF 
       FF FF 
0407AC ED 43 05 08 0330*       ld (dx168),bc ; dx argument for distance168
       04          
0407B1 ED 53 0B 08 0331*       ld (dy168),de ; dy argument for distance168
       04          
0407B6             0332*   ; compute radius
0407B6 CD 11 08 04 0333*       call distance168 ; uh.l = radius
0407BA E5          0334*       push hl ; save radius
0407BB             0335*   ; compute angle
0407BB ED 4B 05 08 0336*       ld bc,(dx168) ; dx argument for atan2_168fast
       04          
0407C0 ED 5B 0B 08 0337*       ld de,(dy168) ; dy argument for atan2_168fast
       04          
0407C5 CD 71 08 04 0338*       call atan2_168fast ; uh.l = angle
0407C9             0339*   ; return result
0407C9 D1          0340*       pop de ; de = radius (was hl)
0407CA C9          0341*       ret
0407CB             0342*   ; end cartesian_to_polar
0407CB             0343*   
0407CB             0344*   ; 16.8 fixed inputs / outputs
0407CB             0345*   ; inputs: ub.c as dx, ud.e as dy
0407CB             0346*   ;        displacements from origin (0,0)
0407CB             0347*   ; returns: uh.l as angle in degrees 256
0407CB             0348*   ;        ud.e as radius
0407CB             0349*   ; destroys: everything except indexes
0407CB             0350*   ; note: uses distance168sm which is more accurate for small deltas
0407CB             0351*   cartesian_to_polar_sm:
0407CB ED 43 05 08 0352*       ld (dx168),bc ; dx argument for distance168
       04          
0407D0 ED 53 0B 08 0353*       ld (dy168),de ; dy argument for distance168
       04          
0407D5             0354*   ; compute radius
0407D5 CD 4C 08 04 0355*       call distance168sm ; uh.l = radius
0407D9 E5          0356*       push hl ; save radius
0407DA             0357*   ; compute angle
0407DA ED 4B 05 08 0358*       ld bc,(dx168) ; dx argument for atan2_168fast
       04          
0407DF ED 5B 0B 08 0359*       ld de,(dy168) ; dy argument for atan2_168fast
       04          
0407E4 CD 71 08 04 0360*       call atan2_168fast ; uh.l = angle
0407E8             0361*   ; return result
0407E8 D1          0362*       pop de ; de = radius (was hl)
0407E9 C9          0363*       ret
0407EA             0364*   ; end cartesian_to_polar
0407EA             0365*   
0407EA             0366*   ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0407EA             0367*   ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0407EA             0368*   ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
0407EA             0369*   ;         also populates scratch locations dx168 and dy168
0407EA             0370*   ; destroys: a,hl,bc,de
0407EA             0371*   dxy168:
0407EA             0372*   ; compute dx = x1-x0
0407EA AF          0373*       xor a ; clear carry
0407EB DD E5       0374*       push ix ; move ix to hl via the stack
0407ED E1          0375*       pop hl ; hl = x1
0407EE ED 42       0376*       sbc hl,bc ; hl = dx
0407F0 22 05 08 04 0377*       ld (dx168),hl ; dx to scratch
0407F4             0378*   ; compute dy = y1-y0
0407F4 AF          0379*       xor a ; clear carry
0407F5 FD E5       0380*       push iy ; move iy to hl via the stack
0407F7 E1          0381*       pop hl ; hl = y1
0407F8 ED 52       0382*       sbc hl,de ; hl = dy
0407FA 22 0B 08 04 0383*       ld (dy168),hl ; dy to scratch
0407FE             0384*   ; populate output registers and return
0407FE EB          0385*       ex de,hl ; ud.e = dy
0407FF ED 4B 05 08 0386*       ld bc,(dx168) ; ub.c = dx
       04          
040804 C9          0387*       ret
040805 00 00 00 00 0388*   dx168: blkb 6,0
       00 00       
04080B 00 00 00 00 0389*   dy168: blkb 6,0
       00 00       
040811             0390*   
040811             0391*   ; compute the euclidian distance between two cartesian coordinates
040811             0392*   ; using the formula d = sqrt(dx^2+dy^2)
040811             0393*   ; inputs: dx168 and dy168 are dx and dy in 16.8 fixed format
040811             0394*   ; output; uh.l is the 16.8 fixed format distance
040811             0395*   ;         also populates scratch locations dx168 and dy168
040811             0396*   ; destroys: a,hl,bc,de
040811             0397*   ; NOTE: rounds both deltas down to the nearest integer to avoid overflow when squaring,
040811             0398*   ;       thus the result will always be an integer, albeit in 16.8 format
040811             0399*   distance168:
040811             0400*   ; compute dy^2
040811 2A 0B 08 04 0401*       ld hl,(dy168)
040815 CD 70 04 04 0402*       call hlu_abs
040819             0403*       ; call hlu_udiv256 ; make integer to avoid overflow
040819             0404*       SRL_UHL ; make integer to avoid overflow
                       M1 Args: none
040819 3B          0001*M1     dec sp ; 1 cycle
04081A E5          0002*M1     push hl ; 4 cycles
04081B 33          0003*M1     inc sp ; 1 cycle
04081C E1          0004*M1     pop hl ; 4 cycles
04081D 23          0005*M1     inc hl ; 1 cycle
04081E 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
040820             0007*M1     ; 13 cycles total
040820 E5          0405*       push hl
040821 D1          0406*       pop de
040822 CD 67 03 04 0407*       call umul24 ; hl = dy^2
040826 E5          0408*       push hl ; save dy^2
040827             0409*   ; compute dx^2
040827 2A 05 08 04 0410*       ld hl,(dx168)
04082B CD 70 04 04 0411*       call hlu_abs
04082F             0412*       ; call hlu_udiv256 ; make integer to avoid overflow
04082F             0413*       SRL_UHL ; make integer to avoid overflow
                       M1 Args: none
04082F 3B          0001*M1     dec sp ; 1 cycle
040830 E5          0002*M1     push hl ; 4 cycles
040831 33          0003*M1     inc sp ; 1 cycle
040832 E1          0004*M1     pop hl ; 4 cycles
040833 23          0005*M1     inc hl ; 1 cycle
040834 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
040836             0007*M1     ; 13 cycles total
040836 E5          0414*       push hl
040837 D1          0415*       pop de
040838 CD 67 03 04 0416*       call umul24 ; hl = dx^2
04083C             0417*   ; add dx^2 and dy^2
04083C D1          0418*       pop de ; de = dy^2 (was hl)
04083D 19          0419*       add hl,de ; hl = dx^2 + dy^2
04083E             0420*   ; compute the square root
04083E CD 3C 09 04 0421*       call sqrt24 ; de = sqrt(dx^2 + dy^2)
040842 EB          0422*       ex de,hl ; hl = distance
040843             0423*       hlu_mul256 ; convert back to 16.8 fixed
                       M1 Args: none
040843 29          0001*M1     add hl,hl ; * 2
040844 29          0002*M1     add hl,hl ; * 4
040845 29          0003*M1     add hl,hl ; * 8
040846 29          0004*M1     add hl,hl ; * 16
040847 29          0005*M1     add hl,hl ; * 32
040848 29          0006*M1     add hl,hl ; * 64
040849 29          0007*M1     add hl,hl ; * 128
04084A 29          0008*M1     add hl,hl ; * 256
04084B C9          0424*       ret
04084C             0425*   
04084C             0426*   ; compute the euclidian distance between two cartesian coordinates
04084C             0427*   ; using the formula d = sqrt(dx^2+dy^2)
04084C             0428*   ; inputs: dx168 and dy168 are dx and dy in 16.8 fixed format
04084C             0429*   ; output; uh.l is the 16.8 fixed format distance
04084C             0430*   ;         also populates scratch locations dx168 and dy168
04084C             0431*   ; destroys: a,hl,bc,de
04084C             0432*   ; NOTE: sm means 'small' because it doesn't round down the deltas
04084C             0433*   ;       making it more accurate for small deltas,
04084C             0434*   ;       but will overflow if used for screen-sized deltas
04084C             0435*   distance168sm:
04084C             0436*   ; compute dy^2
04084C 2A 0B 08 04 0437*       ld hl,(dy168)
040850 CD 70 04 04 0438*       call hlu_abs
040854 E5          0439*       push hl
040855 D1          0440*       pop de
040856 CD 67 03 04 0441*       call umul24 ; hl = dy^2
04085A E5          0442*       push hl ; save dy^2
04085B             0443*   ; compute dx^2
04085B 2A 05 08 04 0444*       ld hl,(dx168)
04085F CD 70 04 04 0445*       call hlu_abs
040863 E5          0446*       push hl
040864 D1          0447*       pop de
040865 CD 67 03 04 0448*       call umul24 ; hl = dx^2
040869             0449*   ; add dx^2 and dy^2
040869 D1          0450*       pop de ; de = dy^2 (was hl)
04086A 19          0451*       add hl,de ; hl = dx^2 + dy^2
04086B             0452*   ; compute the square root
04086B CD 3C 09 04 0453*       call sqrt24 ; de = sqrt(dx^2 + dy^2)
04086F EB          0454*       ex de,hl ; hl = distance
040870 C9          0455*       ret
040871             0456*   
040871             0457*   ; atan2_(ub.c,ud.e) --> uh.l
040871             0458*   ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040871             0459*   ;   whether inputs are integers or fractional doesn't matter
040871             0460*   ;   so long as the sign bit of the upper byte is correct
040871             0461*   ; output: uh.l is the 16.8 fixed angle in degrees 256
040871             0462*   ; angles are COMPASS HEADINGS based on
040871             0463*   ; screen coordinate conventions,where the y axis is flipped
040871             0464*   ; #E0 224      0       32 #20
040871             0465*   ;        -x,-y | +x,-y
040871             0466*   ; #C0 192------+------ 64 #40
040871             0467*   ;        -x,+y | +x,+y
040871             0468*   ; #A0 160   128 #80   96 #60
040871             0469*   atan2_168fast:
040871             0470*   ; get signs and make everything positive
040871             0471*   ; get abs(x) and store its original sign
040871 C5          0472*       push bc
040872 E1          0473*       pop hl
040873 CD 70 04 04 0474*       call hlu_abs ; if x was negative this also sets the sign flag
040877 E5          0475*       push hl ; store abs(x)
040878 C1          0476*       pop bc ; bc = abs(x)
040879 F5          0477*       push af ; store sign of x
04087A             0478*   ; get abs(y) and store its original sign
04087A EB          0479*       ex de,hl ; hl = y
04087B CD 70 04 04 0480*       call hlu_abs ; if y was negative this also sets the sign flag
04087F EB          0481*       ex de,hl ; de = abs(y)
040880 F5          0482*       push af ; store sign of y
040881             0483*   ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
040881             0484*   ; this ensures that our lookup value is between 0 and 1 inclusive
040881 AF          0485*       xor a ; clear the carry flag
040882 D5          0486*       push de
040883 E1          0487*       pop hl
040884 ED 42       0488*       sbc hl,bc
040886 F5          0489*       push af ; save sign of de - bc
040887 F2 90 08 04 0490*       jp p,@1 ; bc <= de, so we skip ahead
04088B             0491*   ; otherwise we swap bc and de
04088B C5          0492*       push bc
04088C E1          0493*       pop hl
04088D EB          0494*       ex de,hl
04088E E5          0495*       push hl
04088F C1          0496*       pop bc
040890             0497*   @1:
040890             0498*   ; now we're ready to snag our preliminary result
040890 C5          0499*       push bc
040891 E1          0500*       pop hl
040892 CD 00 09 04 0501*       call atan_168fast ; uh.l comes back with prelim result
040896             0502*   ; now we adjust uh.l based on sign of de - bc
040896 F1          0503*       pop af
040897 F2 A3 08 04 0504*       jp p,@2 ; bc <= de,so we skip ahead
04089B EB          0505*       ex de,hl
04089C 21 00 40 00 0506*       ld hl,64*256 ; subtract from 64 (90) degrees
0408A0 AF          0507*       xor a ; clear the carry flag
0408A1 ED 52       0508*       sbc hl,de
0408A3             0509*   @2:
0408A3             0510*   ; adjust the result based on quadrant
0408A3             0511*   ; #E0 224      0       32 #20
0408A3             0512*   ;        -x,-y | +x,-y
0408A3             0513*   ; #C0 192------+------ 64 #40
0408A3             0514*   ;        -x,+y | +x,+y
0408A3             0515*   ; #A0 160   128 #80   96 #60
0408A3 F1          0516*       pop af ; sign of y
0408A4 CA E1 08 04 0517*       jp z,@y_zero
0408A8 F2 C1 08 04 0518*       jp p,@y_pos
0408AC             0519*   ; y neg,check x
0408AC F1          0520*       pop af ; sign of x
0408AD CA BB 08 04 0521*       jp z,@y_neg_x_zero
0408B1 F2 C0 08 04 0522*       jp p,@y_neg_x_pos
0408B5             0523*   ; y neg,x neg
0408B5             0524*   ; angle is 128 to 256 (270 to 360)
0408B5             0525*   ; negating the intermediate does the trick
0408B5 CD 80 04 04 0526*       call neg_hlu
0408B9 18 31       0527*       jr @zero_hlu
0408BB             0528*   
0408BB             0529*   @y_neg_x_zero:
0408BB             0530*   ; y neg,x zero
0408BB             0531*   ; angle is 0
0408BB 21 00 00 00 0532*       ld hl,0
0408BF C9          0533*       ret
0408C0             0534*   @y_neg_x_pos:
0408C0             0535*   ; y neg,x pos
0408C0             0536*   ; angle is 0 to 64 (0 to 90)
0408C0             0537*   ; so we're good
0408C0 C9          0538*       ret
0408C1             0539*   
0408C1             0540*   @y_pos:
0408C1 F1          0541*       pop af ; sign of x
0408C2 CA D1 08 04 0542*       jp z,@y_pos_x_zero
0408C6 F2 D6 08 04 0543*       jp p,@y_pos_x_pos
0408CA             0544*   ; y pos,x neg
0408CA             0545*   ; angle is 128 to 192 (180-270)
0408CA             0546*   ; so we add 128 to intermediate
0408CA 11 00 80 00 0547*       ld de,128*256
0408CE 19          0548*       add hl,de
0408CF 18 1B       0549*       jr @zero_hlu
0408D1             0550*   @y_pos_x_zero:
0408D1             0551*   ; y pos,x zero
0408D1             0552*   ; angle is 128 (180)
0408D1 21 00 80 00 0553*       ld hl,128*256
0408D5 C9          0554*       ret
0408D6             0555*   @y_pos_x_pos:
0408D6             0556*   ; y pos,x pos
0408D6             0557*   ; angle is 64 to 128 (90 to 180)
0408D6             0558*   ; neg the intermediate and add 180 degrees
0408D6 CD 80 04 04 0559*       call neg_hlu
0408DA 11 00 80 00 0560*       ld de,128*256
0408DE 19          0561*       add hl,de
0408DF 18 0B       0562*       jr @zero_hlu
0408E1             0563*   
0408E1             0564*   @y_zero:
0408E1 F1          0565*       pop af ; sign of x
0408E2 FA E7 08 04 0566*       jp m,@y_zero_x_neg
0408E6             0567*   ; y zero,x pos
0408E6             0568*   ; angle is 64 (90),nothing to do
0408E6 C9          0569*       ret
0408E7             0570*   @y_zero_x_neg:
0408E7             0571*   ; y zero ,x neg
0408E7             0572*   ; angle is 192 (270)
0408E7 21 00 C0 00 0573*       ld hl,192*256
0408EB C9          0574*       ret
0408EC             0575*   @zero_hlu:
0408EC AF          0576*       xor a
0408ED 22 FA 08 04 0577*       ld (@scratch),hl
0408F1 32 FC 08 04 0578*       ld (@scratch+2),a
0408F5 2A FA 08 04 0579*       ld hl,(@scratch)
0408F9 C9          0580*       ret
0408FA             0581*   @scratch: ds 6
040900             0582*   
040900             0583*   ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040900             0584*   ; output: uh.l is the 16.8 fixed format angle in degrees 256
040900             0585*   ; destroys: a,hl,bc,de
040900             0586*   ; note: only works for angles from 0 to 32 (45) degrees
040900             0587*   ;   use atan2_168fast (which calls this proc) to handle the full 256 (360) degrees
040900             0588*   atan_168fast:
040900             0589*   ; because we use compass headings instead of geometric angles
040900             0590*   ; we compute dx/dy which is 1/tan(theta) in the maths world
040900             0591*   ; we can do faster unsigned division here because we know dx and dy are positive
       FF FF FF FF 
       FF FF 
040900 CD BB 06 04 0592*       call udiv168 ; ud.e = dx/dy
040904 EB          0593*       ex de,hl ; uh.l = dx/dy
040905             0594*   ; test uh.l for 0
040905 19          0595*       add hl,de
040906 B7          0596*       or a
040907 ED 52       0597*       sbc hl,de
040909 28 22       0598*       jr z,@is_zero
04090B             0599*   ; test uh.l for 1
04090B AF          0600*       xor a ; clear carry
04090C EB          0601*       ex de,hl
04090D 21 00 01 00 0602*       ld hl,1*256 ; 1 in 16.8 fixed format
040911 ED 52       0603*       sbc hl,de
040913 28 13       0604*       jr z,@is_45
040915 EB          0605*       ex de,hl
040916             0606*   ; no special cases so we move on
040916             0607*   ; l contains the fractional portion of tan(uh.l)
040916             0608*   ; we multiply it by three to get our lookup table index
040916 26 03       0609*       ld h,3
040918 ED 6C       0610*       mlt hl ; index into lut
04091A 11 00 00 00 0611*       ld de,0 ; clear deu
04091E 54          0612*       ld d,h ; copy hl to de
04091F 5D          0613*       ld e,l ; de contains our index
040920 21 25 0D 04 0614*       ld hl,atan_lut_168 ; grab the lut address
040924 19          0615*       add hl,de ; bump hl by the index
040925 ED 27       0616*       ld hl,(hl) ; don't try this on a z80!
040927 C9          0617*       ret ; and out
040928             0618*   @is_45:
040928 21 00 20 00 0619*       ld hl,32*256
04092C C9          0620*       ret
04092D             0621*   ; for the case tan(0)
04092D             0622*   @is_zero:
04092D 21 00 00 00 0623*       ld hl,0*256
040931 C9          0624*       ret
040932             0625*   
040932             0626*   ; Expects  ADL mode
040932             0627*   ; Inputs:  UH.L
040932             0628*   ; Outputs: UH.L is the 16.8 square root
040932             0629*   ;          UDE is the integer difference inputHL-DE^2
040932             0630*   sqrt168:
040932 CD 3C 09 04 0631*       call sqrt24
040936 EB          0632*       ex de,hl
040937 29          0633*       add hl,hl
040938 29          0634*       add hl,hl
040939 29          0635*       add hl,hl
04093A 29          0636*       add hl,hl
04093B C9          0637*       ret
04093C             0638*   
04093C             0639*   ; credit: xeda112358
04093C             0640*   ; https://www.cemetech.net/forum/viewtopic.php?t=11178&postdays=0&postorder=asc&start=0
04093C             0641*   sqrt24:
04093C             0642*   ; Expects ADL mode
04093C             0643*   ; Inputs: HL
04093C             0644*   ; Outputs: DE is the integer square root
04093C             0645*   ;  HL is the difference inputHL-DE^2
04093C             0646*   ;  c flag reset
04093C 01 00 00 00 0647*       ld bc,0 ; clear bcu
040940 11 00 00 00 0648*       ld de,0 ; clear deu
040944 AF          0649*       xor a
040945 45          0650*       ld b,l
040946 C5          0651*       push bc
040947 47          0652*       ld b,a
040948 6F          0653*       ld l,a
040949             0654*   ; Iteration 1
040949 29          0655*       add hl,hl
04094A CB 11       0656*       rl c
04094C 29          0657*       add hl,hl
04094D CB 11       0658*       rl c
04094F 91          0659*       sub c
040950 30 04       0660*       jr nc,$+6
040952 1C          0661*       inc e
040953 1C          0662*       inc e
040954 2F          0663*       cpl
040955 4F          0664*       ld c,a
040956             0665*   ; Iteration 2
040956 29          0666*       add hl,hl
040957 CB 11       0667*       rl c
040959 29          0668*       add hl,hl
04095A CB 11       0669*       rl c
04095C CB 13       0670*       rl e
04095E 7B          0671*       ld a,e
04095F 91          0672*       sub c
040960 30 04       0673*       jr nc,$+6
040962 1C          0674*       inc e
040963 1C          0675*       inc e
040964 2F          0676*       cpl
040965 4F          0677*       ld c,a
040966             0678*   ; Iteration 3
040966 29          0679*       add hl,hl
040967 CB 11       0680*       rl c
040969 29          0681*       add hl,hl
04096A CB 11       0682*       rl c
04096C CB 13       0683*       rl e
04096E 7B          0684*       ld a,e
04096F 91          0685*       sub c
040970 30 04       0686*       jr nc,$+6
040972 1C          0687*       inc e
040973 1C          0688*       inc e
040974 2F          0689*       cpl
040975 4F          0690*       ld c,a
040976             0691*   ; Iteration 4
040976 29          0692*       add hl,hl
040977 CB 11       0693*       rl c
040979 29          0694*       add hl,hl
04097A CB 11       0695*       rl c
04097C CB 13       0696*       rl e
04097E 7B          0697*       ld a,e
04097F 91          0698*       sub c
040980 30 04       0699*       jr nc,$+6
040982 1C          0700*       inc e
040983 1C          0701*       inc e
040984 2F          0702*       cpl
040985 4F          0703*       ld c,a
040986             0704*   ; Iteration 5
040986 29          0705*       add hl,hl
040987 CB 11       0706*       rl c
040989 29          0707*       add hl,hl
04098A CB 11       0708*       rl c
04098C CB 13       0709*       rl e
04098E 7B          0710*       ld a,e
04098F 91          0711*       sub c
040990 30 04       0712*       jr nc,$+6
040992 1C          0713*       inc e
040993 1C          0714*       inc e
040994 2F          0715*       cpl
040995 4F          0716*       ld c,a
040996             0717*   ; Iteration 6
040996 29          0718*       add hl,hl
040997 CB 11       0719*       rl c
040999 29          0720*       add hl,hl
04099A CB 11       0721*       rl c
04099C CB 13       0722*       rl e
04099E 7B          0723*       ld a,e
04099F 91          0724*       sub c
0409A0 30 04       0725*       jr nc,$+6
0409A2 1C          0726*       inc e
0409A3 1C          0727*       inc e
0409A4 2F          0728*       cpl
0409A5 4F          0729*       ld c,a
0409A6             0730*   ; Iteration 7
0409A6 29          0731*       add hl,hl
0409A7 CB 11       0732*       rl c
0409A9 29          0733*       add hl,hl
0409AA CB 11       0734*       rl c
0409AC CB 10       0735*       rl b
0409AE EB          0736*       ex de,hl
0409AF 29          0737*       add hl,hl
0409B0 E5          0738*       push hl
0409B1 ED 42       0739*       sbc hl,bc
0409B3 30 06       0740*       jr nc,$+8
0409B5 7C          0741*       ld a,h
0409B6 2F          0742*       cpl
0409B7 47          0743*       ld b,a
0409B8 7D          0744*       ld a,l
0409B9 2F          0745*       cpl
0409BA 4F          0746*       ld c,a
0409BB E1          0747*       pop hl
0409BC 30 02       0748*       jr nc,$+4
0409BE 23          0749*       inc hl
0409BF 23          0750*       inc hl
0409C0 EB          0751*       ex de,hl
0409C1             0752*   ; Iteration 8
0409C1 29          0753*       add hl,hl
0409C2 69          0754*       ld l,c
0409C3 60          0755*       ld h,b
0409C4 ED 6A       0756*       adc hl,hl
0409C6 ED 6A       0757*       adc hl,hl
0409C8 EB          0758*       ex de,hl
0409C9 29          0759*       add hl,hl
0409CA ED 52       0760*       sbc hl,de
0409CC 19          0761*       add hl,de
0409CD EB          0762*       ex de,hl
0409CE 30 04       0763*       jr nc,$+6
0409D0 ED 52       0764*       sbc hl,de
0409D2 13          0765*       inc de
0409D3 13          0766*       inc de
0409D4             0767*   ; Iteration 9
0409D4 F1          0768*       pop af
0409D5 17          0769*       rla
0409D6 ED 6A       0770*       adc hl,hl
0409D8 17          0771*       rla
0409D9 ED 6A       0772*       adc hl,hl
0409DB EB          0773*       ex de,hl
0409DC 29          0774*       add hl,hl
0409DD ED 52       0775*       sbc hl,de
0409DF 19          0776*       add hl,de
0409E0 EB          0777*       ex de,hl
0409E1 30 04       0778*       jr nc,$+6
0409E3 ED 52       0779*       sbc hl,de
0409E5 13          0780*       inc de
0409E6 13          0781*       inc de
0409E7             0782*   ; Iteration 10
0409E7 17          0783*       rla
0409E8 ED 6A       0784*       adc hl,hl
0409EA 17          0785*       rla
0409EB ED 6A       0786*       adc hl,hl
0409ED EB          0787*       ex de,hl
0409EE 29          0788*       add hl,hl
0409EF ED 52       0789*       sbc hl,de
0409F1 19          0790*       add hl,de
0409F2 EB          0791*       ex de,hl
0409F3 30 04       0792*       jr nc,$+6
0409F5 ED 52       0793*       sbc hl,de
0409F7 13          0794*       inc de
0409F8 13          0795*       inc de
0409F9             0796*   ; Iteration 11
0409F9 17          0797*       rla
0409FA ED 6A       0798*       adc hl,hl
0409FC 17          0799*       rla
0409FD ED 6A       0800*       adc hl,hl
0409FF EB          0801*       ex de,hl
040A00 29          0802*       add hl,hl
040A01 ED 52       0803*       sbc hl,de
040A03 19          0804*       add hl,de
040A04 EB          0805*       ex de,hl
040A05 30 04       0806*       jr nc,$+6
040A07 ED 52       0807*       sbc hl,de
040A09 13          0808*       inc de
040A0A 13          0809*       inc de
040A0B             0810*   ; Iteration 12
040A0B 17          0811*       rla
040A0C ED 6A       0812*       adc hl,hl
040A0E 17          0813*       rla
040A0F ED 6A       0814*       adc hl,hl
040A11 EB          0815*       ex de,hl
040A12 29          0816*       add hl,hl
040A13 ED 52       0817*       sbc hl,de
040A15 19          0818*       add hl,de
040A16 EB          0819*       ex de,hl
040A17 30 04       0820*       jr nc,$+6
040A19 ED 52       0821*       sbc hl,de
040A1B 13          0822*       inc de
040A1C 13          0823*       inc de
040A1D CB 1A       0824*       rr d
040A1F CB 1B       0825*       rr e
040A21 C9          0826*       ret
040A22             0827*   
040A22             0828*   sin_lut_168:
040A22 00 00 00    0829*       dl 0x000000 ; 0.000 00, 0.000
040A25 06 00 00    0830*       dl 0x000006 ; 1.406 01, 0.025
040A28 0C 00 00    0831*       dl 0x00000C ; 2.813 02, 0.049
040A2B 12 00 00    0832*       dl 0x000012 ; 4.219 03, 0.074
040A2E 19 00 00    0833*       dl 0x000019 ; 5.625 04, 0.098
040A31 1F 00 00    0834*       dl 0x00001F ; 7.031 05, 0.122
040A34 25 00 00    0835*       dl 0x000025 ; 8.438 06, 0.147
040A37 2B 00 00    0836*       dl 0x00002B ; 9.844 07, 0.171
040A3A 31 00 00    0837*       dl 0x000031 ; 11.250 08, 0.195
040A3D 38 00 00    0838*       dl 0x000038 ; 12.656 09, 0.219
040A40 3E 00 00    0839*       dl 0x00003E ; 14.063 0A, 0.243
040A43 44 00 00    0840*       dl 0x000044 ; 15.469 0B, 0.267
040A46 4A 00 00    0841*       dl 0x00004A ; 16.875 0C, 0.290
040A49 50 00 00    0842*       dl 0x000050 ; 18.281 0D, 0.314
040A4C 56 00 00    0843*       dl 0x000056 ; 19.688 0E, 0.337
040A4F 5C 00 00    0844*       dl 0x00005C ; 21.094 0F, 0.360
040A52 61 00 00    0845*       dl 0x000061 ; 22.500 10, 0.383
040A55 67 00 00    0846*       dl 0x000067 ; 23.906 11, 0.405
040A58 6D 00 00    0847*       dl 0x00006D ; 25.313 12, 0.428
040A5B 73 00 00    0848*       dl 0x000073 ; 26.719 13, 0.450
040A5E 78 00 00    0849*       dl 0x000078 ; 28.125 14, 0.471
040A61 7E 00 00    0850*       dl 0x00007E ; 29.531 15, 0.493
040A64 83 00 00    0851*       dl 0x000083 ; 30.938 16, 0.514
040A67 88 00 00    0852*       dl 0x000088 ; 32.344 17, 0.535
040A6A 8E 00 00    0853*       dl 0x00008E ; 33.750 18, 0.556
040A6D 93 00 00    0854*       dl 0x000093 ; 35.156 19, 0.576
040A70 98 00 00    0855*       dl 0x000098 ; 36.563 1A, 0.596
040A73 9D 00 00    0856*       dl 0x00009D ; 37.969 1B, 0.615
040A76 A2 00 00    0857*       dl 0x0000A2 ; 39.375 1C, 0.634
040A79 A7 00 00    0858*       dl 0x0000A7 ; 40.781 1D, 0.653
040A7C AB 00 00    0859*       dl 0x0000AB ; 42.188 1E, 0.672
040A7F B0 00 00    0860*       dl 0x0000B0 ; 43.594 1F, 0.690
040A82 B5 00 00    0861*       dl 0x0000B5 ; 45.000 20, 0.707
040A85 B9 00 00    0862*       dl 0x0000B9 ; 46.406 21, 0.724
040A88 BD 00 00    0863*       dl 0x0000BD ; 47.813 22, 0.741
040A8B C1 00 00    0864*       dl 0x0000C1 ; 49.219 23, 0.757
040A8E C5 00 00    0865*       dl 0x0000C5 ; 50.625 24, 0.773
040A91 C9 00 00    0866*       dl 0x0000C9 ; 52.031 25, 0.788
040A94 CD 00 00    0867*       dl 0x0000CD ; 53.438 26, 0.803
040A97 D1 00 00    0868*       dl 0x0000D1 ; 54.844 27, 0.818
040A9A D4 00 00    0869*       dl 0x0000D4 ; 56.250 28, 0.831
040A9D D8 00 00    0870*       dl 0x0000D8 ; 57.656 29, 0.845
040AA0 DB 00 00    0871*       dl 0x0000DB ; 59.063 2A, 0.858
040AA3 DE 00 00    0872*       dl 0x0000DE ; 60.469 2B, 0.870
040AA6 E1 00 00    0873*       dl 0x0000E1 ; 61.875 2C, 0.882
040AA9 E4 00 00    0874*       dl 0x0000E4 ; 63.281 2D, 0.893
040AAC E7 00 00    0875*       dl 0x0000E7 ; 64.688 2E, 0.904
040AAF EA 00 00    0876*       dl 0x0000EA ; 66.094 2F, 0.914
040AB2 EC 00 00    0877*       dl 0x0000EC ; 67.500 30, 0.924
040AB5 EE 00 00    0878*       dl 0x0000EE ; 68.906 31, 0.933
040AB8 F1 00 00    0879*       dl 0x0000F1 ; 70.313 32, 0.942
040ABB F3 00 00    0880*       dl 0x0000F3 ; 71.719 33, 0.950
040ABE F4 00 00    0881*       dl 0x0000F4 ; 73.125 34, 0.957
040AC1 F6 00 00    0882*       dl 0x0000F6 ; 74.531 35, 0.964
040AC4 F8 00 00    0883*       dl 0x0000F8 ; 75.938 36, 0.970
040AC7 F9 00 00    0884*       dl 0x0000F9 ; 77.344 37, 0.976
040ACA FB 00 00    0885*       dl 0x0000FB ; 78.750 38, 0.981
040ACD FC 00 00    0886*       dl 0x0000FC ; 80.156 39, 0.985
040AD0 FD 00 00    0887*       dl 0x0000FD ; 81.563 3A, 0.989
040AD3 FE 00 00    0888*       dl 0x0000FE ; 82.969 3B, 0.992
040AD6 FE 00 00    0889*       dl 0x0000FE ; 84.375 3C, 0.995
040AD9 FF 00 00    0890*       dl 0x0000FF ; 85.781 3D, 0.997
040ADC FF 00 00    0891*       dl 0x0000FF ; 87.188 3E, 0.999
040ADF FF 00 00    0892*       dl 0x0000FF ; 88.594 3F, 1.000
040AE2 00 01 00    0893*       dl 0x000100 ; 90.000 40, 1.000
040AE5 FF 00 00    0894*       dl 0x0000FF ; 91.406 41, 1.000
040AE8 FF 00 00    0895*       dl 0x0000FF ; 92.813 42, 0.999
040AEB FF 00 00    0896*       dl 0x0000FF ; 94.219 43, 0.997
040AEE FE 00 00    0897*       dl 0x0000FE ; 95.625 44, 0.995
040AF1 FE 00 00    0898*       dl 0x0000FE ; 97.031 45, 0.992
040AF4 FD 00 00    0899*       dl 0x0000FD ; 98.438 46, 0.989
040AF7 FC 00 00    0900*       dl 0x0000FC ; 99.844 47, 0.985
040AFA FB 00 00    0901*       dl 0x0000FB ; 101.250 48, 0.981
040AFD F9 00 00    0902*       dl 0x0000F9 ; 102.656 49, 0.976
040B00 F8 00 00    0903*       dl 0x0000F8 ; 104.063 4A, 0.970
040B03 F6 00 00    0904*       dl 0x0000F6 ; 105.469 4B, 0.964
040B06 F4 00 00    0905*       dl 0x0000F4 ; 106.875 4C, 0.957
040B09 F3 00 00    0906*       dl 0x0000F3 ; 108.281 4D, 0.950
040B0C F1 00 00    0907*       dl 0x0000F1 ; 109.688 4E, 0.942
040B0F EE 00 00    0908*       dl 0x0000EE ; 111.094 4F, 0.933
040B12 EC 00 00    0909*       dl 0x0000EC ; 112.500 50, 0.924
040B15 EA 00 00    0910*       dl 0x0000EA ; 113.906 51, 0.914
040B18 E7 00 00    0911*       dl 0x0000E7 ; 115.313 52, 0.904
040B1B E4 00 00    0912*       dl 0x0000E4 ; 116.719 53, 0.893
040B1E E1 00 00    0913*       dl 0x0000E1 ; 118.125 54, 0.882
040B21 DE 00 00    0914*       dl 0x0000DE ; 119.531 55, 0.870
040B24 DB 00 00    0915*       dl 0x0000DB ; 120.938 56, 0.858
040B27 D8 00 00    0916*       dl 0x0000D8 ; 122.344 57, 0.845
040B2A D4 00 00    0917*       dl 0x0000D4 ; 123.750 58, 0.831
040B2D D1 00 00    0918*       dl 0x0000D1 ; 125.156 59, 0.818
040B30 CD 00 00    0919*       dl 0x0000CD ; 126.563 5A, 0.803
040B33 C9 00 00    0920*       dl 0x0000C9 ; 127.969 5B, 0.788
040B36 C5 00 00    0921*       dl 0x0000C5 ; 129.375 5C, 0.773
040B39 C1 00 00    0922*       dl 0x0000C1 ; 130.781 5D, 0.757
040B3C BD 00 00    0923*       dl 0x0000BD ; 132.188 5E, 0.741
040B3F B9 00 00    0924*       dl 0x0000B9 ; 133.594 5F, 0.724
040B42 B5 00 00    0925*       dl 0x0000B5 ; 135.000 60, 0.707
040B45 B0 00 00    0926*       dl 0x0000B0 ; 136.406 61, 0.690
040B48 AB 00 00    0927*       dl 0x0000AB ; 137.813 62, 0.672
040B4B A7 00 00    0928*       dl 0x0000A7 ; 139.219 63, 0.653
040B4E A2 00 00    0929*       dl 0x0000A2 ; 140.625 64, 0.634
040B51 9D 00 00    0930*       dl 0x00009D ; 142.031 65, 0.615
040B54 98 00 00    0931*       dl 0x000098 ; 143.438 66, 0.596
040B57 93 00 00    0932*       dl 0x000093 ; 144.844 67, 0.576
040B5A 8E 00 00    0933*       dl 0x00008E ; 146.250 68, 0.556
040B5D 88 00 00    0934*       dl 0x000088 ; 147.656 69, 0.535
040B60 83 00 00    0935*       dl 0x000083 ; 149.063 6A, 0.514
040B63 7E 00 00    0936*       dl 0x00007E ; 150.469 6B, 0.493
040B66 78 00 00    0937*       dl 0x000078 ; 151.875 6C, 0.471
040B69 73 00 00    0938*       dl 0x000073 ; 153.281 6D, 0.450
040B6C 6D 00 00    0939*       dl 0x00006D ; 154.688 6E, 0.428
040B6F 67 00 00    0940*       dl 0x000067 ; 156.094 6F, 0.405
040B72 61 00 00    0941*       dl 0x000061 ; 157.500 70, 0.383
040B75 5C 00 00    0942*       dl 0x00005C ; 158.906 71, 0.360
040B78 56 00 00    0943*       dl 0x000056 ; 160.313 72, 0.337
040B7B 50 00 00    0944*       dl 0x000050 ; 161.719 73, 0.314
040B7E 4A 00 00    0945*       dl 0x00004A ; 163.125 74, 0.290
040B81 44 00 00    0946*       dl 0x000044 ; 164.531 75, 0.267
040B84 3E 00 00    0947*       dl 0x00003E ; 165.938 76, 0.243
040B87 38 00 00    0948*       dl 0x000038 ; 167.344 77, 0.219
040B8A 31 00 00    0949*       dl 0x000031 ; 168.750 78, 0.195
040B8D 2B 00 00    0950*       dl 0x00002B ; 170.156 79, 0.171
040B90 25 00 00    0951*       dl 0x000025 ; 171.563 7A, 0.147
040B93 1F 00 00    0952*       dl 0x00001F ; 172.969 7B, 0.122
040B96 19 00 00    0953*       dl 0x000019 ; 174.375 7C, 0.098
040B99 12 00 00    0954*       dl 0x000012 ; 175.781 7D, 0.074
040B9C 0C 00 00    0955*       dl 0x00000C ; 177.188 7E, 0.049
040B9F 06 00 00    0956*       dl 0x000006 ; 178.594 7F, 0.025
040BA2 00 00 00    0957*       dl 0x000000 ; 180.000 80, 0.000
040BA5 FA FF FF    0958*       dl 0xFFFFFA ; 181.406 81, -0.025
040BA8 F4 FF FF    0959*       dl 0xFFFFF4 ; 182.813 82, -0.049
040BAB EE FF FF    0960*       dl 0xFFFFEE ; 184.219 83, -0.074
040BAE E7 FF FF    0961*       dl 0xFFFFE7 ; 185.625 84, -0.098
040BB1 E1 FF FF    0962*       dl 0xFFFFE1 ; 187.031 85, -0.122
040BB4 DB FF FF    0963*       dl 0xFFFFDB ; 188.438 86, -0.147
040BB7 D5 FF FF    0964*       dl 0xFFFFD5 ; 189.844 87, -0.171
040BBA CF FF FF    0965*       dl 0xFFFFCF ; 191.250 88, -0.195
040BBD C8 FF FF    0966*       dl 0xFFFFC8 ; 192.656 89, -0.219
040BC0 C2 FF FF    0967*       dl 0xFFFFC2 ; 194.063 8A, -0.243
040BC3 BC FF FF    0968*       dl 0xFFFFBC ; 195.469 8B, -0.267
040BC6 B6 FF FF    0969*       dl 0xFFFFB6 ; 196.875 8C, -0.290
040BC9 B0 FF FF    0970*       dl 0xFFFFB0 ; 198.281 8D, -0.314
040BCC AA FF FF    0971*       dl 0xFFFFAA ; 199.688 8E, -0.337
040BCF A4 FF FF    0972*       dl 0xFFFFA4 ; 201.094 8F, -0.360
040BD2 9F FF FF    0973*       dl 0xFFFF9F ; 202.500 90, -0.383
040BD5 99 FF FF    0974*       dl 0xFFFF99 ; 203.906 91, -0.405
040BD8 93 FF FF    0975*       dl 0xFFFF93 ; 205.313 92, -0.428
040BDB 8D FF FF    0976*       dl 0xFFFF8D ; 206.719 93, -0.450
040BDE 88 FF FF    0977*       dl 0xFFFF88 ; 208.125 94, -0.471
040BE1 82 FF FF    0978*       dl 0xFFFF82 ; 209.531 95, -0.493
040BE4 7D FF FF    0979*       dl 0xFFFF7D ; 210.938 96, -0.514
040BE7 78 FF FF    0980*       dl 0xFFFF78 ; 212.344 97, -0.535
040BEA 72 FF FF    0981*       dl 0xFFFF72 ; 213.750 98, -0.556
040BED 6D FF FF    0982*       dl 0xFFFF6D ; 215.156 99, -0.576
040BF0 68 FF FF    0983*       dl 0xFFFF68 ; 216.563 9A, -0.596
040BF3 63 FF FF    0984*       dl 0xFFFF63 ; 217.969 9B, -0.615
040BF6 5E FF FF    0985*       dl 0xFFFF5E ; 219.375 9C, -0.634
040BF9 59 FF FF    0986*       dl 0xFFFF59 ; 220.781 9D, -0.653
040BFC 55 FF FF    0987*       dl 0xFFFF55 ; 222.188 9E, -0.672
040BFF 50 FF FF    0988*       dl 0xFFFF50 ; 223.594 9F, -0.690
040C02 4B FF FF    0989*       dl 0xFFFF4B ; 225.000 A0, -0.707
040C05 47 FF FF    0990*       dl 0xFFFF47 ; 226.406 A1, -0.724
040C08 43 FF FF    0991*       dl 0xFFFF43 ; 227.813 A2, -0.741
040C0B 3F FF FF    0992*       dl 0xFFFF3F ; 229.219 A3, -0.757
040C0E 3B FF FF    0993*       dl 0xFFFF3B ; 230.625 A4, -0.773
040C11 37 FF FF    0994*       dl 0xFFFF37 ; 232.031 A5, -0.788
040C14 33 FF FF    0995*       dl 0xFFFF33 ; 233.438 A6, -0.803
040C17 2F FF FF    0996*       dl 0xFFFF2F ; 234.844 A7, -0.818
040C1A 2C FF FF    0997*       dl 0xFFFF2C ; 236.250 A8, -0.831
040C1D 28 FF FF    0998*       dl 0xFFFF28 ; 237.656 A9, -0.845
040C20 25 FF FF    0999*       dl 0xFFFF25 ; 239.063 AA, -0.858
040C23 22 FF FF    1000*       dl 0xFFFF22 ; 240.469 AB, -0.870
040C26 1F FF FF    1001*       dl 0xFFFF1F ; 241.875 AC, -0.882
040C29 1C FF FF    1002*       dl 0xFFFF1C ; 243.281 AD, -0.893
040C2C 19 FF FF    1003*       dl 0xFFFF19 ; 244.688 AE, -0.904
040C2F 16 FF FF    1004*       dl 0xFFFF16 ; 246.094 AF, -0.914
040C32 14 FF FF    1005*       dl 0xFFFF14 ; 247.500 B0, -0.924
040C35 12 FF FF    1006*       dl 0xFFFF12 ; 248.906 B1, -0.933
040C38 0F FF FF    1007*       dl 0xFFFF0F ; 250.313 B2, -0.942
040C3B 0D FF FF    1008*       dl 0xFFFF0D ; 251.719 B3, -0.950
040C3E 0C FF FF    1009*       dl 0xFFFF0C ; 253.125 B4, -0.957
040C41 0A FF FF    1010*       dl 0xFFFF0A ; 254.531 B5, -0.964
040C44 08 FF FF    1011*       dl 0xFFFF08 ; 255.938 B6, -0.970
040C47 07 FF FF    1012*       dl 0xFFFF07 ; 257.344 B7, -0.976
040C4A 05 FF FF    1013*       dl 0xFFFF05 ; 258.750 B8, -0.981
040C4D 04 FF FF    1014*       dl 0xFFFF04 ; 260.156 B9, -0.985
040C50 03 FF FF    1015*       dl 0xFFFF03 ; 261.563 BA, -0.989
040C53 02 FF FF    1016*       dl 0xFFFF02 ; 262.969 BB, -0.992
040C56 02 FF FF    1017*       dl 0xFFFF02 ; 264.375 BC, -0.995
040C59 01 FF FF    1018*       dl 0xFFFF01 ; 265.781 BD, -0.997
040C5C 01 FF FF    1019*       dl 0xFFFF01 ; 267.188 BE, -0.999
040C5F 01 FF FF    1020*       dl 0xFFFF01 ; 268.594 BF, -1.000
040C62 00 FF FF    1021*       dl 0xFFFF00 ; 270.000 C0, -1.000
040C65 01 FF FF    1022*       dl 0xFFFF01 ; 271.406 C1, -1.000
040C68 01 FF FF    1023*       dl 0xFFFF01 ; 272.813 C2, -0.999
040C6B 01 FF FF    1024*       dl 0xFFFF01 ; 274.219 C3, -0.997
040C6E 02 FF FF    1025*       dl 0xFFFF02 ; 275.625 C4, -0.995
040C71 02 FF FF    1026*       dl 0xFFFF02 ; 277.031 C5, -0.992
040C74 03 FF FF    1027*       dl 0xFFFF03 ; 278.438 C6, -0.989
040C77 04 FF FF    1028*       dl 0xFFFF04 ; 279.844 C7, -0.985
040C7A 05 FF FF    1029*       dl 0xFFFF05 ; 281.250 C8, -0.981
040C7D 07 FF FF    1030*       dl 0xFFFF07 ; 282.656 C9, -0.976
040C80 08 FF FF    1031*       dl 0xFFFF08 ; 284.063 CA, -0.970
040C83 0A FF FF    1032*       dl 0xFFFF0A ; 285.469 CB, -0.964
040C86 0C FF FF    1033*       dl 0xFFFF0C ; 286.875 CC, -0.957
040C89 0D FF FF    1034*       dl 0xFFFF0D ; 288.281 CD, -0.950
040C8C 0F FF FF    1035*       dl 0xFFFF0F ; 289.688 CE, -0.942
040C8F 12 FF FF    1036*       dl 0xFFFF12 ; 291.094 CF, -0.933
040C92 14 FF FF    1037*       dl 0xFFFF14 ; 292.500 D0, -0.924
040C95 16 FF FF    1038*       dl 0xFFFF16 ; 293.906 D1, -0.914
040C98 19 FF FF    1039*       dl 0xFFFF19 ; 295.313 D2, -0.904
040C9B 1C FF FF    1040*       dl 0xFFFF1C ; 296.719 D3, -0.893
040C9E 1F FF FF    1041*       dl 0xFFFF1F ; 298.125 D4, -0.882
040CA1 22 FF FF    1042*       dl 0xFFFF22 ; 299.531 D5, -0.870
040CA4 25 FF FF    1043*       dl 0xFFFF25 ; 300.938 D6, -0.858
040CA7 28 FF FF    1044*       dl 0xFFFF28 ; 302.344 D7, -0.845
040CAA 2C FF FF    1045*       dl 0xFFFF2C ; 303.750 D8, -0.831
040CAD 2F FF FF    1046*       dl 0xFFFF2F ; 305.156 D9, -0.818
040CB0 33 FF FF    1047*       dl 0xFFFF33 ; 306.563 DA, -0.803
040CB3 37 FF FF    1048*       dl 0xFFFF37 ; 307.969 DB, -0.788
040CB6 3B FF FF    1049*       dl 0xFFFF3B ; 309.375 DC, -0.773
040CB9 3F FF FF    1050*       dl 0xFFFF3F ; 310.781 DD, -0.757
040CBC 43 FF FF    1051*       dl 0xFFFF43 ; 312.188 DE, -0.741
040CBF 47 FF FF    1052*       dl 0xFFFF47 ; 313.594 DF, -0.724
040CC2 4B FF FF    1053*       dl 0xFFFF4B ; 315.000 E0, -0.707
040CC5 50 FF FF    1054*       dl 0xFFFF50 ; 316.406 E1, -0.690
040CC8 55 FF FF    1055*       dl 0xFFFF55 ; 317.813 E2, -0.672
040CCB 59 FF FF    1056*       dl 0xFFFF59 ; 319.219 E3, -0.653
040CCE 5E FF FF    1057*       dl 0xFFFF5E ; 320.625 E4, -0.634
040CD1 63 FF FF    1058*       dl 0xFFFF63 ; 322.031 E5, -0.615
040CD4 68 FF FF    1059*       dl 0xFFFF68 ; 323.438 E6, -0.596
040CD7 6D FF FF    1060*       dl 0xFFFF6D ; 324.844 E7, -0.576
040CDA 72 FF FF    1061*       dl 0xFFFF72 ; 326.250 E8, -0.556
040CDD 78 FF FF    1062*       dl 0xFFFF78 ; 327.656 E9, -0.535
040CE0 7D FF FF    1063*       dl 0xFFFF7D ; 329.063 EA, -0.514
040CE3 82 FF FF    1064*       dl 0xFFFF82 ; 330.469 EB, -0.493
040CE6 88 FF FF    1065*       dl 0xFFFF88 ; 331.875 EC, -0.471
040CE9 8D FF FF    1066*       dl 0xFFFF8D ; 333.281 ED, -0.450
040CEC 93 FF FF    1067*       dl 0xFFFF93 ; 334.688 EE, -0.428
040CEF 99 FF FF    1068*       dl 0xFFFF99 ; 336.094 EF, -0.405
040CF2 9F FF FF    1069*       dl 0xFFFF9F ; 337.500 F0, -0.383
040CF5 A4 FF FF    1070*       dl 0xFFFFA4 ; 338.906 F1, -0.360
040CF8 AA FF FF    1071*       dl 0xFFFFAA ; 340.313 F2, -0.337
040CFB B0 FF FF    1072*       dl 0xFFFFB0 ; 341.719 F3, -0.314
040CFE B6 FF FF    1073*       dl 0xFFFFB6 ; 343.125 F4, -0.290
040D01 BC FF FF    1074*       dl 0xFFFFBC ; 344.531 F5, -0.267
040D04 C2 FF FF    1075*       dl 0xFFFFC2 ; 345.938 F6, -0.243
040D07 C8 FF FF    1076*       dl 0xFFFFC8 ; 347.344 F7, -0.219
040D0A CF FF FF    1077*       dl 0xFFFFCF ; 348.750 F8, -0.195
040D0D D5 FF FF    1078*       dl 0xFFFFD5 ; 350.156 F9, -0.171
040D10 DB FF FF    1079*       dl 0xFFFFDB ; 351.563 FA, -0.147
040D13 E1 FF FF    1080*       dl 0xFFFFE1 ; 352.969 FB, -0.122
040D16 E7 FF FF    1081*       dl 0xFFFFE7 ; 354.375 FC, -0.098
040D19 EE FF FF    1082*       dl 0xFFFFEE ; 355.781 FD, -0.074
040D1C F4 FF FF    1083*       dl 0xFFFFF4 ; 357.188 FE, -0.049
040D1F FA FF FF    1084*       dl 0xFFFFFA ; 358.594 FF, -0.025
040D22 00 00 00    1085*       dl 0x000000 ; 0.000 00, 0.000 for interpolation
040D25             1086*   
040D25             1087*   atan_lut_168:
040D25 00 00 00    1088*       dl 0x000000 ; 000000, 0.000
040D28 28 00 00    1089*       dl 0x000028 ; 000001, 0.224
040D2B 51 00 00    1090*       dl 0x000051 ; 000002, 0.448
040D2E 7A 00 00    1091*       dl 0x00007A ; 000003, 0.671
040D31 A2 00 00    1092*       dl 0x0000A2 ; 000004, 0.895
040D34 CB 00 00    1093*       dl 0x0000CB ; 000005, 1.119
040D37 F4 00 00    1094*       dl 0x0000F4 ; 000006, 1.343
040D3A 1D 01 00    1095*       dl 0x00011D ; 000007, 1.566
040D3D 45 01 00    1096*       dl 0x000145 ; 000008, 1.790
040D40 6E 01 00    1097*       dl 0x00016E ; 000009, 2.013
040D43 97 01 00    1098*       dl 0x000197 ; 00000A, 2.237
040D46 BF 01 00    1099*       dl 0x0001BF ; 00000B, 2.460
040D49 E8 01 00    1100*       dl 0x0001E8 ; 00000C, 2.684
040D4C 11 02 00    1101*       dl 0x000211 ; 00000D, 2.907
040D4F 39 02 00    1102*       dl 0x000239 ; 00000E, 3.130
040D52 62 02 00    1103*       dl 0x000262 ; 00000F, 3.353
040D55 8B 02 00    1104*       dl 0x00028B ; 000010, 3.576
040D58 B3 02 00    1105*       dl 0x0002B3 ; 000011, 3.799
040D5B DC 02 00    1106*       dl 0x0002DC ; 000012, 4.022
040D5E 04 03 00    1107*       dl 0x000304 ; 000013, 4.245
040D61 2D 03 00    1108*       dl 0x00032D ; 000014, 4.467
040D64 55 03 00    1109*       dl 0x000355 ; 000015, 4.690
040D67 7E 03 00    1110*       dl 0x00037E ; 000016, 4.912
040D6A A6 03 00    1111*       dl 0x0003A6 ; 000017, 5.134
040D6D CE 03 00    1112*       dl 0x0003CE ; 000018, 5.356
040D70 F7 03 00    1113*       dl 0x0003F7 ; 000019, 5.578
040D73 1F 04 00    1114*       dl 0x00041F ; 00001A, 5.799
040D76 48 04 00    1115*       dl 0x000448 ; 00001B, 6.021
040D79 70 04 00    1116*       dl 0x000470 ; 00001C, 6.242
040D7C 98 04 00    1117*       dl 0x000498 ; 00001D, 6.463
040D7F C0 04 00    1118*       dl 0x0004C0 ; 00001E, 6.684
040D82 E8 04 00    1119*       dl 0x0004E8 ; 00001F, 6.905
040D85 11 05 00    1120*       dl 0x000511 ; 000020, 7.125
040D88 39 05 00    1121*       dl 0x000539 ; 000021, 7.345
040D8B 61 05 00    1122*       dl 0x000561 ; 000022, 7.565
040D8E 89 05 00    1123*       dl 0x000589 ; 000023, 7.785
040D91 B1 05 00    1124*       dl 0x0005B1 ; 000024, 8.005
040D94 D9 05 00    1125*       dl 0x0005D9 ; 000025, 8.224
040D97 01 06 00    1126*       dl 0x000601 ; 000026, 8.443
040D9A 28 06 00    1127*       dl 0x000628 ; 000027, 8.662
040D9D 50 06 00    1128*       dl 0x000650 ; 000028, 8.881
040DA0 78 06 00    1129*       dl 0x000678 ; 000029, 9.099
040DA3 A0 06 00    1130*       dl 0x0006A0 ; 00002A, 9.317
040DA6 C7 06 00    1131*       dl 0x0006C7 ; 00002B, 9.535
040DA9 EF 06 00    1132*       dl 0x0006EF ; 00002C, 9.752
040DAC 16 07 00    1133*       dl 0x000716 ; 00002D, 9.970
040DAF 3E 07 00    1134*       dl 0x00073E ; 00002E, 10.187
040DB2 65 07 00    1135*       dl 0x000765 ; 00002F, 10.403
040DB5 8D 07 00    1136*       dl 0x00078D ; 000030, 10.620
040DB8 B4 07 00    1137*       dl 0x0007B4 ; 000031, 10.836
040DBB DB 07 00    1138*       dl 0x0007DB ; 000032, 11.051
040DBE 03 08 00    1139*       dl 0x000803 ; 000033, 11.267
040DC1 2A 08 00    1140*       dl 0x00082A ; 000034, 11.482
040DC4 51 08 00    1141*       dl 0x000851 ; 000035, 11.697
040DC7 78 08 00    1142*       dl 0x000878 ; 000036, 11.911
040DCA 9F 08 00    1143*       dl 0x00089F ; 000037, 12.125
040DCD C6 08 00    1144*       dl 0x0008C6 ; 000038, 12.339
040DD0 ED 08 00    1145*       dl 0x0008ED ; 000039, 12.553
040DD3 13 09 00    1146*       dl 0x000913 ; 00003A, 12.766
040DD6 3A 09 00    1147*       dl 0x00093A ; 00003B, 12.978
040DD9 61 09 00    1148*       dl 0x000961 ; 00003C, 13.191
040DDC 87 09 00    1149*       dl 0x000987 ; 00003D, 13.403
040DDF AE 09 00    1150*       dl 0x0009AE ; 00003E, 13.614
040DE2 D4 09 00    1151*       dl 0x0009D4 ; 00003F, 13.825
040DE5 FB 09 00    1152*       dl 0x0009FB ; 000040, 14.036
040DE8 21 0A 00    1153*       dl 0x000A21 ; 000041, 14.247
040DEB 47 0A 00    1154*       dl 0x000A47 ; 000042, 14.457
040DEE 6D 0A 00    1155*       dl 0x000A6D ; 000043, 14.666
040DF1 94 0A 00    1156*       dl 0x000A94 ; 000044, 14.876
040DF4 BA 0A 00    1157*       dl 0x000ABA ; 000045, 15.085
040DF7 E0 0A 00    1158*       dl 0x000AE0 ; 000046, 15.293
040DFA 05 0B 00    1159*       dl 0x000B05 ; 000047, 15.501
040DFD 2B 0B 00    1160*       dl 0x000B2B ; 000048, 15.709
040E00 51 0B 00    1161*       dl 0x000B51 ; 000049, 15.916
040E03 77 0B 00    1162*       dl 0x000B77 ; 00004A, 16.123
040E06 9C 0B 00    1163*       dl 0x000B9C ; 00004B, 16.329
040E09 C2 0B 00    1164*       dl 0x000BC2 ; 00004C, 16.535
040E0C E7 0B 00    1165*       dl 0x000BE7 ; 00004D, 16.740
040E0F 0C 0C 00    1166*       dl 0x000C0C ; 00004E, 16.945
040E12 32 0C 00    1167*       dl 0x000C32 ; 00004F, 17.150
040E15 57 0C 00    1168*       dl 0x000C57 ; 000050, 17.354
040E18 7C 0C 00    1169*       dl 0x000C7C ; 000051, 17.558
040E1B A1 0C 00    1170*       dl 0x000CA1 ; 000052, 17.761
040E1E C6 0C 00    1171*       dl 0x000CC6 ; 000053, 17.964
040E21 EB 0C 00    1172*       dl 0x000CEB ; 000054, 18.166
040E24 0F 0D 00    1173*       dl 0x000D0F ; 000055, 18.368
040E27 34 0D 00    1174*       dl 0x000D34 ; 000056, 18.569
040E2A 58 0D 00    1175*       dl 0x000D58 ; 000057, 18.770
040E2D 7D 0D 00    1176*       dl 0x000D7D ; 000058, 18.970
040E30 A1 0D 00    1177*       dl 0x000DA1 ; 000059, 19.170
040E33 C6 0D 00    1178*       dl 0x000DC6 ; 00005A, 19.370
040E36 EA 0D 00    1179*       dl 0x000DEA ; 00005B, 19.569
040E39 0E 0E 00    1180*       dl 0x000E0E ; 00005C, 19.767
040E3C 32 0E 00    1181*       dl 0x000E32 ; 00005D, 19.965
040E3F 56 0E 00    1182*       dl 0x000E56 ; 00005E, 20.163
040E42 7A 0E 00    1183*       dl 0x000E7A ; 00005F, 20.360
040E45 9E 0E 00    1184*       dl 0x000E9E ; 000060, 20.556
040E48 C1 0E 00    1185*       dl 0x000EC1 ; 000061, 20.752
040E4B E5 0E 00    1186*       dl 0x000EE5 ; 000062, 20.947
040E4E 08 0F 00    1187*       dl 0x000F08 ; 000063, 21.142
040E51 2C 0F 00    1188*       dl 0x000F2C ; 000064, 21.337
040E54 4F 0F 00    1189*       dl 0x000F4F ; 000065, 21.531
040E57 72 0F 00    1190*       dl 0x000F72 ; 000066, 21.724
040E5A 95 0F 00    1191*       dl 0x000F95 ; 000067, 21.917
040E5D B8 0F 00    1192*       dl 0x000FB8 ; 000068, 22.109
040E60 DB 0F 00    1193*       dl 0x000FDB ; 000069, 22.301
040E63 FE 0F 00    1194*       dl 0x000FFE ; 00006A, 22.493
040E66 21 10 00    1195*       dl 0x001021 ; 00006B, 22.683
040E69 44 10 00    1196*       dl 0x001044 ; 00006C, 22.874
040E6C 66 10 00    1197*       dl 0x001066 ; 00006D, 23.063
040E6F 89 10 00    1198*       dl 0x001089 ; 00006E, 23.253
040E72 AB 10 00    1199*       dl 0x0010AB ; 00006F, 23.441
040E75 CD 10 00    1200*       dl 0x0010CD ; 000070, 23.629
040E78 EF 10 00    1201*       dl 0x0010EF ; 000071, 23.817
040E7B 11 11 00    1202*       dl 0x001111 ; 000072, 24.004
040E7E 33 11 00    1203*       dl 0x001133 ; 000073, 24.191
040E81 55 11 00    1204*       dl 0x001155 ; 000074, 24.376
040E84 77 11 00    1205*       dl 0x001177 ; 000075, 24.562
040E87 99 11 00    1206*       dl 0x001199 ; 000076, 24.747
040E8A BA 11 00    1207*       dl 0x0011BA ; 000077, 24.931
040E8D DC 11 00    1208*       dl 0x0011DC ; 000078, 25.115
040E90 FD 11 00    1209*       dl 0x0011FD ; 000079, 25.298
040E93 1E 12 00    1210*       dl 0x00121E ; 00007A, 25.481
040E96 3F 12 00    1211*       dl 0x00123F ; 00007B, 25.663
040E99 60 12 00    1212*       dl 0x001260 ; 00007C, 25.844
040E9C 81 12 00    1213*       dl 0x001281 ; 00007D, 26.025
040E9F A2 12 00    1214*       dl 0x0012A2 ; 00007E, 26.206
040EA2 C3 12 00    1215*       dl 0x0012C3 ; 00007F, 26.386
040EA5 E4 12 00    1216*       dl 0x0012E4 ; 000080, 26.565
040EA8 04 13 00    1217*       dl 0x001304 ; 000081, 26.744
040EAB 25 13 00    1218*       dl 0x001325 ; 000082, 26.922
040EAE 45 13 00    1219*       dl 0x001345 ; 000083, 27.100
040EB1 65 13 00    1220*       dl 0x001365 ; 000084, 27.277
040EB4 85 13 00    1221*       dl 0x001385 ; 000085, 27.453
040EB7 A5 13 00    1222*       dl 0x0013A5 ; 000086, 27.629
040EBA C5 13 00    1223*       dl 0x0013C5 ; 000087, 27.805
040EBD E5 13 00    1224*       dl 0x0013E5 ; 000088, 27.979
040EC0 05 14 00    1225*       dl 0x001405 ; 000089, 28.154
040EC3 24 14 00    1226*       dl 0x001424 ; 00008A, 28.327
040EC6 44 14 00    1227*       dl 0x001444 ; 00008B, 28.501
040EC9 63 14 00    1228*       dl 0x001463 ; 00008C, 28.673
040ECC 83 14 00    1229*       dl 0x001483 ; 00008D, 28.845
040ECF A2 14 00    1230*       dl 0x0014A2 ; 00008E, 29.017
040ED2 C1 14 00    1231*       dl 0x0014C1 ; 00008F, 29.187
040ED5 E0 14 00    1232*       dl 0x0014E0 ; 000090, 29.358
040ED8 FF 14 00    1233*       dl 0x0014FF ; 000091, 29.527
040EDB 1E 15 00    1234*       dl 0x00151E ; 000092, 29.697
040EDE 3C 15 00    1235*       dl 0x00153C ; 000093, 29.865
040EE1 5B 15 00    1236*       dl 0x00155B ; 000094, 30.033
040EE4 79 15 00    1237*       dl 0x001579 ; 000095, 30.201
040EE7 98 15 00    1238*       dl 0x001598 ; 000096, 30.368
040EEA B6 15 00    1239*       dl 0x0015B6 ; 000097, 30.534
040EED D4 15 00    1240*       dl 0x0015D4 ; 000098, 30.700
040EF0 F2 15 00    1241*       dl 0x0015F2 ; 000099, 30.865
040EF3 10 16 00    1242*       dl 0x001610 ; 00009A, 31.030
040EF6 2E 16 00    1243*       dl 0x00162E ; 00009B, 31.194
040EF9 4C 16 00    1244*       dl 0x00164C ; 00009C, 31.357
040EFC 6A 16 00    1245*       dl 0x00166A ; 00009D, 31.520
040EFF 87 16 00    1246*       dl 0x001687 ; 00009E, 31.682
040F02 A5 16 00    1247*       dl 0x0016A5 ; 00009F, 31.844
040F05 C2 16 00    1248*       dl 0x0016C2 ; 0000A0, 32.005
040F08 DF 16 00    1249*       dl 0x0016DF ; 0000A1, 32.166
040F0B FC 16 00    1250*       dl 0x0016FC ; 0000A2, 32.326
040F0E 19 17 00    1251*       dl 0x001719 ; 0000A3, 32.486
040F11 36 17 00    1252*       dl 0x001736 ; 0000A4, 32.645
040F14 53 17 00    1253*       dl 0x001753 ; 0000A5, 32.803
040F17 70 17 00    1254*       dl 0x001770 ; 0000A6, 32.961
040F1A 8C 17 00    1255*       dl 0x00178C ; 0000A7, 33.118
040F1D A9 17 00    1256*       dl 0x0017A9 ; 0000A8, 33.275
040F20 C5 17 00    1257*       dl 0x0017C5 ; 0000A9, 33.431
040F23 E2 17 00    1258*       dl 0x0017E2 ; 0000AA, 33.587
040F26 FE 17 00    1259*       dl 0x0017FE ; 0000AB, 33.742
040F29 1A 18 00    1260*       dl 0x00181A ; 0000AC, 33.896
040F2C 36 18 00    1261*       dl 0x001836 ; 0000AD, 34.050
040F2F 52 18 00    1262*       dl 0x001852 ; 0000AE, 34.203
040F32 6E 18 00    1263*       dl 0x00186E ; 0000AF, 34.356
040F35 8A 18 00    1264*       dl 0x00188A ; 0000B0, 34.509
040F38 A5 18 00    1265*       dl 0x0018A5 ; 0000B1, 34.660
040F3B C1 18 00    1266*       dl 0x0018C1 ; 0000B2, 34.811
040F3E DC 18 00    1267*       dl 0x0018DC ; 0000B3, 34.962
040F41 F7 18 00    1268*       dl 0x0018F7 ; 0000B4, 35.112
040F44 13 19 00    1269*       dl 0x001913 ; 0000B5, 35.262
040F47 2E 19 00    1270*       dl 0x00192E ; 0000B6, 35.410
040F4A 49 19 00    1271*       dl 0x001949 ; 0000B7, 35.559
040F4D 64 19 00    1272*       dl 0x001964 ; 0000B8, 35.707
040F50 7F 19 00    1273*       dl 0x00197F ; 0000B9, 35.854
040F53 99 19 00    1274*       dl 0x001999 ; 0000BA, 36.001
040F56 B4 19 00    1275*       dl 0x0019B4 ; 0000BB, 36.147
040F59 CE 19 00    1276*       dl 0x0019CE ; 0000BC, 36.293
040F5C E9 19 00    1277*       dl 0x0019E9 ; 0000BD, 36.438
040F5F 03 1A 00    1278*       dl 0x001A03 ; 0000BE, 36.582
040F62 1D 1A 00    1279*       dl 0x001A1D ; 0000BF, 36.726
040F65 37 1A 00    1280*       dl 0x001A37 ; 0000C0, 36.870
040F68 51 1A 00    1281*       dl 0x001A51 ; 0000C1, 37.013
040F6B 6B 1A 00    1282*       dl 0x001A6B ; 0000C2, 37.155
040F6E 85 1A 00    1283*       dl 0x001A85 ; 0000C3, 37.297
040F71 9F 1A 00    1284*       dl 0x001A9F ; 0000C4, 37.439
040F74 B9 1A 00    1285*       dl 0x001AB9 ; 0000C5, 37.579
040F77 D2 1A 00    1286*       dl 0x001AD2 ; 0000C6, 37.720
040F7A EC 1A 00    1287*       dl 0x001AEC ; 0000C7, 37.859
040F7D 05 1B 00    1288*       dl 0x001B05 ; 0000C8, 37.999
040F80 1E 1B 00    1289*       dl 0x001B1E ; 0000C9, 38.137
040F83 37 1B 00    1290*       dl 0x001B37 ; 0000CA, 38.276
040F86 50 1B 00    1291*       dl 0x001B50 ; 0000CB, 38.413
040F89 69 1B 00    1292*       dl 0x001B69 ; 0000CC, 38.550
040F8C 82 1B 00    1293*       dl 0x001B82 ; 0000CD, 38.687
040F8F 9B 1B 00    1294*       dl 0x001B9B ; 0000CE, 38.823
040F92 B4 1B 00    1295*       dl 0x001BB4 ; 0000CF, 38.959
040F95 CC 1B 00    1296*       dl 0x001BCC ; 0000D0, 39.094
040F98 E5 1B 00    1297*       dl 0x001BE5 ; 0000D1, 39.228
040F9B FD 1B 00    1298*       dl 0x001BFD ; 0000D2, 39.362
040F9E 16 1C 00    1299*       dl 0x001C16 ; 0000D3, 39.496
040FA1 2E 1C 00    1300*       dl 0x001C2E ; 0000D4, 39.629
040FA4 46 1C 00    1301*       dl 0x001C46 ; 0000D5, 39.762
040FA7 5E 1C 00    1302*       dl 0x001C5E ; 0000D6, 39.894
040FAA 76 1C 00    1303*       dl 0x001C76 ; 0000D7, 40.025
040FAD 8E 1C 00    1304*       dl 0x001C8E ; 0000D8, 40.156
040FB0 A5 1C 00    1305*       dl 0x001CA5 ; 0000D9, 40.286
040FB3 BD 1C 00    1306*       dl 0x001CBD ; 0000DA, 40.416
040FB6 D5 1C 00    1307*       dl 0x001CD5 ; 0000DB, 40.546
040FB9 EC 1C 00    1308*       dl 0x001CEC ; 0000DC, 40.675
040FBC 04 1D 00    1309*       dl 0x001D04 ; 0000DD, 40.803
040FBF 1B 1D 00    1310*       dl 0x001D1B ; 0000DE, 40.931
040FC2 32 1D 00    1311*       dl 0x001D32 ; 0000DF, 41.059
040FC5 49 1D 00    1312*       dl 0x001D49 ; 0000E0, 41.186
040FC8 60 1D 00    1313*       dl 0x001D60 ; 0000E1, 41.312
040FCB 77 1D 00    1314*       dl 0x001D77 ; 0000E2, 41.438
040FCE 8E 1D 00    1315*       dl 0x001D8E ; 0000E3, 41.564
040FD1 A5 1D 00    1316*       dl 0x001DA5 ; 0000E4, 41.689
040FD4 BB 1D 00    1317*       dl 0x001DBB ; 0000E5, 41.814
040FD7 D2 1D 00    1318*       dl 0x001DD2 ; 0000E6, 41.938
040FDA E9 1D 00    1319*       dl 0x001DE9 ; 0000E7, 42.061
040FDD FF 1D 00    1320*       dl 0x001DFF ; 0000E8, 42.184
040FE0 15 1E 00    1321*       dl 0x001E15 ; 0000E9, 42.307
040FE3 2C 1E 00    1322*       dl 0x001E2C ; 0000EA, 42.429
040FE6 42 1E 00    1323*       dl 0x001E42 ; 0000EB, 42.551
040FE9 58 1E 00    1324*       dl 0x001E58 ; 0000EC, 42.672
040FEC 6E 1E 00    1325*       dl 0x001E6E ; 0000ED, 42.793
040FEF 84 1E 00    1326*       dl 0x001E84 ; 0000EE, 42.913
040FF2 99 1E 00    1327*       dl 0x001E99 ; 0000EF, 43.033
040FF5 AF 1E 00    1328*       dl 0x001EAF ; 0000F0, 43.152
040FF8 C5 1E 00    1329*       dl 0x001EC5 ; 0000F1, 43.271
040FFB DA 1E 00    1330*       dl 0x001EDA ; 0000F2, 43.390
040FFE F0 1E 00    1331*       dl 0x001EF0 ; 0000F3, 43.508
041001 05 1F 00    1332*       dl 0x001F05 ; 0000F4, 43.625
041004 1B 1F 00    1333*       dl 0x001F1B ; 0000F5, 43.742
041007 30 1F 00    1334*       dl 0x001F30 ; 0000F6, 43.859
04100A 45 1F 00    1335*       dl 0x001F45 ; 0000F7, 43.975
04100D 5A 1F 00    1336*       dl 0x001F5A ; 0000F8, 44.091
041010 6F 1F 00    1337*       dl 0x001F6F ; 0000F9, 44.206
041013 84 1F 00    1338*       dl 0x001F84 ; 0000FA, 44.321
041016 99 1F 00    1339*       dl 0x001F99 ; 0000FB, 44.435
041019 AD 1F 00    1340*       dl 0x001FAD ; 0000FC, 44.549
04101C C2 1F 00    1341*       dl 0x001FC2 ; 0000FD, 44.662
04101F D7 1F 00    1342*       dl 0x001FD7 ; 0000FE, 44.775
041022 EB 1F 00    1343*       dl 0x001FEB ; 0000FF, 44.888
041025 00 20 00    1344*       dl 0x002000 ; 000100, 45.000 only needed for interpolation
041028             0038        include "timer.inc"
041028             0001*   ; Table 32. Timer Control Registers
041028             0002*   TMR0_CTL: equ 80h
041028             0003*   TMR1_CTL: equ 83h
041028             0004*   TMR2_CTL: equ 86h
041028             0005*   TMR3_CTL: equ 89h
041028             0006*   TMR4_CTL: equ 8Ch
041028             0007*   TMR5_CTL: equ 8Fh
041028             0008*   
041028             0009*   ; each timer register takes three bytes:
041028             0010*   ;   0: control register
041028             0011*   ;   1: low byte of timer reset value
041028             0012*   ;   2: high byte of timer reset value
041028             0013*   ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
041028             0014*   ; which correctly force the high and upper bytes of the address bus to zero
041028             0015*   
041028             0016*   TMR_REG_CTL: equ 0
041028             0017*   TMR_RES_LOW: equ 1
041028             0018*   TMR_RES_HIGH: equ 2
041028             0019*   
041028             0020*   ; Timer Control Register Bit Definitions
041028             0021*   PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
041028             0022*                               ; This bit is reset to 0 every time the TMRx_CTL register is read.
041028             0023*   PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
041028             0024*                               ; an interrupt signal is sent to the CPU. This bit remains 1 until
041028             0025*                               ; the TMRx_CTL register is read.
041028             0026*   
041028             0027*   IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
041028             0028*   IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
041028             0029*   
041028             0030*   PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
041028             0031*                               ;  0,and counting stops when the end-of-count value is reached.
041028             0032*   PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
041028             0033*                               ; written to the counter when the end-of-count value is reached.
041028             0034*   
041028             0035*   ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
041028             0036*   CLK_DIV_256:  equ %00001100 ;
041028             0037*   CLK_DIV_64:   equ %00001000 ;
041028             0038*   CLK_DIV_16:   equ %00000100 ;
041028             0039*   CLK_DIV_4:    equ %00000000 ;
041028             0040*   
041028             0041*   RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
041028             0042*   RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
041028             0043*                               ; When a 1 is written to this bit,the values in the reload registers
041028             0044*                               ;  are loaded into the downcounter when the timer restarts. The
041028             0045*                               ; programmer must ensure that this bit is set to 1 each time
041028             0046*                               ; SINGLE-PASS mode is used.
041028             0047*   
041028             0048*   ; disable/enable the programmable reload timer
041028             0049*   PRT_EN_0:     equ %00000000 ;
041028             0050*   PRT_EN_1:     equ %00000001 ;
041028             0051*   
041028             0052*   ; Table 37. Timer Input Source Select Register
041028             0053*   ; Each of the 4 timers are allocated two bits of the 8-bit register
041028             0054*   ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
041028             0055*   ;   00: System clock / CLK_DIV
041028             0056*   ;   01: RTC / CLK_DIV
041028             0057*   ;   NOTE: these are the values given in the manual,but it may be a typo
041028             0058*   ;   10: GPIO port B pin 1.
041028             0059*   ;   11: GPIO port B pin 1.
041028             0060*   TMR_ISS:   equ 92h ; register address
041028             0061*   
041028             0062*   ; Table 51. Real-Time Clock Control Register
041028             0063*   RTC_CTRL: equ EDh ; register address
041028             0064*   
041028             0065*   ; alarm interrupt disable/enable
041028             0066*   RTC_ALARM_0:    equ %00000000
041028             0067*   RTC_ALARM_1:    equ %10000000
041028             0068*   
041028             0069*   ; interrupt on alarm disable/enable
041028             0070*   RTC_INT_ENT_0:  equ %00000000
041028             0071*   RTC_INT_ENT_1:  equ %01000000
041028             0072*   
041028             0073*   RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
041028             0074*   RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
041028             0075*   
041028             0076*   RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
041028             0077*                                   ; On-chip 32768 Hz oscillator is enabled.
041028             0078*   RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
041028             0079*                                   ; On-chip 32768 Hz oscillator is disabled.
041028             0080*   
041028             0081*   RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
041028             0082*   RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
041028             0083*   
041028             0084*   RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
041028             0085*   RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
041028             0086*   
041028             0087*   RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
041028             0088*                                   ; RTC counter is enabled.
041028             0089*   RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
041028             0090*                                   ; RTC counter is disabled.
041028             0091*   
041028             0092*   ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
041028             0093*   
041028             0094*   prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
041028             0095*   prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
041028 00 00 00    0096*   prt_reload: dl 0x000000
04102B             0097*   
04102B             0098*   ; returns: a = 0 if running on hardware,1 if running on emulator
04102B             0099*   ;          de = number PRT interrupts during test interval
04102B             0100*   prt_calibrate:
04102B CD FA 12 04 0101*       call vdu_vblank
04102F             0102*   ; set a MOS timer
04102F 21 78 00 00 0103*       ld hl,120*1 ; 1 second
041033 FD 21 B3 11 0104*       ld iy,tmr_test
       04          
041038 CD 91 11 04 0105*       call tmr_set
04103C             0106*   ; set a PRT timer
04103C             0107*       ; ld hl,prt_reload_hardware
04103C             0108*       ; ld hl,prt_reload_emulator
04103C 21 05 2D 00 0109*       ld hl,prt_reload_emulator + prt_reload_hardware / 2
041040 22 28 10 04 0110*       ld (prt_reload),hl
041044 CD CC 10 04 0111*       call prt_set
041048             0112*   @loop:
041048             0113*   ; check time remaining on MOS timer
041048 CD 9F 11 04 0114*       call tmr_get
04104C CA 56 10 04 0115*       jp z,@done ; time expired,so quit
041050 FA 56 10 04 0116*       jp m,@done ; time past expiration (negative),so quit
041054 18 F2       0117*       jr @loop
041056             0118*   @done:
041056 ED 5B 1A 11 0119*       ld de,(prt_irq_counter)
       04          
04105B 01 0C 2D 00 0120*       ld bc,prt_reload_hardware ; default value for running on hardware
04105F ED 43 28 10 0121*       ld (prt_reload),bc
       04          
041064 21 64 00 00 0122*       ld hl,100 ; halfway between 101 for real hardware and 99 for emulator
041068 AF          0123*       xor a ; clear carry,zero is default value for running on hardware
041069 32 8B 10 04 0124*       ld (is_emulator),a
04106D ED 52       0125*       sbc hl,de
04106F 21 8C 10 04 0126*       ld hl,on_hardware ; default message for running on hardware
041073 CA 2B 10 04 0127*       jp z,prt_calibrate ; zero result is indeterminate so we try again
041077 F8          0128*       ret m ; negative result means we're on hardware
041078 3C          0129*       inc a ; we're on emulator
041079 32 8B 10 04 0130*       ld (is_emulator),a
04107D 01 FF 2C 00 0131*       ld bc,prt_reload_emulator
041081 ED 43 28 10 0132*       ld (prt_reload),bc
       04          
041086 21 A2 10 04 0133*       ld hl,on_emulator
04108A C9          0134*       ret
04108B 00          0135*   is_emulator: db 0
04108C 52 75 6E 6E 0136*   on_hardware: defb "Running on hardware\r\n",0
       69 6E 67 20 
       6F 6E 20 68 
       61 72 64 77 
       61 72 65 0D 
       0A 00       
0410A2 52 75 6E 6E 0137*   on_emulator: defb "Running on emulator\r\n",0
       69 6E 67 20 
       6F 6E 20 65 
       6D 75 6C 61 
       74 6F 72 0D 
       0A 00       
0410B8             0138*   
0410B8 43 61 6C 69 0139*   calibrating_timer: defb "Calibrating timer\r\n",0
       62 72 61 74 
       69 6E 67 20 
       74 69 6D 65 
       72 0D 0A 00 
0410CC             0140*   
0410CC             0141*   ; set PRT timer
0410CC             0142*   prt_set:
0410CC 21 00 00 00 0143*       ld hl,0
0410D0 22 1A 11 04 0144*       ld (prt_irq_counter),hl
0410D4 2A 28 10 04 0145*       ld hl,(prt_reload)
0410D8 ED 29 84    0146*       out0 (TMR1_CTL+TMR_RES_LOW),l
0410DB ED 21 85    0147*   	out0 (TMR1_CTL+TMR_RES_HIGH),h
0410DE             0148*   ; disable timer
0410DE 3E 06       0149*       ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
0410E0 ED 39 83    0150*   	out0 (TMR1_CTL+TMR_REG_CTL),a
0410E3             0151*   ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
0410E3 3E 57       0152*       ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
0410E5 ED 39 83    0153*   	out0 (TMR1_CTL+TMR_REG_CTL),a
0410E8 C9          0154*       ret
0410E9             0155*   
0410E9             0156*   ; ===============================================
0410E9             0157*   ; PRT Timer Interrupt Handling
0410E9             0158*   ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.asm
0410E9             0159*   ; -----------------------------------------------
0410E9             0160*   prt_irq_init:
0410E9             0161*       ; set up interrupt vector table 2
0410E9 21 00 00 00 0162*   	ld hl,0
0410ED 3A 0C 01 00 0163*   	ld a,($10c)
0410F1 6F          0164*   	ld l,a
0410F2 3A 0D 01 00 0165*   	ld a,($10d)
0410F6 67          0166*   	ld h,a
0410F7             0167*   
0410F7             0168*   	; skip over CALL ($c3)
0410F7 23          0169*   	inc hl
0410F8             0170*   	; load address of jump into vector table 2 (in ram)
0410F8 ED 27       0171*   	ld hl,(hl)
0410FA             0172*   
0410FA             0173*   	; write CALL prt_irq_handler to vector table 2
0410FA 3E C3       0174*   	ld a,$c3
0410FC 77          0175*   	ld (hl),a
0410FD 23          0176*   	inc hl
0410FE 11 05 11 04 0177*   	ld de,prt_irq_handler
041102 ED 1F       0178*   	ld (hl),de
041104             0179*   
041104 C9          0180*       ret
041105             0181*   
041105             0182*   prt_irq_handler:
041105 F3          0183*   	di
041106 F5          0184*   	push af
041107 E5          0185*       push hl
041108 ED 38 83    0186*   	in0 a,(TMR1_CTL+TMR_REG_CTL)
04110B 2A 1A 11 04 0187*   	ld hl,(prt_irq_counter)
04110F 23          0188*   	inc hl
041110 22 1A 11 04 0189*   	ld (prt_irq_counter),hl
041114 E1          0190*       pop hl
041115 F1          0191*   	pop af
041116 FB          0192*   	ei
041117 5B ED 4D    0193*   	reti.l
04111A             0194*   
04111A             0195*   prt_irq_counter:
04111A 00 00 00    0196*   	.dl 0
04111D             0197*   prt_irq_counter_saved:
04111D 00 00 00    0198*       .dl 0
041120             0199*   
041120             0200*   prt_loop_reset:
041120 E5          0201*       push hl
041121 21 00 00 00 0202*   	ld hl,0
041125 22 1A 11 04 0203*   	ld (prt_irq_counter),hl
041129 22 8B 11 04 0204*       ld (prt_loop_counter),hl
04112D 22 8E 11 04 0205*       ld (prt_loops),hl
041131 CD CC 10 04 0206*       call prt_set
041135 E1          0207*       pop hl
041136 C9          0208*       ret
041137             0209*   
041137             0210*   prt_loop_start:
041137 E5          0211*       push hl
041138 21 00 00 00 0212*   	ld hl,0
04113C 22 1A 11 04 0213*   	ld (prt_irq_counter),hl
041140 E1          0214*       pop hl
041141 C9          0215*       ret
041142             0216*   
041142             0217*   prt_loop_stop:
041142 E5          0218*       push hl
041143 D5          0219*       push de
041144 2A 1A 11 04 0220*       ld hl,(prt_irq_counter)
041148 ED 5B 8B 11 0221*       ld de,(prt_loop_counter)
       04          
04114D 19          0222*       add hl,de
04114E 22 8B 11 04 0223*       ld (prt_loop_counter),hl
041152 21 00 00 00 0224*       ld hl,0
041156 22 1A 11 04 0225*       ld (prt_irq_counter),hl
04115A 2A 8E 11 04 0226*       ld hl,(prt_loops)
04115E 23          0227*       inc hl
04115F 22 8E 11 04 0228*       ld (prt_loops),hl
041163 D1          0229*       pop de
041164 E1          0230*       pop hl
041165 C9          0231*       ret
041166             0232*   
041166             0233*   ; inputs: bc = y,x text coordinates to print
041166             0234*   prt_loop_print:
041166 F5          0235*       push af
041167 E5          0236*       push hl
041168 C5          0237*       push bc
041169 D5          0238*       push de
04116A DD E5       0239*       push ix
04116C FD E5       0240*       push iy
04116E CD 72 12 04 0241*       call vdu_move_cursor
041172             0242*   
041172 2A 8B 11 04 0243*       ld hl,(prt_loop_counter)
041176 CD CC 00 04 0244*       call printDec
04117A             0245*   
04117A 2A 8E 11 04 0246*       ld hl,(prt_loops)
04117E CD CC 00 04 0247*       call printDec
041182             0248*   
041182 FD E1       0249*       pop iy
041184 DD E1       0250*       pop ix
041186 D1          0251*       pop de
041187 C1          0252*       pop bc
041188 E1          0253*       pop hl
041189 F1          0254*       pop af
04118A C9          0255*       ret
04118B             0256*   
04118B             0257*   prt_loop_counter:
04118B 00 00 00    0258*       .dl 0
04118E             0259*   prt_loops:
04118E 00 00 00    0260*       .dl 0
041191             0261*   
041191             0262*   ; ===============================================
041191             0263*   ; Timer functions
041191             0264*   ; -----------------------------------------------
041191             0265*   ; set a countdown timer
041191             0266*   ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
041191             0267*   ; returns: hl = current time
041191             0268*   tmr_set:
041191 FD 2F 03    0269*       ld (iy+3),hl            ; set time remaining
041194             0270*       MOSCALL mos_sysvars     ; ix points to syvars table
                       M1 Args: function=mos_sysvars 
041194 3E 08       0001*M1 			LD	A, function
041196 5B CF       0002*M1 			RST.LIL	08h
041198 DD 27 00    0271*       ld hl,(ix+sysvar_time)  ; get current time
04119B FD 2F 00    0272*       ld (iy+0),hl            ; set start time
04119E C9          0273*       ret
04119F             0274*   
04119F             0275*   ; gets time remaining on a countdown timer
04119F             0276*   ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
04119F             0277*   ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
04119F             0278*   ;          sign flags: pos = time not expired,zero or neg = time expired
04119F             0279*   tmr_get:
04119F             0280*       MOSCALL mos_sysvars     ; ix points to syvars table
                       M1 Args: function=mos_sysvars 
04119F 3E 08       0001*M1 			LD	A, function
0411A1 5B CF       0002*M1 			RST.LIL	08h
0411A3 DD 17 00    0281*       ld de,(ix+sysvar_time)  ; get current time
0411A6 FD 27 00    0282*       ld hl,(iy+0)            ; get start time
0411A9 AF          0283*       xor a                   ; clear carry
0411AA ED 52       0284*       sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0411AC FD 17 03    0285*       ld de,(iy+3)            ; get timer set value
0411AF AF          0286*       xor a                   ; clear carry
0411B0 ED 5A       0287*       adc hl,de               ; hl = time remaining
0411B2             0288*                               ; (we do adc because add hl,rr doesn't set sign or zero flags)
0411B2 C9          0289*       ret
0411B3             0290*   
0411B3             0291*   tmr_test: ds 6 ; example of a buffer to hold timer data
0411B9             0292*   
       FF FF FF FF 
       FF FF 
0411B9 00 00 00    0293*   timestamp_now: dl 0
0411BC 00 00 00    0294*   timestamp_old: dl 0
0411BF 00 00 00    0295*   timestamp_chg: dl 0
0411C2             0296*   
0411C2             0297*   ; update the global timestamp from the system clock
0411C2             0298*   ; inputs: none
0411C2             0299*   ; returns: hl = time elapsed in 1/120ths of a second
0411C2             0300*   ;          de = current time
0411C2             0301*   ;          ix = pointer to syvars table
0411C2             0302*   ; destroys: af,hl,de,ix
0411C2             0303*   timestamp_tick:
0411C2 ED 5B B9 11 0304*       ld de,(timestamp_now)   ; get previous time
       04          
0411C7 ED 53 BC 11 0305*       ld (timestamp_old),de   ; save previous time
       04          
0411CC             0306*       MOSCALL mos_sysvars     ; ix points to syvars table
                       M1 Args: function=mos_sysvars 
0411CC 3E 08       0001*M1 			LD	A, function
0411CE 5B CF       0002*M1 			RST.LIL	08h
0411D0 DD 27 00    0307*       ld hl,(ix+sysvar_time)  ; get current time
0411D3 22 B9 11 04 0308*       ld (timestamp_now),hl   ; save current time
0411D7 AF          0309*       xor a                   ; clear carry
0411D8 ED 52       0310*       sbc hl,de               ; hl = time elapsed
0411DA 22 BF 11 04 0311*       ld (timestamp_chg),hl   ; save elapsed time
0411DE C9          0312*       ret
0411DF             0313*   
0411DF             0314*   ; set a countdown timer
0411DF             0315*   ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0411DF             0316*   ; requires: timestamp_tick to be called at least once before this function
0411DF             0317*   ; returns: hl = current time
0411DF             0318*   ; destroys: hl
0411DF             0319*   timestamp_tmr_set:
0411DF FD 2F 03    0320*       ld (iy+3),hl            ; set time remaining
0411E2 2A B9 11 04 0321*       ld hl,(timestamp_now)   ; get current timestamp
0411E6 FD 2F 00    0322*       ld (iy+0),hl            ; set start time
0411E9 C9          0323*       ret
0411EA             0324*   
0411EA             0325*   ; gets time remaining on a countdown timer following the global timestamp
0411EA             0326*   ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0411EA             0327*   ; requires: timestamp_tick to be called at least once before this function
0411EA             0328*   ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0411EA             0329*   ;          sign flags: pos = time not expired,zero or neg = time expired
0411EA             0330*   ; destroys: af,hl,de
0411EA             0331*   timestamp_tmr_get:
0411EA ED 5B B9 11 0332*       ld de,(timestamp_now)   ; get current timestamp
       04          
0411EF FD 27 00    0333*       ld hl,(iy+0)            ; get start time
0411F2 AF          0334*       xor a                   ; clear carry
0411F3 ED 52       0335*       sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0411F5 FD 17 03    0336*       ld de,(iy+3)            ; get timer set value
0411F8 AF          0337*       xor a                   ; clear carry
0411F9 ED 5A       0338*       adc hl,de               ; hl = time remaining
0411FB             0339*                               ; (we do adc because add hl,rr doesn't set sign or zero flags)
0411FB C9          0340*       ret
0411FC             0341*   
0411FC             0342*   ; set a stopwatch
0411FC             0343*   ; returns: hl = start time
0411FC             0344*   ; destroys: hl,ix
0411FC             0345*   stopwatch_set:
0411FC             0346*       MOSCALL mos_sysvars     ; ix points to syvars table
                       M1 Args: function=mos_sysvars 
0411FC 3E 08       0001*M1 			LD	A, function
0411FE 5B CF       0002*M1 			RST.LIL	08h
041200 DD 27 00    0347*       ld hl,(ix+sysvar_time)  ; get current time
041203 22 18 12 04 0348*       ld (stopwatch_started),hl            ; set start time
041207 C9          0349*       ret
041208             0350*   
041208             0351*   ; gets time elapsed on a stopwatch
041208             0352*   ; returns: hl = time elapsed in 1/120ths of a second
041208             0353*   ; destroys: af,hl,de,ix
041208             0354*   stopwatch_get:
041208             0355*       MOSCALL mos_sysvars     ; ix points to syvars table
                       M1 Args: function=mos_sysvars 
041208 3E 08       0001*M1 			LD	A, function
04120A 5B CF       0002*M1 			RST.LIL	08h
04120C DD 27 00    0356*       ld hl,(ix+sysvar_time)  ; get current time
04120F ED 5B 18 12 0357*       ld de,(stopwatch_started)            ; get start time
       04          
041214 AF          0358*       xor a                   ; clear carry
041215 ED 52       0359*       sbc hl,de               ; hl = time elapsed (will always be zero or positive)
041217 C9          0360*       ret
041218             0361*   
041218             0362*   stopwatch_started: ds 3 ; buffer to hold stopwatch start time
04121B             0363*   
04121B             0364*   ; ------------------
04121B             0365*   ; delay routine
04121B             0366*   ; Author: Richard Turrnidge
04121B             0367*   ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.asm
04121B             0368*   ; routine waits a fixed time,then returns
04121B             0369*   ; arrive with A =  the delay byte. One bit to be set only.
04121B             0370*   ; eg. ld A,00000100b
04121B             0371*   
04121B             0372*   multiPurposeDelay:
       FF FF FF 
04121B F5          0373*       push af
04121C C5          0374*       push bc
04121D DD E5       0375*       push ix
04121F 47          0376*       ld b,a
041220 3E 08       0377*       ld a,$08
041222 5B CF       0378*       RST.LIL	08h                 ; get IX pointer to sysvars
041224             0379*   
041224             0380*   waitLoop:
041224             0381*   
041224 DD 7E 00    0382*       ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
041227             0383*   
041227             0384*                                   ;   we check if bit set is same as last time we checked.
041227             0385*                                   ;   bit 0 - don't use
041227             0386*                                   ;   bit 1 - changes 64 times per second
041227             0387*                                   ;   bit 2 - changes 32 times per second
041227             0388*                                   ;   bit 3 - changes 16 times per second
041227             0389*   
041227             0390*                                   ;   bit 4 - changes 8 times per second
041227             0391*                                   ;   bit 5 - changes 4 times per second
041227             0392*                                   ;   bit 6 - changes 2 times per second
041227             0393*                                   ;   bit 7 - changes 1 times per second
041227 A0          0394*       and b
041228 4F          0395*       ld c,a
041229 3A 3A 12 04 0396*       ld a,(oldTimeStamp)
04122D B9          0397*       cp c                        ; is A same as last value?
04122E 28 F4       0398*       jr z,waitLoop              ; loop here if it is
041230 79          0399*       ld a,c
041231 32 3A 12 04 0400*       ld (oldTimeStamp),a        ; set new value
041235             0401*   
041235 DD E1       0402*       pop ix
041237 C1          0403*       pop bc
041238 F1          0404*       pop af
041239 C9          0405*       ret
04123A             0406*   
04123A 00          0407*   oldTimeStamp:   .db 00h
04123B             0039        include "vdu.inc"
04123B             0001*   ; VDU 30: Home cursor
04123B             0002*   vdu_home_cursor:
04123B 3E 1E       0003*       ld a,30
04123D 5B D7       0004*   	rst.lil $10
04123F C9          0005*   	ret
041240             0006*   
041240             0007*   vdu_cursor_on:
041240 21 4B 12 04 0008*   	ld hl,@cmd
041244 01 03 00 00 0009*   	ld bc,@end-@cmd
041248 5B DF       0010*   	rst.lil $18
04124A C9          0011*   	ret
04124B             0012*   @cmd:
04124B 17 01 01    0013*   	db 23,1,1
04124E             0014*   @end:
04124E             0015*   
04124E             0016*   vdu_cursor_off:
04124E 21 59 12 04 0017*   	ld hl,@cmd
041252 01 03 00 00 0018*   	ld bc,@end-@cmd
041256 5B DF       0019*   	rst.lil $18
041258 C9          0020*   	ret
041259             0021*   @cmd:
041259 17 01 00    0022*   	db 23,1,0
04125C             0023*   @end:
04125C             0024*   
04125C             0025*   ; VDU 5: Write text at graphics cursor
04125C             0026*   ; inputs: a is the character to write to the screen
04125C             0027*   ; prerequisites: the graphics cursor at the intended position on screen
04125C             0028*   ; outputs: see the name of the function
04125C             0029*   ; destroys: a, hl, bc
04125C             0030*   vdu_char_to_gfx_cursor:
04125C 32 6C 12 04 0031*   	ld (@arg),a
041260 21 6B 12 04 0032*   	ld hl,@cmd
041264 01 02 00 00 0033*   	ld bc,@end-@cmd
041268 5B DF       0034*   	rst.lil $18
04126A C9          0035*   	ret
04126B 05          0036*   @cmd: db 5
04126C 00          0037*   @arg: db 0
04126D             0038*   @end:
04126D             0039*   ; VDU 9: Move cursor forward one character
04126D             0040*   vdu_cursor_forward:
04126D 3E 09       0041*       ld a,9
04126F 5B D7       0042*   	rst.lil $10
041271 C9          0043*   	ret
041272             0044*   
041272             0045*   ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
041272             0046*   ; inputs: c=x, b=y 8-bit unsigned integers
041272             0047*   vdu_move_cursor:
041272 ED 43 83 12 0048*       ld (@x0),bc
       04          
041277 21 82 12 04 0049*   	ld hl,@cmd
04127B 01 03 00 00 0050*   	ld bc,@end-@cmd
04127F 5B DF       0051*   	rst.lil $18
041281 C9          0052*   	ret
041282 1F          0053*   @cmd: 	db 31
041283 00          0054*   @x0:	db 0
041284 00          0055*   @y0: 	db 0
041285 00          0056*   @end: 	db 0 ; padding
041286             0057*   
041286             0058*   ; VDU 12: Clear text area (CLS)
041286             0059*   vdu_cls:
041286 3E 0C       0060*       ld a,12
041288 5B D7       0061*   	rst.lil $10
04128A C9          0062*   	ret
04128B             0063*   
04128B             0064*   vdu_flip:
04128B 21 96 12 04 0065*   	ld hl,@cmd
04128F 01 03 00 00 0066*   	ld bc,@end-@cmd
041293 5B DF       0067*   	rst.lil $18
041295 C9          0068*   	ret
041296 17 00 C3    0069*   @cmd: db 23,0,0xC3
041299             0070*   @end:
041299             0071*   
041299             0072*   ; VDU 16: Clear graphics area (CLG)
041299             0073*   vdu_clg:
041299 3E 10       0074*       ld a,16
04129B 5B D7       0075*   	rst.lil $10
04129D C9          0076*   	ret
04129E             0077*   
04129E             0078*   ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
04129E             0079*   ; VDU 23, 7: Scrolling
04129E             0080*   ;     VDU 23, 7, extent, direction, speed: Scroll the screen
04129E             0081*   ; inputs: a, extent; l, direction; h; speed
04129E             0082*   vdu_scroll_down:
04129E 32 B3 12 04 0083*   	ld (@extent),a
0412A2 22 B4 12 04 0084*   	ld (@dir),hl ; implicitly populates @speed
0412A6 21 B1 12 04 0085*   	ld hl,@cmd
0412AA 01 05 00 00 0086*   	ld bc,@end-@cmd
0412AE 5B DF       0087*   	rst.lil $18     ;; Sending command to VDP
0412B0 C9          0088*   	ret
0412B1 17 07       0089*   @cmd:       db 23,7
0412B3 00          0090*   @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
0412B4 00          0091*   @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
0412B5 00          0092*   @speed:     db 0x00 ; pixels
0412B6 00          0093*   @end:		db 0x00 ; padding
0412B7             0094*   
0412B7             0095*   ; COLOUR MODES
0412B7             0096*   ; Mode	Effect
0412B7             0097*   ; 0	Set on-screen pixel to target colour value
0412B7             0098*   ; 1	OR value with the on-screen pixel
0412B7             0099*   ; 2	AND value with the on-screen pixel
0412B7             0100*   ; 3	XOR value with the on-screen pixel
0412B7             0101*   ; 4	Invert the on-screen pixel
0412B7             0102*   ; 5	No operation
0412B7             0103*   ; 6	AND the inverse of the specified colour with the on-screen pixel
0412B7             0104*   ; 7	OR the inverse of the specified colour with the on-screen pixel
0412B7             0105*   
0412B7             0106*   ; VDU 17, colour: Define text colour (COLOUR)
0412B7             0107*   vdu_colour_text:
0412B7 32 C7 12 04 0108*   	ld (@arg),a
0412BB 21 C6 12 04 0109*   	ld hl,@cmd
0412BF 01 02 00 00 0110*   	ld bc,@end-@cmd
0412C3 5B DF       0111*   	rst.lil $18
0412C5 C9          0112*   	ret
0412C6 11          0113*   @cmd: db 17
0412C7 00          0114*   @arg: db 0
0412C8             0115*   @end:
0412C8             0116*   
0412C8             0117*   ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
0412C8             0118*   ; inputs: a=mode, c=colour (add 128 to set background colour)
0412C8             0119*   vdu_gcol:
0412C8 32 DD 12 04 0120*   	ld (@mode),a
0412CC 79          0121*       ld a,c
0412CD 32 DE 12 04 0122*       ld (@col),a
0412D1 21 DC 12 04 0123*   	ld hl,@cmd
0412D5 01 03 00 00 0124*   	ld bc,@end-@cmd
0412D9 5B DF       0125*   	rst.lil $18
0412DB C9          0126*   	ret
0412DC 12          0127*   @cmd:  db 18
0412DD 00          0128*   @mode: db 0
0412DE 00          0129*   @col:  db 0
0412DF             0130*   @end:
0412DF             0131*   
0412DF             0132*   
0412DF             0133*   ; VDU 28, left, bottom, right, top: Set text viewport **
0412DF             0134*   ; MIND THE LITTLE-ENDIANESS
0412DF             0135*   ; inputs: c=left,b=bottom,e=right,d=top
0412DF             0136*   ; outputs; nothing
0412DF             0137*   ; destroys: a might make it out alive
0412DF             0138*   vdu_set_txt_viewport:
0412DF ED 43 F5 12 0139*       ld (@lb),bc
       04          
0412E4 ED 53 F7 12 0140*   	ld (@rt),de
       04          
0412E9 21 F4 12 04 0141*   	ld hl,@cmd
0412ED 01 05 00 00 0142*   	ld bc,@end-@cmd
0412F1 5B DF       0143*   	rst.lil $18
0412F3 C9          0144*   	ret
0412F4 1C          0145*   @cmd:   db 28 ; set text viewport command
0412F5 00 00       0146*   @lb: 	dw 0x0000 ; set by bc
0412F7 00 00       0147*   @rt: 	dw 0x0000 ; set by de
0412F9 00          0148*   @end:   db 0x00	  ; padding
0412FA             0149*   
0412FA             0150*   ; Wait for VBLANK interrupt
0412FA             0151*   vdu_vblank:
0412FA DD E5       0152*       PUSH 	IX
0412FC             0153*   	MOSCALL	mos_sysvars
                       M1 Args: function=mos_sysvars 
0412FC 3E 08       0001*M1 			LD	A, function
0412FE 5B CF       0002*M1 			RST.LIL	08h
041300 DD 7E 00    0154*   	LD	A, (IX + sysvar_time + 0)
041303             0155*   @wait:
041303 DD BE 00    0156*       CP 	A, (IX + sysvar_time + 0)
041306 28 FB       0157*       JR	Z, @wait
041308 DD E1       0158*       POP	IX
04130A C9          0159*       RET
04130B             0160*   
04130B             0161*   ; VDU 29, x; y;: Set graphics origin
04130B             0162*   ; This command sets the graphics origin.
04130B             0163*   ; The origin is the point on the screen where the coordinates (0,0) are located.
04130B             0164*   ; inputs: bc=x0,de=y0
04130B             0165*   ; outputs; nothing
04130B             0166*   ; destroys: a might make it out alive
04130B             0167*   vdu_set_gfx_origin:
04130B ED 43 21 13 0168*       ld (@x0),bc
       04          
041310 ED 53 23 13 0169*       ld (@y0),de
       04          
041315 21 20 13 04 0170*       ld hl,@cmd
041319 01 05 00 00 0171*       ld bc,@end-@cmd
04131D 5B DF       0172*       rst.lil $18
04131F C9          0173*       ret
041320 1D          0174*   @cmd:   db 29 ; set graphics origin command
041321 00 00       0175*   @x0: 	dw 0x0000 ; set by bc
041323 00 00       0176*   @y0: 	dw 0x0000 ; set by de
041325 00          0177*   @end:   db 0x00	  ; padding
041326             0178*   
041326             0179*   ; VDU 24, left; bottom; right; top;: Set graphics viewport
041326             0180*   ; NOTE: the order of the y-coordinate parameters are inverted
041326             0181*   ; 	because we have turned off logical screen scaling
041326             0182*   ; NOTE: coordinates are relative to current gfx origin
041326             0183*   ; inputs: bc=x0,de=y0,ix=x1,iy=y1
041326             0184*   ; outputs; nothing
041326             0185*   ; destroys: a might make it out alive
041326             0186*   vdu_set_gfx_viewport:
041326 ED 43 46 13 0187*       ld (@x0),bc
       04          
04132B FD 22 48 13 0188*       ld (@y1),iy
       04          
041330 DD 22 4A 13 0189*   	ld (@x1),ix
       04          
041335 ED 53 4C 13 0190*   	ld (@y0),de
       04          
04133A 21 45 13 04 0191*   	ld hl,@cmd
04133E 01 09 00 00 0192*   	ld bc,@end-@cmd
041342 5B DF       0193*   	rst.lil $18
041344 C9          0194*   	ret
041345 18          0195*   @cmd:   db 24 ; set graphics viewport command
041346 00 00       0196*   @x0: 	dw 0x0000 ; set by bc
041348 00 00       0197*   @y1: 	dw 0x0000 ; set by iy
04134A 00 00       0198*   @x1: 	dw 0x0000 ; set by ix
04134C 00 00       0199*   @y0: 	dw 0x0000 ; set by de
04134E 00          0200*   @end:   db 0x00	  ; padding
04134F             0201*   
04134F             0202*   ; VDU 26: Reset graphics and text viewports
04134F             0203*   vdu_reset_viewports:
04134F 3E 1A       0204*       ld a,26
041351 5B D7       0205*       rst.lil $10
041353 C9          0206*       ret
041354             0207*   
041354             0208*   ; SCREEN MODES
041354             0209*   ; ===============================
041354             0210*   ; Mode  Horz  Vert  Cols  Refresh
041354             0211*   ; ---   ----  ----  ----  -------
041354             0212*   ; 11    320   240   2     60hz
041354             0213*   ; 139   320   240   2     60hz
041354             0214*   ; 23    512   384   2     60hz
041354             0215*   ; 151   512   384   2     60hz
041354             0216*   ; 6     640   240   2     60hz
041354             0217*   ; 134   640   240   2     60hz
041354             0218*   ; 2     640   480   2     60hz
041354             0219*   ; 130   640   480   2     60hz
041354             0220*   ; 17    800   600   2     60hz
041354             0221*   ; 145   800   600   2     60hz
041354             0222*   ; 18    1024  768   2     60hz
041354             0223*   ; 146   1024  768   2     60hz
041354             0224*   ; ---   ----  ----  ----  -------
041354             0225*   ; 10    320   240   4     60hz
041354             0226*   ; 138   320   240   4     60hz
041354             0227*   ; 22    512   384   4     60hz
041354             0228*   ; 150   512   384   4     60hz
041354             0229*   ; 5     640   240   4     60hz
041354             0230*   ; 133   640   240   4     60hz
041354             0231*   ; 1     640   480   4     60hz
041354             0232*   ; 129   640   480   4     60hz
041354             0233*   ; 16    800   600   4     60hz
041354             0234*   ; 19    1024  768   4     60hz
041354             0235*   ; ---   ----  ----  ----  -------
041354             0236*   ; 9     320   240   16    60hz
041354             0237*   ; 137   320   240   16    60hz
041354             0238*   ; 21    512   384   16    60hz
041354             0239*   ; 149   512   384   16    60hz
041354             0240*   ; 4     640   240   16    60hz
041354             0241*   ; 132   640   240   16    60hz
041354             0242*   ; 0     640   480   16    60hz
041354             0243*   ; 7     n/a   n/a   16    60hz
041354             0244*   ; ---   ----  ----  ----  -------
041354             0245*   ; 8     320   240   64    60hz
041354             0246*   ; 136   320   240   64    60hz
041354             0247*   ; 20    512   384   64    60hz
041354             0248*   ; 3     640   240   64    60hz
041354             0249*   ; ---   ----  ----  ----  -------
041354             0250*   vdu_set_screen_mode:
041354 32 64 13 04 0251*   	ld (@arg),a
041358 21 63 13 04 0252*   	ld hl,@cmd
04135C 01 02 00 00 0253*   	ld bc,@end-@cmd
041360 5B DF       0254*   	rst.lil $18
041362 C9          0255*   	ret
041363 16          0256*   @cmd: db 22 ; set screen mode
041364 00          0257*   @arg: db 0  ; screen mode parameter
041365             0258*   @end:
041365             0259*   
041365             0260*   ; get the current screen mode
041365             0261*   ; inputs: none
041365             0262*   ; outputs: a=screen mode
041365             0263*   ; destroys: af, ix
041365             0264*   vdu_get_screen_mode:
041365             0265*       MOSCALL mos_sysvars
                       M1 Args: function=mos_sysvars 
041365 3E 08       0001*M1 			LD	A, function
041367 5B CF       0002*M1 			RST.LIL	08h
041369 DD 7E 27    0266*       ld a,(IX+sysvar_scrMode)
04136C C9          0267*       ret
04136D             0268*   ; end vdu_get_screen_mode
04136D             0269*   
04136D             0270*   ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
04136D             0271*   ; inputs: a is scaling mode, 1=on, 0=off
04136D             0272*   ; note: default setting on boot is scaling ON
04136D             0273*   vdu_set_scaling:
04136D 32 7F 13 04 0274*   	ld (@arg),a
041371 21 7C 13 04 0275*   	ld hl,@cmd
041375 01 04 00 00 0276*   	ld bc,@end-@cmd
041379 5B DF       0277*   	rst.lil $18
04137B C9          0278*   	ret
04137C 17 00 C0    0279*   @cmd: db 23,0,0xC0
04137F 00          0280*   @arg: db 0  ; scaling on/off
041380             0281*   @end:
041380             0282*   
041380             0283*   ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
041380             0284*   ; inputs: hl=bufferId
041380             0285*   vdu_buff_select:
041380 22 92 13 04 0286*   	ld (@bufferId),hl
041384 21 8F 13 04 0287*   	ld hl,@cmd
041388 01 05 00 00 0288*   	ld bc,@end-@cmd
04138C 5B DF       0289*   	rst.lil $18
04138E C9          0290*   	ret
04138F 17 1B 20    0291*   @cmd: db 23,27,0x20
041392 00 00       0292*   @bufferId: dw 0x0000
041394 00          0293*   @end: db 0x00 ; padding
041395             0294*   
041395             0295*   ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
041395             0296*   ; inputs: a=format; bc=width; de=height
041395             0297*   ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
041395             0298*   ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
041395             0299*   ; 0 	RGBA8888 (4-bytes per pixel)
041395             0300*   ; 1 	RGBA2222 (1-bytes per pixel)
041395             0301*   ; 2 	Mono/Mask (1-bit per pixel)
041395             0302*   ; 3 	Reserved for internal use by VDP (“native” format)
041395             0303*   vdu_bmp_create:
041395 ED 43 B1 13 0304*       ld (@width),bc
       04          
04139A ED 53 B3 13 0305*       ld (@height),de
       04          
04139F 32 B5 13 04 0306*       ld (@fmt),a
0413A3 21 AE 13 04 0307*   	ld hl,@cmd
0413A7 01 08 00 00 0308*   	ld bc,@end-@cmd
0413AB 5B DF       0309*   	rst.lil $18
0413AD C9          0310*   	ret
0413AE 17 1B 21    0311*   @cmd:       db 23,27,0x21
0413B1 00 00       0312*   @width:     dw 0x0000
0413B3 00 00       0313*   @height:    dw 0x0000
0413B5 00          0314*   @fmt:       db 0x00
0413B6             0315*   @end:
0413B6             0316*   
0413B6             0317*   ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
0413B6             0318*   ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
0413B6             0319*   vdu_load_img_rgba2_to_8:
0413B6             0320*   ; backup the target buffer id and image dimensions
0413B6 E5          0321*       push hl
0413B7 D5          0322*       push de
0413B8 C5          0323*       push bc
0413B9             0324*   ; load the rgba2 image to working buffer 65534
0413B9 21 FE FF 00 0325*       ld hl,65534 ; temporary working buffer id
0413BD CD 94 14 04 0326*   	call vdu_load_buffer_from_file
0413C1             0327*   ; restore the image dimensions and target buffer id
0413C1 C1          0328*       pop bc
0413C2 D1          0329*       pop de
0413C3 E1          0330*       pop hl
0413C4             0331*   ; fall through to vdu_rgba2_to_8
0413C4             0332*   
0413C4             0333*   ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
0413C4             0334*   ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
0413C4             0335*   ; the "expand bitmap" command is:
0413C4             0336*   ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0413C4             0337*   ; and then to reverse the byte order to fix endian-ness:
0413C4             0338*   ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0413C4             0339*   ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0413C4             0340*   ; VDU 23,27,&20,targetBufferID%;
0413C4             0341*   ; VDU 23,27,&21,width%;height%;0
0413C4             0342*   ; -------------------------------------------------------------------
0413C4             0343*   ; inputs: bc,de image width,height ; hl = targetBufferId
0413C4             0344*   ; prerequisites: rgba2 image data loaded into workingBufferId 65534
0413C4             0345*   vdu_rgba2_to_8:
0413C4             0346*   ; load the image dimensions and buffer id parameters
0413C4 ED 43 20 14 0347*       ld (@width),bc
       04          
0413C9 ED 53 22 14 0348*       ld (@height),de
       04          
0413CE 22 05 14 04 0349*       ld (@bufferId0),hl
0413D2 22 12 14 04 0350*       ld (@bufferId2),hl
0413D6 22 1B 14 04 0351*       ld (@bufferId1),hl
0413DA             0352*   ; clean up bytes that got stomped on by the ID loads
0413DA 3E 48       0353*       ld a,0x48
0413DC 32 07 14 04 0354*       ld (@bufferId0+2),a
0413E0 3E 17       0355*       ld a,23
0413E2 32 1D 14 04 0356*       ld (@bufferId1+2),a
0413E6 3E 18       0357*       ld a,24
0413E8 32 14 14 04 0358*       ld (@bufferId2+2),a
0413EC AF          0359*       xor a
0413ED 32 24 14 04 0360*       ld (@height+2),a
0413F1             0361*   ; send the vdu command strings
0413F1 21 FC 13 04 0362*       ld hl,@beg
0413F5 01 29 00 00 0363*       ld bc,@end-@beg
0413F9 5B DF       0364*       rst.lil $18
0413FB C9          0365*       ret
0413FC             0366*   @beg:
0413FC             0367*   ; Command 14: Consolidate blocks in a buffer
0413FC             0368*   ; VDU 23, 0, &A0, bufferId; 14
0413FC 17 00 A0    0369*       db 23,0,0xA0
0413FF FE FF       0370*       dw 65534 ; workingBufferId
041401 0E          0371*       db 14 ; consolidate blocks
041402             0372*   ; the "expand bitmap" command is:
041402             0373*   ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
041402 17 00 A0    0374*       db 23,0,0xA0
041405 00 00       0375*   @bufferId0: dw 0x0000 ; targetBufferId
041407 48          0376*       db 0x48 ; given as decimal command 72 in the docs
041408 02          0377*       db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
041409 FE FF       0378*       dw 65534 ; sourceBufferId
04140B 00 7F BF FF 0379*       db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
04140F             0380*   ; reverse the byte order to fix endian-ness:
04140F             0381*   ; Command 24: Reverse the order of data of blocks within a buffer
04140F             0382*   ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
04140F             0383*   ; VDU 23,0,&A0,targetBufferID%;24,4,4;
04140F 17 00 A0    0384*       db 23,0,0xA0
041412 00 00       0385*   @bufferId2:    dw 0x0000 ; targetBufferId
041414 18          0386*       db 24 ; reverse byte order
041415 04          0387*       db 4 ; option: Reverse data of the value size within chunk of data of the specified size
041416 04 00       0388*       dw 4 ; size (4 bytes)
041418             0389*   ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
041418             0390*   ; VDU 23,27,&20,targetBufferID%;
041418 17 1B 20    0391*       db 23,27,0x20 ; select bitmap
04141B 00 00       0392*   @bufferId1: dw 0x0000 ; targetBufferId
04141D             0393*   ; VDU 23,27,&21,width%;height%;0
04141D 17 1B 21    0394*       db 23,27,0x21 ; create bitmap from buffer
041420 00 00       0395*   @width: dw 0x0000
041422 00 00       0396*   @height: dw 0x0000
041424 00          0397*       db 0x00 ; rgba8888 format
041425             0398*   @end:
041425             0399*   
041425             0400*   ; scratch variables
041425 00 00 00    0401*   bufferId0: dl 0x000000
041428 00 00 00    0402*   bufferId1: dl 0x000000
04142B             0403*   
04142B             0404*   ; load a vdu buffer from local memory
04142B             0405*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
04142B             0406*   vdu_load_buffer:
04142B ED 43 54 14 0407*       ld (@length),bc
       04          
041430 D5          0408*       push de ; save data pointer
041431             0409*   ; send the vdu command string
041431 7D          0410*       ld a,l
041432 32 51 14 04 0411*       ld (@bufferId),a
041436 7C          0412*       ld a,h
041437 32 52 14 04 0413*       ld (@bufferId+1),a
04143B 21 4E 14 04 0414*       ld hl,@cmd
04143F 01 08 00 00 0415*       ld bc,@end-@cmd
041443 5B DF       0416*       rst.lil $18
041445             0417*   ; send the buffer data
041445 E1          0418*       pop hl ; pointer to data
041446 ED 4B 54 14 0419*       ld bc,(@length)
       04          
04144B 5B DF       0420*       rst.lil $18 ; send it
04144D C9          0421*       ret
04144E             0422*   ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04144E 17 00 A0    0423*   @cmd:       db 23,0,0xA0
041451 00 00       0424*   @bufferId:	dw 0x0000
041453 00          0425*   		    db 0 ; load buffer
041454 00 00       0426*   @length:	dw 0x0000
041456 00          0427*   @end: db 0 ; padding
041457             0428*   
041457             0429*   ; Command 14: Consolidate blocks in a buffer
041457             0430*   vdu_consolidate_buffer:
041457             0431*   ; set parameters for vdu call
041457 7D          0432*       ld a,l
041458 32 6F 14 04 0433*       ld (@bufferId),a
04145C 7C          0434*       ld a,h
04145D 32 70 14 04 0435*       ld (@bufferId+1),a
041461 21 6C 14 04 0436*       ld hl,@beg
041465 01 06 00 00 0437*       ld bc,@end-@beg
041469 5B DF       0438*       rst.lil $18
04146B C9          0439*       ret
04146C             0440*   ; VDU 23, 0, &A0, bufferId; 14
04146C 17 00 A0    0441*   @beg: db 23,0,0xA0
04146F 00 00       0442*   @bufferId: dw 0x0000
041471 0E          0443*              db 14
041472             0444*   @end:
041472             0445*   
041472             0446*   ; load an image file to a buffer and make it a bitmap
041472             0447*   ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
041472             0448*   vdu_load_img:
041472             0449*   ; back up image type and dimension parameters
041472 22 25 14 04 0450*       ld (bufferId0),hl
041476 F5          0451*       push af
041477 C5          0452*   	push bc
041478 D5          0453*   	push de
041479             0454*   ; load the image
041479 CD 94 14 04 0455*   	call vdu_load_buffer_from_file
04147D             0456*   ; now make it a bitmap
04147D 2A 25 14 04 0457*       ld hl,(bufferId0)
041481 CD 57 14 04 0458*       call vdu_consolidate_buffer
041485 2A 25 14 04 0459*       ld hl,(bufferId0)
041489 CD 80 13 04 0460*       call vdu_buff_select
04148D D1          0461*   	pop de ; image height
04148E C1          0462*   	pop bc ; image width
04148F F1          0463*   	pop af ; image type
041490 C3 95 13 04 0464*   	jp vdu_bmp_create ; will return to caller from there
041494             0465*   
041494             0466*   ; inputs: hl = bufferId; iy = pointer to filename
041494             0467*   vdu_load_buffer_from_file:
041494 22 25 14 04 0468*       ld (bufferId0),hl
041498             0469*   
041498             0470*   ; clear target buffer
041498 CD 40 16 04 0471*       call vdu_clear_buffer
04149C             0472*   
04149C             0473*   ; open the file in read mode
04149C             0474*   ; Open a file
04149C             0475*   ; HLU: Filename
04149C             0476*   ;   C: Mode
04149C             0477*   ; Returns:
04149C             0478*   ;   A: Filehandle, or 0 if couldn't open
04149C FD E5       0479*   	push iy ; pointer to filename
04149E E1          0480*   	pop hl
04149F 0E 01       0481*   	ld c,fa_read
0414A1             0482*       MOSCALL mos_fopen
                       M1 Args: function=mos_fopen 
0414A1 3E 0A       0001*M1 			LD	A, function
0414A3 5B CF       0002*M1 			RST.LIL	08h
0414A5 32 E0 14 04 0483*       ld (@filehandle),a
0414A9             0484*   
0414A9             0485*   @read_file:
0414A9             0486*   ; Read a block of data from a file
0414A9             0487*   ;   C: Filehandle
0414A9             0488*   ; HLU: Pointer to where to write the data to
0414A9             0489*   ; DEU: Number of bytes to read
0414A9             0490*   ; Returns:
0414A9             0491*   ; DEU: Number of bytes read
0414A9 3A E0 14 04 0492*       ld a,(@filehandle)
0414AD 4F          0493*       ld c,a
0414AE 21 00 E0 B7 0494*       ld hl,filedata
0414B2 11 00 20 00 0495*       ld de,8192 ; max we can read into onboard sram at one time
0414B6             0496*       MOSCALL mos_fread
                       M1 Args: function=mos_fread 
0414B6 3E 1A       0001*M1 			LD	A, function
0414B8 5B CF       0002*M1 			RST.LIL	08h
0414BA             0497*   
0414BA             0498*   ; test de for zero bytes read
0414BA 21 00 00 00 0499*       ld hl,0
0414BE AF          0500*       xor a ; clear carry
0414BF ED 52       0501*       sbc hl,de
0414C1 CA D7 14 04 0502*       jp z,@close_file
0414C5             0503*   
0414C5             0504*   ; load a vdu buffer from local memory
0414C5             0505*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0414C5 2A 25 14 04 0506*       ld hl,(bufferId0)
0414C9 D5          0507*       push de ; chunksize
0414CA C1          0508*       pop bc
0414CB 11 00 E0 B7 0509*       ld de,filedata
0414CF CD 2B 14 04 0510*       call vdu_load_buffer
0414D3             0511*   
0414D3             0512*   ; read the next block
0414D3 C3 A9 14 04 0513*       jp @read_file
0414D7             0514*   
0414D7             0515*   ; close the file
0414D7             0516*   @close_file:
0414D7 3A E0 14 04 0517*       ld a,(@filehandle)
0414DB             0518*       MOSCALL mos_fclose
                       M1 Args: function=mos_fclose 
0414DB 3E 0B       0001*M1 			LD	A, function
0414DD 5B CF       0002*M1 			RST.LIL	08h
0414DF C9          0519*       ret ; vdu_load_buffer_from_file
0414E0             0520*   
0414E0 00          0521*   @filehandle: db 0 ; file handle
0414E1 00 00 00    0522*   @fil: dl 0 ; pointer to FIL struct
0414E4             0523*   
0414E4 00 00 00    0524*   @chunkpointer: dl 0 ; pointer to current chunk
0414E7             0525*   
0414E7             0526*   ; File information structure (FILINFO)
0414E7             0527*   @filinfo:
0414E7 00 00 00 00 0528*   @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
0414EB 00 00       0529*   @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
0414ED 00 00       0530*   @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
0414EF 00          0531*   @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
0414F0 00 00 00 00 0532*   @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
0414FD 00 00 00 00 0533*   @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415FD             0040        include "vdu_buffered_api.inc"
0415FD             0001*   ; https://agonconsole8.github.io/agon-docs/vdp/Buffered-Commands-API/
0415FD             0002*   
0415FD             0003*   ; Command 0: Write block to a buffer
0415FD             0004*   ; VDU 23, 0, &A0, bufferId; 0, length; <buffer-data>
0415FD             0005*   ; inputs: hl = bufferId, bc = length of data, de = pointer to data
0415FD             0006*   vdu_write_block_to_buffer:
0415FD             0007*   ; back up input parameters
0415FD D5          0008*       push de ; pointer to data
0415FE C5          0009*       push bc ; length of data
0415FF             0010*   ; set up the vdu command string
0415FF 22 1F 16 04 0011*       ld (@bufferId),hl
041603 ED 43 22 16 0012*       ld (@length),bc
       04          
041608 AF          0013*       xor a ; load buffer
041609 32 21 16 04 0014*       ld (@bufferId+2),a
04160D 21 1C 16 04 0015*       ld hl,@cmd0
041611 01 08 00 00 0016*       ld bc,@end0-@cmd0
041615 5B DF       0017*       rst.lil $18
041617             0018*   ; send the buffer data
041617 C1          0019*       pop bc ; length of data
041618 E1          0020*       pop hl ; pointer to data (was de)
041619 5B DF       0021*       rst.lil $18 ; send it
04161B C9          0022*       ret
04161C             0023*   ; command string data
04161C 17 00 A0    0024*   @cmd0:      db 23,0,0xA0
04161F 00 00       0025*   @bufferId:	dw 0x0000
041621 00          0026*               db 0 ; load buffer
041622 00 00       0027*   @length:	dw 0x0000
041624 00          0028*   @end0:      db 0x00 ; padding
041625             0029*   ; end vdu_write_block_to_buffer
041625             0030*   
041625             0031*   ; Command 1: Call a buffer
041625             0032*   ; VDU 23, 0, &A0, bufferId; 1
041625             0033*   ; inputs: hl = bufferId
041625             0034*   vdu_call_buffer:
041625 22 3D 16 04 0035*       ld (@bufferId),hl
041629 3E 01       0036*       ld a,1 ; call buffer
04162B 32 3F 16 04 0037*       ld (@bufferId+2),a
04162F 21 3A 16 04 0038*       ld hl,@cmd
041633 01 06 00 00 0039*       ld bc,@end-@cmd
041637 5B DF       0040*       rst.lil $18
041639 C9          0041*       ret
04163A 17 00 A0    0042*   @cmd:     db 23,0,0xA0
04163D 00 00       0043*   @bufferId: dw 0x0000
04163F 01          0044*              db 1 ; call buffer
041640             0045*   @end:
041640             0046*   ; end vdu_call_buffer
041640             0047*   
041640             0048*   ; Command 2: Clear a buffer
041640             0049*   ; VDU 23, 0 &A0, bufferId; 2
041640             0050*   ; inputs: hl = bufferId
041640             0051*   vdu_clear_buffer:
041640 22 58 16 04 0052*       ld (@bufferId),hl
041644 3E 02       0053*       ld a,2 ; clear buffer
041646 32 5A 16 04 0054*       ld (@bufferId+2),a
04164A 21 55 16 04 0055*       ld hl,@cmd
04164E 01 06 00 00 0056*       ld bc,@end-@cmd
041652 5B DF       0057*       rst.lil $18
041654 C9          0058*       ret
041655 17 00 A0    0059*   @cmd:     db 23,0,0xA0
041658 00 00       0060*   @bufferId: dw 0x0000
04165A 02          0061*              db 2 ; clear buffer
04165B             0062*   @end:
04165B             0063*   ; end vdu_clear_buffer
04165B             0064*   
04165B             0065*   ; Clear all buffers
04165B             0066*   ; inputs: none
04165B             0067*   vdu_clear_all_buffers:
04165B             0068*   ; clear all buffers
04165B 21 66 16 04 0069*       ld hl,@beg
04165F 01 06 00 00 0070*       ld bc,@end-@beg
041663 5B DF       0071*       rst.lil $18
041665 C9          0072*       ret
041666 17 00 A0    0073*   @beg: db 23,0,$A0
041669 FF FF       0074*         dw -1 ; bufferId -1 (65535) means clear all buffers
04166B 02          0075*         db 2  ; command 2: clear a buffer
04166C             0076*   @end:
04166C             0077*   ; end vdu_clear_all_buffers
04166C             0078*   
04166C             0079*   ; Command 3: Create a writeable buffer
04166C             0080*   ; VDU 23, 0 &A0, bufferId; 3, length;
04166C             0081*   ; inputs: hl = bufferId, bc = length
04166C             0082*   vdu_create_writeable_buffer:
04166C 22 89 16 04 0083*       ld (@bufferId),hl
041670 ED 43 8C 16 0084*       ld (@length),bc
       04          
041675 3E 03       0085*       ld a,3 ; create writeable buffer
041677 32 8B 16 04 0086*       ld (@bufferId+2),a
04167B 21 86 16 04 0087*       ld hl,@cmd
04167F 01 08 00 00 0088*       ld bc,@end-@cmd
041683 5B DF       0089*       rst.lil $18
041685 C9          0090*       ret
041686 17 00 A0    0091*   @cmd:     db 23,0,0xA0
041689 00 00       0092*   @bufferId: dw 0x0000
04168B 03          0093*              db 3 ; create writeable buffer
04168C 00 00       0094*   @length: dw 0x0000
04168E 00          0095*   @end:     db 0x00 ; padding
04168F             0096*   ; end vdu_create_writeable_buffer
04168F             0097*   
04168F             0098*   ; Command 4: Set output stream to a buffer
04168F             0099*   ; VDU 23, 0 &A0, bufferId; 4
04168F             0100*   ; inputs: hl = bufferId
04168F             0101*   vdu_set_output_stream_buffer:
04168F 22 A7 16 04 0102*       ld (@bufferId),hl
041693 3E 04       0103*       ld a,4 ; set output stream to buffer
041695 32 A9 16 04 0104*       ld (@bufferId+2),a
041699 21 A4 16 04 0105*       ld hl,@cmd
04169D 01 06 00 00 0106*       ld bc,@end-@cmd
0416A1 5B DF       0107*       rst.lil $18
0416A3 C9          0108*       ret
0416A4 17 00 A0    0109*   @cmd:     db 23,0,0xA0
0416A7 00 00       0110*   @bufferId: dw 0x0000
0416A9 04          0111*              db 4 ; set output stream to buffer
0416AA 00          0112*   @end:     db 0x00 ; padding
0416AB             0113*   ; end vdu_set_output_stream_buffer
0416AB             0114*   
0416AB             0115*   ; Command 5: Adjust buffer contents
0416AB             0116*   ; VDU 23, 0, &A0, bufferId; 5, operation, offset; [count;] <operand>, [arguments]
0416AB             0117*   vdu_adjust_buffer:
0416AB C9          0118*       ret ; TODO: implement
0416AC             0119*   ; end vdu_adjust_buffer
0416AC             0120*   
0416AC             0121*   ; Command 6: Conditionally call a buffer
0416AC             0122*   ; VDU 23, 0, &A0, bufferId; 6, operation, checkBufferId; checkOffset; [arguments]
0416AC             0123*   vdu_call_buffer_conditional:
0416AC C9          0124*       ret ; TODO: implement
0416AD             0125*   ; end vdu_call_buffer_conditional
0416AD             0126*   
0416AD             0127*   ; Command 7: Jump to a buffer
0416AD             0128*   ; VDU 23, 0, &A0, bufferId; 7
0416AD             0129*   ; inputs: hl = bufferId
0416AD             0130*   vdu_jump_to_buffer:
0416AD 22 C5 16 04 0131*       ld (@bufferId),hl
0416B1 3E 07       0132*       ld a,7 ; jump to buffer
0416B3 32 C7 16 04 0133*       ld (@bufferId+2),a
0416B7 21 C2 16 04 0134*       ld hl,@cmd
0416BB 01 06 00 00 0135*       ld bc,@end-@cmd
0416BF 5B DF       0136*       rst.lil $18
0416C1 C9          0137*       ret
0416C2 17 00 A0    0138*   @cmd:     db 23,0,0xA0
0416C5 00 00       0139*   @bufferId: dw 0x0000
0416C7 07          0140*              db 7 ; jump to buffer
0416C8 00          0141*   @end:     db 0x00 ; padding
0416C9             0142*   ; end vdu_jump_to_buffer
0416C9             0143*   
0416C9             0144*   ; Command 8: Conditional Jump to a buffer
0416C9             0145*   ; VDU 23, 0, &A0, bufferId; 8, operation, checkBufferId; checkOffset; [arguments]
0416C9             0146*   vdu_jump_to_buffer_conditional:
0416C9 C9          0147*       ret ; TODO: implement
0416CA             0148*   ; end vdu_jump_to_buffer_conditional
0416CA             0149*   
0416CA             0150*   ; Command 9: Jump to an offset in a buffer
0416CA             0151*   ; VDU 23, 0, &A0, bufferId; 9, offset; offsetHighByte, [blockNumber;]
0416CA             0152*   vdu_jump_to_buffer_offset:
0416CA C9          0153*       ret ; TODO: implement
0416CB             0154*   ; end vdu_jump_to_buffer_offset
0416CB             0155*   
0416CB             0156*   ; Command 10: Conditional jump to an offset in a buffer
0416CB             0157*   ; VDU 23, 0, &A0, bufferId; 10, offset; offsetHighByte, [blockNumber;] [arguments]
0416CB             0158*   vdu_jump_to_buffer_offset_conditional:
0416CB C9          0159*       ret ; TODO: implement
0416CC             0160*   ; end vdu_jump_to_buffer_offset_conditional
0416CC             0161*   
0416CC             0162*   ; Command 11: Call buffer with an offset
0416CC             0163*   ; VDU 23, 0, &A0, bufferId; 11, offset; offsetHighByte, [blockNumber;]
0416CC             0164*   vdu_call_buffer_offset:
0416CC C9          0165*       ret ; TODO: implement
0416CD             0166*   ; end vdu_call_buffer_offset
0416CD             0167*   
0416CD             0041        include "vdu_fonts.inc"
0416CD             0001*   ; select font
0416CD             0002*   ; inputs: hl = bufferId, a = font flags
0416CD             0003*   ; Flags:
0416CD             0004*   ; Bit	Description
0416CD             0005*   ; 0	Adjust cursor position to ensure text baseline is aligned
0416CD             0006*   ;   0: Do not adjust cursor position (best for changing font on a new line)
0416CD             0007*   ;   1: Adjust cursor position (best for changing font in the middle of a line)
0416CD             0008*   ; 1-7	Reserved for future use
0416CD             0009*   ; VDU 23, 0, &95, 0, bufferId; flags: Select font
0416CD             0010*   vdu_font_select:
0416CD 22 E4 16 04 0011*       ld (@bufferId),hl
0416D1 32 E6 16 04 0012*       ld (@flags),a
0416D5 21 E0 16 04 0013*       ld hl,@cmd
0416D9 01 07 00 00 0014*       ld bc,@end-@cmd
0416DD 5B DF       0015*       rst.lil $18
0416DF C9          0016*       ret
0416E0 17 00 95 00 0017*   @cmd: db 23, 0, 0x95, 0
0416E4 00 00       0018*   @bufferId: dw 0x0000
0416E6 00          0019*   @flags: db 0x00
0416E7             0020*   @end:
0416E7             0021*   
0416E7             0022*   ; create font from buffer
0416E7             0023*   ; inputs: hl = bufferId, e = width, d = height, d = ascent, a = flags
0416E7             0024*   ; VDU 23, 0, &95, 1, bufferId; width, height, ascent, flags: Create font from buffer
0416E7             0025*   vdu_font_create:
0416E7 22 0C 17 04 0026*       ld (@bufferId),hl
0416EB ED 53 0E 17 0027*       ld (@width),de ; also loads height
       04          
0416F0 32 11 17 04 0028*       ld (@flags),a
0416F4 7A          0029*       ld a,d ; height
0416F5 32 10 17 04 0030*       ld (@ascent),a ; ascent = height
0416F9             0031*   ; consolidate buffer
0416F9 CD 57 14 04 0032*       call vdu_consolidate_buffer
0416FD             0033*   ; create font
0416FD 21 08 17 04 0034*       ld hl,@cmd
041701 01 0A 00 00 0035*       ld bc,@end-@cmd
041705 5B DF       0036*       rst.lil $18
041707 C9          0037*       ret
041708 17 00 95 01 0038*   @cmd: db 23, 0, 0x95, 1
04170C 00 00       0039*   @bufferId: dw 0x0000
04170E 00          0040*   @width: db 0x00
04170F 00          0041*   @height: db 0x00
041710 00          0042*   @ascent: db 0x00
041711 00          0043*   @flags: db 0x00
041712             0044*   @end:
041712             0045*   
041712             0046*   ; set or adjust font property
041712             0047*   ; inputs: hl = bufferId, a = field, de = value
041712             0048*   ; VDU 23, 0, &95, 2, bufferId; field, value;: Set or adjust font property
041712             0049*   vdu_font_property:
041712 22 2E 17 04 0050*       ld (@bufferId),hl
041716 32 30 17 04 0051*       ld (@field),a
04171A ED 53 31 17 0052*       ld (@value),de
       04          
04171F 21 2A 17 04 0053*       ld hl,@cmd
041723 01 09 00 00 0054*       ld bc,@end-@cmd
041727 5B DF       0055*       rst.lil $18
041729 C9          0056*       ret
04172A 17 00 95 02 0057*   @cmd: db 23, 0, 0x95, 2
04172E 00 00       0058*   @bufferId: dw 0x0000
041730 00          0059*   @field: db 0x00
041731 00 00       0060*   @value: dw 0x0000
041733 00          0061*   @end: db 0x00 ; padding
041734             0062*   
041734             0063*   ; VDU 23, 0, &95, 3, bufferId; [<args>]: Reserved
041734             0064*   
041734             0065*   ; Clear/Delete font
041734             0066*   ; inputs: hl = bufferId
041734             0067*   ; VDU 23, 0, &95, 4, bufferId;: Clear/Delete font
041734             0068*   vdu_font_clear:
041734 22 47 17 04 0069*       ld (@bufferId),hl
041738 21 43 17 04 0070*       ld hl,@cmd
04173C 01 06 00 00 0071*       ld bc,@end-@cmd
041740 5B DF       0072*       rst.lil $18
041742 C9          0073*       ret
041743 17 00 95 04 0074*   @cmd: db 23, 0, 0x95, 4
041747 00 00       0075*   @bufferId: dw 0x0000
041749 00          0076*   @end: db 0x00 ; padding
04174A             0077*   
04174A             0078*   ; Copy system font to buffer
04174A             0079*   ; inputs: hl = bufferId
04174A             0080*   ; VDU 23, 0, &95, 5, bufferId;: Copy system font to buffer
04174A             0081*   vdu_font_copy_system:
04174A 22 5D 17 04 0082*       ld (@bufferId),hl
04174E 21 59 17 04 0083*       ld hl,@cmd
041752 01 06 00 00 0084*       ld bc,@end-@cmd
041756 5B DF       0085*       rst.lil $18
041758 C9          0086*       ret
041759 17 00 95 05 0087*   @cmd: db 23, 0, 0x95, 5
04175D 00 00       0088*   @bufferId: dw 0x0000
04175F 00          0089*   @end: db 0x00 ; padding
041760             0042        include "vdu_plot.inc"
041760             0001*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
041760             0002*   ; PLOT code 	(Decimal) 	Effect
041760             0003*   ; &00-&07 	0-7 	Solid line, includes both ends
041760             0004*   plot_sl_both: equ 0x00
041760             0005*   
041760             0006*   ; &08-&0F 	8-15 	Solid line, final point omitted
041760             0007*   plot_sl_first: equ 0x08
041760             0008*   
041760             0009*   ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
041760             0010*   ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
041760             0011*   
041760             0012*   ; &20-&27 	32-39 	Solid line, first point omitted
041760             0013*   plot_sl_last: equ 0x20
041760             0014*   
041760             0015*   ; &28-&2F 	40-47 	Solid line, both points omitted
041760             0016*   plot_sl_none: equ 0x28
041760             0017*   
041760             0018*   ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
041760             0019*   ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
041760             0020*   
041760             0021*   ; &40-&47 	64-71 	Point plot
041760             0022*   plot_pt: equ 0x40
041760             0023*   
041760             0024*   ; &48-&4F 	72-79 	Line fill left and right to non-background §§
041760             0025*   plot_lf_lr_non_bg: equ 0x48
041760             0026*   
041760             0027*   ; &50-&57 	80-87 	Triangle fill
041760             0028*   plot_tf: equ 0x50
041760             0029*   
041760             0030*   ; &58-&5F 	88-95 	Line fill right to background §§
041760             0031*   plot_lf_r_bg: equ 0x58
041760             0032*   
041760             0033*   ; &60-&67 	96-103 	Rectangle fill
041760             0034*   plot_rf: equ 0x60
041760             0035*   
041760             0036*   ; &68-&6F 	104-111 	Line fill left and right to foreground §§
041760             0037*   plot_lf_lr_fg: equ 0x60
041760             0038*   
041760             0039*   ; &70-&77 	112-119 	Parallelogram fill
041760             0040*   plot_pf: equ 0x70
041760             0041*   
041760             0042*   ; &78-&7F 	120-127 	Line fill right to non-foreground §§
041760             0043*   plot_lf_r_non_fg: equ 0x78
041760             0044*   
041760             0045*   ; &80-&87 	128-135 	Not supported (Flood until non-background)
041760             0046*   ; &88-&8F 	136-143 	Not supported (Flood until foreground)
041760             0047*   
041760             0048*   ; &90-&97 	144-151 	Circle outline
041760             0049*   plot_co: equ 0x90
041760             0050*   
041760             0051*   ; &98-&9F 	152-159 	Circle fill
041760             0052*   plot_cf: equ 0x98
041760             0053*   
041760             0054*   ; &A0-&A7 	160-167 	Not supported (Circular arc)
041760             0055*   ; &A8-&AF 	168-175 	Not supported (Circular segment)
041760             0056*   ; &B0-&B7 	176-183 	Not supported (Circular sector)
041760             0057*   
041760             0058*   ; &B8-&BF 	184-191 	Rectangle copy/move
041760             0059*   plot_rcm: equ 0xB8
041760             0060*   
041760             0061*   ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
041760             0062*   ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
041760             0063*   ; &D0-&D7 	208-215 	Not defined
041760             0064*   ; &D8-&DF 	216-223 	Not defined
041760             0065*   ; &E0-&E7 	224-231 	Not defined
041760             0066*   
041760             0067*   ; &E8-&EF 	232-239 	Bitmap plot §
041760             0068*   plot_bmp: equ 0xE8
041760             0069*   
041760             0070*   ; &F0-&F7 	240-247 	Not defined
041760             0071*   ; &F8-&FF 	248-255 	Not defined
041760             0072*   
041760             0073*   ; § Support added in Agon Console8 VDP 2.1.0 §§ Support added in
041760             0074*   ; Agon Console8 VDP 2.2.0
041760             0075*   
041760             0076*   ; Within each group of eight plot codes, the effects are as follows:
041760             0077*   ; Plot code 	Effect
041760             0078*   ; 0 	Move relative
041760             0079*   mv_rel: equ 0
041760             0080*   
041760             0081*   ; 1 	Plot relative in current foreground colour
041760             0082*   dr_rel_fg: equ 1
041760             0083*   
041760             0084*   ; 2 	Not supported (Plot relative in logical inverse colour)
041760             0085*   ; 3 	Plot relative in current background colour
041760             0086*   dr_rel_bg: equ 3
041760             0087*   
041760             0088*   ; 4 	Move absolute
041760             0089*   mv_abs: equ 4
041760             0090*   
041760             0091*   ; 5 	Plot absolute in current foreground colour
041760             0092*   dr_abs_fg: equ 5
041760             0093*   
041760             0094*   ; 6 	Not supported (Plot absolute in logical inverse colour)
041760             0095*   ; 7 	Plot absolute in current background colour
041760             0096*   dr_abs_bg: equ 7
041760             0097*   
041760             0098*   ; Codes 0-3 use the position data provided as part of the command
041760             0099*   ; as a relative position, adding the position given to the current
041760             0100*   ; graphical cursor position. Codes 4-7 use the position data provided
041760             0101*   ; as part of the command as an absolute position, setting the current
041760             0102*   ; graphical cursor position to the position given.
041760             0103*   
041760             0104*   ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
041760             0105*   ; current pixel colour. These operations cannot currently be supported
041760             0106*   ; by the graphics system the Agon VDP uses, so these codes are not
041760             0107*   ; supported. Support for these codes may be added in a future version
041760             0108*   ; of the VDP firmware.
041760             0109*   
041760             0110*   ; 16 colour palette constants
041760             0111*   c_black: equ 0
041760             0112*   c_red_dk: equ 1
041760             0113*   c_green_dk: equ 2
041760             0114*   c_yellow_dk: equ 3
041760             0115*   c_blue_dk: equ 4
041760             0116*   c_magenta_dk: equ 5
041760             0117*   c_cyan_dk: equ 6
041760             0118*   c_grey: equ 7
041760             0119*   c_grey_dk: equ 8
041760             0120*   c_red: equ 9
041760             0121*   c_green: equ 10
041760             0122*   c_yellow: equ 11
041760             0123*   c_blue: equ 12
041760             0124*   c_magenta: equ 13
041760             0125*   c_cyan: equ 14
041760             0126*   c_white: equ 15
041760             0127*   
041760             0128*   ; VDU 25, mode, x; y;: PLOT command
041760             0129*   ; inputs: a=mode, bc=x0, de=y0
041760             0130*   vdu_plot:
041760 32 7A 17 04 0131*       ld (@mode),a
041764 ED 43 7B 17 0132*       ld (@x0),bc
       04          
041769 ED 53 7D 17 0133*       ld (@y0),de
       04          
04176E 21 79 17 04 0134*   	ld hl,@cmd
041772 01 06 00 00 0135*   	ld bc,@end-@cmd
041776 5B DF       0136*   	rst.lil $18
041778 C9          0137*   	ret
041779 19          0138*   @cmd:   db 25
04177A 00          0139*   @mode:  db 0
04177B 00 00       0140*   @x0: 	dw 0
04177D 00 00       0141*   @y0: 	dw 0
04177F 00          0142*   @end:   db 0 ; extra byte to soak up deu
041780             0143*   
041780             0144*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
041780             0145*   ; &E8-&EF 	232-239 	Bitmap plot §
041780             0146*   ; VDU 25, mode, x; y;: PLOT command
041780             0147*   ; inputs: bc=x0, de=y0
041780             0148*   ; prerequisites: vdu_buff_select
041780             0149*   vdu_plot_bmp:
041780 ED 43 97 17 0150*       ld (@x0),bc
       04          
041785 ED 53 99 17 0151*       ld (@y0),de
       04          
04178A 21 95 17 04 0152*   	ld hl,@cmd
04178E 01 06 00 00 0153*   	ld bc,@end-@cmd
041792 5B DF       0154*   	rst.lil $18
041794 C9          0155*   	ret
041795 19          0156*   @cmd:   db 25
041796 ED          0157*   @mode:  db plot_bmp+dr_abs_fg ; 0xED
041797 00 00       0158*   @x0: 	dw 0x0000
041799 00 00       0159*   @y0: 	dw 0x0000
04179B 00          0160*   @end:   db 0x00 ; padding
04179C             0161*   
04179C             0162*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
04179C             0163*   ; &E8-&EF 	232-239 	Bitmap plot §
04179C             0164*   ; VDU 25, mode, x; y;: PLOT command
04179C             0165*   ; inputs: bc=x0, de=y0
04179C             0166*   ; USING 16.8 FIXED POINT COORDINATES
04179C             0167*   ; inputs: ub.c is x coordinate, ud.e is y coordinate
04179C             0168*   ;   the fractional portiion of the inputs are truncated
04179C             0169*   ;   leaving only the 16-bit integer portion
04179C             0170*   ; prerequisites: vdu_buff_select
04179C             0171*   vdu_plot_bmp168:
04179C             0172*   ; populate in the reverse of normal to keep the
04179C             0173*   ; inputs from stomping on each other
04179C ED 53 BA 17 0174*       ld (@y0-1),de
       04          
0417A1 ED 43 B8 17 0175*       ld (@x0-1),bc
       04          
0417A6 3E ED       0176*       ld a,plot_bmp+dr_abs_fg ; 0xED
0417A8 32 B8 17 04 0177*       ld (@mode),a ; restore the mode byte that got stomped on by bcu
0417AC 21 B7 17 04 0178*   	ld hl,@cmd
0417B0 01 06 00 00 0179*   	ld bc,@end-@cmd
0417B4 5B DF       0180*   	rst.lil $18
0417B6 C9          0181*   	ret
0417B7 19          0182*   @cmd:   db 25
0417B8 ED          0183*   @mode:  db plot_bmp+dr_abs_fg ; 0xED
0417B9 00 00       0184*   @x0: 	dw 0x0000
0417BB 00 00       0185*   @y0: 	dw 0x0000
0417BD             0186*   @end:  ; no padding required b/c we shifted de right
0417BD             0187*   
0417BD             0188*   ; draw a filled rectangle
0417BD             0189*   vdu_plot_rf:
0417BD ED 43 E4 17 0190*       ld (@x0),bc
       04          
0417C2 ED 53 E6 17 0191*       ld (@y0),de
       04          
0417C7 DD 22 EA 17 0192*       ld (@x1),ix
       04          
0417CC FD 22 EC 17 0193*       ld (@y1),iy
       04          
0417D1 3E 19       0194*       ld a,25 ; we have to reload the 2nd plot command
0417D3 32 E8 17 04 0195*       ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0417D7 21 E2 17 04 0196*   	ld hl,@cmd0
0417DB 01 0C 00 00 0197*   	ld bc,@end-@cmd0
0417DF 5B DF       0198*   	rst.lil $18
0417E1 C9          0199*       ret
0417E2 19          0200*   @cmd0:  db 25 ; plot
0417E3 04          0201*   @arg0:  db plot_sl_both+mv_abs
0417E4 00 00       0202*   @x0:    dw 0x0000
0417E6 00 00       0203*   @y0:    dw 0x0000
0417E8 19          0204*   @cmd1:  db 25 ; plot
0417E9 65          0205*   @arg1:  db plot_rf+dr_abs_fg
0417EA 00 00       0206*   @x1:    dw 0x0000
0417EC 00 00       0207*   @y1:    dw 0x0000
0417EE 00          0208*   @end:   db 0x00 ; padding
0417EF             0209*   
0417EF             0210*   ; draw a filled circle
0417EF             0211*   vdu_plot_cf:
0417EF ED 43 16 18 0212*       ld (@x0),bc
       04          
0417F4 ED 53 18 18 0213*       ld (@y0),de
       04          
0417F9 DD 22 1C 18 0214*       ld (@x1),ix
       04          
0417FE FD 22 1E 18 0215*       ld (@y1),iy
       04          
041803 3E 19       0216*       ld a,25 ; we have to reload the 2nd plot command
041805 32 1A 18 04 0217*       ld (@cmd1),a ; because the 24-bit y0 load stomped on it
041809 21 14 18 04 0218*   	ld hl,@cmd0
04180D 01 0C 00 00 0219*   	ld bc,@end-@cmd0
041811 5B DF       0220*   	rst.lil $18
041813 C9          0221*       ret
041814 19          0222*   @cmd0:  db 25 ; plot
041815 04          0223*   @arg0:  db plot_sl_both+mv_abs
041816 00 00       0224*   @x0:    dw 0x0000
041818 00 00       0225*   @y0:    dw 0x0000
04181A 19          0226*   @cmd1:  db 25 ; plot
04181B 9D          0227*   @arg1:  db plot_cf+dr_abs_fg
04181C 00 00       0228*   @x1:    dw 0x0000
04181E 00 00       0229*   @y1:    dw 0x0000
041820 00          0230*   @end:   db 0x00 ; padding
041821             0043        include "vdu_sound.inc"
041821             0001*   ; enable enough additional channels so that total enabled = max_channels
041821             0002*   ; inputs: max_channels set
041821             0003*   ; returns: nothing
041821             0004*   ; destroys: af, bc, hl
041821             0005*   vdu_enable_channels:
041821 3E 01       0006*       ld a,max_channels
041823 D6 03       0007*       sub 3 ; subtract number of default channels already enabled
041825 F2 2C 18 04 0008*       jp p,@loop
041829 C9          0009*       ret
04182A 3E 03       0010*       ld a,3 ; first non-default channel
04182C             0011*   @loop:
04182C 32 47 18 04 0012*       ld (@channel),a
041830 21 44 18 04 0013*       ld hl,@beg
041834 01 05 00 00 0014*       ld bc,@end-@beg
041838 F5          0015*       push af
041839 5B DF       0016*       rst.lil $18
04183B F1          0017*       pop af
04183C 3C          0018*       inc a
04183D FE 01       0019*       cp max_channels
04183F C2 2C 18 04 0020*       jp nz,@loop
041843 C9          0021*       ret
041844             0022*   @beg:
041844 17 00 85    0023*               db 23, 0, $85
041847 00          0024*   @channel:   db 0
041848 08          0025*               db 8 ; command 8: enable channel
041849             0026*   @end:
041849             0027*   
041849             0028*   ; disable all but the three default sound channels
041849             0029*   ; inputs: max_channels set
041849             0030*   ; outputs: none
041849             0031*   ; destroys: ah,hl,bc
041849             0032*   vdu_disable_channels:
041849 3E 01       0033*       ld a,max_channels
04184B D6 03       0034*       sub 3 ; subtract number of default channels already enabled
04184D F2 54 18 04 0035*       jp p,@loop
041851 C9          0036*       ret
041852 3E 03       0037*       ld a,3 ; first non-default channel
041854             0038*   @loop:
041854 32 6F 18 04 0039*       ld (@channel),a
041858 21 6C 18 04 0040*       ld hl,@beg
04185C 01 05 00 00 0041*       ld bc,@end-@beg
041860 F5          0042*       push af
041861 5B DF       0043*       rst.lil $18
041863 F1          0044*       pop af
041864 3C          0045*       inc a
041865 FE 01       0046*       cp max_channels
041867 C2 54 18 04 0047*       jp nz,@loop
04186B C9          0048*       ret
04186C             0049*   @beg:
04186C 17 00 85    0050*       db 23, 0, $85
04186F 00          0051*   @channel: db 0
041870 09          0052*       db 9 ; command 9: disable channel
041871             0053*   @end:
041871             0054*   
041871             0055*   
041871             0056*   ; ############################################################
041871             0057*   ; VDU SOUND API
041871             0058*   ; ############################################################
041871             0059*   ; Command 0: Play note
041871             0060*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
041871             0061*       MACRO PLAY_NOTE channel, volume, frequency, duration
041871             0062*       ld hl, @PLAY_NOTE_CMD        ; Start of command block
041871             0063*       ld bc, @PLAY_NOTE_END - @PLAY_NOTE_CMD  ; Command block size
041871             0064*       rst.lil $18
041871             0065*       jr @PLAY_NOTE_END
041871             0066*   @PLAY_NOTE_CMD:  db 23, 0, 0x85               ; Command header
041871             0067*                    db channel                  ; Channel, 0 (commented out)
041871             0068*                    db 0                        ; Play note command
041871             0069*                    db volume                   ; Volume
041871             0070*                    dw frequency                ; Frequency
041871             0071*                    dw duration                 ; Duration
041871             0072*   @PLAY_NOTE_END:
041871             0073*       ENDMACRO
041871             0074*   
041871             0075*       MACRO MUTE_CHANNEL channel
041871             0076*       ld hl, @MUTE_CHANNEL_CMD     ; Start of command block
041871             0077*       ld bc, @MUTE_CHANNEL_END - @MUTE_CHANNEL_CMD  ; Command block size
041871             0078*       rst.lil $18
041871             0079*       jr @MUTE_CHANNEL_END
041871             0080*   @MUTE_CHANNEL_CMD: db 23, 0, 0x85             ; Command header
041871             0081*                      db channel                ; Channel, 0 (commented out)
041871             0082*                      db 2                      ; Set volume command
041871             0083*                      db 0                      ; Volume (mute)
041871             0084*   @MUTE_CHANNEL_END:
041871             0085*       ENDMACRO
041871             0086*   
041871             0087*   ; inputs: c = channel, b = volume, hl = frequency; de = duration;
041871             0088*   vdu_play_note:
041871 79          0089*       ld a,c
041872 32 92 18 04 0090*       ld (@channel),a
041876 78          0091*       ld a,b
041877 32 94 18 04 0092*       ld (@volume),a
04187B 22 95 18 04 0093*       ld (@frequency),hl
04187F ED 53 97 18 0094*       ld (@duration),de
       04          
041884 21 8F 18 04 0095*       ld hl,@cmd
041888 01 0A 00 00 0096*       ld bc,@end-@cmd
04188C 5B DF       0097*       rst.lil $18
04188E C9          0098*       ret
04188F 17 00 85    0099*   @cmd:       db 23, 0, 0x85
041892 00          0100*   @channel:   db 0x00
041893 00          0101*               db 0x00 ; play note command
041894 00          0102*   @volume:    db 0x00
041895 00 00       0103*   @frequency: dw 0x0000
041897 00 00       0104*   @duration:  dw 0x0000
041899 00          0105*   @end:       db 0x00 ; padding
04189A             0106*   
04189A             0107*   ; Command 1: Status
04189A             0108*   ; VDU 23, 0, &85, channel, 1
04189A             0109*   ; inputs: a = channel
04189A             0110*   ; Returns a bit mask indicating the status of the specified channel, or 255 if the channel is not valid, or has been disabled. The bit mask is as follows:
04189A             0111*   ; Bit 	Name 	Meaning
04189A             0112*   ; 0 	Active 	When set this indicates the channel is in use (has an active waveform)
04189A             0113*   ; 1 	Playing 	Indicates the channel is actively playing a note, and thus will reject calls to play a new note
04189A             0114*   ; 2 	Indefinite 	Set if the channel is playing an indefinite duration note
04189A             0115*   ; 3 	Has Volume Envelope 	Set if the channel has a volume envelope
04189A             0116*   ; 4 	Has Frequency Envelope 	Set if the channel has a frequency envelope
04189A             0117*   
04189A             0118*   ; Bits 5-7 are reserved for future use and, for enabled channels, will currently always be zero.
04189A             0119*   vdu_channel_status:
04189A 32 AC 18 04 0120*       ld (@channel),a
04189E 21 A9 18 04 0121*       ld hl,@cmd
0418A2 01 05 00 00 0122*       ld bc,@end-@cmd
0418A6 5B DF       0123*       rst.lil $18
0418A8 C9          0124*       ret
0418A9 17 00 85    0125*   @cmd:       db 23, 0, 0x85
0418AC 00          0126*   @channel:   db 0x00
0418AD 01          0127*               db 0x01 ; get channel status command
0418AE             0128*   @end:
0418AE             0129*   
0418AE             0130*   ; VDU 23, 0, &85, channel, 2, volume
0418AE             0131*   ; inputs: c = channel, b = volume
0418AE             0132*   ; Sets the volume of the specified channel. The volume is a value from 0 to 127, where 0 is silent and 127 is full volume. Values over 127 will be treated as 127 (with one exception described later).
0418AE             0133*   
0418AE             0134*   ; Specifying a channel of -1 (or 255) will set the global sound system volume level. (Requires Console8 VDP 2.5.0 or later.)
0418AE             0135*   
0418AE             0136*   ; Using this command provides more direct control over a channel than the play note command. It can be used to adjust the volume of a channel that is already playing a note.
0418AE             0137*   vdu_channel_volume:
0418AE 79          0138*       ld a,c
0418AF 32 C6 18 04 0139*       ld (@channel),a
0418B3 78          0140*       ld a,b
0418B4 32 C8 18 04 0141*       ld (@volume),a
0418B8 21 C3 18 04 0142*       ld hl,@cmd
0418BC 01 06 00 00 0143*       ld bc,@end-@cmd
0418C0 5B DF       0144*       rst.lil $18
0418C2 C9          0145*       ret
0418C3 17 00 85    0146*   @cmd:       db 23, 0, 0x85
0418C6 00          0147*   @channel:   db 0x00
0418C7 02          0148*               db 0x02 ; set volume command
0418C8 00          0149*   @volume:    db 0x00
0418C9             0150*   @end:
0418C9             0151*   
0418C9             0152*   ; VDU 23, 0, &85, channel, 3, frequency;
0418C9             0153*   
0418C9             0154*   ; Sets the frequency of the specified channel. The frequency is a 16-bit value specifying in Hz the frequency of the note to be played.
0418C9             0155*   
0418C9             0156*   ; Using this command provides more direct control over a channel than the play note command. It can be used to adjust the frequency of a channel that is already playing a note.
0418C9             0157*   
0418C9             0158*   ; Returns 1 on success, 0 for failure.
0418C9             0159*   vdu_channel_frequency:
0418C9 79          0160*       ld a,c
0418CA 32 E1 18 04 0161*       ld (@channel),a
0418CE ED 53 E3 18 0162*       ld (@frequency),de
       04          
0418D3 21 DE 18 04 0163*       ld hl,@cmd
0418D7 01 07 00 00 0164*       ld bc,@end-@cmd
0418DB 5B DF       0165*       rst.lil $18
0418DD C9          0166*       ret
0418DE 17 00 85    0167*   @cmd:       db 23, 0, 0x85
0418E1 00          0168*   @channel:   db 0x00
0418E2 03          0169*               db 0x03 ; set frequency command
0418E3 00 00       0170*   @frequency: dw 0x0000
0418E5 00          0171*   @end:       db 0x00 ; padding
0418E6             0172*   
0418E6             0173*   
0418E6             0174*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
0418E6             0175*   ; inputs: c = channel, b = waveformOrSample, [hl = bufferId]
0418E6             0176*   ; Sets the waveform type for a channel to use. The waveformOrSample value is a single byte treated as a signed value.
0418E6             0177*   
0418E6             0178*   ; Using a negative value for the waveform indicates that a sample should be used instead. For more information see the documentation for the sample command.
0418E6             0179*   
0418E6             0180*   ; By default a channel is set to use waveform 0 (square wave).
0418E6             0181*   
0418E6             0182*   ; Valid waveform values are as follows:
0418E6             0183*   ; Value 	Waveform
0418E6             0184*   ; 0 	Square wave
0418E6             0185*   ; 1 	Triangle wave
0418E6             0186*   ; 2 	Sawtooth wave
0418E6             0187*   ; 3 	Sine wave
0418E6             0188*   ; 4 	Noise (simple white noise with no frequency support)
0418E6             0189*   ; 5 	VIC Noise (emulates a VIC6561; supports frequency)
0418E6             0190*   ; 8 	Sample (specifying a 16-bit buffer ID for sample data)
0418E6             0191*   
0418E6             0192*   vdu_channel_waveform:
0418E6 79          0193*       ld a,c
0418E7 32 0C 19 04 0194*       ld (@channel),a
0418EB 78          0195*       ld a,b
0418EC 32 0E 19 04 0196*       ld (@waveform),a
0418F0 FE 08       0197*       cp 8 ; check if the waveform is a sample
0418F2 28 06       0198*       jr z, @sample
0418F4 01 06 00 00 0199*       ld bc,@bufferId-@cmd
0418F8 18 08       0200*       jr @sendToVdu
0418FA             0201*   @sample:
0418FA 22 0F 19 04 0202*       ld (@bufferId),hl
0418FE 01 08 00 00 0203*       ld bc,@end-@cmd
041902             0204*   @sendToVdu:
041902 21 09 19 04 0205*       ld hl,@cmd
041906 5B DF       0206*       rst.lil $18
041908 C9          0207*       ret
041909 17 00 85    0208*   @cmd:       db 23, 0, 0x85
04190C 00          0209*   @channel:   db 0x00
04190D 04          0210*               db 0x04 ; set waveform command
04190E 00          0211*   @waveform:  db 0x00
04190F 00 00       0212*   @bufferId:  dw 0x0000
041911 00          0213*   @end:       db 0x00 ; padding
041912             0214*   
041912             0215*   ; VDU 23, 0, &85, channel (ignored), 5, 2, bufferId; format, [sampleRate;]
041912             0216*   ; inputs: hl = bufferId; a = format, de = sample rate in Hz
041912             0217*   ; The format is a single byte giving the format of the sample data. The following formats are supported:
041912             0218*   ; Value	Description
041912             0219*   ; 0	8-bit signed
041912             0220*   ; 1	8-bit unsigned
041912             0221*   ; The format value can also have modifier bits set to modify the behaviour of the sample. The following modifier bits are supported:
041912             0222*   ; Value	Description
041912             0223*   ; 8	sample rate is sent in the next 16-bits
041912             0224*   ; 16	sample is tuneable
041912             0225*   ; The default sample rate for samples on the VDP is 16kHz (actually 16.384kHz to be precise).
041912             0226*   vdu_buffer_to_sound:
041912 22 32 19 04 0227*       ld (@bufferId),hl
041916 C6 08       0228*       add a,8 ; modify format byte to indicate sample rate argument is given
041918 32 34 19 04 0229*       ld (@format),a
04191C ED 53 35 19 0230*       ld (@sampleRate),de
       04          
041921 21 2C 19 04 0231*       ld hl,@cmd
041925 01 0B 00 00 0232*       ld bc,@end-@cmd
041929 5B DF       0233*       rst.lil $18
04192B C9          0234*       ret
04192C 17 00 85    0235*   @cmd:       db 23, 0, 0x85
04192F 00          0236*   @channel:   db 0x00 ; ignored
041930 05          0237*               db 0x05 ; buffer to sound command
041931 02          0238*               db 0x02 ; command 2 create sample
041932 00 00       0239*   @bufferId:  dw 0x0000
041934 00          0240*   @format:    db 0x00
041935 00 00       0241*   @sampleRate: dw 0x0000
041937 00          0242*   @end:       db 0x00 ; padding
041938             0243*   
041938             0244*   ; Command 13: Set sample rate
041938             0245*   ; VDU 23, 0, &85, channel, 13, sampleRate;
041938             0246*   ; inputs: c = channel, hl = sampleRate (Hz)
041938             0247*   vdu_set_sample_rate:
041938 79          0248*       ld a,c
041939 32 4F 19 04 0249*       ld (@channel),a
04193D 22 51 19 04 0250*       ld (@sampleRate),hl
041941 21 4C 19 04 0251*       ld hl,@cmd
041945 01 07 00 00 0252*       ld bc,@end-@cmd
041949 5B DF       0253*       rst.lil $18
04194B C9          0254*       ret
04194C 17 00 85    0255*   @cmd:       db 23, 0, 0x85
04194F 00          0256*   @channel:   db 0x00
041950 0D          0257*               db 13 ; set sample rate command
041951 00 00       0258*   @sampleRate: dw 0x0000
041953 00          0259*   @end:       db 0x00 ; padding
041954             0260*   
041954             0261*   ; load a sound file to a buffer
041954             0262*   ; inputs: hl = bufferId ; de = sampleRate in Hz ; iy = pointer to filename
041954             0263*   vdu_load_sfx:
041954             0264*   ; back up input parameters
041954 E5          0265*       push hl ; bufferId
041955 D5          0266*       push de ; sample rate
041956             0267*   ; load the sound
041956 CD 94 14 04 0268*       call vdu_load_buffer_from_file
04195A             0269*   ; now make the buffer a sound sample
04195A D1          0270*       pop de ; sample rate
04195B E1          0271*       pop hl ; bufferId
04195C AF          0272*       xor a ; zero is the magic number for mono 8-bit signed PCM
04195D CD 12 19 04 0273*       call vdu_buffer_to_sound
041961 C9          0274*       ret
041962             0275*   
041962             0276*   
041962 00          0277*   last_channel: db 0
041963             0278*   max_channels: equ 1
041963             0279*   
041963             0280*   ; play a sound effect from an already loaded buffer
041963             0281*   ; inputs: hl = bufferId ; bc = duration in milliseconds
041963             0282*   vdu_play_sfx:
041963 22 9B 19 04 0283*       ld (@bufferId),hl
041967 ED 43 A5 19 0284*       ld (@duration),bc
       04          
04196C 3E 17       0285*       ld a,23
04196E 32 9D 19 04 0286*       ld (@bufferId+2),a
041972 3A 62 19 04 0287*       ld a,(last_channel)
041976 3C          0288*       inc a
041977             0289*       ; and 31 ; modulo 32
041977 FE 01       0290*       cp max_channels
041979 C2 7E 19 04 0291*       jp nz,@load_channel
04197D AF          0292*       xor a
04197E             0293*   @load_channel:
04197E 32 62 19 04 0294*       ld (last_channel),a
041982 32 98 19 04 0295*       ld (@channel0),a
041986 32 A0 19 04 0296*       ld (@channel1),a
04198A 21 95 19 04 0297*       ld hl, @sample
04198E 01 12 00 00 0298*       ld bc, @sample_end - @sample
041992 5B DF       0299*       rst.lil $18
041994 C9          0300*       ret
041995             0301*   @sample:
041995             0302*   ; Command 4: Set waveform
041995             0303*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
041995 17 00 85    0304*       .db 23,0,$85                        ; do sound
041998             0305*   @channel0:
041998 00 04 08    0306*       .db 0,4,8 ; channel, command, waveform
04199B             0307*   @bufferId:
04199B 00 00       0308*       .dw 0x0000
04199D             0309*   ; Command 0: Play note
04199D             0310*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
04199D 17 00 85    0311*       .db 23,0,$85                        ; do sound
0419A0             0312*   @channel1:
0419A0 00 00 7F    0313*       .db 0,0,127                ; channel, volume
0419A3 00 00       0314*       .dw 0
0419A5             0315*   @duration:                              ; freq (tuneable samples only)
0419A5 00 00       0316*       .dw 0x0000                        ; duration
0419A7             0317*   @sample_end:
0419A7 00          0318*       .db 0x00 ; padding
0419A8             0319*   
0419A8             0320*   ; inputs: c = channel, b = volume, de = sample rate; hl = bufferId;
0419A8             0321*   vdu_play_sample:
0419A8             0322*       ; populate input parameters
0419A8 79          0323*       ld a,c
0419A9 32 DB 19 04 0324*       ld (@channel0),a
0419AD 32 E3 19 04 0325*       ld (@channel1),a
0419B1 32 EA 19 04 0326*       ld (@channel2),a
0419B5 78          0327*       ld a,b
0419B6 32 EC 19 04 0328*       ld (@volume),a
0419BA ED 53 E5 19 0329*       ld (@sampleRate),de
       04          
0419BF 22 DE 19 04 0330*       ld (@bufferId),hl
0419C3 3E 17       0331*       ld a,23
0419C5 32 E0 19 04 0332*       ld (@cmd1),a
0419C9 32 E7 19 04 0333*       ld (@cmd2),a
0419CD             0334*       ; prep the vdu command string
0419CD 21 D8 19 04 0335*       ld hl, @cmd0
0419D1 01 19 00 00 0336*       ld bc, @end - @cmd0
0419D5 5B DF       0337*       rst.lil $18
0419D7 C9          0338*       ret
0419D8             0339*   ; set waveform command
0419D8 17 00 85    0340*   @cmd0:       db 23, 0, 0x85
0419DB 00          0341*   @channel0:   db 0x00
0419DC 04          0342*                db 0x04 ; set waveform command
0419DD 08          0343*   @waveform:   db 0x08 ; sample
0419DE 00 00       0344*   @bufferId:   dw 0x0000
0419E0             0345*   ; set sample rate command
0419E0 17 00 85    0346*   @cmd1:       db 23, 0, 0x85
0419E3 00          0347*   @channel1:   db 0x00
0419E4 0D          0348*               db 13 ; set sample rate command
0419E5 00 00       0349*   @sampleRate: dw 0x0000
0419E7             0350*   ; play note command
0419E7 17 00 85    0351*   @cmd2:       db 23, 0, 0x85
0419EA 00          0352*   @channel2:   db 0x00
0419EB 00          0353*                db 0x00 ; play note command
0419EC 00          0354*   @volume:     db 0x00
0419ED 00 00       0355*   @frequency:  dw 0x00 ; no effect unless buffer has been set to tuneable sample
0419EF 00 00       0356*   @duration:   dw 0x0000 ; milliseconds: set to -1 to loop indefinitely, 0 to play full duration once
0419F1 00          0357*   @end:        db 0x00 ; padding
0419F2             0044    
0419F2             0045    ; APPLICATION INCLUDES
0419F2             0046        include "layout.inc"
0419F2             0001*   text_right: equ 63       ; 64 columns, zero-based
0419F2             0002*   text_bottom: equ 47      ; 48 rows, zero-based
0419F2             0003*   
0419F2             0004*   ; set text viewport for current playing song
0419F2             0005*   vp_now_playing_left: equ 0
0419F2             0006*   vp_now_playing_top: equ 0
0419F2             0007*   vp_now_playing_right: equ text_right
0419F2             0008*   vp_now_playing_bottom: equ vp_now_playing_top+1
0419F2             0009*   
0419F2             0010*   vp_now_playing:
0419F2 0E 00       0011*       ld c, vp_now_playing_left
0419F4 16 00       0012*       ld d, vp_now_playing_top
0419F6 1E 3F       0013*       ld e, vp_now_playing_right
0419F8 06 01       0014*       ld b, vp_now_playing_bottom
0419FA CD DF 12 04 0015*       call vdu_set_txt_viewport
0419FE C9          0016*       ret
0419FF             0017*   ; end vp_now_playing
0419FF             0018*   
0419FF             0019*   ; set text viewport for playing breadcrumbs
0419FF             0020*   vp_breadcrumbs_left: equ 0
0419FF             0021*   vp_breadcrumbs_top: equ 1
0419FF             0022*   vp_breadcrumbs_right: equ text_right
0419FF             0023*   vp_breadcrumbs_bottom: equ vp_breadcrumbs_top
0419FF             0024*   
0419FF             0025*   vp_breadcrumbs:
0419FF 0E 00       0026*       ld c, vp_breadcrumbs_left
041A01 16 01       0027*       ld d, vp_breadcrumbs_top
041A03 1E 3F       0028*       ld e, vp_breadcrumbs_right
041A05 06 01       0029*       ld b, vp_breadcrumbs_bottom
041A07 CD DF 12 04 0030*       call vdu_set_txt_viewport
041A0B C9          0031*       ret
041A0C             0032*   ; end vp_breadcrumbs
041A0C             0033*   
041A0C             0034*   ; set text viewport for directory listing
041A0C             0035*   vp_dir_left: equ 0
041A0C             0036*   vp_dir_top: equ 30
041A0C             0037*   vp_dir_right: equ text_right
041A0C             0038*   vp_dir_bottom: equ vp_dir_top+10
041A0C             0039*   vp_dir:
041A0C 0E 00       0040*       ld c,vp_dir_left
041A0E 16 1E       0041*       ld d,vp_dir_top
041A10 1E 3F       0042*       ld e,vp_dir_right
041A12 06 28       0043*       ld b,vp_dir_bottom
041A14 CD DF 12 04 0044*       call vdu_set_txt_viewport
041A18 C9          0045*       ret
041A19             0046*   
041A19             0047*   ; print bottom border of directory listing
041A19             0048*   print_dir_border_bottom:
041A19 0E 00       0049*       ld c,vp_dir_left
041A1B 16 28       0050*       ld d,vp_dir_bottom
041A1D 1E 3F       0051*       ld e,text_right
041A1F 06 28       0052*       ld b,vp_dir_bottom
041A21 CD DF 12 04 0053*       call vdu_set_txt_viewport
041A25 21 3A 2A 04 0054*       ld hl,str_thick_dashes
041A29 CD 67 00 04 0055*       call printString
041A2D C9          0056*       ret
041A2E             0057*   ; end vp_dir_border
041A2E             0058*   
041A2E             0059*   vp_prt_reload_left: equ 0
041A2E             0060*   vp_prt_reload_top: equ vp_dir_bottom+1
041A2E             0061*   vp_prt_reload_right: equ text_right
041A2E             0062*   vp_prt_reload_bottom: equ vp_prt_reload_top
041A2E             0063*   vp_prt_reload:
041A2E 0E 00       0064*       ld c,vp_prt_reload_left
041A30 16 29       0065*       ld d,vp_prt_reload_top
041A32 1E 3F       0066*       ld e,vp_prt_reload_right
041A34 06 29       0067*       ld b,vp_prt_reload_bottom
041A36 CD DF 12 04 0068*       call vdu_set_txt_viewport
041A3A CD 86 12 04 0069*       call vdu_cls
041A3E CD 60 00 04 0070*       call printInline
041A42 50 52 54 20 0071*       asciz "PRT reload: "
       72 65 6C 6F 
       61 64 3A 20 
       00          
041A4F 2A 9A 25 04 0072*       ld hl,(ps_prt_reload)
041A53 CD CC 00 04 0073*       call printDec
041A57 C9          0074*       ret
041A58             0047        include "ascii.inc"
041A58             0001*   agon_jukebox_ascii:
041A58 20 20 20 5F 0002*       db 32,32,32,95,95,95,95,95,32,32,32,32,95,95,95,95,95,95,95,95,32,95,95,95,95,95,95,95,95,32,32,32,32,95,95,95,95,95,95,95,13,10
       5F 5F 5F 5F 
       20 20 20 20 
       5F 5F 5F 5F 
       5F 5F 5F 5F 
       20 5F 5F 5F 
       5F 5F 5F 5F 
       5F 20 20 20 
       20 5F 5F 5F 
       5F 5F 5F 5F 
       0D 0A       
041A82 20 20 2F 20 0003*       db 32,32,47,32,32,95,32,32,92,32,32,47,32,32,95,95,95,95,95,47,32,92,95,95,95,95,95,32,32,92,32,32,32,92,32,32,32,32,32,32,92,13,10
       20 5F 20 20 
       5C 20 20 2F 
       20 20 5F 5F 
       5F 5F 5F 2F 
       20 5C 5F 5F 
       5F 5F 5F 20 
       20 5C 20 20 
       20 5C 20 20 
       20 20 20 20 
       5C 0D 0A    
041AAD 20 2F 20 20 0004*       db 32,47,32,32,47,95,92,32,32,92,47,32,32,32,92,32,32,95,95,95,32,32,47,32,32,32,124,32,32,32,92,32,32,47,32,32,32,124,32,32,32,92,13,10
       2F 5F 5C 20 
       20 5C 2F 20 
       20 20 5C 20 
       20 5F 5F 5F 
       20 20 2F 20 
       20 20 7C 20 
       20 20 5C 20 
       20 2F 20 20 
       20 7C 20 20 
       20 5C 0D 0A 
041AD9 2F 20 20 20 0005*       db 47,32,32,32,32,124,32,32,32,32,92,32,32,32,32,92,95,92,32,32,92,47,32,32,32,32,124,32,32,32,32,92,47,32,32,32,32,124,32,32,32,32,92,13,10
       20 7C 20 20 
       20 20 5C 20 
       20 20 20 5C 
       5F 5C 20 20 
       5C 2F 20 20 
       20 20 7C 20 
       20 20 20 5C 
       2F 20 20 20 
       20 7C 20 20 
       20 20 5C 0D 
       0A          
041B06 5C 5F 5F 5F 0006*       db 92,95,95,95,95,124,95,95,32,32,47,92,95,95,95,95,95,95,32,32,47,92,95,95,95,95,95,95,95,32,32,47,92,95,95,95,95,124,95,95,32,32,47,13,10
       5F 7C 5F 5F 
       20 20 2F 5C 
       5F 5F 5F 5F 
       5F 5F 20 20 
       2F 5C 5F 5F 
       5F 5F 5F 5F 
       5F 20 20 2F 
       5C 5F 5F 5F 
       5F 7C 5F 5F 
       20 20 2F 0D 
       0A          
041B33 20 20 20 20 0007*       db 32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,32,92,47,13,10
       20 20 20 20 
       5C 2F 20 20 
       20 20 20 20 
       20 20 5C 2F 
       20 20 20 20 
       20 20 20 20 
       20 5C 2F 20 
       20 20 20 20 
       20 20 20 20 
       5C 2F 0D 0A 
041B5F 20 20 20 20 0008*       db 32,32,32,32,32,95,95,95,95,32,95,95,95,95,32,95,95,95,32,95,95,95,95,32,32,95,95,32,95,95,95,95,95,95,95,95,95,95,95,13,10
       20 5F 5F 5F 
       5F 20 5F 5F 
       5F 5F 20 5F 
       5F 5F 20 5F 
       5F 5F 5F 20 
       20 5F 5F 20 
       5F 5F 5F 5F 
       5F 5F 5F 5F 
       5F 5F 5F 0D 
       0A          
041B88 20 20 20 20 0009*       db 32,32,32,32,124,32,32,32,32,124,32,32,32,32,124,32,32,32,92,32,32,32,32,124,47,32,95,124,92,95,32,32,32,95,95,95,95,95,47,13,10
       7C 20 20 20 
       20 7C 20 20 
       20 20 7C 20 
       20 20 5C 20 
       20 20 20 7C 
       2F 20 5F 7C 
       5C 5F 20 20 
       20 5F 5F 5F 
       5F 5F 2F 0D 
       0A          
041BB1 20 20 20 20 0010*       db 32,32,32,32,124,32,32,32,32,124,32,32,32,32,124,32,32,32,47,32,32,32,32,32,32,60,32,32,32,124,32,32,32,32,95,95,41,95,13,10
       7C 20 20 20 
       20 7C 20 20 
       20 20 7C 20 
       20 20 2F 20 
       20 20 20 20 
       20 3C 20 20 
       20 7C 20 20 
       20 20 5F 5F 
       29 5F 0D 0A 
041BD9 2F 5C 5F 5F 0011*       db 47,92,95,95,124,32,32,32,32,124,32,32,32,32,124,32,32,47,124,32,32,32,32,124,32,32,92,32,32,124,32,32,32,32,32,32,32,32,92,13,10
       7C 20 20 20 
       20 7C 20 20 
       20 20 7C 20 
       20 2F 7C 20 
       20 20 20 7C 
       20 20 5C 20 
       20 7C 20 20 
       20 20 20 20 
       20 20 5C 0D 
       0A          
041C02 5C 5F 5F 5F 0012*       db 92,95,95,95,95,95,95,95,95,124,95,95,95,95,95,95,47,32,124,95,95,95,95,124,95,95,32,92,47,95,95,95,95,95,95,95,32,32,47,13,10
       5F 5F 5F 5F 
       5F 7C 5F 5F 
       5F 5F 5F 5F 
       2F 20 7C 5F 
       5F 5F 5F 7C 
       5F 5F 20 5C 
       2F 5F 5F 5F 
       5F 5F 5F 5F 
       20 20 2F 0D 
       0A          
041C2B 20 20 20 20 0013*       db 32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,92,47,13,10
       20 20 20 20 
       20 20 20 20 
       20 20 20 20 
       20 20 20 20 
       20 20 20 20 
       20 20 5C 2F 
       20 20 20 20 
       20 20 20 20 
       5C 2F 0D 0A 
041C53 20 20 20 20 0014*       db 32,32,32,32,95,95,95,95,95,95,95,95,95,95,32,95,95,95,95,95,95,95,95,32,32,95,95,95,95,32,32,95,95,95,13,10
       5F 5F 5F 5F 
       5F 5F 5F 5F 
       5F 5F 20 5F 
       5F 5F 5F 5F 
       5F 5F 5F 20 
       20 5F 5F 5F 
       5F 20 20 5F 
       5F 5F 0D 0A 
041C77 20 20 20 20 0015*       db 32,32,32,32,92,95,95,95,95,95,95,32,32,32,92,92,95,95,95,95,95,32,32,92,32,92,32,32,32,92,47,32,32,47,13,10
       5C 5F 5F 5F 
       5F 5F 5F 20 
       20 20 5C 5C 
       5F 5F 5F 5F 
       5F 20 20 5C 
       20 5C 20 20 
       20 5C 2F 20 
       20 2F 0D 0A 
041C9B 20 20 20 20 0016*       db 32,32,32,32,32,124,32,32,32,32,124,32,32,95,47,32,47,32,32,32,124,32,32,32,92,32,92,32,32,32,32,32,47,13,10
       20 7C 20 20 
       20 20 7C 20 
       20 5F 2F 20 
       2F 20 20 20 
       7C 20 20 20 
       5C 20 5C 20 
       20 20 20 20 
       2F 0D 0A    
041CBE 20 20 20 20 0017*       db 32,32,32,32,32,124,32,32,32,32,124,32,32,32,92,47,32,32,32,32,124,32,32,32,32,92,47,32,32,32,32,32,92,13,10
       20 7C 20 20 
       20 20 7C 20 
       20 20 5C 2F 
       20 20 20 20 
       7C 20 20 20 
       20 5C 2F 20 
       20 20 20 20 
       5C 0D 0A    
041CE1 20 20 20 20 0018*       db 32,32,32,32,32,124,95,95,95,95,95,95,32,32,47,92,95,95,95,95,95,95,95,32,32,47,95,95,95,47,92,32,32,92,13,10
       20 7C 5F 5F 
       5F 5F 5F 5F 
       20 20 2F 5C 
       5F 5F 5F 5F 
       5F 5F 5F 20 
       20 2F 5F 5F 
       5F 2F 5C 20 
       20 5C 0D 0A 
041D05 20 20 20 20 0019*       db 32,32,32,32,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,92,95,47,13,10
       20 20 20 20 
       20 20 20 20 
       5C 2F 20 20 
       20 20 20 20 
       20 20 20 5C 
       2F 20 20 20 
       20 20 20 5C 
       5F 2F 0D 0A 
041D29 00          0020*       db 0 ; list terminator
041D2A             0048        include "input.inc"
041D2A             0001*   get_input:
041D2A             0002*   @loop:
041D2A             0003*   ; wait for the user to push a button
041D2A             0004*       MOSCALL mos_getkey ; a = ascii code of key pressed
                       M1 Args: function=mos_getkey 
041D2A 3E 00       0001*M1 			LD	A, function
041D2C 5B CF       0002*M1 			RST.LIL	08h
041D2E F3          0005*       di ; disable interrupts
041D2F             0006*       ; rst.lil 10h ; print the key pressed
041D2F             0007*   ; app control commands
041D2F FE 1B       0008*       cp '\e' ; escape
041D31 C8          0009*       ret z ; returns to main, which re-enables interrupts and exits app
041D32             0010*   ; prt time tweaking
041D32 FE 5B       0011*       cp '[' ; decrease PRT timer reload value
041D34 C2 56 1D 04 0012*       jp nz,@F
041D38 2A 9A 25 04 0013*       ld hl,(ps_prt_reload)
041D3C 11 B8 FF FF 0014*       ld de,-72 ; 1 ms
041D40 19          0015*       add hl,de
041D41 22 9A 25 04 0016*       ld (ps_prt_reload),hl
041D45 CD 2E 1A 04 0017*       call vp_prt_reload
041D49 CD FF 19 04 0018*       call vp_breadcrumbs
041D4D CD 9D 25 04 0019*       call ps_prt_start
041D51 FB          0020*       ei
041D52 C3 2A 1D 04 0021*       jp @loop
041D56             0022*   @@:
041D56 FE 5D       0023*       cp ']' ; increase PRT timer reload value
041D58 C2 7A 1D 04 0024*       jp nz,@F
041D5C 2A 9A 25 04 0025*       ld hl,(ps_prt_reload)
041D60 11 48 00 00 0026*       ld de,72 ; 1 ms
041D64 19          0027*       add hl,de
041D65 22 9A 25 04 0028*       ld (ps_prt_reload),hl
041D69 CD 2E 1A 04 0029*       call vp_prt_reload
041D6D CD FF 19 04 0030*       call vp_breadcrumbs
041D71 CD 9D 25 04 0031*       call ps_prt_start
041D75 FB          0032*       ei
041D76 C3 2A 1D 04 0033*       jp @loop
041D7A             0034*   ; DIRECTORY PAGING
041D7A             0035*   @@:
041D7A FE 15       0036*       cp 0x15 ; right arrow
041D7C CA 54 24 04 0037*       jp z,ps_dir_next_page
041D80 FE 08       0038*       cp 0x08 ; left arrow
041D82 CA 77 24 04 0039*       jp z,ps_dir_prev_page
041D86             0040*   ; SONG PLAYING COMMANDS
041D86             0041*   ; toggle pause playback
041D86 FE 70       0042*       cp 'p'
041D88 C2 CE 1D 04 0043*       jp nz,@F
041D8C 3E 01       0044*       ld a,ps_mode_playing
041D8E 21 EF 1D 04 0045*       ld hl,ps_mode
041D92 AE          0046*       xor a,(hl)
041D93 77          0047*       ld (hl),a
041D94 C3 2A 1D 04 0048*       jp @loop
041D98             0049*   ; toggle loop play
041D98 FE 6C       0050*       cp 'l'
041D9A C2 CE 1D 04 0051*       jp nz,@F
041D9E 3E 0A       0052*       ld a,ps_mode_loop
041DA0 21 EF 1D 04 0053*       ld hl,ps_mode
041DA4 AE          0054*       xor a,(hl)
041DA5 77          0055*       ld (hl),a
041DA6 C3 2A 1D 04 0056*       jp @loop
041DAA             0057*   ; toggle shuffle play
041DAA FE 73       0058*       cp 's'
041DAC C2 CE 1D 04 0059*       jp nz,@F
041DB0 3E 04       0060*       ld a,ps_mode_shuffle
041DB2 21 EF 1D 04 0061*       ld hl,ps_mode
041DB6 AE          0062*       xor a,(hl)
041DB7 77          0063*       ld (hl),a
041DB8 C3 2A 1D 04 0064*       jp @loop
041DBC             0065*   ; play random song
041DBC FE 72       0066*       cp 'r'
041DBE C2 CE 1D 04 0067*       jp nz,@F
041DC2 3E 04       0068*       ld a,ps_mode_shuffle
041DC4 21 EF 1D 04 0069*       ld hl,ps_mode
041DC8 B6          0070*       or a,(hl)
041DC9 77          0071*       ld (hl),a
041DCA C3 C5 24 04 0072*       jp ps_play_random
041DCE             0073*   ; 0-9 play song keys
041DCE             0074*   @@:
041DCE FE 30       0075*       cp '0'
041DD0 DA EA 1D 04 0076*       jp c,@no_cmd ; not a song command
041DD4 FE 3A       0077*       cp '9'+1
041DD6 D2 EA 1D 04 0078*       jp nc,@no_cmd ; not a song command
041DDA F5          0079*       push af ; preserve keypress
041DDB CD 8C 22 04 0080*       call ps_close_file
041DDF F1          0081*       pop af ; restore keypress
041DE0             0082*   ; get pointer to song filename and play it
041DE0 D6 30       0083*       sub '0' ; a = index into filename lut
041DE2 CD 9E 24 04 0084*       call ps_get_song_fn_from_pg_idx ; carry set indicates success
041DE6 DA CB 21 04 0085*       jp c,play_song ; re-enables interrupts and jp's to get_input when finished
041DEA             0086*   @no_cmd: ; no valid commands so loop
041DEA FB          0087*       ei ; reenable interrupts
041DEB C3 2A 1D 04 0088*       jp @loop
041DEF             0089*   ; end get_input
041DEF             0049        include "play.inc"
041DEF             0001*   ; stream a song from the SD card
041DEF             0002*   ; inputs: hl = pointer to filename
041DEF             0003*   ; requirements: the file must be 8-bit signed PCM mono
041DEF             0004*   ; uses: sound channels 0 and 1, buffers 0x3000 and 0x3001
041DEF             0005*   ; play_song constants
041DEF             0006*   ch0_buffer: equ 0x3000
041DEF             0007*   ch1_buffer: equ 0x3001
041DEF             0008*   cmd0_buffer: equ 0x3002
041DEF             0009*   cmd1_buffer: equ 0x3003
041DEF             0010*   
041DEF             0011*   ; ps_mode bitmasks
041DEF             0012*   ps_mode_playing: equ %00000001 ; 0 = paused 1 = playing, p key toggles
041DEF             0013*   ps_mode_loop:    equ 000000010 ; 0 = no loop 1 = loop (overrides ps_mode_shuffle if on), l key toggles
041DEF             0014*   ps_mode_shuffle: equ %00000100 ; 0 = shuffle off 1 = on, s key toggles
041DEF             0015*   
041DEF             0016*   ; play_song state variables
041DEF             0017*   ; current active channel and bufferId's
041DEF 00          0018*   ps_mode: db 0 ; playback mode bitmask
041DF0 00          0019*   ps_channel: db 0 ; channel number
041DF1 00 00 00    0020*   ps_cmdId: dl 0 ; command bufferId
041DF4 00 00 00    0021*   ps_sampleId: dl 0 ; sample bufferId
041DF7 00 00 00 00 0022*   ps_dir_path:   blkw 256,0 ; path of the current directory
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041FF7 00 00 00    0023*   ps_dir_num_files: dl 0 ; number of files/directories in the directory (virtually unlimited)
041FFA 00 00 00    0024*   ps_dir_num_pages: dl 0 ; number of pages in the directory (virtually unlimited)
041FFD 00 00 00    0025*   ps_page_num_files: dl 0 ; number of files/directories in the current directory page (max 10)
042000 00 00 00    0026*   ps_pagelast_num_files: dl 0 ; mod(ps_dir_num_files,10)
042003 00 00 00    0027*   ps_page_cur: dl 0 ; current directory page number
042006 00          0028*   ps_song_idx_cur: db 0 ; current song index in the directory page
042007 00 00 00    0029*   ps_song_fn_cur: dl 0 ; pointer to current song filename
04200A 00 00 00 00 0030*   ps_page_fn_ptrs: blkw 10*3,0 ; list of filename pointers in the current directory page
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042046             0031*   
042046             0032*   ; play_song directory info
042046             0033*   ps_dir_struct:
042046 00 00 00 00 0034*   ps_dptr:       blkb  4,0   ; Current read/write offset
04204A 00 00 00 00 0035*   ps_clust:      blkb  4,0   ; Current cluster
04204E 00 00 00 00 0036*   ps_sect:       blkb  4,0   ; Current sector (0:Read operation has terminated)
042052 00 00 00    0037*   ps_dir:        blkb  3,0   ; Pointer to the directory item in the win[]
042055 00 00 00 00 0038*   ps_fn:         blkb  12,0  ; SFN (in/out) {body[8],ext[3],status[1]}
       00 00 00 00 
       00 00 00 00 
042061 00 00 00 00 0039*   ps_blk_ofs:    blkb  4,0   ; Offset of current entry block being processed (0xFFFFFFFF:Invalid)
042065             0040*   
042065             0041*   ; play_song file info
042065 00          0042*   ps_filehandle_cur: db 0 ; file handle
042066 00 00 00    0043*   ps_chunkpointer: dl 0 ; pointer to current chunk
042069             0044*   ; File information structure (FILINFO)
042069             0045*   ps_file_struct:
042069 00 00 00 00 0046*   ps_file_fsize:    blkb 4, 0   ; File size (4 bytes)
04206D 00 00       0047*   ps_file_fdate:    blkb 2, 0   ; Modified date (2 bytes)
04206F 00 00       0048*   ps_file_ftime:    blkb 2, 0   ; Modified time (2 bytes)
042071 00          0049*   ps_file_fattrib:  blkb 1, 0   ; File attribute (1 byte)
042072 00 00 00 00 0050*   ps_file_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
04207F 00 00 00 00 0051*   ps_file_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04217F             0052*   
04217F             0053*   ; buffer for play_song sound data
04217F             0054*   ps_wav_header: ; marker for top of the wav file header and song data
04217F             0055*   ; (must be last so buffer doesn't overwrite other program code or data)
04217F             0056*   ; .wav header data
04217F             0057*   ; WAV File Structure in Memory with LIST Chunk
04217F 00 00 00 00 0058*   ps_wav_riff:          blkb 4,0   ; 4 bytes: "RIFF" identifier
042183 00 00 00 00 0059*   ps_wav_file_size:     blkb 4,0   ; 4 bytes: Total file size minus 8 bytes for RIFF header
042187 00 00 00 00 0060*   ps_wav_wave:          blkb 4,0   ; 4 bytes: "WAVE" identifier
04218B 00 00 00 00 0061*   ps_wav_fmt_marker:    blkb 4,0   ; 4 bytes: "fmt " subchunk marker
04218F 00 00 00 00 0062*   ps_wav_fmt_size:      blkb 4,0   ; 4 bytes: Format chunk size (16 for PCM)
042193 00 00       0063*   ps_wav_audio_format:  blkb 2,0   ; 2 bytes: Audio format (1 = PCM)
042195 00 00       0064*   ps_wav_num_channels:  blkb 2,0   ; 2 bytes: Number of channels (1 = mono, 2 = stereo)
042197 00 00 00 00 0065*   ps_wav_sample_rate:   blkb 4,0   ; 4 bytes: Sample rate in Hz (e.g., 32768)
04219B 00 00 00 00 0066*   ps_wav_byte_rate:     blkb 4,0   ; 4 bytes: Bytes per second (SampleRate * NumChannels * BitsPerSample / 8)
04219F 00 00       0067*   ps_wav_block_align:   blkb 2,0   ; 2 bytes: Bytes per sample block (NumChannels * BitsPerSample / 8)
0421A1 00 00       0068*   ps_wav_bits_per_sample: blkb 2,0 ; 2 bytes: Bits per sample (e.g., 8 or 16)
0421A3             0069*   
0421A3             0070*   ; LIST Chunk (Extra Metadata)
0421A3 00 00 00 00 0071*   ps_wav_list_marker:   blkb 4,0   ; 4 bytes: "LIST" marker
0421A7 00 00 00 00 0072*   ps_wav_list_size:     blkb 4,0   ; 4 bytes: Size of the LIST chunk (e.g., 26)
0421AB 00 00 00 00 0073*   ps_wav_info_marker:   blkb 4,0   ; 4 bytes: "INFO" marker
0421AF 00 00 00 00 0074*   ps_wav_isft_marker:   blkb 4,0   ; 4 bytes: "ISFT" marker (software identifier)
0421B3 00 00 00 00 0075*   ps_wav_isft_data:     blkb 14,0  ; 14 bytes: Software info string (e.g., "Lavf59.27.100")
       00 00 00 00 
       00 00 00 00 
       00 00       
0421C1 00 00       0076*   ps_wav_isft_padding:  blkb 2,0   ; 2 bytes: Padding/NULL terminator for alignment
0421C3             0077*   
0421C3             0078*   ; Data Chunk
0421C3 00 00 00 00 0079*   ps_wav_data_marker:   blkb 4,0   ; 4 bytes: "data" subchunk marker
0421C7 00 00 00 00 0080*   ps_wav_data_size:     blkb 4,0   ; 4 bytes: Size of the audio data in bytes
0421CB             0081*   ; Total Header Size: 76 bytes
0421CB             0082*   play_song:
0421CB 22 07 20 04 0083*       ld (ps_song_fn_cur),hl
0421CF             0084*   ; stop the PRT timer
0421CF CD BA 25 04 0085*       call ps_prt_stop
0421D3             0086*   ; tell the user what they've won
0421D3 CD F2 19 04 0087*       call vp_now_playing
0421D7 CD 86 12 04 0088*       call vdu_cls
0421DB 2A 07 20 04 0089*       ld hl,(ps_song_fn_cur)
0421DF CD 60 00 04 0090*       call printInline
0421E3 50 6C 61 79 0091*       asciz "Playing song: "
       69 6E 67 20 
       73 6F 6E 67 
       3A 20 00    
0421F2 2A 07 20 04 0092*       ld hl,(ps_song_fn_cur)
0421F6 CD 67 00 04 0093*       call printString ; print the song filename
0421FA             0094*   ; highlight the song being played
0421FA CD 16 24 04 0095*       call ps_highlight_song
0421FE             0096*   ; reset text viewport for playing breadcrumbs
0421FE CD FF 19 04 0097*       call vp_breadcrumbs
042202             0098*   ; open the file in read mode
042202             0099*   ; Open a file
042202             0100*   ; HLU: Filename
042202             0101*   ;   C: Mode
042202             0102*   ; Returns:
042202             0103*   ;   A: Filehandle, or 0 if couldn't open
042202 2A 07 20 04 0104*       ld hl,(ps_song_fn_cur)
042206 0E 01       0105*   	ld c,fa_read
042208             0106*       MOSCALL mos_fopen
                       M1 Args: function=mos_fopen 
042208 3E 0A       0001*M1 			LD	A, function
04220A 5B CF       0002*M1 			RST.LIL	08h
04220C 32 65 20 04 0107*       ld (ps_filehandle_cur),a
042210             0108*   ; read the .wav header data and copy it to the buffer
042210 CD F5 24 04 0109*       call ps_read_wav_header
042214             0110*   ; read the first block of data
042214 CD 27 22 04 0111*       call ps_read_file
042218             0112*   ; set ps_mode_playing
042218 21 EF 1D 04 0113*       ld hl,ps_mode
04221C CB CE       0114*       set ps_mode_playing,(hl)
04221E             0115*   ; enable interrupts and start the PRT timer
04221E FB          0116*       ei
04221F CD 9D 25 04 0117*       call ps_prt_start
042223             0118*   ; jump to user input loop:
042223             0119*   ; the play sample interrupt will return to there
042223             0120*   ; and exit app will return to main from there as well
042223 C3 2A 1D 04 0121*       jp get_input
042227             0122*   ; end play_song
042227             0123*   
042227             0124*   ; read the next 1-second's worth of sound data from the file
042227             0125*   ; and upload it to the sample buffer
042227             0126*   ps_read_file:
042227             0127*   ; disable interrupts so load is guaranteed to complete
042227 F3          0128*       di
042228             0129*   ; print a playing breadcrumb
042228 3E 2E       0130*       ld a,'.'
04222A 5B D7       0131*       rst.lil 10h
04222C             0132*   ; Read a block of data from a file
04222C             0133*   ;   C: Filehandle
04222C             0134*   ; HLU: Pointer to where to write the data to
04222C             0135*   ; DEU: Number of bytes to read
04222C             0136*   ; Returns:
04222C             0137*   ; DEU: Number of bytes read
04222C 3A 65 20 04 0138*       ld a,(ps_filehandle_cur)
042230 4F          0139*       ld c,a
042231 21 00 00 05 0140*       ld hl,ps_wav_data_start
042235 ED 5B 97 21 0141*       ld de,(ps_wav_sample_rate)
       04          
04223A             0142*       MOSCALL mos_fread
                       M1 Args: function=mos_fread 
04223A 3E 1A       0001*M1 			LD	A, function
04223C 5B CF       0002*M1 			RST.LIL	08h
04223E             0143*   ; test de for zero bytes read
04223E 21 00 00 00 0144*       ld hl,0
042242 AF          0145*       xor a ; clear carry
042243 ED 52       0146*       sbc hl,de ; hl = 0-chunksize
042245 C2 51 22 04 0147*       jp nz,@load ; we read some data
042249             0148*   ; no data read so close file and play a random song
042249 CD 8C 22 04 0149*       call ps_close_file
04224D C3 C5 24 04 0150*       jp ps_play_random
042251             0151*   ; load a vdu buffer from local memory
042251             0152*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
042251             0153*   @load:
042251 3A F0 1D 04 0154*       ld a,(ps_channel)
042255 3C          0155*       inc a
042256 E6 01       0156*       and 1
042258 32 F0 1D 04 0157*       ld (ps_channel),a
04225C 21 00 30 00 0158*       ld hl,ch0_buffer
042260 6F          0159*       ld l,a
042261 22 F4 1D 04 0160*       ld (ps_sampleId),hl
042265 CD 40 16 04 0161*       call vdu_clear_buffer
042269 2A F4 1D 04 0162*       ld hl,(ps_sampleId)
04226D D5          0163*       push de ; chunksize
04226E C1          0164*       pop bc ; how much data to load
04226F 11 00 00 05 0165*       ld de,ps_wav_data_start ; pointer to data
042273 CD 2B 14 04 0166*       call vdu_load_buffer
042277 C9          0167*       ret
042278             0168*   ; end ps_read_file
042278             0169*   
042278             0170*   ; this is called by the PRT timer interrupt
042278             0171*   ps_play_sample:
042278             0172*   ; call the command buffer to play the sound
042278 2A F4 1D 04 0173*       ld hl,(ps_sampleId)
04227C 2C          0174*       inc l
04227D 2C          0175*       inc l
04227E 22 F1 1D 04 0176*       ld (ps_cmdId),hl ; TODO: perhaps not needed
042282 CD 25 16 04 0177*       call vdu_call_buffer
042286             0178*   ; load the next chunk of data
042286 CD 27 22 04 0179*       call ps_read_file
04228A             0180*   ; reenable interrupts and return to the user input loop
04228A FB          0181*       ei
04228B C9          0182*       ret
04228C             0183*   ; end ps_play_sample
04228C             0184*   
04228C             0185*   ; close the file
04228C             0186*   ps_close_file:
04228C CD BA 25 04 0187*       call ps_prt_stop ; stop the PRT timer
042290 3A 65 20 04 0188*       ld a,(ps_filehandle_cur)
042294             0189*       MOSCALL mos_fclose
                       M1 Args: function=mos_fclose 
042294 3E 0B       0001*M1 			LD	A, function
042296 5B CF       0002*M1 			RST.LIL	08h
042298 C9          0190*       ret
042299             0191*   ; end ps_close_file
042299             0192*   
042299             0193*   ps_get_dir:
042299             0194*   ; reset filecounter
042299 21 00 00 00 0195*       ld hl,0
04229D 22 F7 1F 04 0196*       ld (ps_dir_num_files),hl
0422A1             0197*   ; initialize pointers to store directory info
0422A1 21 F7 1D 04 0198*       ld hl,ps_dir_path  ; where to store result
0422A5 01 FF 00 00 0199*       ld bc,255          ; max length (final byte is zero terminator)
0422A9             0200*       MOSCALL ffs_getcwd ; MOS api get current working directory
                       M1 Args: function=ffs_getcwd 
0422A9 3E 9E       0001*M1 			LD	A, function
0422AB 5B CF       0002*M1 			RST.LIL	08h
0422AD             0201*   ; now get dir info
0422AD 21 46 20 04 0202*       ld hl,ps_dir_struct ; define where to store directory info
0422B1 11 F7 1D 04 0203*       ld de,ps_dir_path   ; this is pointer to the path to the directory
0422B5             0204*       MOSCALL ffs_dopen   ; open dir
                       M1 Args: function=ffs_dopen 
0422B5 3E 91       0001*M1 			LD	A, function
0422B7 5B CF       0002*M1 			RST.LIL	08h
0422B9             0205*   ; set up pointers
0422B9 DD 21 00 00 0206*       ld ix,ps_dir_fil_list ; this is the pointer to the fileinfo table
       06          
0422BE             0207*   @readFileInfo:               ; we will loop here until all files have been processed
0422BE 21 46 20 04 0208*       ld hl,ps_dir_struct      ; HL is where to get directory info
0422C2 DD E5       0209*       push ix
0422C4 D1          0210*       pop de ; where to store current file info
0422C5             0211*       MOSCALL ffs_dread        ; read next item from dir
                       M1 Args: function=ffs_dread 
0422C5 3E 93       0001*M1 			LD	A, function
0422C7 5B CF       0002*M1 			RST.LIL	08h
0422C9             0212*   
0422C9 DD 7E 16    0213*       ld a,(ix+filinfo_fname)  ; get first char of file name
0422CC B7          0214*       or a                     ; if zero then we are at the end of the listing
0422CD CA FF 22 04 0215*       jp z,@allDone
0422D1             0216*   
0422D1 DD 7E 08    0217*       ld a,(ix+filinfo_fattrib) ; get the file attribute
0422D4 CB AF       0218*       res 5,a ; clear bit 5 (archive) see: https://discord.com/channels/1158535358624039014/1158536667670511726/1328466726098309173
0422D6 B7          0219*       or a ; if zero this is a file
0422D7 C2 E0 22 04 0220*       jp nz,@F ; not zero so this is some other file type
0422DB CB EF       0221*       set 5,a ; set bit 5 (archive) so will be consistent btw emulator and hardware
0422DD DD 77 08    0222*       ld (ix+filinfo_fattrib),a ; update so we don't have to do this every time downstream
0422E0             0223*   
0422E0             0224*   @@: ; skip over writing hidden and system files
0422E0 E6 02       0225*       and AM_HID ; hidden file
0422E2 C2 BE 22 04 0226*       jp nz,@readFileInfo
0422E6 E6 04       0227*       and AM_SYS ; system file
0422E8 C2 BE 22 04 0228*       jp nz,@readFileInfo
0422EC             0229*   
0422EC             0230*   ; valid file or directory
0422EC 2A F7 1F 04 0231*       ld hl,(ps_dir_num_files) ; get the current file counter
0422F0 23          0232*       inc hl                  ; increment the counter
0422F1 22 F7 1F 04 0233*       ld (ps_dir_num_files),hl
0422F5 11 16 01 00 0234*       ld de,filinfo_struct_size ; length of fileinfo record
0422F9 DD 19       0235*       add ix,de ; point to next fileinfo record
0422FB             0236*   
0422FB C3 BE 22 04 0237*       jp @readFileInfo         ; loop around to check next entry
0422FF             0238*   @allDone:
0422FF             0239*   ; compute page statistics
0422FF 2A F7 1F 04 0240*       ld hl,(ps_dir_num_files) ; get the number of files
042303 11 0A 00 00 0241*       ld de,10 ; max files per page
042307 CD 80 03 04 0242*       call udiv24 ; de = hl/10, hl = mod(hl,10)
04230B             0243*       SIGN_HLU ; check remainder for zero
                       M1 Args: none
04230B 19          0001*M1     add hl,de ; 1 cycle
04230C B7          0002*M1     or a ; clear flags ; 1 cycle
04230D ED 52       0003*M1     sbc hl,de ; 2 cycles
04230F             0004*M1     ; 4 cycles total
04230F C2 18 23 04 0244*       jp nz,@F
042313 21 0A 00 00 0245*       ld hl,10 ; if zero then we have exactly 10 files on the last page ...
042317 1B          0246*       dec de ; ... and we don't need an additional page for the remainder
042318             0247*   @@:
042318 22 00 20 04 0248*       ld (ps_pagelast_num_files),hl ; save the number of files on the last page
04231C 13          0249*       inc de ; bump the page count
04231D ED 53 FA 1F 0250*       ld (ps_dir_num_pages),de ; save the number of pages
       04          
042322             0251*   ; reset the song index and page to zero and populate the page filename pointers
042322 AF          0252*       xor a
042323 32 06 20 04 0253*       ld (ps_song_idx_cur),a
042327 21 00 00 00 0254*       ld hl,0
04232B 22 03 20 04 0255*       ld (ps_page_cur),hl
04232F CD 3C 23 04 0256*       call ps_fill_page_fn_ptrs
042333             0257*   ; close the directory
042333 21 46 20 04 0258*       ld hl,ps_dir_struct      ; load H: with address of the DIR struct
042337             0259*       MOSCALL ffs_dclose       ; close dir
                       M1 Args: function=ffs_dclose 
042337 3E 92       0001*M1 			LD	A, function
042339 5B CF       0002*M1 			RST.LIL	08h
04233B             0260*   ; ; DEBUG
04233B             0261*   ;     call printNewLine
04233B             0262*   ;     call printInline
04233B             0263*   ;     asciz "Number of files: "
04233B             0264*   ;     ld hl,(ps_dir_num_files)
04233B             0265*   ;     call printHexUHL
04233B             0266*   
04233B             0267*   ;     call printNewLine
04233B             0268*   ;     call printInline
04233B             0269*   ;     asciz "Number of pages: "
04233B             0270*   ;     ld hl,(ps_dir_num_pages)
04233B             0271*   ;     call printHexUHL
04233B             0272*   
04233B             0273*   ;     call printNewLine
04233B             0274*   ;     call printInline
04233B             0275*   ;     asciz "Number of files on last page: "
04233B             0276*   ;     ld hl,(ps_pagelast_num_files)
04233B             0277*   ;     call printHexUHL
04233B             0278*   ;     call printNewLine
04233B             0279*   ; ; END DEBUG
04233B C9          0280*       ret
04233C             0281*   ; end ps_get_dir
04233C             0282*   
04233C             0283*   ; populate the page filename pointers for the current directory page
04233C             0284*   ; inputs: ps_page_cur
04233C             0285*   ; prerequisites: ps_get_dir called on a valid directory
04233C             0286*   ; outputs: a populated filename pointer list for the current page
04233C             0287*   ; destroys: a, hl, bc, de, ix
04233C             0288*   ps_fill_page_fn_ptrs:
04233C 2A 03 20 04 0289*       ld hl,(ps_page_cur) ; get the current page number
042340 11 DC 0A 00 0290*       ld de,10*filinfo_struct_size ; records/page * bytes/record
042344 CD 67 03 04 0291*       call umul24 ; hl = offset into the fileinfo table
042348 11 00 00 06 0292*       ld de,ps_dir_fil_list ; base address of fileinfo table
04234C 19          0293*       add hl,de ; add the offset to the base address
04234D DD 21 0A 20 0294*       ld ix,ps_page_fn_ptrs ; get the address of the page fileinfo pointer table
       04          
042352 11 16 01 00 0295*       ld de,filinfo_struct_size ; bytes per filename record
042356 06 0A       0296*       ld b,10 ; number of files per page
042358             0297*   @loop:
042358 DD 2F 00    0298*       ld (ix),hl ; store the filename pointer
04235B ED 32 03    0299*       lea ix,ix+3 ; bump the index pointer
04235E 19          0300*       add hl,de ; add the record size to the filename pointer
04235F 10 F7       0301*       djnz @loop
042361 C9          0302*       ret
042362             0303*   ; end ps_fill_page_fn_ptrs
042362             0304*   
042362             0305*   ps_get_page_num_files:
042362             0306*   ; check whether we're at last page
042362 2A 03 20 04 0307*       ld hl,(ps_page_cur)
042366 ED 5B FA 1F 0308*       ld de,(ps_dir_num_pages)
       04          
04236B 1B          0309*       dec de ; zero-based
04236C B7          0310*       or a ; clear carry
04236D ED 52       0311*       sbc hl,de
04236F 06 0A       0312*       ld b,10 ; b = default number of files per page
042371 C0          0313*       ret nz ; not the last page
042372 3A 00 20 04 0314*       ld a,(ps_pagelast_num_files) ; get the number of files on the last page
042376 47          0315*       ld b,a ; b = number of files on the last page
042377 C9          0316*       ret
042378             0317*   ; end ps_get_page_num_files
042378             0318*   
042378             0319*   ps_print_dir_page:
042378             0320*   ; set text viewport for directory listing
042378 CD 0C 1A 04 0321*       call vp_dir
04237C CD 86 12 04 0322*       call vdu_cls
042380             0323*   ; loop through the fileinfo pointer table and print out the filenames
042380 CD 62 23 04 0324*       call ps_get_page_num_files ; b = loop counter
042384 AF          0325*       xor a ; song index
042385 DD 21 0A 20 0326*       ld ix,ps_page_fn_ptrs
       04          
04238A             0327*   @loop:
04238A C5          0328*       push bc ; save loop counter
04238B F5          0329*       push af ; save song index
04238C CD 0A 26 04 0330*       call printHexA ; print the song index
042390             0331*   ; branch on the file attribute
042390 DD 27 00    0332*       ld hl,(ix) ; get the filename pointer
042393 01 08 00 00 0333*       ld bc,filinfo_fattrib
042397 09          0334*       add hl,bc ; hl points to the file attribute
042398 7E          0335*       ld a,(hl)
042399 FE 10       0336*       cp AM_DIR ; if zero, is directory
04239B C2 AC 23 04 0337*       jp nz,@print_file ; not directory so just write filename
04239F E5          0338*       push hl
0423A0 CD 60 00 04 0339*       call printInline
0423A4 3C 44 49 52 0340*       asciz "<DIR> "
       3E 20 00    
0423AB E1          0341*       pop hl
0423AC             0342*   @print_file:
0423AC 01 0E 00 00 0343*       ld bc,filinfo_fname-filinfo_fattrib ; offset to the filename
0423B0 09          0344*       add hl,bc ; hl points to the filename
0423B1 CD 67 00 04 0345*       call printString ; print the filename
0423B5 CD 7C 00 04 0346*       call printNewLine
0423B9             0347*   @bump_counters:
0423B9 ED 32 03    0348*       lea ix,ix+3 ; bump the filename pointer
0423BC F1          0349*       pop af ; restore song index
0423BD 3C          0350*       inc a ; increment the song index
0423BE C1          0351*       pop bc ; restore loop counter
0423BF 10 C9       0352*       djnz @loop
0423C1             0353*   ; print the bottom border
0423C1 CD 19 1A 04 0354*       call print_dir_border_bottom
0423C5 C9          0355*       ret
0423C6             0356*   ; end ps_print_dir_page
0423C6             0357*   
0423C6             0358*   ps_print_dir:
0423C6             0359*   ; test whether there are any files in the directory
0423C6 2A F7 1F 04 0360*       ld hl,(ps_dir_num_files)
0423CA             0361*       SIGN_HLU
                       M1 Args: none
0423CA 19          0001*M1     add hl,de ; 1 cycle
0423CB B7          0002*M1     or a ; clear flags ; 1 cycle
0423CC ED 52       0003*M1     sbc hl,de ; 2 cycles
0423CE             0004*M1     ; 4 cycles total
0423CE C8          0362*       ret z ; if zero, no files in the directory
0423CF             0363*   ; loop through the fileinfo table and print out the filenames
0423CF DD 21 00 00 0364*       ld ix,ps_dir_fil_list
       06          
0423D4 2A F7 1F 04 0365*       ld hl,(ps_dir_num_files)
0423D8             0366*   @print_loop:
0423D8 E5          0367*       push hl ; loop counter
0423D9             0368*   ; branch on the file attribute
0423D9 DD 7E 08    0369*       ld a,(ix+filinfo_fattrib)
0423DC             0370*   ; ; DEBUG
0423DC             0371*   ;     PUSH_ALL
0423DC             0372*   ;     call printBin8
0423DC             0373*   ;     ld a,' '
0423DC             0374*   ;     rst.lil 10h
0423DC             0375*   ;     POP_ALL
0423DC             0376*   ; ; END DEBUG
0423DC FE 10       0377*       cp AM_DIR ; if zero, is directory
0423DE C2 ED 23 04 0378*       jp nz,@print_file ; not directory so just write filename
0423E2 CD 60 00 04 0379*       call printInline
0423E6 3C 44 49 52 0380*       asciz "<DIR> "
       3E 20 00    
0423ED             0381*   @print_file:
0423ED ED 32 16    0382*       lea ix,ix+filinfo_fname ; point to filinfo_fname
0423F0 DD E5       0383*       push ix
0423F2 E1          0384*       pop hl ; get the address of the filename
0423F3 CD 67 00 04 0385*       call printString
0423F7 CD 7C 00 04 0386*       call printNewLine
0423FB 11 00 01 00 0387*       ld de,256 ; length of filename
0423FF DD 19       0388*       add ix,de ; bump pointer to next filinfo record
042401             0389*   @dec_loop_counter:
042401 E1          0390*       pop hl
042402 2B          0391*       dec hl ; decrement the loop counter
042403             0392*       SIGN_HLU ; check for zero
                       M1 Args: none
042403 19          0001*M1     add hl,de ; 1 cycle
042404 B7          0002*M1     or a ; clear flags ; 1 cycle
042405 ED 52       0003*M1     sbc hl,de ; 2 cycles
042407             0004*M1     ; 4 cycles total
042407 C2 D8 23 04 0393*       jp nz,@print_loop
04240B C9          0394*       ret
04240C             0395*   @skip_file:
04240C 11 16 01 00 0396*       ld de,filinfo_struct_size
042410 DD 19       0397*       add ix,de ; bump pointer to next filinfo record
042412 C3 01 24 04 0398*       jp @dec_loop_counter
042416             0399*   ; end ps_print_dir
042416             0400*   
042416             0401*   ps_highlight_song:
042416             0402*   ; refresh the directory listing
042416 CD 78 23 04 0403*       call ps_print_dir_page
04241A             0404*   ; highlight the song being played in the directory listing
04241A 3A 06 20 04 0405*       ld a,(ps_song_idx_cur)
04241E 16 1E       0406*       ld d,vp_dir_top
042420 82          0407*       add a,d
042421 0E 00       0408*       ld c,vp_dir_left
042423 57          0409*       ld d,a
042424 1E 3F       0410*       ld e,vp_dir_right
042426 47          0411*       ld b,a
042427 CD DF 12 04 0412*       call vdu_set_txt_viewport
04242B             0413*   ; set text background color
04242B 3E 8F       0414*       ld a,c_white+128
04242D CD B7 12 04 0415*       call vdu_colour_text
042431             0416*   ; set text foreground color
042431 3E 04       0417*       ld a,c_blue_dk
042433 CD B7 12 04 0418*       call vdu_colour_text
042437             0419*   ; print the index and song filename
042437 3A 06 20 04 0420*       ld a,(ps_song_idx_cur)
04243B CD 0A 26 04 0421*       call printHexA
04243F 2A 07 20 04 0422*       ld hl,(ps_song_fn_cur)
042443 CD 67 00 04 0423*       call printString
042447             0424*   ; set text background color
042447 3E 84       0425*       ld a,c_blue_dk+128
042449 CD B7 12 04 0426*       call vdu_colour_text
04244D             0427*   ; set text foreground color
04244D 3E 0F       0428*       ld a,c_white
04244F CD B7 12 04 0429*       call vdu_colour_text
042453 C9          0430*       ret
042454             0431*   ; end ps_highlight_song
042454             0432*   
042454             0433*   ps_dir_next_page:
042454             0434*   ; advance the page number
042454 2A 03 20 04 0435*       ld hl,(ps_page_cur) ; get the current page number
042458 23          0436*       inc hl ; increment the page number
042459 ED 5B FA 1F 0437*       ld de,(ps_dir_num_pages) ; get the number of pages
       04          
04245E CD 80 03 04 0438*       call udiv24 ; hl = mod(ps_page_cur+1,ps_dir_num_pages)
042462 22 03 20 04 0439*       ld (ps_page_cur),hl ; save the new page number
042466             0440*   ; populate the page filename pointers
042466 CD 3C 23 04 0441*       call ps_fill_page_fn_ptrs
04246A             0442*   ; print the new page and reset text viewport to now playing breadcrumbs
04246A CD 78 23 04 0443*       call ps_print_dir_page
04246E CD FF 19 04 0444*       call vp_breadcrumbs
042472             0445*   ; enable interrupts and jump back to the user input loop
042472 FB          0446*       ei
042473 C3 2A 1D 04 0447*       jp get_input
042477             0448*   ; end ps_dir_next_page
042477             0449*   
042477             0450*   ps_dir_prev_page:
042477             0451*   ; decrement the page number
042477 2A 03 20 04 0452*       ld hl,(ps_page_cur) ; get the current page number
04247B 2B          0453*       dec hl ; decrement the page number
04247C             0454*       SIGN_HLU ; check for zero
                       M1 Args: none
04247C 19          0001*M1     add hl,de ; 1 cycle
04247D B7          0002*M1     or a ; clear flags ; 1 cycle
04247E ED 52       0003*M1     sbc hl,de ; 2 cycles
042480             0004*M1     ; 4 cycles total
042480 F2 89 24 04 0455*       jp p,@F ; >= 0 so we're good
042484 2A FA 1F 04 0456*       ld hl,(ps_dir_num_pages) ; get the number of pages
042488 2B          0457*       dec hl ; zero-based
042489             0458*   @@:
042489 22 03 20 04 0459*       ld (ps_page_cur),hl ; save the new page number
04248D             0460*   ; populate the page filename pointers
04248D CD 3C 23 04 0461*       call ps_fill_page_fn_ptrs
042491             0462*   ; print the new page and reset text viewport to now playing breadcrumbs
042491 CD 78 23 04 0463*       call ps_print_dir_page
042495 CD FF 19 04 0464*       call vp_breadcrumbs
042499             0465*   ; enable interrupts and jump back to the user input loop
042499 FB          0466*       ei
04249A C3 2A 1D 04 0467*       jp get_input
04249E             0468*   ; end ps_dir_prev_page
04249E             0469*   
04249E             0470*   ; get the filename of the song at the current index
04249E             0471*   ; inputs: a = song index
04249E             0472*   ; returns: carry set if song index in range, new filemame in hl and ps_song_idx_cur, ps_song_fn_cur set to new index
04249E             0473*   ;          carry reset if song index out of range, current filename in hl, ps_song_idx_cur, ps_song_fn_cur unchanged
04249E             0474*   ; destroys: af, bc, de
04249E             0475*   ps_get_song_fn_from_pg_idx:
04249E F5          0476*       push af ; save song index
04249F CD 62 23 04 0477*       call ps_get_page_num_files ; b = number of files on the page
0424A3 F1          0478*       pop af ; restore song index
0424A4 B8          0479*       cp b ; compare song index to number of files on the page
0424A5 2A 07 20 04 0480*       ld hl,(ps_song_fn_cur) ; get the current song filename
0424A9 D0          0481*       ret nc ; requested song index is out of range so return current filename and no carry
0424AA 32 06 20 04 0482*       ld (ps_song_idx_cur),a ; save the song index
0424AE 21 0A 20 04 0483*       ld hl,ps_page_fn_ptrs ; get the address of the page fileinfo pointer table
0424B2 47          0484*       ld b,a ; song index
0424B3 0E 03       0485*       ld c,3 ; 3 bytes per filename pointer
0424B5 ED 4C       0486*       mlt bc ; index into the fileinfo pointer table
0424B7 09          0487*       add hl,bc ; hl points to the fileinfo pointer
0424B8 ED 27       0488*       ld hl,(hl) ; hl points to the fileinfo
0424BA 01 16 00 00 0489*       ld bc,filinfo_fname ; offset to the filename
0424BE 09          0490*       add hl,bc ; hl points to the filename
0424BF 22 07 20 04 0491*       ld (ps_song_fn_cur),hl ; save the new song filename
0424C3 37          0492*       scf ; set carry to indicate success
0424C4 C9          0493*       ret
0424C5             0494*   ; end ps_get_song_fn_from_pg_idx
0424C5             0495*   
0424C5             0496*   ; queue a random song on the current page to play next
0424C5             0497*   ps_play_random:
0424C5             0498*   ; back up current song index
0424C5 2A 07 20 04 0499*       ld hl,(ps_song_fn_cur)
0424C9 22 F2 24 04 0500*       ld (@songFn),hl
0424CD             0501*   ; get the number of songs in the current directory
0424CD CD 62 23 04 0502*       call ps_get_page_num_files
0424D1             0503*   ; get a random song index
0424D1 CD 38 05 04 0504*       call rand_8 ; a = 0-255
0424D5 67          0505*       ld h,a
0424D6 2E 0A       0506*       ld l,10 ; modulo 10
0424D8 CD 74 05 04 0507*       call udiv8 ; a = mod(a,10)
0424DC CD 9E 24 04 0508*       call ps_get_song_fn_from_pg_idx
0424E0 EB          0509*       ex de,hl ; setting up cp hl,de
0424E1 2A F2 24 04 0510*       ld hl,(@songFn) ; don't play the same song twice in a row
0424E5 B7          0511*       or a ; clear carry
0424E6 ED 52       0512*       sbc hl,de
0424E8 CA C5 24 04 0513*       jp z,ps_play_random ; same song, try again
0424EC EB          0514*       ex de,hl ; pointer back to hl
0424ED CD CB 21 04 0515*       call play_song ; hit it
0424F1 C9          0516*       ret
0424F2 00 00 00    0517*   @songFn: dl 0
0424F5             0518*   ; end ps_play_random
0424F5             0519*   
0424F5             0520*   ps_read_wav_header:
0424F5             0521*   ; Read a block of data from a file
0424F5             0522*   ;   C: Filehandle
0424F5             0523*   ; HLU: Pointer to where to write the data to
0424F5             0524*   ; DEU: Number of bytes to read
0424F5             0525*   ; Returns:
0424F5             0526*   ; DEU: Number of bytes read
0424F5 3A 65 20 04 0527*       ld a,(ps_filehandle_cur)
0424F9 4F          0528*       ld c,a
0424FA 21 7F 21 04 0529*       ld hl,ps_wav_header
0424FE 11 4C 00 00 0530*       ld de,wav_header_size
042502             0531*       MOSCALL mos_fread
                       M1 Args: function=mos_fread 
042502 3E 1A       0001*M1 			LD	A, function
042504 5B CF       0002*M1 			RST.LIL	08h
042506             0532*   ; test de for zero bytes read
042506 21 00 00 00 0533*       ld hl,0
04250A AF          0534*       xor a ; clear carry
04250B ED 52       0535*       sbc hl,de ; hl = 0-chunksize
04250D C8          0536*       ret z ; no data read so return zero to caller
04250E             0537*   ; data read so initialize song variables
04250E             0538*   ; load play sample command buffers (namely the sample rate for now)
04250E CD 13 25 04 0539*       call ps_load_command_buffers
042512 C9          0540*       ret
042513             0541*   ; end ps_read_wav_header
042513             0542*   
042513             0543*   ps_load_command_buffers:
042513 21 02 30 00 0544*       ld hl,cmd0_buffer
042517 CD 40 16 04 0545*       call vdu_clear_buffer
04251B 2A 97 21 04 0546*       ld hl,(ps_wav_sample_rate)
04251F 22 69 25 04 0547*       ld (ps_sr0),hl
042523 3E 17       0548*       ld a,23
042525 32 6B 25 04 0549*       ld (ps_sr0+2),a
042529 21 02 30 00 0550*       ld hl,cmd0_buffer
04252D 01 1D 00 00 0551*       ld bc,ps_cmd0_end-ps_cmd0
042531 11 60 25 04 0552*       ld de,ps_cmd0
042535 CD FD 15 04 0553*       call vdu_write_block_to_buffer
042539             0554*   
042539 21 03 30 00 0555*       ld hl,cmd1_buffer
04253D CD 40 16 04 0556*       call vdu_clear_buffer
042541 2A 97 21 04 0557*       ld hl,(ps_wav_sample_rate)
042545 22 86 25 04 0558*       ld (ps_sr1),hl
042549 3E 17       0559*       ld a,23
04254B 32 88 25 04 0560*       ld (ps_sr1+2),a
04254F 21 03 30 00 0561*       ld hl,cmd1_buffer
042553 01 1D 00 00 0562*       ld bc,ps_cmd1_end-ps_cmd1
042557 11 7D 25 04 0563*       ld de,ps_cmd1
04255B CD FD 15 04 0564*       call vdu_write_block_to_buffer
04255F C9          0565*       ret
042560             0566*   ps_cmd0:
042560             0567*   ; vdu_buffer_to_sound command string
042560             0568*   ; Command 5: Buffer to sound
042560             0569*   ; VDU 23, 0, &85, channel (ignored), 5, 2, bufferId; format, [sampleRate;]
042560 17 00 85    0570*       db 23,0,0x85 ; vdu sound command header
042563 00          0571*       db 0x00 ; channel (ignored)
042564 05          0572*       db 0x05 ; buffer to sound command
042565 02          0573*       db 0x02 ; command 2 create sample
042566 00 30       0574*       dw ch0_buffer
042568 09          0575*       db 1+8 ; 8-bit unsigned PCM mono, 8 = sample rate argument follows
042569             0576*   ps_sr0:
042569 00 00       0577*       dw 0x0000 ; sample rate Hz
04256B             0578*   ; vdu_play_sfx command string
04256B             0579*   ; Command 4: Set waveform
04256B             0580*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
04256B 17 00 85    0581*       db 23,0,$85 ; vdu sound command header
04256E 00          0582*       db 0 ; channel
04256F 04          0583*       db 4 ; set waveform command
042570 08          0584*       db 8 ; waveform 8 = sample
042571 00 30       0585*       dw ch0_buffer ; sample bufferId
042573             0586*   ; Command 0: Play note
042573             0587*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
042573 17 00 85    0588*       db 23,0,$85 ; vdu sound command header
042576 00          0589*       db 0 ; channel
042577 00          0590*       db 0 ; play note command
042578 7F          0591*       db 127  ; volume 127 = max
042579 00 00       0592*       dw 0 ; frequency (relevant only for tuneable samples)
04257B 00 00       0593*       dw 0 ; duration (ms), zero means play one time in full
04257D             0594*   ps_cmd0_end:
04257D             0595*   
04257D             0596*   ps_cmd1:
04257D             0597*   ; vdu_buffer_to_sound command string
04257D             0598*   ; Command 5: Buffer to sound
04257D             0599*   ; VDU 23, 0, &85, channel (ignored), 5, 2, bufferId; format, [sampleRate;]
04257D 17 00 85    0600*       db 23,0,0x85 ; vdu sound command header
042580 00          0601*       db 0x00 ; channel (ignored)
042581 05          0602*       db 0x05 ; buffer to sound command
042582 02          0603*       db 0x02 ; command 2 create sample
042583 01 30       0604*       dw ch1_buffer
042585 09          0605*       db 1+8 ; 8-bit unsigned PCM mono, 8 = sample rate argument follows
042586             0606*   ps_sr1:
042586 00 00       0607*       dw 0x0000 ; sample rate Hz
042588             0608*   ; vdu_play_sfx command string
042588             0609*   ; Command 4: Set waveform
042588             0610*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
042588 17 00 85    0611*       db 23,0,$85 ; vdu sound command header
04258B 01          0612*       db 1 ; channel
04258C 04          0613*       db 4 ; set waveform command
04258D 08          0614*       db 8 ; waveform 8 = sample
04258E 01 30       0615*       dw ch1_buffer ; sample bufferId
042590             0616*   ; Command 0: Play note
042590             0617*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
042590 17 00 85    0618*       db 23,0,$85 ; vdu sound command header
042593 01          0619*       db 1 ; channel
042594 00          0620*       db 0 ; play note command
042595 7F          0621*       db 127  ; volume 127 = max
042596 00 00       0622*       dw 0 ; frequency (relevant only for tuneable samples)
042598 00 00       0623*       dw 0 ; duration (ms), zero means play one time in full
04259A             0624*   ps_cmd1_end:
04259A             0625*   ; end ps_load_command_buffers
04259A             0050        include "timer_jukebox.inc"
04259A A0 8C 00    0001*   ps_prt_reload: dl [72000/2] ; 36000 = 2 ticks per second at 18.432 MHz with a 256 clock divider
04259D             0002*   
04259D             0003*   ; start PRT timer
04259D             0004*   ps_prt_start:
04259D 21 00 00 00 0005*       ld hl,0
0425A1 22 DC 25 04 0006*       ld (ps_prt_irq_counter),hl
0425A5 2A 9A 25 04 0007*       ld hl,(ps_prt_reload)
0425A9 ED 29 84    0008*       out0 (TMR1_CTL+TMR_RES_LOW),l
0425AC ED 21 85    0009*   	out0 (TMR1_CTL+TMR_RES_HIGH),h
0425AF             0010*   ; disable timer (in effect, reset it)
0425AF 3E 0E       0011*       ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_256 | RST_EN_1 | PRT_EN_0
0425B1 ED 39 83    0012*   	out0 (TMR1_CTL+TMR_REG_CTL),a
0425B4             0013*   ; enable timer,with interrupt and CONTINUOUS mode,clock divider 256
0425B4 3E 5F       0014*       ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_256 | RST_EN_1 | PRT_EN_1
0425B6 ED 39 83    0015*   	out0 (TMR1_CTL+TMR_REG_CTL),a
0425B9 C9          0016*       ret
0425BA             0017*   
0425BA             0018*   ; stop PRT timer
0425BA             0019*   ps_prt_stop:
0425BA 3E 0E       0020*       ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_256 | RST_EN_1 | PRT_EN_0
0425BC ED 39 83    0021*   	out0 (TMR1_CTL+TMR_REG_CTL),a
0425BF C9          0022*       ret
0425C0             0023*   
0425C0             0024*   ; ===============================================
0425C0             0025*   ; PRT Timer Interrupt Handling
0425C0             0026*   ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.asm
0425C0             0027*   ; -----------------------------------------------
0425C0             0028*   ps_prt_irq_init:
0425C0             0029*       ; set up interrupt vector table 2
0425C0 21 00 00 00 0030*   	ld hl,0
0425C4 3A 0C 01 00 0031*   	ld a,($10c)
0425C8 6F          0032*   	ld l,a
0425C9 3A 0D 01 00 0033*   	ld a,($10d)
0425CD 67          0034*   	ld h,a
0425CE             0035*   
0425CE             0036*   	; skip over CALL ($c3)
0425CE 23          0037*   	inc hl
0425CF             0038*   	; load address of jump into vector table 2 (in ram)
0425CF ED 27       0039*   	ld hl,(hl)
0425D1             0040*   
0425D1             0041*   	; write CALL ps_prt_irq_handler to vector table 2
0425D1 3E C3       0042*   	ld a,$c3
0425D3 77          0043*   	ld (hl),a
0425D4 23          0044*   	inc hl
0425D5 11 DD 25 04 0045*   	ld de,ps_prt_irq_handler
0425D9 ED 1F       0046*   	ld (hl),de
0425DB             0047*   
0425DB C9          0048*       ret
0425DC             0049*   ; end ps_prt_irq_init
0425DC             0050*   
0425DC             0051*   ; interrupt routine for playing the next sample
0425DC             0052*   ps_prt_irq_counter:
0425DC 00          0053*   	db 0
0425DD             0054*   ps_prt_irq_handler:
0425DD F3          0055*       di
0425DE 08          0056*       ex af,af'
0425DF D9          0057*       exx
0425E0             0058*   ; clear sysvar_keyascii
0425E0             0059*   	MOSCALL mos_sysvars
                       M1 Args: function=mos_sysvars 
0425E0 3E 08       0001*M1 			LD	A, function
0425E2 5B CF       0002*M1 			RST.LIL	08h
0425E4 AF          0060*   	xor a
0425E5 DD 77 05    0061*   	ld (IX+sysvar_keyascii),a
0425E8             0062*   ; read the timer interrupt and bump the counter
0425E8 ED 38 83    0063*       in0 a,(TMR1_CTL+TMR_REG_CTL)
0425EB 3A DC 25 04 0064*       ld a,(ps_prt_irq_counter)
0425EF 3C          0065*       inc a
0425F0 E6 01       0066*       and 1 ; modulo 2
0425F2 32 DC 25 04 0067*       ld (ps_prt_irq_counter),a
0425F6             0068*   ; if counter zero, play the next sample
0425F6 C2 04 26 04 0069*       jp nz,@F
0425FA 21 EF 1D 04 0070*       ld hl,ps_mode
0425FE CB 4E       0071*       bit ps_mode_playing,(hl)
042600 C4 78 22 04 0072*       call nz,ps_play_sample
042604             0073*   @@:
042604 D9          0074*       exx
042605 08          0075*       ex af,af'
042606 FB          0076*       ei
042607 5B ED 4D    0077*       reti.l
04260A             0078*   ; end ps_prt_irq_handler
04260A             0051        include "wav.inc"
04260A             0001*   ; WAV File Structure Offsets and Descriptions
04260A             0002*   wav_riff:          EQU 0    ; 4 bytes: "RIFF" identifier
04260A             0003*   wav_file_size:     EQU 4    ; 4 bytes: Total file size minus 8 bytes for RIFF header
04260A             0004*   wav_wave:          EQU 8    ; 4 bytes: "WAVE" identifier
04260A             0005*   wav_fmt_marker:    EQU 12   ; 4 bytes: "fmt " subchunk marker
04260A             0006*   wav_fmt_size:      EQU 16   ; 4 bytes: Format chunk size (16 for PCM)
04260A             0007*   wav_audio_format:  EQU 20   ; 2 bytes: Audio format (1 = PCM)
04260A             0008*   wav_num_channels:  EQU 22   ; 2 bytes: Number of channels (1 = mono, 2 = stereo)
04260A             0009*   wav_sample_rate:   EQU 24   ; 4 bytes: Sample rate in Hz (e.g., 32768)
04260A             0010*   wav_byte_rate:     EQU 28   ; 4 bytes: Bytes per second (SampleRate * NumChannels * BitsPerSample / 8)
04260A             0011*   wav_block_align:   EQU 32   ; 2 bytes: Bytes per sample block (NumChannels * BitsPerSample / 8)
04260A             0012*   wav_bits_per_sample: EQU 34 ; 2 bytes: Bits per sample (e.g., 8 or 16)
04260A             0013*   
04260A             0014*   ; LIST Chunk (Extra Metadata)
04260A             0015*   wav_list_marker:   EQU 36   ; 4 bytes: "LIST" marker
04260A             0016*   wav_list_size:     EQU 40   ; 4 bytes: Size of the LIST chunk (e.g., 26)
04260A             0017*   wav_info_marker:   EQU 44   ; 4 bytes: "INFO" marker
04260A             0018*   wav_isft_marker:   EQU 48   ; 4 bytes: "ISFT" marker (software identifier)
04260A             0019*   wav_isft_data:     EQU 52   ; 14 bytes: Software info string (e.g., "Lavf59.27.100")
04260A             0020*   wav_isft_padding:  EQU 66   ; 2 bytes: Padding/NULL terminator for alignment
04260A             0021*   
04260A             0022*   ; Data Chunk
04260A             0023*   wav_data_marker:   EQU 68   ; 4 bytes: "data" subchunk marker
04260A             0024*   wav_data_size:     EQU 72   ; 4 bytes: Size of the audio data in bytes
04260A             0025*   wav_data_start:    EQU 76   ; Start of audio data
04260A             0026*   wav_header_size:   EQU wav_data_start ; Total Header Size: 76 bytes
04260A             0052        include "debug.inc"
04260A             0001*   printHexA:
04260A F5          0002*       push af
04260B C5          0003*       push bc
04260C CD AE 00 04 0004*       call printHex8
042610 3E 20       0005*       ld a,' '
042612 5B D7       0006*       rst.lil 10h
042614 C1          0007*       pop bc
042615 F1          0008*       pop af
042616 C9          0009*       ret
042617             0010*   
042617             0011*   printHexHL:
042617 F5          0012*       push af
042618 C5          0013*       push bc
042619 CD A8 00 04 0014*       call printHex16
04261D 3E 20       0015*       ld a,' '
04261F 5B D7       0016*       rst.lil 10h
042621 C1          0017*       pop bc
042622 F1          0018*       pop af
042623 C9          0019*       ret
042624             0020*   
042624             0021*   printHexUHL:
042624 F5          0022*       push af
042625 C5          0023*       push bc
042626 CD A0 00 04 0024*       call printHex24
04262A 3E 20       0025*       ld a,' '
04262C 5B D7       0026*       rst.lil 10h
04262E C1          0027*       pop bc
04262F F1          0028*       pop af
042630 C9          0029*       ret
042631             0030*   
042631             0031*   printHexAUHL:
042631 F5          0032*       push af
042632 C5          0033*       push bc
042633 CD AE 00 04 0034*       call printHex8
042637 3E 2E       0035*       ld a,'.'
042639 5B D7       0036*       rst.lil 10h
04263B CD A0 00 04 0037*       call printHex24
04263F 3E 20       0038*       ld a,' '
042641 5B D7       0039*       rst.lil 10h
042643 C1          0040*       pop bc
042644 F1          0041*       pop af
042645 C9          0042*       ret
042646             0043*   
042646             0044*   printHexABHL:
042646             0045*   ; preserve registers
042646 C5          0046*       push bc ; b will be ok c will not
042647 F5          0047*       push af ; will get totally destroyed
042648             0048*   ; print a
042648 CD AE 00 04 0049*       call printHex8
04264C             0050*   ; print b
04264C 78          0051*       ld a,b
04264D CD AE 00 04 0052*       call printHex8
042651             0053*   ; print hl
042651 CD A8 00 04 0054*       call printHex16
042655             0055*   ; restore registers
042655 F1          0056*       pop af
042656 C1          0057*       pop bc
042657 C9          0058*       ret
042658             0059*   
042658             0060*   printHexBHL:
042658             0061*   ; preserve registers
042658 C5          0062*       push bc ; b will be ok c will not
042659 F5          0063*       push af ; will get totally destroyed
04265A             0064*   ; print b
04265A 78          0065*       ld a,b
04265B CD AE 00 04 0066*       call printHex8
04265F             0067*   ; print hl
04265F CD A8 00 04 0068*       call printHex16
042663             0069*   ; restore registers
042663 F1          0070*       pop af
042664 C1          0071*       pop bc
042665 C9          0072*       ret
042666             0073*   
042666             0074*   printHexCDE:
042666             0075*   ; preserve registers
042666 C5          0076*       push bc ; b will be ok c will not
042667 F5          0077*       push af ; will get totally destroyed
042668             0078*   ; print c
042668 79          0079*       ld a,c
042669 CD AE 00 04 0080*       call printHex8
04266D             0081*   ; print de
04266D EB          0082*       ex de,hl
04266E CD A8 00 04 0083*       call printHex16
042672 EB          0084*       ex de,hl
042673             0085*   ; restore registers
042673 F1          0086*       pop af
042674 C1          0087*       pop bc
042675 C9          0088*       ret
042676             0089*   
042676             0090*   printHexUIX:
042676             0091*   ; store everything in scratch
042676 22 35 03 04 0092*       ld (uhl),hl
04267A ED 43 38 03 0093*       ld (ubc),bc
       04          
04267F ED 53 3B 03 0094*       ld (ude),de
       04          
042684 DD 22 3E 03 0095*       ld (uix),ix
       04          
042689 FD 22 41 03 0096*       ld (uiy),iy
       04          
04268E F5          0097*       push af ; fml
04268F             0098*   
04268F 21 CC 02 04 0099*       ld hl,str_ixu
042693 CD 67 00 04 0100*       call printString
042697 2A 3E 03 04 0101*       ld hl,(uix)
04269B CD A0 00 04 0102*       call printHex24
04269F CD 7C 00 04 0103*       call printNewLine
0426A3             0104*   
0426A3             0105*   ; restore everything
0426A3 2A 35 03 04 0106*       ld hl, (uhl)
0426A7 ED 4B 38 03 0107*       ld bc, (ubc)
       04          
0426AC ED 5B 3B 03 0108*       ld de, (ude)
       04          
0426B1 DD 2A 3E 03 0109*       ld ix, (uix)
       04          
0426B6 FD 2A 41 03 0110*       ld iy, (uiy)
       04          
0426BB F1          0111*       pop af
0426BC             0112*   ; all done
0426BC C9          0113*       ret
0426BD             0114*   
0426BD             0115*   
0426BD             0116*   ; print registers to screen in hexidecimal format
0426BD             0117*   ; inputs: none
0426BD             0118*   ; outputs: values of every register printed to screen
0426BD             0119*   ;    values of each register in global scratch memory
0426BD             0120*   ; destroys: nothing
0426BD             0121*   stepRegistersHex:
0426BD             0122*   ; store everything in scratch
0426BD 22 35 03 04 0123*       ld (uhl),hl
0426C1 ED 43 38 03 0124*       ld (ubc),bc
       04          
0426C6 ED 53 3B 03 0125*       ld (ude),de
       04          
0426CB DD 22 3E 03 0126*       ld (uix),ix
       04          
0426D0 FD 22 41 03 0127*       ld (uiy),iy
       04          
0426D5 F5          0128*       push af ; fml
0426D6 E1          0129*       pop hl ; thanks, zilog
0426D7 22 32 03 04 0130*       ld (uaf),hl
0426DB F5          0131*       push af ; dammit
0426DC             0132*   
0426DC             0133*   ; home the cursor
0426DC             0134*       ; call vdu_home_cursor
0426DC             0135*   
0426DC             0136*   ; print each register
0426DC 21 B8 02 04 0137*       ld hl,str_afu
0426E0 CD 67 00 04 0138*       call printString
0426E4 2A 32 03 04 0139*       ld hl,(uaf)
0426E8 CD A0 00 04 0140*       call printHex24
0426EC CD 7C 00 04 0141*       call printNewLine
0426F0             0142*   
0426F0 21 BD 02 04 0143*       ld hl,str_hlu
0426F4 CD 67 00 04 0144*       call printString
0426F8 2A 35 03 04 0145*       ld hl,(uhl)
0426FC CD A0 00 04 0146*       call printHex24
042700 CD 7C 00 04 0147*       call printNewLine
042704             0148*   
042704 21 C2 02 04 0149*       ld hl,str_bcu
042708 CD 67 00 04 0150*       call printString
04270C 2A 38 03 04 0151*       ld hl,(ubc)
042710 CD A0 00 04 0152*       call printHex24
042714 CD 7C 00 04 0153*       call printNewLine
042718             0154*   
042718 21 C7 02 04 0155*       ld hl,str_deu
04271C CD 67 00 04 0156*       call printString
042720 2A 3B 03 04 0157*       ld hl,(ude)
042724 CD A0 00 04 0158*       call printHex24
042728 CD 7C 00 04 0159*       call printNewLine
04272C             0160*   
04272C 21 CC 02 04 0161*       ld hl,str_ixu
042730 CD 67 00 04 0162*       call printString
042734 2A 3E 03 04 0163*       ld hl,(uix)
042738 CD A0 00 04 0164*       call printHex24
04273C CD 7C 00 04 0165*       call printNewLine
042740             0166*   
042740 21 D1 02 04 0167*       ld hl,str_iyu
042744 CD 67 00 04 0168*       call printString
042748 2A 41 03 04 0169*       ld hl,(uiy)
04274C CD A0 00 04 0170*       call printHex24
042750 CD 7C 00 04 0171*       call printNewLine
042754             0172*   
042754             0173*       ; call vsync
042754             0174*   
042754 CD 7C 00 04 0175*       call printNewLine
042758             0176*   
042758             0177*   ; check for right shift key and quit if pressed
042758             0178*       MOSCALL mos_getkbmap
                       M1 Args: function=mos_getkbmap 
042758 3E 1E       0001*M1 			LD	A, function
04275A 5B CF       0002*M1 			RST.LIL	08h
04275C             0179*   @stayhere:
04275C             0180*   ; 7 RightShift
04275C DD CB 00 76 0181*       bit 6,(ix+0)
042760 20 02       0182*       jr nz,@RightShift
042762 18 F8       0183*       jr @stayhere
042764             0184*   @RightShift:
042764 DD CB 0E 86 0185*       res 0,(ix+14) ; debounce the key (hopefully)
042768 3E 80       0186*       ld a,%10000000
04276A             0187*       ; call multiPurposeDelay
04276A             0188*   
04276A             0189*   ; restore everything
04276A 2A 35 03 04 0190*       ld hl, (uhl)
04276E ED 4B 38 03 0191*       ld bc, (ubc)
       04          
042773 ED 5B 3B 03 0192*       ld de, (ude)
       04          
042778 DD 2A 3E 03 0193*       ld ix, (uix)
       04          
04277D FD 2A 41 03 0194*       ld iy, (uiy)
       04          
042782 F1          0195*       pop af
042783             0196*   ; all done
042783 C9          0197*       ret
042784             0198*   
042784             0199*   ; print registers to screen in hexidecimal format
042784             0200*   ; inputs: none
042784             0201*   ; outputs: values of every register printed to screen
042784             0202*   ;    values of each register in global scratch memory
042784             0203*   ; destroys: nothing
042784             0204*   dumpRegistersHex:
042784             0205*   ; store everything in scratch
042784 22 35 03 04 0206*       ld (uhl),hl
042788 ED 43 38 03 0207*       ld (ubc),bc
       04          
04278D ED 53 3B 03 0208*       ld (ude),de
       04          
042792 DD 22 3E 03 0209*       ld (uix),ix
       04          
042797 FD 22 41 03 0210*       ld (uiy),iy
       04          
04279C F5          0211*       push af ; fml
04279D E1          0212*       pop hl ; thanks, zilog
04279E 22 32 03 04 0213*       ld (uaf),hl
0427A2 F5          0214*       push af ; dammit
0427A3             0215*   
0427A3             0216*   ; home the cursor
0427A3             0217*       ; call vdu_home_cursor
0427A3             0218*       ; call printNewLine
0427A3             0219*   
0427A3             0220*   ; print each register
0427A3 21 B8 02 04 0221*       ld hl,str_afu
0427A7 CD 67 00 04 0222*       call printString
0427AB 2A 32 03 04 0223*       ld hl,(uaf)
0427AF CD A0 00 04 0224*       call printHex24
0427B3 CD 7C 00 04 0225*       call printNewLine
0427B7             0226*   
0427B7 21 BD 02 04 0227*       ld hl,str_hlu
0427BB CD 67 00 04 0228*       call printString
0427BF 2A 35 03 04 0229*       ld hl,(uhl)
0427C3 CD A0 00 04 0230*       call printHex24
0427C7 CD 7C 00 04 0231*       call printNewLine
0427CB             0232*   
0427CB 21 C2 02 04 0233*       ld hl,str_bcu
0427CF CD 67 00 04 0234*       call printString
0427D3 2A 38 03 04 0235*       ld hl,(ubc)
0427D7 CD A0 00 04 0236*       call printHex24
0427DB CD 7C 00 04 0237*       call printNewLine
0427DF             0238*   
0427DF 21 C7 02 04 0239*       ld hl,str_deu
0427E3 CD 67 00 04 0240*       call printString
0427E7 2A 3B 03 04 0241*       ld hl,(ude)
0427EB CD A0 00 04 0242*       call printHex24
0427EF CD 7C 00 04 0243*       call printNewLine
0427F3             0244*   
0427F3 21 CC 02 04 0245*       ld hl,str_ixu
0427F7 CD 67 00 04 0246*       call printString
0427FB 2A 3E 03 04 0247*       ld hl,(uix)
0427FF CD A0 00 04 0248*       call printHex24
042803 CD 7C 00 04 0249*       call printNewLine
042807             0250*   
042807 21 D1 02 04 0251*       ld hl,str_iyu
04280B CD 67 00 04 0252*       call printString
04280F 2A 41 03 04 0253*       ld hl,(uiy)
042813 CD A0 00 04 0254*       call printHex24
042817             0255*   
042817 CD 7C 00 04 0256*       call printNewLine
04281B CD 7C 00 04 0257*       call printNewLine
04281F             0258*   ; restore everything
04281F 2A 35 03 04 0259*       ld hl, (uhl)
042823 ED 4B 38 03 0260*       ld bc, (ubc)
       04          
042828 ED 5B 3B 03 0261*       ld de, (ude)
       04          
04282D DD 2A 3E 03 0262*       ld ix, (uix)
       04          
042832 FD 2A 41 03 0263*       ld iy, (uiy)
       04          
042837 F1          0264*       pop af
042838             0265*   ; all done
042838 C9          0266*       ret
042839             0267*   
042839             0268*   dumpRegistersHexPrime:
042839 D9          0269*       exx
04283A 08          0270*       ex af,af'
04283B CD 84 27 04 0271*       call dumpRegistersHex
04283F 08          0272*       ex af,af'
042840 D9          0273*       exx
042841 C9          0274*       ret
042842             0275*   
042842             0276*   ; additionally dump prime registers
042842             0277*   ; inputs: none
042842             0278*   ; outputs: values of every register printed to screen
042842             0279*   ; destroys: nothing
042842             0280*   dumpRegistersHexAll:
042842 CD 84 27 04 0281*       call dumpRegistersHex
042846 08          0282*       ex af,af'
042847 D9          0283*       exx
042848 CD 84 27 04 0284*       call dumpRegistersHex
04284C 08          0285*       ex af,af'
04284D D9          0286*       exx
04284E C9          0287*       ret
04284F             0288*   
04284F             0289*   ; print hlu to screen in hexidecimal format
04284F             0290*   ; inputs: none
04284F             0291*   ; destroys: nothing
04284F             0292*   print_hex_hl:
04284F F5          0293*       push af
042850 E5          0294*       push hl
042851 21 BD 02 04 0295*       ld hl,str_hlu
042855 CD 67 00 04 0296*       call printString
042859 E1          0297*       pop hl
04285A E5          0298*       push hl
04285B CD A0 00 04 0299*       call printHex24
04285F 3E 20       0300*       ld a,' '
042861 5B D7       0301*       rst.lil 10h
042863 E1          0302*       pop hl
042864 F1          0303*       pop af
042865 C9          0304*       ret
042866             0305*   
042866             0306*   ; print bcu to screen in hexidecimal format
042866             0307*   ; inputs: none
042866             0308*   ; destroys: nothing
042866             0309*   print_hex_bc:
042866 F5          0310*       push af
042867 E5          0311*       push hl
042868 C5          0312*       push bc
042869 21 C2 02 04 0313*       ld hl,str_bcu
04286D CD 67 00 04 0314*       call printString
042871 E1          0315*       pop hl
042872 E5          0316*       push hl
042873 CD A0 00 04 0317*       call printHex24
042877 3E 20       0318*       ld a,' '
042879 5B D7       0319*       rst.lil 10h
04287B C1          0320*       pop bc
04287C E1          0321*       pop hl
04287D F1          0322*       pop af
04287E C9          0323*       ret
04287F             0324*   
04287F             0325*   ; print deu to screen in hexidecimal format
04287F             0326*   ; inputs: none
04287F             0327*   ; destroys: nothing
04287F             0328*   print_hex_de:
04287F F5          0329*       push af
042880 E5          0330*       push hl
042881 D5          0331*       push de
042882 21 C7 02 04 0332*       ld hl,str_deu
042886 CD 67 00 04 0333*       call printString
04288A E1          0334*       pop hl
04288B E5          0335*       push hl
04288C CD A0 00 04 0336*       call printHex24
042890 3E 20       0337*       ld a,' '
042892 5B D7       0338*       rst.lil 10h
042894 D1          0339*       pop de
042895 E1          0340*       pop hl
042896 F1          0341*       pop af
042897 C9          0342*       ret
042898             0343*   
042898             0344*   
042898             0345*   ; inputs: whatever is in the flags register
042898             0346*   ; outputs: binary representation of flags
042898             0347*   ;          with a header so we know which is what
042898             0348*   ; destroys: nothing
042898             0349*   ; preserves: everything
042898             0350*   dumpFlags:
042898             0351*   ; first we curse zilog for not giving direct access to flags
042898 F5          0352*       push af ; this is so we can send it back unharmed
042899 F5          0353*       push af ; this is so we can pop it to hl
04289A             0354*   ; store everything in scratch
04289A 22 35 03 04 0355*       ld (uhl),hl
04289E ED 43 38 03 0356*       ld (ubc),bc
       04          
0428A3 ED 53 3B 03 0357*       ld (ude),de
       04          
0428A8 DD 22 3E 03 0358*       ld (uix),ix
       04          
0428AD FD 22 41 03 0359*       ld (uiy),iy
       04          
0428B2             0360*   ; next we print the header
0428B2 21 DE 28 04 0361*       ld hl,@header
0428B6 CD 67 00 04 0362*       call printString
0428BA E1          0363*       pop hl ; flags are now in l
0428BB 7D          0364*       ld a,l ; flags are now in a
0428BC CD 6E 02 04 0365*       call printBin8
0428C0 CD 7C 00 04 0366*       call printNewLine
0428C4             0367*   ; restore everything
0428C4 2A 35 03 04 0368*       ld hl, (uhl)
0428C8 ED 4B 38 03 0369*       ld bc, (ubc)
       04          
0428CD ED 5B 3B 03 0370*       ld de, (ude)
       04          
0428D2 DD 2A 3E 03 0371*       ld ix, (uix)
       04          
0428D7 FD 2A 41 03 0372*       ld iy, (uiy)
       04          
0428DC F1          0373*       pop af ; send her home the way she came
0428DD C9          0374*       ret
0428DE             0375*   ; Bit 7 (S): Sign flag
0428DE             0376*   ; Bit 6 (Z): Zero flag
0428DE             0377*   ; Bit 5 (5): Reserved (copy of bit 5 of the result)
0428DE             0378*   ; Bit 4 (H): Half Carry flag
0428DE             0379*   ; Bit 3 (3): Reserved (copy of bit 3 of the result)
0428DE             0380*   ; Bit 2 (PV): Parity/Overflow flag
0428DE             0381*   ; Bit 1 (N): Subtract flag
0428DE             0382*   ; Bit 0 (C): Carry flag
0428DE 53 5A 78 48 0383*   @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
0428E9             0384*   
0428E9             0385*   
0428E9             0386*   ; print bytes from an address to the screen in hexidecimal format
0428E9             0387*   ; inputs: hl = address of first byte to print, a = number of bytes to print
0428E9             0388*   ; outputs: values of each byte printed to screen separated by spaces
0428E9             0389*   ; destroys: nothing
0428E9             0390*   dumpMemoryHex:
0428E9             0391*   ; save registers to the stack
0428E9 C5          0392*       push bc
0428EA E5          0393*       push hl
0428EB F5          0394*       push af
0428EC             0395*   
0428EC             0396*   ; print the address and separator
0428EC CD A0 00 04 0397*       call printHex24
0428F0 3E 3A       0398*       ld a,':'
0428F2 5B D7       0399*       rst.lil 10h
0428F4 3E 20       0400*       ld a,' '
0428F6 5B D7       0401*       rst.lil 10h
0428F8             0402*   
0428F8             0403*   ; set b to be our loop counter
0428F8 F1          0404*       pop af
0428F9 47          0405*       ld b,a
0428FA E1          0406*       pop hl
0428FB E5          0407*       push hl
0428FC F5          0408*       push af
0428FD             0409*   @loop:
0428FD             0410*   ; print the byte
0428FD 7E          0411*       ld a,(hl)
0428FE CD AE 00 04 0412*       call printHex8
042902             0413*   ; print a space
042902 3E 20       0414*       ld a,' '
042904 5B D7       0415*       rst.lil 10h
042906 23          0416*       inc hl
042907 10 F4       0417*       djnz @loop
042909             0418*       ; call printNewLine
042909             0419*   
042909             0420*   ; restore everything
042909 F1          0421*       pop af
04290A E1          0422*       pop hl
04290B C1          0423*       pop bc
04290C             0424*   
04290C             0425*   ; all done
04290C C9          0426*       ret
04290D             0427*   
04290D             0428*   
04290D             0429*   ; print bytes from an address to the screen in binary format
04290D             0430*   ; inputs: hl = address of first byte to print, a = number of bytes to print
04290D             0431*   ; outputs: values of each byte printed to screen separated by spaces
04290D             0432*   ; destroys: nothing
04290D             0433*   dumpMemoryBin:
04290D             0434*   ; save all registers to the stack
04290D F5          0435*       push af
04290E C5          0436*       push bc
04290F D5          0437*       push de
042910 E5          0438*       push hl
042911 DD E5       0439*       push ix
042913 FD E5       0440*       push iy
042915             0441*   
042915             0442*   ; set b to be our loop counter
042915 47          0443*       ld b,a
042916             0444*   @loop:
042916             0445*   ; print the byte
042916 7E          0446*       ld a,(hl)
042917 E5          0447*       push hl
042918 C5          0448*       push bc
042919 CD 6E 02 04 0449*       call printBin8
04291D C1          0450*       pop bc
04291E             0451*   ; print a space
04291E 3E 20       0452*       ld a,' '
042920 5B D7       0453*       rst.lil 10h
042922 E1          0454*       pop hl
042923 23          0455*       inc hl
042924 10 F0       0456*       djnz @loop
042926 CD 7C 00 04 0457*       call printNewLine
04292A             0458*   
04292A             0459*   ; restore everything
04292A FD E1       0460*       pop iy
04292C DD E1       0461*       pop ix
04292E E1          0462*       pop hl
04292F D1          0463*       pop de
042930 C1          0464*       pop bc
042931 F1          0465*       pop af
042932             0466*   ; all done
042932 C9          0467*       ret
042933             0468*   
042933             0469*   ; print bytes from an address to the screen in binary format
042933             0470*   ; with the bits of each byte in reverse order (lsb first)
042933             0471*   ; inputs: hl = address of first byte to print, a = number of bytes to print
042933             0472*   ; outputs: values of each byte printed to screen separated by spaces
042933             0473*   ; destroys: nothing
042933             0474*   dumpMemoryBinRev:
042933             0475*   ; save all registers to the stack
042933 F5          0476*       push af
042934 C5          0477*       push bc
042935 D5          0478*       push de
042936 E5          0479*       push hl
042937 DD E5       0480*       push ix
042939 FD E5       0481*       push iy
04293B             0482*   
04293B             0483*   ; set b to be our loop counter
04293B 47          0484*       ld b,a
04293C             0485*   @loop:
04293C             0486*   ; print the byte
04293C 7E          0487*       ld a,(hl)
04293D E5          0488*       push hl
04293E C5          0489*       push bc
04293F CD 93 02 04 0490*       call printBin8Rev
042943 C1          0491*       pop bc
042944             0492*   ; print a space
042944 3E 20       0493*       ld a,' '
042946 5B D7       0494*       rst.lil 10h
042948 E1          0495*       pop hl
042949 23          0496*       inc hl
04294A 10 F0       0497*       djnz @loop
04294C CD 7C 00 04 0498*       call printNewLine
042950             0499*   
042950             0500*   ; restore everything
042950 FD E1       0501*       pop iy
042952 DD E1       0502*       pop ix
042954 E1          0503*       pop hl
042955 D1          0504*       pop de
042956 C1          0505*       pop bc
042957 F1          0506*       pop af
042958             0507*   ; all done
042958 C9          0508*       ret
042959             0509*   
042959             0510*   DEBUG_PRINT:
042959             0511*       PUSH_ALL
                       M1 Args: none
042959 08          0001*M1     ex af,af'
04295A D9          0002*M1     exx
04295B F5          0003*M1     push af
04295C E5          0004*M1     push hl
04295D C5          0005*M1     push bc
04295E D5          0006*M1     push de
04295F             0007*M1 
04295F 08          0008*M1     ex af,af'
042960 D9          0009*M1     exx
042961 F5          0010*M1     push af
042962 E5          0011*M1     push hl
042963 C5          0012*M1     push bc
042964 D5          0013*M1     push de
042965 DD E5       0014*M1     push ix
042967 FD E5       0015*M1     push iy
042969             0512*       ; ld c,0 ; X
042969             0513*       ; ld b,0 ; Y
042969             0514*       ; call vdu_move_cursor
042969 CD 7C 00 04 0515*       call printNewLine
04296D             0516*       POP_ALL
                       M1 Args: none
04296D FD E1       0001*M1     pop iy
04296F DD E1       0002*M1     pop ix
042971 D1          0003*M1     pop de
042972 C1          0004*M1     pop bc
042973 E1          0005*M1     pop hl
042974 F1          0006*M1     pop af
042975 08          0007*M1     ex af,af'
042976 D9          0008*M1     exx
042977             0009*M1 
042977 D1          0010*M1     pop de
042978 C1          0011*M1     pop bc
042979 E1          0012*M1     pop hl
04297A F1          0013*M1     pop af
04297B 08          0014*M1     ex af,af'
04297C D9          0015*M1     exx
04297D             0517*       PUSH_ALL
                       M1 Args: none
04297D 08          0001*M1     ex af,af'
04297E D9          0002*M1     exx
04297F F5          0003*M1     push af
042980 E5          0004*M1     push hl
042981 C5          0005*M1     push bc
042982 D5          0006*M1     push de
042983             0007*M1 
042983 08          0008*M1     ex af,af'
042984 D9          0009*M1     exx
042985 F5          0010*M1     push af
042986 E5          0011*M1     push hl
042987 C5          0012*M1     push bc
042988 D5          0013*M1     push de
042989 DD E5       0014*M1     push ix
04298B FD E5       0015*M1     push iy
04298D CD 98 28 04 0518*       call dumpFlags
042991             0519*       POP_ALL
                       M1 Args: none
042991 FD E1       0001*M1     pop iy
042993 DD E1       0002*M1     pop ix
042995 D1          0003*M1     pop de
042996 C1          0004*M1     pop bc
042997 E1          0005*M1     pop hl
042998 F1          0006*M1     pop af
042999 08          0007*M1     ex af,af'
04299A D9          0008*M1     exx
04299B             0009*M1 
04299B D1          0010*M1     pop de
04299C C1          0011*M1     pop bc
04299D E1          0012*M1     pop hl
04299E F1          0013*M1     pop af
04299F 08          0014*M1     ex af,af'
0429A0 D9          0015*M1     exx
0429A1             0520*       PUSH_ALL
                       M1 Args: none
0429A1 08          0001*M1     ex af,af'
0429A2 D9          0002*M1     exx
0429A3 F5          0003*M1     push af
0429A4 E5          0004*M1     push hl
0429A5 C5          0005*M1     push bc
0429A6 D5          0006*M1     push de
0429A7             0007*M1 
0429A7 08          0008*M1     ex af,af'
0429A8 D9          0009*M1     exx
0429A9 F5          0010*M1     push af
0429AA E5          0011*M1     push hl
0429AB C5          0012*M1     push bc
0429AC D5          0013*M1     push de
0429AD DD E5       0014*M1     push ix
0429AF FD E5       0015*M1     push iy
0429B1 CD 84 27 04 0521*       call dumpRegistersHex
0429B5             0522*       ; call waitKeypress
0429B5 CD 7C 00 04 0523*       call printNewLine
0429B9             0524*       POP_ALL
                       M1 Args: none
0429B9 FD E1       0001*M1     pop iy
0429BB DD E1       0002*M1     pop ix
0429BD D1          0003*M1     pop de
0429BE C1          0004*M1     pop bc
0429BF E1          0005*M1     pop hl
0429C0 F1          0006*M1     pop af
0429C1 08          0007*M1     ex af,af'
0429C2 D9          0008*M1     exx
0429C3             0009*M1 
0429C3 D1          0010*M1     pop de
0429C4 C1          0011*M1     pop bc
0429C5 E1          0012*M1     pop hl
0429C6 F1          0013*M1     pop af
0429C7 08          0014*M1     ex af,af'
0429C8 D9          0015*M1     exx
0429C9 C9          0525*       ret
0429CA             0526*   DEBUG_WAITKEYPRESS:
0429CA             0527*       PUSH_ALL
                       M1 Args: none
0429CA 08          0001*M1     ex af,af'
0429CB D9          0002*M1     exx
0429CC F5          0003*M1     push af
0429CD E5          0004*M1     push hl
0429CE C5          0005*M1     push bc
0429CF D5          0006*M1     push de
0429D0             0007*M1 
0429D0 08          0008*M1     ex af,af'
0429D1 D9          0009*M1     exx
0429D2 F5          0010*M1     push af
0429D3 E5          0011*M1     push hl
0429D4 C5          0012*M1     push bc
0429D5 D5          0013*M1     push de
0429D6 DD E5       0014*M1     push ix
0429D8 FD E5       0015*M1     push iy
0429DA CD 5A 03 04 0528*       call waitKeypress
0429DE             0529*       POP_ALL
                       M1 Args: none
0429DE FD E1       0001*M1     pop iy
0429E0 DD E1       0002*M1     pop ix
0429E2 D1          0003*M1     pop de
0429E3 C1          0004*M1     pop bc
0429E4 E1          0005*M1     pop hl
0429E5 F1          0006*M1     pop af
0429E6 08          0007*M1     ex af,af'
0429E7 D9          0008*M1     exx
0429E8             0009*M1 
0429E8 D1          0010*M1     pop de
0429E9 C1          0011*M1     pop bc
0429EA E1          0012*M1     pop hl
0429EB F1          0013*M1     pop af
0429EC 08          0014*M1     ex af,af'
0429ED D9          0015*M1     exx
0429EE C9          0530*       RET
0429EF             0531*   
0429EF             0532*   dumpVduCmdStr:
0429EF             0533*       PUSH_ALL
                       M1 Args: none
0429EF 08          0001*M1     ex af,af'
0429F0 D9          0002*M1     exx
0429F1 F5          0003*M1     push af
0429F2 E5          0004*M1     push hl
0429F3 C5          0005*M1     push bc
0429F4 D5          0006*M1     push de
0429F5             0007*M1 
0429F5 08          0008*M1     ex af,af'
0429F6 D9          0009*M1     exx
0429F7 F5          0010*M1     push af
0429F8 E5          0011*M1     push hl
0429F9 C5          0012*M1     push bc
0429FA D5          0013*M1     push de
0429FB DD E5       0014*M1     push ix
0429FD FD E5       0015*M1     push iy
0429FF 79          0534*       ld a,c
042A00 CD E9 28 04 0535*       call dumpMemoryHex
042A04 CD 5A 03 04 0536*       call waitKeypress
042A08             0537*       POP_ALL
                       M1 Args: none
042A08 FD E1       0001*M1     pop iy
042A0A DD E1       0002*M1     pop ix
042A0C D1          0003*M1     pop de
042A0D C1          0004*M1     pop bc
042A0E E1          0005*M1     pop hl
042A0F F1          0006*M1     pop af
042A10 08          0007*M1     ex af,af'
042A11 D9          0008*M1     exx
042A12             0009*M1 
042A12 D1          0010*M1     pop de
042A13 C1          0011*M1     pop bc
042A14 E1          0012*M1     pop hl
042A15 F1          0013*M1     pop af
042A16 08          0014*M1     ex af,af'
042A17 D9          0015*M1     exx
042A18 C9          0538*       ret
042A19             0539*   ; end dumpVduCmdStr
042A19             0053    
042A19             0054    ; --- MAIN PROGRAM FILE ---
042A19 00          0055    original_screen_mode: db 0
042A1A             0056    
042A1A             0057    init:
042A1A C9          0058        ret
042A1B             0059    ; end init
042A1B 2D 2D 2D 2D 0060    str_dashes: asciz "------------------------------"
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 00    
042A3A 3D 3D 3D 3D 0061    str_thick_dashes: asciz "=============================="
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 00    
042A59             0062    
042A59             0063    main:
042A59             0064    ; initialize the current directory
042A59 CD 7C 2A 04 0065        call get_dir
042A5D             0066    
042A5D             0067    ; list all the files in the directory
042A5D CD 60 00 04 0068        call printInline
042A61 0D 0A 46 69 0069        asciz "\r\nFiles in directory\r\n"
       6C 65 73 20 
       69 6E 20 64 
       69 72 65 63 
       74 6F 72 79 
       0D 0A 00    
042A78 CD 91 2B 04 0070        call print_dir
042A7C             0071    ; end main
042A7C             0072    
042A7C             0073    get_dir:
042A7C             0074    ; reset filecounter
042A7C 21 00 00 00 0075        ld hl,0
042A80 22 F7 1F 04 0076        ld (ps_dir_num_files),hl
042A84             0077    ; initialize pointers to store directory info
042A84 21 F7 1D 04 0078        ld hl,ps_dir_path  ; where to store result
042A88 01 FF 00 00 0079        ld bc,255          ; max length (final byte is zero terminator)
042A8C             0080        MOSCALL ffs_getcwd ; MOS api get current working directory
                       M1 Args: function=ffs_getcwd 
042A8C 3E 9E       0001M1  			LD	A, function
042A8E 5B CF       0002M1  			RST.LIL	08h
042A90             0081    ; now get dir info
042A90 21 46 20 04 0082        ld hl,ps_dir_struct ; define where to store directory info
042A94 11 F7 1D 04 0083        ld de,ps_dir_path   ; this is pointer to the path to the directory
042A98             0084        MOSCALL ffs_dopen   ; open dir
                       M1 Args: function=ffs_dopen 
042A98 3E 91       0001M1  			LD	A, function
042A9A 5B CF       0002M1  			RST.LIL	08h
042A9C             0085    ; set up pointers
042A9C DD 21 00 00 0086        ld ix,ps_dir_fil_list ; this is the pointer to the fileinfo table
       06          
042AA1             0087    @readFileInfo:               ; we will loop here until all files have been processed
042AA1 21 46 20 04 0088        ld hl,ps_dir_struct      ; HL is where to get directory info
042AA5 DD E5       0089        push ix
042AA7 D1          0090        pop de ; where to store current file info
042AA8             0091        MOSCALL ffs_dread        ; read next item from dir
                       M1 Args: function=ffs_dread 
042AA8 3E 93       0001M1  			LD	A, function
042AAA 5B CF       0002M1  			RST.LIL	08h
042AAC             0092    
042AAC DD 7E 16    0093        ld a,(ix+filinfo_fname)  ; get first char of file name
042AAF B7          0094        or a                     ; if zero then we are at the end of the listing
042AB0 CA E2 2A 04 0095        jp z,@allDone
042AB4             0096    
042AB4 DD 7E 08    0097        ld a,(ix+filinfo_fattrib) ; get the file attribute
042AB7 CB AF       0098        res 5,a ; clear bit 5 (archive) see: https://discord.com/channels/1158535358624039014/1158536667670511726/1328466726098309173
042AB9 B7          0099        or a ; if zero this is a file
042ABA C2 C3 2A 04 0100        jp nz,@F ; not zero so this is some other file type
042ABE CB EF       0101        set 5,a ; set bit 5 (archive) so will be consistent btw emulator and hardware
042AC0 DD 77 08    0102        ld (ix+filinfo_fattrib),a ; update so we don't have to do this every time downstream
042AC3             0103    
042AC3             0104    @@: ; skip over writing hidden and system files
042AC3 E6 02       0105        and AM_HID ; hidden file
042AC5 C2 A1 2A 04 0106        jp nz,@readFileInfo
042AC9 E6 04       0107        and AM_SYS ; system file
042ACB C2 A1 2A 04 0108        jp nz,@readFileInfo
042ACF             0109    
042ACF             0110    ; valid file or directory
042ACF 2A F7 1F 04 0111        ld hl,(ps_dir_num_files) ; get the current file counter
042AD3 23          0112        inc hl                  ; increment the counter
042AD4 22 F7 1F 04 0113        ld (ps_dir_num_files),hl
042AD8 11 16 01 00 0114        ld de,filinfo_struct_size ; length of fileinfo record
042ADC DD 19       0115        add ix,de ; point to next fileinfo record
042ADE             0116    
042ADE C3 A1 2A 04 0117        jp @readFileInfo         ; loop around to check next entry
042AE2             0118    @allDone:
042AE2             0119    ; compute page statistics
042AE2 2A F7 1F 04 0120        ld hl,(ps_dir_num_files) ; get the number of files
042AE6 11 0A 00 00 0121        ld de,10 ; max files per page
042AEA CD 80 03 04 0122        call udiv24 ; de = hl/10, hl = mod(hl,10)
042AEE             0123        SIGN_HLU ; check remainder for zero
                       M1 Args: none
042AEE 19          0001M1      add hl,de ; 1 cycle
042AEF B7          0002M1      or a ; clear flags ; 1 cycle
042AF0 ED 52       0003M1      sbc hl,de ; 2 cycles
042AF2             0004M1      ; 4 cycles total
042AF2 CA F7 2A 04 0124        jp z,@F ; if zero then we have exactly 10 files
042AF6 13          0125        inc de ; bump the page count
042AF7             0126    @@:
042AF7 ED 53 FA 1F 0127        ld (ps_dir_num_pages),de ; save the number of pages
       04          
042AFC 22 00 20 04 0128        ld (ps_pagelast_num_files),hl ; save the number of files on the last page
042B00             0129    ; reset the song index and page to zero and populate the page filename pointers
042B00 AF          0130        xor a
042B01 32 06 20 04 0131        ld (ps_song_idx_cur),a
042B05 21 00 00 00 0132        ld hl,0
042B09 22 03 20 04 0133        ld (ps_page_cur),hl
042B0D CD 3C 23 04 0134        call ps_fill_page_fn_ptrs
042B11             0135    ; close the directory
042B11 21 46 20 04 0136        ld hl,ps_dir_struct      ; load H: with address of the DIR struct
042B15             0137        MOSCALL ffs_dclose       ; close dir
                       M1 Args: function=ffs_dclose 
042B15 3E 92       0001M1  			LD	A, function
042B17 5B CF       0002M1  			RST.LIL	08h
042B19             0138    
042B19             0139    ; DEBUG
042B19 CD 7C 00 04 0140        call printNewLine
042B1D CD 60 00 04 0141        call printInline
042B21 4E 75 6D 62 0142        asciz "Number of files: "
       65 72 20 6F 
       66 20 66 69 
       6C 65 73 3A 
       20 00       
042B33 2A F7 1F 04 0143        ld hl,(ps_dir_num_files)
042B37 CD 24 26 04 0144        call printHexUHL
042B3B             0145    
042B3B CD 7C 00 04 0146        call printNewLine
042B3F CD 60 00 04 0147        call printInline
042B43 4E 75 6D 62 0148        asciz "Number of pages: "
       65 72 20 6F 
       66 20 70 61 
       67 65 73 3A 
       20 00       
042B55 2A FA 1F 04 0149        ld hl,(ps_dir_num_pages)
042B59 CD 24 26 04 0150        call printHexUHL
042B5D             0151    
042B5D CD 7C 00 04 0152        call printNewLine
042B61 CD 60 00 04 0153        call printInline
042B65 4E 75 6D 62 0154        asciz "Number of files on last page: "
       65 72 20 6F 
       66 20 66 69 
       6C 65 73 20 
       6F 6E 20 6C 
       61 73 74 20 
       70 61 67 65 
       3A 20 00    
042B84 2A 00 20 04 0155        ld hl,(ps_pagelast_num_files)
042B88 CD 24 26 04 0156        call printHexUHL
042B8C CD 7C 00 04 0157        call printNewLine
042B90             0158    ; END DEBUG
042B90 C9          0159        ret
042B91             0160    ; end get_dir
042B91             0161    
042B91             0162    print_dir:
042B91             0163    ; test whether there are any files in the directory
042B91 2A F7 1F 04 0164        ld hl,(ps_dir_num_files)
042B95             0165        SIGN_HLU
                       M1 Args: none
042B95 19          0001M1      add hl,de ; 1 cycle
042B96 B7          0002M1      or a ; clear flags ; 1 cycle
042B97 ED 52       0003M1      sbc hl,de ; 2 cycles
042B99             0004M1      ; 4 cycles total
042B99 C8          0166        ret z ; if zero, no files in the directory
042B9A             0167    ; loop through the fileinfo table and print out the filenames
042B9A DD 21 00 00 0168        ld ix,ps_dir_fil_list
       06          
042B9F 2A F7 1F 04 0169        ld hl,(ps_dir_num_files)
042BA3             0170    @print_loop:
042BA3 E5          0171        push hl ; loop counter
042BA4             0172    ; branch on the file attribute
042BA4 DD 7E 08    0173        ld a,(ix+filinfo_fattrib)
042BA7             0174    ; DEBUG
042BA7             0175        PUSH_ALL
                       M1 Args: none
042BA7 08          0001M1      ex af,af'
042BA8 D9          0002M1      exx
042BA9 F5          0003M1      push af
042BAA E5          0004M1      push hl
042BAB C5          0005M1      push bc
042BAC D5          0006M1      push de
042BAD             0007M1  
042BAD 08          0008M1      ex af,af'
042BAE D9          0009M1      exx
042BAF F5          0010M1      push af
042BB0 E5          0011M1      push hl
042BB1 C5          0012M1      push bc
042BB2 D5          0013M1      push de
042BB3 DD E5       0014M1      push ix
042BB5 FD E5       0015M1      push iy
042BB7 CD 6E 02 04 0176        call printBin8
042BBB 3E 20       0177        ld a,' '
042BBD 5B D7       0178        rst.lil 10h
042BBF             0179        POP_ALL
                       M1 Args: none
042BBF FD E1       0001M1      pop iy
042BC1 DD E1       0002M1      pop ix
042BC3 D1          0003M1      pop de
042BC4 C1          0004M1      pop bc
042BC5 E1          0005M1      pop hl
042BC6 F1          0006M1      pop af
042BC7 08          0007M1      ex af,af'
042BC8 D9          0008M1      exx
042BC9             0009M1  
042BC9 D1          0010M1      pop de
042BCA C1          0011M1      pop bc
042BCB E1          0012M1      pop hl
042BCC F1          0013M1      pop af
042BCD 08          0014M1      ex af,af'
042BCE D9          0015M1      exx
042BCF             0180    ; END DEBUG
042BCF FE 10       0181        cp AM_DIR ; if zero, is directory
042BD1 C2 E0 2B 04 0182        jp nz,@print_file ; not directory so just write filename
042BD5 CD 60 00 04 0183        call printInline
042BD9 3C 44 49 52 0184        asciz "<DIR> "
       3E 20 00    
042BE0             0185    @print_file:
042BE0 ED 32 16    0186        lea ix,ix+filinfo_fname ; point to filinfo_fname
042BE3 DD E5       0187        push ix
042BE5 E1          0188        pop hl ; get the address of the filename
042BE6 CD 67 00 04 0189        call printString
042BEA CD 7C 00 04 0190        call printNewLine
042BEE 11 00 01 00 0191        ld de,256 ; length of filename
042BF2 DD 19       0192        add ix,de ; bump pointer to next filinfo record
042BF4             0193    @dec_loop_counter:
042BF4 E1          0194        pop hl
042BF5 2B          0195        dec hl ; decrement the loop counter
042BF6             0196        SIGN_HLU ; check for zero
                       M1 Args: none
042BF6 19          0001M1      add hl,de ; 1 cycle
042BF7 B7          0002M1      or a ; clear flags ; 1 cycle
042BF8 ED 52       0003M1      sbc hl,de ; 2 cycles
042BFA             0004M1      ; 4 cycles total
042BFA C2 A3 2B 04 0197        jp nz,@print_loop
042BFE C9          0198        ret
042BFF             0199    @skip_file:
042BFF 11 16 01 00 0200        ld de,filinfo_struct_size
042C03 DD 19       0201        add ix,de ; bump pointer to next filinfo record
042C05 C3 F4 2B 04 0202        jp @dec_loop_counter
042C09             0203    ; end print_dir
042C09             0204    
042C09             0205    ; must be final include in program so file data does not stomp on program code or other data
042C09             0206        include "files.inc"
042C09             0001*   ; THIS MUST BE LAST INCLUDE SO FILE DATA DOES NOT OVERWRITE OTHER CODE OR DATA
042C09             0002*   
042C09             0003*   ; buffer for loading files unrelated to audio
042C09             0004*   ; e.g.: fonts, sprites, etc. (limited to 8k)
042C09             0005*   filedata: equ 0xB7E000 ; address of onboard 8k sram
042C09             0006*   
042C09             0007*   ;     align 256 ; make things nice for indexing into especially ps_dir_fil_list
042C09             0008*   ; ; buffer for sound data
042C09             0009*   ps_wav_data_start: equ 0x050000 ;    equ $   ; (042E00) Start of audio data
042C09             0010*   
042C09             0011*   ; this list can grow as large as necessary to hold all the files in the directory
042C09             0012*   ; each entry will be 278 bytes (filinfo_struct_size)
042C09             0013*   ps_dir_fil_list: equ 0x060000 ; equ ps_wav_data_start+65536 ; (052E00) max file data we can load in one chunk is 64k
