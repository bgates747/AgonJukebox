PC     Output      Line
040000             0001        assume adl=1
040000             0002        org 0x040000
040000 C3 45 00 04 0003        jp start
040004 FF FF FF FF 0004        align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0005        db "MOS"
040043 00          0006        db 00h
040044 01          0007        db 01h
040045             0008    
040045             0009    start:
040045 F5          0010        push af
040046 C5          0011        push bc
040047 D5          0012        push de
040048 DD E5       0013        push ix
04004A FD E5       0014        push iy
04004C             0015    
04004C CD 90 2C 04 0016        call init
040050 CD DE 2C 04 0017        call main
040054             0018    
040054             0019    exit:
040054 FD E1       0020        pop iy
040056 DD E1       0021        pop ix
040058 D1          0022        pop de
040059 C1          0023        pop bc
04005A F1          0024        pop af
04005B 21 00 00 00 0025        ld hl,0
04005F             0026    
04005F C9          0027        ret
040060             0028    
040060             0029    ; API INCLUDES
040060             0030        include "mos_api.inc"
040060             0001*   ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.inc
040060             0002*   ; Title:	AGON MOS - API for user projects
040060             0003*   ; Author:	Dean Belfield
040060             0004*   ;			Adapted for agon-ez80asm by Jeroen Venema
040060             0005*   ;			Added MOS error codes for return in HL
040060             0006*   ; Created:	03/08/2022
040060             0007*   ; Last Updated:	10/08/2023
040060             0008*   ;
040060             0009*   ; Modinfo:
040060             0010*   ; 05/08/2022:	Added mos_feof
040060             0011*   ; 09/08/2022:	Added system variables: cursorX, cursorY
040060             0012*   ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040060             0013*   ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040060             0014*   ; 24/09/2022:	Added mos_getError, mos_mkdir
040060             0015*   ; 13/10/2022:	Added mos_oscli
040060             0016*   ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040060             0017*   ; 04/03/2023:	Added sysvar_scrpixelIndex
040060             0018*   ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040060             0019*   ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040060             0020*   ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040060             0021*   ; 22/03/2023:	The VDP commands are now indexed from 0x80
040060             0022*   ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040060             0023*   ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040060             0024*   ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040060             0025*   ; 19/05/2023:	Added sysvar_scrMode
040060             0026*   ; 05/06/2023:	Added sysvar_rtcEnable
040060             0027*   ; 03/08/2023:	Added mos_setkbvector
040060             0028*   ; 10/08/2023:	Added mos_getkbmap
040060             0029*   
040060             0030*   ; VDP control (VDU 23, 0, n)
040060             0031*   ;
040060             0032*   vdp_gp:				EQU 80h
040060             0033*   vdp_keycode:		EQU 81h
040060             0034*   vdp_cursor:			EQU	82h
040060             0035*   vdp_scrchar:		EQU	83h
040060             0036*   vdp_scrpixel:		EQU	84h
040060             0037*   vdp_audio:			EQU	85h
040060             0038*   vdp_mode:			EQU	86h
040060             0039*   vdp_rtc:			EQU	87h
040060             0040*   vdp_keystate:		EQU	88h
040060             0041*   vdp_logicalcoords:	EQU	C0h
040060             0042*   vdp_terminalmode:	EQU	FFh
040060             0043*   
040060             0044*   ; MOS high level functions
040060             0045*   ;
040060             0046*   mos_getkey:			EQU	00h
040060             0047*   mos_load:			EQU	01h
040060             0048*   mos_save:			EQU	02h
040060             0049*   mos_cd:				EQU	03h
040060             0050*   mos_dir:			EQU	04h
040060             0051*   mos_del:			EQU	05h
040060             0052*   mos_ren:			EQU	06h
040060             0053*   mos_mkdir:			EQU	07h
040060             0054*   mos_sysvars:		EQU	08h
040060             0055*   mos_editline:		EQU	09h
040060             0056*   mos_fopen:			EQU	0Ah
040060             0057*   mos_fclose:			EQU	0Bh
040060             0058*   mos_fgetc:			EQU	0Ch
040060             0059*   mos_fputc:			EQU	0Dh
040060             0060*   mos_feof:			EQU	0Eh
040060             0061*   mos_getError:		EQU	0Fh
040060             0062*   mos_oscli:			EQU	10h
040060             0063*   mos_copy:			EQU	11h
040060             0064*   mos_getrtc:			EQU	12h
040060             0065*   mos_setrtc:			EQU	13h
040060             0066*   mos_setintvector:	EQU	14h
040060             0067*   mos_uopen:			EQU	15h
040060             0068*   mos_uclose:			EQU	16h
040060             0069*   mos_ugetc:			EQU	17h
040060             0070*   mos_uputc:			EQU	18h
040060             0071*   mos_getfil:			EQU	19h
040060             0072*   mos_fread:			EQU	1Ah
040060             0073*   mos_fwrite:			EQU	1Bh
040060             0074*   mos_flseek:			EQU	1Ch
040060             0075*   mos_setkbvector:	EQU	1Dh
040060             0076*   mos_getkbmap:		EQU	1Eh
040060             0077*   
040060             0078*   ; MOS program exit codes
040060             0079*   ;
040060             0080*   EXIT_OK:				EQU  0;	"OK",
040060             0081*   EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
040060             0082*   EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
040060             0083*   EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
040060             0084*   EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
040060             0085*   EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
040060             0086*   EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
040060             0087*   EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
040060             0088*   EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
040060             0089*   EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
040060             0090*   EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
040060             0091*   EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
040060             0092*   EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
040060             0093*   EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
040060             0094*   EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
040060             0095*   EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
040060             0096*   EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
040060             0097*   EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
040060             0098*   EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
040060             0099*   EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
040060             0100*   EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
040060             0101*   EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
040060             0102*   ; FatFS file access functions
040060             0103*   ;
040060             0104*   ffs_fopen:			EQU	80h
040060             0105*   ffs_fclose:			EQU	81h
040060             0106*   ffs_fread:			EQU	82h
040060             0107*   ffs_fwrite:			EQU	83h
040060             0108*   ffs_flseek:			EQU	84h
040060             0109*   ffs_ftruncate:		EQU	85h
040060             0110*   ffs_fsync:			EQU	86h
040060             0111*   ffs_fforward:		EQU	87h
040060             0112*   ffs_fexpand:		EQU	88h
040060             0113*   ffs_fgets:			EQU	89h
040060             0114*   ffs_fputc:			EQU	8Ah
040060             0115*   ffs_fputs:			EQU	8Bh
040060             0116*   ffs_fprintf:		EQU	8Ch
040060             0117*   ffs_ftell:			EQU	8Dh
040060             0118*   ffs_feof:			EQU	8Eh
040060             0119*   ffs_fsize:			EQU	8Fh
040060             0120*   ffs_ferror:			EQU	90h
040060             0121*   
040060             0122*   ; FatFS directory access functions
040060             0123*   ;
040060             0124*   ffs_dopen:			EQU	91h
040060             0125*   ffs_dclose:			EQU	92h
040060             0126*   ffs_dread:			EQU	93h
040060             0127*   ffs_dfindfirst:		EQU	94h
040060             0128*   ffs_dfindnext:		EQU	95h
040060             0129*   
040060             0130*   ; FatFS file and directory management functions
040060             0131*   ;
040060             0132*   ffs_stat:			EQU	96h
040060             0133*   ffs_unlink:			EQU	97h
040060             0134*   ffs_rename:			EQU	98h
040060             0135*   ffs_chmod:			EQU	99h
040060             0136*   ffs_utime:			EQU	9Ah
040060             0137*   ffs_mkdir:			EQU	9Bh
040060             0138*   ffs_chdir:			EQU	9Ch
040060             0139*   ffs_chdrive:		EQU	9Dh
040060             0140*   ffs_getcwd:			EQU	9Eh
040060             0141*   
040060             0142*   ; FatFS volume management and system configuration functions
040060             0143*   ;
040060             0144*   ffs_mount:			EQU	9Fh
040060             0145*   ffs_mkfs:			EQU	A0h
040060             0146*   ffs_fdisk:			EQU	A1h
040060             0147*   ffs_getfree:		EQU	A2h
040060             0148*   ffs_getlabel:		EQU	A3h
040060             0149*   ffs_setlabel:		EQU	A4h
040060             0150*   ffs_setcp:			EQU	A5h
040060             0151*   
040060             0152*   ; File access modes
040060             0153*   ;
040060             0154*   fa_read:			EQU	01h
040060             0155*   fa_write:			EQU	02h
040060             0156*   fa_open_existing:	EQU	00h
040060             0157*   fa_create_new:		EQU	04h
040060             0158*   fa_create_always:	EQU	08h
040060             0159*   fa_open_always:		EQU	10h
040060             0160*   fa_open_append:		EQU	30h
040060             0161*   
040060             0162*   ; System variable indexes for api_sysvars
040060             0163*   ; Index into _sysvars in globals.inc
040060             0164*   ;
040060             0165*   sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040060             0166*   sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
040060             0167*   sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040060             0168*   sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
040060             0169*   sysvar_cursorX:			EQU	07h	; 1: Cursor X position
040060             0170*   sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
040060             0171*   sysvar_scrchar:			EQU	09h	; 1: Character read from screen
040060             0172*   sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040060             0173*   sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040060             0174*   sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040060             0175*   sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
040060             0176*   sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
040060             0177*   sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
040060             0178*   sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
040060             0179*   sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
040060             0180*   sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040060             0181*   sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
040060             0182*   sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040060             0183*   sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
040060             0184*   sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
040060             0185*   sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
040060             0186*   sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
040060             0187*   sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
040060             0188*   sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
040060             0189*   sysvar_scrMode:			EQU	27h	; 1: Screen mode
040060             0190*   sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040060             0191*   
040060             0192*   ; Flags for the VPD protocol
040060             0193*   ;
040060             0194*   vdp_pflag_cursor:		EQU	00000001b
040060             0195*   vdp_pflag_scrchar:		EQU	00000010b
040060             0196*   vdp_pflag_point:		EQU	00000100b
040060             0197*   vdp_pflag_audio:		EQU	00001000b
040060             0198*   vdp_pflag_mode:			EQU	00010000b
040060             0199*   vdp_pflag_rtc:			EQU	00100000b
040060             0200*   
040060             0201*   ;
040060             0202*   ; FatFS structures
040060             0203*   ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040060             0204*   ;
040060             0205*   ; Object ID and allocation information (FFOBJID)
040060             0206*   ;
040060             0207*   ; Indexes into FFOBJID structure
040060             0208*   ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
040060             0209*   ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
040060             0210*   ffobjid_attr:		EQU	5	; 1: Object attribute
040060             0211*   ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040060             0212*   ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
040060             0213*   ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
040060             0214*   ;
040060             0215*   ; File object structure (FIL)
040060             0216*   ;
040060             0217*   ; Indexes into FIL structure
040060             0218*   fil_obj:		EQU 0	; 15: Object identifier
040060             0219*   fil_flag:		EQU	15 	;  1: File status flags
040060             0220*   fil_err:		EQU	16	;  1: Abort flag (error code)
040060             0221*   fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
040060             0222*   fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
040060             0223*   fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
040060             0224*   fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
040060             0225*   fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
040060             0226*   ;
040060             0227*   ; Directory object structure (DIR)
040060             0228*   ; Indexes into DIR structure
040060             0229*   dir_obj:		EQU  0	; 15: Object identifier
040060             0230*   dir_dptr:		EQU	15	;  4: Current read/write offset
040060             0231*   dir_clust:		EQU	19	;  4: Current cluster
040060             0232*   dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
040060             0233*   dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
040060             0234*   dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
040060             0235*   dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040060             0236*   ;
040060             0237*   ; File information structure (FILINFO)
040060             0238*   ;
040060             0239*   ; Indexes into FILINFO structure
040060             0240*   filinfo_fsize:		EQU 0	;   4: File size
040060             0241*   filinfo_fdate:		EQU	4	;   2: Modified date
040060             0242*   filinfo_ftime:		EQU	6	;   2: Modified time
040060             0243*   filinfo_fattrib:	EQU	8	;   1: File attribute
040060             0244*   filinfo_altname:	EQU	9	;  13: Alternative file name
040060             0245*   filinfo_fname:		EQU	22	; 256: Primary file name
040060             0246*   ;
040060             0247*   ; Macro for calling the API
040060             0248*   ; Parameters:
040060             0249*   ; - function: One of the function numbers listed above
040060             0250*   ;
040060             0251*   	MACRO	MOSCALL	function
040060             0252*   			LD	A, function
040060             0253*   			RST.LIL	08h
040060             0254*   	ENDMACRO
040060             0031        include "macros.inc"
040060             0001*   
040060             0002*   ; test the sign of HL
040060             0003*   ; inputs: HL obviously
040060             0004*   ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
040060             0005*   ; destroys: flags
040060             0006*       MACRO SIGN_HLU
040060             0007*       add hl,de ; 1 cycle
040060             0008*       or a ; clear flags ; 1 cycle
040060             0009*       sbc hl,de ; 2 cycles
040060             0010*       ; 4 cycles total
040060             0011*       ENDMACRO
040060             0012*   
040060             0013*   ; put the value in A into HLU
040060             0014*   ; affects: HLU
040060             0015*   ; destroys: nothing
040060             0016*   ; note: $ instead of @@ b/c anon labels deprecated in ez80asm
040060             0017*       MACRO A_TO_HLU
040060             0018*       xor a ; 1 cycle
040060             0019*       ld ($+8+1),hl ; 7 cycles
040060             0020*       ld ($+4+3),a ; 5 cycles
040060             0021*       ld hl,0x000000 ; 4 cycles
040060             0022*       ; 17 cycles total
040060             0023*       ENDMACRO
040060             0024*   
040060             0025*   ; alternative: https://discord.com/channels/1158535358624039014/1282290921815408681/1318315567102300220
040060             0026*   ; one cycle less but burns flags
040060             0027*       MACRO A_TO_HLU_ALT
040060             0028*       push hl ; 4 cycles
040060             0029*       ld hl,2 ; 4 cycles
040060             0030*       add hl,sp ; 1 cycle
040060             0031*       ld (hl),a ; 2 cycles
040060             0032*       pop hl ; 4 cycles
040060             0033*       ; 15 cycles total
040060             0034*       ENDMACRO
040060             0035*   
040060             0036*       MACRO hlu_mul256
040060             0037*       add hl,hl ; * 2
040060             0038*       add hl,hl ; * 4
040060             0039*       add hl,hl ; * 8
040060             0040*       add hl,hl ; * 16
040060             0041*       add hl,hl ; * 32
040060             0042*       add hl,hl ; * 64
040060             0043*       add hl,hl ; * 128
040060             0044*       add hl,hl ; * 256
040060             0045*       ENDMACRO
040060             0046*   
040060             0047*   ; https://discord.com/channels/1158535358624039014/1282290921815408681/1317793870070812715
040060             0048*       MACRO SRL_UHL
040060             0049*       dec sp ; 1 cycle
040060             0050*       push hl ; 4 cycles
040060             0051*       inc sp ; 1 cycle
040060             0052*       pop hl ; 4 cycles
040060             0053*       inc hl ; 1 cycle
040060             0054*       dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
040060             0055*       ; 13 cycles total
040060             0056*       ENDMACRO
040060             0057*   
040060             0058*       MACRO printChar char
040060             0059*       LD A, char
040060             0060*       RST.LIL 10h
040060             0061*       ENDMACRO
040060             0062*   
040060             0063*   ; Simulated call to subroutine at HL
040060             0064*   ; inputs: HL pointing to the subroutine address plus whatever the called function expects
040060             0065*   ; outputs: whatever the subroutine does, including HL and BC
040060             0066*   ; destroys: only what the subroutine does, but always BC
040060             0067*       MACRO CALL_HL
040060             0068*       ld bc,$+6 ; Address of first instruction after the jump
040060             0069*       push bc ; which constitutes the return address
040060             0070*       jp (hl) ; Jump to the address in HL
040060             0071*       ENDMACRO
040060             0072*   
040060             0073*   ; Simulated call to subroutine at IX
040060             0074*   ; inputs: IX pointing to the subroutine address plus whatever the called function expects
040060             0075*   ; outputs: whatever the subroutine does, including IX and BC
040060             0076*   ; destroys: only what the subroutine does, but always BC
040060             0077*       MACRO CALL_IX
040060             0078*       ld bc,$+6 ; Address of first instruction after the jump
040060             0079*       push bc ; which constitutes the return address
040060             0080*       jp (ix) ; Jump to the address in IX
040060             0081*       ENDMACRO
040060             0082*   
040060             0083*   ; Simulated call to soubroutinte at IY
040060             0084*   ; inputs: IY pointing to the subroutine address plus whatever the called function expects
040060             0085*   ; outputs: whatever the subroutine does, including IY and BC
040060             0086*   ; destroys: only what the subroutine does, but always BC
040060             0087*       MACRO CALL_IY
040060             0088*       ld bc,$+6 ; Address of first instruction after the jump
040060             0089*       push bc ; which constitutes the return address
040060             0090*       jp (iy) ; Jump to the address in IY
040060             0091*       ENDMACRO
040060             0092*   
040060             0093*   ; put the value in HLU into A
040060             0094*   ; destroys: af
040060             0095*       MACRO HLU_TO_A
040060             0096*       dec sp ; 1 cycle
040060             0097*       push hl ; 4 cycles
040060             0098*       inc sp ; 1 cycle
040060             0099*       pop af ; 4 cycles
040060             0100*       ; 10 cycles total
040060             0101*       ENDMACRO
040060             0102*   
040060             0103*       MACRO PUSH_ALL
040060             0104*       ex af,af'
040060             0105*       exx
040060             0106*       push af
040060             0107*       push hl
040060             0108*       push bc
040060             0109*       push de
040060             0110*   
040060             0111*       ex af,af'
040060             0112*       exx
040060             0113*       push af
040060             0114*       push hl
040060             0115*       push bc
040060             0116*       push de
040060             0117*       push ix
040060             0118*       push iy
040060             0119*       ENDMACRO
040060             0120*   
040060             0121*       MACRO POP_ALL
040060             0122*       pop iy
040060             0123*       pop ix
040060             0124*       pop de
040060             0125*       pop bc
040060             0126*       pop hl
040060             0127*       pop af
040060             0128*       ex af,af'
040060             0129*       exx
040060             0130*   
040060             0131*       pop de
040060             0132*       pop bc
040060             0133*       pop hl
040060             0134*       pop af
040060             0135*       ex af,af'
040060             0136*       exx
040060             0137*       ENDMACRO
040060             0032        include "functions.inc"
040060             0001*   ; Print a zero-terminated string inline with code, e.g.:
040060             0002*   ;
040060             0003*   ;    call printInline
040060             0004*   ;    ASCIZ "Hello, world!\r\n"
040060             0005*   ;
040060             0006*   ; Destroys: HL,AF
040060             0007*   printInline:
040060 E1          0008*       pop hl ; get the return address = pointer to start of string
040061 CD 67 00 04 0009*       call printString ; HL advances to end of string
040065 E5          0010*       push hl ; restore the return address = pointer to end of string
040066 C9          0011*       ret
040067             0012*   
040067             0013*   ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
040067             0014*   ; Print a zero-terminated string
040067             0015*   ; HL: Pointer to string
040067             0016*   ; returns: hl pointed to character after string terminator
040067             0017*   ; destroys: af, hl
040067             0018*   printString:
040067 C5          0019*       PUSH BC
040068 01 00 00 00 0020*       LD BC,0
04006C 3E 00       0021*       LD A,0
04006E 5B DF       0022*       RST.LIL 18h
040070 C1          0023*       POP BC
040071 C9          0024*       RET
040072             0025*   ; print a VDU sequence
040072             0026*   ; HL: Pointer to VDU sequence - <1 byte length> <data>
040072             0027*   sendVDUsequence:
040072 C5          0028*       PUSH BC
040073 01 00 00 00 0029*       LD BC, 0
040077 4E          0030*       LD C, (HL)
040078 5B DF       0031*       RST.LIL 18h
04007A C1          0032*       POP BC
04007B C9          0033*       RET
04007C             0034*   ; Print Newline sequence to VDP
04007C             0035*   ; destroys: nothing
04007C             0036*   printNewLine:
04007C F5          0037*       push af ; for some reason rst.lil 10h sets carry flag
04007D 3E 0D       0038*       LD A, '\r'
04007F 5B D7       0039*       RST.LIL 10h
040081 3E 0A       0040*       LD A, '\n'
040083 5B D7       0041*       RST.LIL 10h
040085 F1          0042*       pop af
040086 C9          0043*       RET
040087             0044*   
040087             0045*   ; print a zero-terminated string at a graphics coordinate
040087             0046*   ; Inputs: HL Pointer to string, BC,DE x,y position (in pixels)
040087             0047*   printStringGfx:
040087 E5          0048*       push hl ; preserve string pointer
040088             0049*   ; move graphics cursor to x,y location
040088 3E 44       0050*       ld a,plot_pt+mv_abs
04008A CD D0 1B 04 0051*       call vdu_plot
04008E             0052*   ; print string
04008E E1          0053*       pop hl ; restore string pointer
04008F             0054*   @print_loop:
04008F 7E          0055*       ld a,(hl)
040090 B7          0056*       or a ; check for end of string
040091 C8          0057*       ret z ; if zero, we're done
040092 08          0058*       ex af,af' ; preserve character
040093 3E 05       0059*       ld a,5 ; VDU 5 char to gfx cursor
040095 5B D7       0060*       rst.lil 10h ; send it
040097 08          0061*       ex af,af' ; restore character
040098 5B D7       0062*       rst.lil 10h ; print character
04009A 23          0063*       inc hl
04009B C3 8F 00 04 0064*       jp @print_loop
04009F C9          0065*       ret
0400A0             0066*   ; end printStringGfx
0400A0             0067*   
0400A0             0068*   ; Print a 24-bit HEX number
0400A0             0069*   ; HLU: Number to print
0400A0             0070*   printHex24:
0400A0             0071*       HLU_TO_A
0400A0 3B          0001*M1     dec sp ; 1 cycle
0400A1 E5          0002*M1     push hl ; 4 cycles
0400A2 33          0003*M1     inc sp ; 1 cycle
0400A3 F1          0004*M1     pop af ; 4 cycles
0400A4             0005*M1     ; 10 cycles total
0400A4 CD AE 00 04 0072*       CALL printHex8
0400A8             0073*   ; Print a 16-bit HEX number
0400A8             0074*   ; HL: Number to print
0400A8             0075*   printHex16:
0400A8 7C          0076*       LD A,H
0400A9 CD AE 00 04 0077*       CALL printHex8
0400AD 7D          0078*       LD A,L
0400AE             0079*   ; Print an 8-bit HEX number
0400AE             0080*   ; A: Number to print
0400AE             0081*   printHex8:
0400AE 4F          0082*       LD C,A
0400AF 1F          0083*       RRA
0400B0 1F          0084*       RRA
0400B1 1F          0085*       RRA
0400B2 1F          0086*       RRA
0400B3 CD B8 00 04 0087*       CALL @F
0400B7 79          0088*       LD A,C
0400B8             0089*   @@:
0400B8 E6 0F       0090*       AND 0Fh
0400BA C6 90       0091*       ADD A,90h
0400BC 27          0092*       DAA
0400BD CE 40       0093*       ADC A,40h
0400BF 27          0094*       DAA
0400C0 5B D7       0095*       RST.LIL 10h
0400C2 C9          0096*       RET
0400C3             0097*   
0400C3             0098*   ; Print a 0x HEX prefix
0400C3             0099*   DisplayHexPrefix:
0400C3 3E 30       0100*       LD A, '0'
0400C5 5B D7       0101*       RST.LIL 10h
0400C7 3E 78       0102*       LD A, 'x'
0400C9 5B D7       0103*       RST.LIL 10h
0400CB C9          0104*       RET
0400CC             0105*   
0400CC             0106*       MACRO printDecBC
0400CC             0107*       push hl
0400CC             0108*       push bc
0400CC             0109*       pop hl
0400CC             0110*       call printDec
0400CC             0111*       pop hl
0400CC             0112*       ENDMACRO
0400CC             0113*   
0400CC             0114*       MACRO printDecDE
0400CC             0115*       push hl
0400CC             0116*       push de
0400CC             0117*       pop hl
0400CC             0118*       call printDec
0400CC             0119*       pop hl
0400CC             0120*       ENDMACRO
0400CC             0121*   
0400CC             0122*       MACRO printDecHL
0400CC             0123*       call printDec
0400CC             0124*       ENDMACRO
0400CC             0125*   
0400CC             0126*       MACRO printDecIX
0400CC             0127*       push hl
0400CC             0128*       push ix
0400CC             0129*       pop hl
0400CC             0130*       call printDec
0400CC             0131*       pop hl
0400CC             0132*       ENDMACRO
0400CC             0133*   
0400CC             0134*       MACRO printDecIY
0400CC             0135*       push hl
0400CC             0136*       push iy
0400CC             0137*       pop hl
0400CC             0138*       call printDec
0400CC             0139*       pop hl
0400CC             0140*       ENDMACRO
0400CC             0141*   
0400CC             0142*   
0400CC             0143*   ; Prints the right justified decimal value in HL without leading zeroes
0400CC             0144*   ; HL : Value to print
0400CC             0145*   ; preserves all registers and flags
0400CC             0146*   printDec:
0400CC             0147*   ; BEGIN MY CODE
0400CC             0148*   ; back up all the things
0400CC F5          0149*       push af
0400CD C5          0150*       push bc
0400CE D5          0151*       push de
0400CF E5          0152*       push hl
0400D0             0153*   ; END MY CODE
0400D0 11 F8 00 04 0154*       LD DE, _printDecBuffer
0400D4 CD 08 01 04 0155*       CALL u24_to_ascii
0400D8             0156*   ; BEGIN MY CODE
0400D8             0157*   ; replace leading zeroes with spaces
0400D8 21 F8 00 04 0158*       LD HL, _printDecBuffer
0400DC 06 07       0159*       ld B, 7 ; if HL was 0, we want to keep the final zero
0400DE             0160*   @loop:
0400DE 7E          0161*       LD A, (HL)
0400DF FE 30       0162*       CP '0'
0400E1 C2 EB 00 04 0163*       JP NZ, @done
0400E5 3E 20       0164*       LD A, ' '
0400E7 77          0165*       LD (HL), A
0400E8 23          0166*       INC HL
0400E9             0167*       ; CALL vdu_cursor_forward
0400E9 10 F3       0168*       DJNZ @loop
0400EB             0169*   @done:
0400EB             0170*   ; END MY CODE
0400EB 21 F8 00 04 0171*       LD HL, _printDecBuffer
0400EF CD 67 00 04 0172*       CALL printString
0400F3             0173*   ; BEGIN MY CODE
0400F3             0174*   ; restore all the things
0400F3 E1          0175*       pop hl
0400F4 D1          0176*       pop de
0400F5 C1          0177*       pop bc
0400F6 F1          0178*       pop af
0400F7             0179*   ; END MY CODE
0400F7 C9          0180*       RET
0400F8 00 00 00 00 0181*   _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040108             0182*   
040108             0183*   ; This routine converts the unsigned 24-bit value in HLU into its ASCII representation,
040108             0184*   ; starting to memory location pointing by DE, in decimal form and with leading zeroes
040108             0185*   ; so it will allways be 8 characters length
040108             0186*   ; HL : Value to convert to string
040108             0187*   ; DE : pointer to buffer, at least 8 byte + 0
040108             0188*   u24_to_ascii:
040108 01 80 69 67 0189*       LD BC,-10000000
04010C CD 3F 01 04 0190*       CALL @one_digit
040110 01 C0 BD F0 0191*       LD BC,-1000000
040114 CD 3F 01 04 0192*       CALL @one_digit
040118 01 60 79 FE 0193*       LD BC,-100000
04011C CD 3F 01 04 0194*       CALL @one_digit
040120 01 F0 D8 FF 0195*       LD BC,-10000
040124 CD 3F 01 04 0196*       CALL @one_digit
040128 01 18 FC FF 0197*       LD BC,-1000
04012C CD 3F 01 04 0198*       CALL @one_digit
040130 01 9C FF FF 0199*       LD BC,-100
040134 CD 3F 01 04 0200*       CALL @one_digit
040138 0E F6       0201*       LD C,-10
04013A CD 3F 01 04 0202*       CALL @one_digit
04013E 48          0203*       LD C,B
04013F             0204*   @one_digit:
04013F 3E 2F       0205*       LD A,'0'-1
040141             0206*   @divide_me:
040141 3C          0207*       INC A
040142 09          0208*       ADD HL,BC
040143 38 FC       0209*       JR C,@divide_me
040145 ED 42       0210*       SBC HL,BC
040147 12          0211*       LD (DE),A
040148 13          0212*       INC DE
040149 C9          0213*       RET
04014A             0214*   
04014A             0215*   print_u24:
04014A D5          0216*       push de
04014B E5          0217*       push hl
04014C 11 F8 00 04 0218*       ld de,_printDecBuffer
040150 CD 08 01 04 0219*       call u24_to_ascii
040154 21 F8 00 04 0220*       ld hl,_printDecBuffer
040158 CD 67 00 04 0221*       call printString
04015C 3E 20       0222*       ld a,' '
04015E 5B D7       0223*       rst.lil 10h
040160 E1          0224*       pop hl
040161 D1          0225*       pop de
040162 C9          0226*       ret
040163             0227*   
040163             0228*   ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
040163             0229*   ; HL : Value to convert to string (integer part in H, fractional part in L)
040163             0230*   ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
040163             0231*   u168_to_ascii:
040163             0232*   ; add a leading space to make room for sign flag if needed
040163 3E 20       0233*       ld a,' '
040165 12          0234*       ld (de),a
040166 13          0235*       inc de
040167             0236*   ; Convert integer part
040167 E5          0237*       push hl ; Save HL (weâ€™ll need the fractional part later)
040168             0238*       ; call hlu_udiv256 ; Shift to get integer portion in HL
040168             0239*       SRL_UHL ; Shift to get integer portion in HL
040168 3B          0001*M1     dec sp ; 1 cycle
040169 E5          0002*M1     push hl ; 4 cycles
04016A 33          0003*M1     inc sp ; 1 cycle
04016B E1          0004*M1     pop hl ; 4 cycles
04016C 23          0005*M1     inc hl ; 1 cycle
04016D 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
04016F             0007*M1     ; 13 cycles total
04016F 01 F0 D8 FF 0240*       ld bc, -10000
040173 CD 96 01 04 0241*       call @one_int
040177 01 18 FC FF 0242*       ld bc, -1000
04017B CD 96 01 04 0243*       call @one_int
04017F 01 9C FF FF 0244*       ld bc, -100
040183 CD 96 01 04 0245*       call @one_int
040187 0E F6       0246*       ld c, -10
040189 CD 96 01 04 0247*       call @one_int
04018D 48          0248*       ld c, b
04018E CD 96 01 04 0249*       call @one_int
040192 C3 A1 01 04 0250*       jp @frac ; Jump to fractional part conversion
040196             0251*   @one_int:
040196 3E 2F       0252*       ld a, '0' - 1 ; Start ASCII character at '0'
040198             0253*   @divide_me:
040198 3C          0254*       inc a
040199 09          0255*       add hl, bc ; Accumulate until overflow
04019A 38 FC       0256*       jr c, @divide_me
04019C ED 42       0257*       sbc hl, bc ; Remove excess after overflow
04019E 12          0258*       ld (de), a ; Store ASCII digit
04019F 13          0259*       inc de
0401A0 C9          0260*       ret
0401A1             0261*   ; Convert fractional part
0401A1             0262*   @frac:
0401A1 3E 2E       0263*       ld a, '.' ; Decimal point
0401A3 12          0264*       ld (de), a
0401A4 13          0265*       inc de
0401A5 E1          0266*       pop hl ; Restore HL with original fraction
0401A6 06 03       0267*       ld b, 3 ; Loop counter for 3 fractional digits
0401A8             0268*   @frac_loop:
0401A8 26 0A       0269*       ld h, 10 ; Load multiplier for fractional part
0401AA ED 6C       0270*       mlt hl ; Multiply by 10, result in HL (H holds the integer part)
0401AC 3E 30       0271*       ld a, '0'
0401AE 84          0272*       add a, h ; Convert integer part to ASCII
0401AF 12          0273*       ld (de), a
0401B0 13          0274*       inc de
0401B1 10 F5       0275*       djnz @frac_loop ; Repeat for each fractional digit
0401B3             0276*   ; Add null terminator
0401B3 AF          0277*       xor a ; Null terminator
0401B4 12          0278*       ld (de), a
0401B5 C9          0279*       ret
0401B6             0280*   
0401B6             0281*   print_u168:
0401B6 D5          0282*       push de
0401B7 E5          0283*       push hl
0401B8 11 F8 00 04 0284*       ld de,_printDecBuffer
0401BC CD 63 01 04 0285*       call u168_to_ascii
0401C0 21 F8 00 04 0286*       ld hl,_printDecBuffer
0401C4 CD 67 00 04 0287*       call printString
0401C8 E1          0288*       pop hl
0401C9 D1          0289*       pop de
0401CA C9          0290*       ret
0401CB             0291*   
0401CB             0292*   ; signed version of u168_to_ascii
0401CB             0293*   s168_to_ascii:
0401CB D5          0294*       push de ; save starting address of buffer
0401CC CD 70 04 04 0295*       call hlu_abs
0401D0 F5          0296*       push af ; save sign flag
0401D1 CD 63 01 04 0297*       call u168_to_ascii
0401D5 F1          0298*       pop af ; restore sign flag
0401D6 D1          0299*       pop de ; restore starting address of buffer
0401D7 F0          0300*       ret p ; hlu was positive so nothing to do
0401D8 3E 2D       0301*       ld a,'-'
0401DA 12          0302*       ld (de),a
0401DB C9          0303*       ret
0401DC             0304*   
0401DC             0305*   print_s168:
0401DC D5          0306*       push de
0401DD E5          0307*       push hl
0401DE 11 F8 00 04 0308*       ld de,_printDecBuffer
0401E2 CD CB 01 04 0309*       call s168_to_ascii
0401E6 21 F8 00 04 0310*       ld hl,_printDecBuffer
0401EA CD 67 00 04 0311*       call printString
0401EE E1          0312*       pop hl
0401EF D1          0313*       pop de
0401F0 C9          0314*       ret
0401F1             0315*   
0401F1             0316*   print_s168_hl:
0401F1 F5          0317*       push af
0401F2 E5          0318*       push hl
0401F3 CD DC 01 04 0319*       call print_s168
0401F7 3E 20       0320*       ld a,' '
0401F9 5B D7       0321*       rst.lil 10h
0401FB E1          0322*       pop hl
0401FC F1          0323*       pop af
0401FD C9          0324*       ret
0401FE             0325*   
0401FE             0326*   print_s168_bc:
0401FE F5          0327*       push af
0401FF C5          0328*       push bc
040200 E5          0329*       push hl
040201 C5          0330*       push bc
040202 E1          0331*       pop hl
040203 CD DC 01 04 0332*       call print_s168
040207 3E 20       0333*       ld a,' '
040209 5B D7       0334*       rst.lil 10h
04020B E1          0335*       pop hl
04020C C1          0336*       pop bc
04020D F1          0337*       pop af
04020E C9          0338*       ret
04020F             0339*   
04020F             0340*   print_s168_de:
04020F F5          0341*       push af
040210 D5          0342*       push de
040211 E5          0343*       push hl
040212 EB          0344*       ex de,hl
040213 CD DC 01 04 0345*       call print_s168
040217 3E 20       0346*       ld a,' '
040219 5B D7       0347*       rst.lil 10h
04021B E1          0348*       pop hl
04021C D1          0349*       pop de
04021D F1          0350*       pop af
04021E C9          0351*       ret
04021F             0352*   
04021F             0353*   print_s168_hl_bc_de:
04021F F5          0354*       push af
040220 C5          0355*       push bc
040221 D5          0356*       push de
040222 E5          0357*       push hl
040223 CD DC 01 04 0358*       call print_s168
040227 3E 20       0359*       ld a,' '
040229 5B D7       0360*       rst.lil 10h
04022B C5          0361*       push bc
04022C E1          0362*       pop hl
04022D CD DC 01 04 0363*       call print_s168
040231 3E 20       0364*       ld a,' '
040233 5B D7       0365*       rst.lil 10h
040235 EB          0366*       ex de,hl
040236 CD DC 01 04 0367*       call print_s168
04023A 3E 20       0368*       ld a,' '
04023C 5B D7       0369*       rst.lil 10h
04023E E1          0370*       pop hl
04023F D1          0371*       pop de
040240 C1          0372*       pop bc
040241 F1          0373*       pop af
040242 C9          0374*       ret
040243             0375*   
040243             0376*   print_s168_bc_de:
040243 F5          0377*       push af
040244 C5          0378*       push bc
040245 D5          0379*       push de
040246 C5          0380*       push bc
040247 E1          0381*       pop hl
040248 CD DC 01 04 0382*       call print_s168
04024C 3E 20       0383*       ld a,' '
04024E 5B D7       0384*       rst.lil 10h
040250 EB          0385*       ex de,hl
040251 CD DC 01 04 0386*       call print_s168
040255 3E 20       0387*       ld a,' '
040257 5B D7       0388*       rst.lil 10h
040259 E1          0389*       pop hl
04025A D1          0390*       pop de
04025B C1          0391*       pop bc
04025C F1          0392*       pop af
04025D C9          0393*       ret
04025E             0394*   
04025E             0395*   print_s168_a:
04025E F5          0396*       push af
04025F C5          0397*       push bc
040260 E5          0398*       push hl
040261 21 00 00 00 0399*       ld hl,0
040265 6F          0400*       ld l,a
040266 CD F1 01 04 0401*       call print_s168_hl
04026A E1          0402*       pop hl
04026B C1          0403*       pop bc
04026C F1          0404*       pop af
04026D C9          0405*       ret
04026E             0406*   
04026E             0407*   ; #### new functions added by Brandon R. Gates ####
04026E             0408*   
04026E             0409*   ; print the binary representation of the 8-bit value in a
04026E             0410*   ; destroys a, hl, bc
04026E             0411*   printBin8:
04026E 06 08       0412*       ld b,8 ; loop counter for 8 bits
040270 21 8B 02 04 0413*       ld hl,@cmd ; set hl to the low byte of the output string
040274             0414*       ; (which will be the high bit of the value in a)
040274             0415*   @loop:
040274 07          0416*       rlca ; put the next highest bit into carry
040275 38 04       0417*       jr c,@one
040277 36 30       0418*       ld (hl),'0'
040279 18 02       0419*       jr @next_bit
04027B             0420*   @one:
04027B 36 31       0421*       ld (hl),'1'
04027D             0422*   @next_bit:
04027D 23          0423*       inc hl
04027E 10 F4       0424*       djnz @loop
040280             0425*   ; print it
040280 21 8B 02 04 0426*       ld hl,@cmd
040284 01 08 00 00 0427*       ld bc,@end-@cmd
040288 5B DF       0428*       rst.lil $18
04028A C9          0429*       ret
04028B             0430*   @cmd: ds 8 ; eight bytes for eight bits
040293             0431*   @end:
040293             0432*   
040293             0433*   ; print the binary representation of the 8-bit value in a
040293             0434*   ; in reverse order (lsb first)
040293             0435*   ; destroys a, hl, bc
040293             0436*   printBin8Rev:
       FF FF FF FF 
       FF FF FF FF 
040293 06 08       0437*       ld b,8 ; loop counter for 8 bits
040295 21 B0 02 04 0438*       ld hl,@cmd ; set hl to the low byte of the output string
040299             0439*       ; (which will be the high bit of the value in a)
040299             0440*   @loop:
040299 0F          0441*       rrca ; put the next lowest bit into carry
04029A 38 04       0442*       jr c,@one
04029C 36 30       0443*       ld (hl),'0'
04029E 18 02       0444*       jr @next_bit
0402A0             0445*   @one:
0402A0 36 31       0446*       ld (hl),'1'
0402A2             0447*   @next_bit:
0402A2 23          0448*       inc hl
0402A3 10 F4       0449*       djnz @loop
0402A5             0450*   ; print it
0402A5 21 B0 02 04 0451*       ld hl,@cmd
0402A9 01 08 00 00 0452*       ld bc,@end-@cmd
0402AD 5B DF       0453*       rst.lil $18
0402AF C9          0454*       ret
0402B0             0455*   @cmd: ds 8 ; eight bytes for eight bits
0402B8             0456*   @end:
0402B8             0457*   
       FF FF FF FF 
       FF FF FF FF 
0402B8 20 61 66 3D 0458*   str_afu: db " af=",0
       00          
0402BD 20 68 6C 3D 0459*   str_hlu: db " hl=",0
       00          
0402C2 20 62 63 3D 0460*   str_bcu: db " bc=",0
       00          
0402C7 20 64 65 3D 0461*   str_deu: db " de=",0
       00          
0402CC 20 69 78 3D 0462*   str_ixu: db " ix=",0
       00          
0402D1 20 69 79 3D 0463*   str_iyu: db " iy=",0
       00          
0402D6             0464*   
0402D6             0465*   ; print udeuhl to screen in hexidecimal format
0402D6             0466*   ; inputs: none
0402D6             0467*   ; outputs: concatenated hexidecimal udeuhl
0402D6             0468*   ; destroys: nothing
0402D6             0469*   dumpUDEUHLHex:
0402D6             0470*   ; store everything in scratch
0402D6 22 35 03 04 0471*       ld (uhl),hl
0402DA ED 43 38 03 0472*       ld (ubc),bc
       04          
0402DF ED 53 3B 03 0473*       ld (ude),de
       04          
0402E4 DD 22 3E 03 0474*       ld (uix),ix
       04          
0402E9 FD 22 41 03 0475*       ld (uiy),iy
       04          
0402EE F5          0476*       push af
0402EF             0477*   
0402EF             0478*   ; print each register
0402EF             0479*   
0402EF 21 29 03 04 0480*       ld hl,str_udeuhl
0402F3 CD 67 00 04 0481*       call printString
0402F7 2A 3B 03 04 0482*       ld hl,(ude)
0402FB CD A0 00 04 0483*       call printHex24
0402FF 3E 2E       0484*       ld a,'.' ; print a dot to separate the values
040301 5B D7       0485*       rst.lil 10h
040303 2A 35 03 04 0486*       ld hl,(uhl)
040307 CD A0 00 04 0487*       call printHex24
04030B CD 7C 00 04 0488*       call printNewLine
04030F             0489*   
04030F             0490*   ; restore everything
04030F 2A 35 03 04 0491*       ld hl, (uhl)
040313 ED 4B 38 03 0492*       ld bc, (ubc)
       04          
040318 ED 5B 3B 03 0493*       ld de, (ude)
       04          
04031D DD 2A 3E 03 0494*       ld ix, (uix)
       04          
040322 FD 2A 41 03 0495*       ld iy, (uiy)
       04          
040327 F1          0496*       pop af
040328             0497*   ; all done
040328 C9          0498*       ret
040329             0499*   
040329 75 64 65 2E 0500*   str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
040332             0501*   
040332             0502*   ; global scratch memory for registers
040332 00 00 00    0503*   uaf: dl 0
040335 00 00 00    0504*   uhl: dl 0
040338 00 00 00    0505*   ubc: dl 0
04033B 00 00 00    0506*   ude: dl 0
04033E 00 00 00    0507*   uix: dl 0
040341 00 00 00    0508*   uiy: dl 0
040344 00 00 00    0509*   usp: dl 0
040347 00 00 00    0510*   upc: dl 0
04034A             0511*   
04034A             0512*   
04034A             0513*   ; set all the bits in the flag register
04034A             0514*   ; more of an academic exercise than anything useful
04034A             0515*   ; inputs; none
04034A             0516*   ; outputs; a=0,f=255
04034A             0517*   ; destroys: flags, hl
04034A             0518*   ; preserves: a, because why not
04034A             0519*   setAllFlags:
04034A 21 FF 00 00 0520*       ld hl,255
04034E 67          0521*       ld h,a ; four cycles to preserve a is cheap
04034F E5          0522*       push hl
040350 F1          0523*       pop af
040351 C9          0524*       ret
040352             0525*   
040352             0526*   ; reset all the bits in the flag register
040352             0527*   ; unlike its inverse counterpart, this may actually be useful
040352             0528*   ; inputs; none
040352             0529*   ; outputs; a=0,f=0
040352             0530*   ; destroys: flags, hl
040352             0531*   ; preserves: a, because why not
040352             0532*   resetAllFlags:
040352 21 00 00 00 0533*       ld hl,0
040356 67          0534*       ld h,a ; four cycles to preserve a is cheap
040357 E5          0535*       push hl
040358 F1          0536*       pop af
040359 C9          0537*       ret
04035A             0538*   
04035A             0539*   ; wait until user presses a key
04035A             0540*   ; inputs: none
04035A             0541*   ; outputs: ascii code of key pressed in a
04035A             0542*   ; destroys: af,ix
04035A             0543*   waitKeypress:
04035A             0544*       MOSCALL mos_getkey
04035A 3E 00       0001*M1 			LD	A, function
04035C 5B CF       0002*M1 			RST.LIL	08h
04035E C9          0545*       ret
04035F             0546*   
04035F             0547*   ; clear a block of memory by writing a prescribed value to each byte in the range
04035F             0548*   ; inputs: a = value to write, hl = address of first byte, bc = number of bytes
04035F             0549*   ; outputs: memory block is cleared
04035F             0550*   ; destroys: hl, de
04035F             0551*   clear_mem:
04035F 0B          0552*       dec bc ; we do this because we will increment de before writing the first byte
040360 77          0553*       ld (hl),a
040361 E5          0554*       push hl
040362 D1          0555*       pop de
040363 13          0556*       inc de ; target address
040364 ED B0       0557*       ldir
040366 C9          0558*       ret
040367             0033        include "arith24.inc"
040367             0001*   ;------------------------------------------------------------------------
040367             0002*   ;  arith24.asm
040367             0003*   ;  24-bit ez80 arithmetic routines
040367             0004*   ;  Copyright (c) Shawn Sijnstra 2024
040367             0005*   ;  MIT license
040367             0006*   ;
040367             0007*   ;  This library was created as a tool to help make ez80
040367             0008*   ;  24-bit native assembly routines for simple mathematical problems
040367             0009*   ;  more widely available.
040367             0010*   ;
040367             0011*   ;------------------------------------------------------------------------
040367             0012*   
040367             0013*   ;------------------------------------------------------------------------
040367             0014*   ; umul24:	HL = HL*DE (unsigned)
040367             0015*   ; Preserves AF, BC, DE
040367             0016*   ; Uses a fast multiply routine.
040367             0017*   ;------------------------------------------------------------------------
040367             0018*   umul24:
040367 D5          0019*   	push	DE
040368 C5          0020*   	push	BC
040369 F5          0021*   	push	AF
04036A E5          0022*   	push	HL
04036B C1          0023*   	pop		BC
04036C 3E 18       0024*       ld	 	a, 24 ; No. of bits to process
04036E 21 00 00 00 0025*       ld	 	hl, 0 ; Result
040372             0026*   umul24_lp:
040372 29          0027*   	add	hl,hl
040373 EB          0028*   	ex	de,hl
040374 29          0029*   	add	hl,hl
040375 EB          0030*   	ex	de,hl
040376 30 01       0031*   	jr	nc,umul24_nc
040378 09          0032*   	add	hl,bc
040379             0033*   umul24_nc:
040379 3D          0034*   	dec	a
04037A 20 F6       0035*   	jr	nz,umul24_lp
04037C F1          0036*   	pop	af
04037D C1          0037*   	pop	bc
04037E D1          0038*   	pop	de
04037F C9          0039*   	ret
040380             0040*   
040380             0041*   
040380             0042*   ;------------------------------------------------------------------------
040380             0043*   ; udiv24
040380             0044*   ; Unsigned 24-bit division
040380             0045*   ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
040380             0046*   ;
040380             0047*   ; Uses AF BC DE HL
040380             0048*   ; Uses Restoring Division algorithm
040380             0049*   ;------------------------------------------------------------------------
040380             0050*   
040380             0051*   udiv24:
040380 E5          0052*   	push	hl
040381 C1          0053*   	pop		bc	;move dividend to BCU
040382 21 00 00 00 0054*   	ld		hl,0	;result
040386 A7          0055*   	and		a
040387 ED 52       0056*   	sbc		hl,de	;test for div by 0
040389 C8          0057*   	ret		z		;it's zero, carry flag is clear
04038A 19          0058*   	add		hl,de	;HL is 0 again
04038B 3E 18       0059*   	ld		a,24	;number of loops through.
04038D             0060*   udiv1:
04038D C5          0061*   	push	bc	;complicated way of doing this because of lack of access to top bits
04038E E3          0062*   	ex		(sp),hl
04038F 37          0063*   	scf
040390 ED 6A       0064*   	adc	hl,hl
040392 E3          0065*   	ex	(sp),hl
040393 C1          0066*   	pop	bc		;we now have bc = (bc * 2) + 1
040394             0067*   
040394 ED 6A       0068*   	adc	hl,hl
040396 A7          0069*   	and	a		;is this the bug
040397 ED 52       0070*   	sbc	hl,de
040399 30 02       0071*   	jr	nc,udiv2
04039B 19          0072*   	add	hl,de
04039C             0073*   ;	dec	c
04039C 0B          0074*   	dec	bc
04039D             0075*   udiv2:
04039D 3D          0076*   	dec	a
04039E 20 ED       0077*   	jr	nz,udiv1
0403A0 37          0078*   	scf		;flag used for div0 error
0403A1 C5          0079*   	push	bc
0403A2 D1          0080*   	pop		de	;remainder
0403A3 C9          0081*   	ret
0403A4             0082*   
0403A4             0083*   
0403A4             0084*   
0403A4             0085*   ;------------------------------------------------------------------------
0403A4             0086*   ; neg24
0403A4             0087*   ; Returns: HLU = 0-HLU
0403A4             0088*   ; preserves all other registers
0403A4             0089*   ;------------------------------------------------------------------------
0403A4             0090*   neg24:
0403A4 D5          0091*   	push	de
0403A5 EB          0092*   	ex		de,hl
0403A6 21 00 00 00 0093*   	ld		hl,0
0403AA B7          0094*   	or		a
0403AB ED 52       0095*   	sbc		hl,de
0403AD D1          0096*   	pop		de
0403AE C9          0097*   	ret
0403AF             0098*   
0403AF             0099*   ;------------------------------------------------------------------------
0403AF             0100*   ; or_hlu_deu: 24 bit bitwise OR
0403AF             0101*   ; Returns: hlu = hlu OR deu
0403AF             0102*   ; preserves all other registers
0403AF             0103*   ;------------------------------------------------------------------------
0403AF             0104*   or_hlu_deu:
0403AF 22 38 04 04 0105*   	ld	(bitbuf1),hl
0403B3 ED 53 3B 04 0106*   	ld	(bitbuf2),de
       04          
0403B8 D5          0107*   	push	de	;preserve DEU
0403B9 C5          0108*   	push	bc	;preserve BCU
0403BA 06 03       0109*   	ld		b,3
0403BC 21 38 04 04 0110*   	ld	hl,bitbuf1
0403C0 11 38 04 04 0111*   	ld	de,bitbuf1
0403C4             0112*   orloop_24:
0403C4 1A          0113*   	ld	a,(de)
0403C5 B6          0114*   	or	(hl)
0403C6 12          0115*   	ld	(de),a
0403C7 13          0116*   	inc	de
0403C8 23          0117*   	inc	hl
0403C9 10 F9       0118*   	djnz	orloop_24
0403CB 2A 3B 04 04 0119*   	ld	hl,(bitbuf2)
0403CF C1          0120*   	pop		bc	;restore BC
0403D0 D1          0121*   	pop		de	;restore DE
0403D1             0122*   
0403D1             0123*   ;------------------------------------------------------------------------
0403D1             0124*   ; and_hlu_deu: 24 bit bitwise AND
0403D1             0125*   ; Returns: hlu = hlu AND deu
0403D1             0126*   ; preserves all other registers
0403D1             0127*   ;------------------------------------------------------------------------
0403D1             0128*   and_hlu_deu:
0403D1 22 38 04 04 0129*   	ld	(bitbuf1),hl
0403D5 ED 53 3B 04 0130*   	ld	(bitbuf2),de
       04          
0403DA D5          0131*   	push	de	;preserve DEU
0403DB C5          0132*   	push	bc	;preserve BCU
0403DC 06 03       0133*   	ld		b,3
0403DE 21 38 04 04 0134*   	ld	hl,bitbuf1
0403E2 11 38 04 04 0135*   	ld	de,bitbuf1
0403E6             0136*   andloop_24:
0403E6 1A          0137*   	ld	a,(de)
0403E7 A6          0138*   	and	(hl)
0403E8 12          0139*   	ld	(de),a
0403E9 13          0140*   	inc	de
0403EA 23          0141*   	inc	hl
0403EB 10 F9       0142*   	djnz	andloop_24
0403ED 2A 3B 04 04 0143*   	ld	hl,(bitbuf2)
0403F1 C1          0144*   	pop		bc	;restore BC
0403F2 D1          0145*   	pop		de	;restore DE
0403F3             0146*   
0403F3             0147*   ;------------------------------------------------------------------------
0403F3             0148*   ; xor_hlu_deu: 24 bit bitwise XOR
0403F3             0149*   ; Returns: hlu = hlu XOR deu
0403F3             0150*   ; preserves all other registers
0403F3             0151*   ;------------------------------------------------------------------------
0403F3             0152*   xor_hlu_deu:
0403F3 22 38 04 04 0153*   	ld	(bitbuf1),hl
0403F7 ED 53 3B 04 0154*   	ld	(bitbuf2),de
       04          
0403FC D5          0155*   	push	de	;preserve DEU
0403FD C5          0156*   	push	bc	;preserve BCU
0403FE 06 03       0157*   	ld		b,3
040400 21 38 04 04 0158*   	ld	hl,bitbuf1
040404 11 38 04 04 0159*   	ld	de,bitbuf1
040408             0160*   xorloop_24:
040408 1A          0161*   	ld	a,(de)
040409 AE          0162*   	xor	(hl)
04040A 12          0163*   	ld	(de),a
04040B 13          0164*   	inc	de
04040C 23          0165*   	inc	hl
04040D 10 F9       0166*   	djnz	xorloop_24
04040F 2A 3B 04 04 0167*   	ld	hl,(bitbuf2)
040413 C1          0168*   	pop		bc	;restore BC
040414 D1          0169*   	pop		de	;restore DE
040415             0170*   
040415             0171*   ;------------------------------------------------------------------------
040415             0172*   ; shl_hlu: 24 bit shift left hlu by a positions
040415             0173*   ; Returns: hlu = hlu << a
040415             0174*   ;		   a = 0
040415             0175*   ; NOTE: only considers a up to 16 bits.
040415             0176*   ; preserves all other registers
040415             0177*   ; modified by Brandon R. Gates to use a instead of de
040415             0178*   ;------------------------------------------------------------------------
040415             0179*   shl_hlu:
040415 B7          0180*   	or a
040416 C8          0181*   	ret		z		;we're done
040417 29          0182*   	add		hl,hl	;shift HLU left
040418 3D          0183*   	dec a
040419 18 FA       0184*   	jr		shl_hlu
04041B             0185*   
04041B             0186*   ;------------------------------------------------------------------------
04041B             0187*   ; shr_hlu: 24 bit shift right hlu by a positions
04041B             0188*   ; Returns: hlu = hlu >> a
04041B             0189*   ;		   a = 0
04041B             0190*   ; NOTE: only considers a up to 16 bits.
04041B             0191*   ; preserves all other registers
04041B             0192*   ; modified by Brandon R. Gates to use a instead of de
04041B             0193*   ;------------------------------------------------------------------------
04041B             0194*   shr_hlu:
04041B 22 38 04 04 0195*   	ld		(bitbuf1),hl
04041F 21 3A 04 04 0196*   	ld		hl,bitbuf1+2
040423             0197*   @shr_loop:
040423 B7          0198*   	or a
040424 28 0D       0199*   	jr		z,@shr_done		;we're done
040426             0200*   ;carry is clear from or instruction
040426 CB 1E       0201*   	rr		(hl)
040428 2B          0202*   	dec		hl
040429 CB 1E       0203*   	rr		(hl)
04042B 2B          0204*   	dec		hl
04042C CB 1E       0205*   	rr		(hl)
04042E 23          0206*   	inc		hl
04042F 23          0207*   	inc		hl
040430 3D          0208*   	dec a
040431 18 F0       0209*   	jr		@shr_loop
040433             0210*   @shr_done:
040433 2A 38 04 04 0211*   	ld		hl,(bitbuf1)	;collect result
040437 C9          0212*   	ret
040438             0213*   
040438             0214*   ;------------------------------------------------------------------------
040438             0215*   ; Scratch area for calculations
040438             0216*   ;------------------------------------------------------------------------
040438 00 00 00    0217*   bitbuf1:	dw24	0	;bit manipulation buffer 1
04043B 00 00 00    0218*   bitbuf2:	dw24	0	;bit manipulation buffer 2
04043E             0219*   
04043E             0220*   ; -----------------------------------------------------------------------
04043E             0221*   ; Functions added by Brandon R. Gates
04043E             0222*   ; -----------------------------------------------------------------------
04043E             0223*   
04043E             0224*   ;------------------------------------------------------------------------
04043E             0225*   ; shr_hlu_div: Quick division by powers of two based on log2 of A
04043E             0226*   ;              Determines the LSB of A and shifts HLU accordingly.
04043E             0227*   ;              HLU = HLU >> LSB(A)
04043E             0228*   ; Returns: HLU = HLU >> LSB(A)
04043E             0229*   ; Destroys: af
04043E             0230*   ;------------------------------------------------------------------------
04043E             0231*   shr_hlu_log2a:
04043E B7          0232*   	or a    ; check for zero
04043F C8          0233*   	ret z   ; nothing to shift so we're done
040440 C5          0234*   	push 	bc ; preserve
040441 06 00       0235*   	ld		b,0 ; clear b
040443             0236*   @find_bit:
040443 0F          0237*   	rrca ; bit 0 to carry
040444 DA 4D 04 04 0238*   	jp c,@found_bit
040448 04          0239*   	inc b ; next bit
040449 C3 43 04 04 0240*   	jp @find_bit
04044D             0241*   @found_bit:
04044D 78          0242*   	ld a,b
04044E CD 1B 04 04 0243*   	call shr_hlu
040452 C1          0244*   	pop 	bc ; restore
040453 C9          0245*   	ret
040454             0246*   ; end shr_hlu_log2a
040454             0247*   
040454             0248*   ;------------------------------------------------------------------------
040454             0249*   ; shl_hlu_log2a: Quick multiplication by powers of two based on log2 of A
040454             0250*   ;                Determines the LSB of A and shifts HLU accordingly.
040454             0251*   ;                HLU = HLU << LSB(A)
040454             0252*   ; Returns: HLU = HLU << LSB(A)
040454             0253*   ; Destroys: af
040454             0254*   ;------------------------------------------------------------------------
040454             0255*   shl_hlu_log2a:
040454 B7          0256*   	or a    ; check for zero
040455 C8          0257*   	ret z   ; nothing to shift so we're done
040456 C5          0258*   	push 	bc ; preserve
040457 06 00       0259*   	ld		b,0 ; clear b
040459             0260*   @find_bit:
040459 0F          0261*   	rrca ; bit 0 to carry
04045A DA 63 04 04 0262*   	jp c,@found_bit
04045E 04          0263*   	inc b ; next bit
04045F C3 59 04 04 0264*   	jp @find_bit
040463             0265*   @found_bit:
040463 78          0266*   	ld a,b
040464 CD 15 04 04 0267*   	call shl_hlu
040468 C1          0268*   	pop 	bc ; restore
040469 C9          0269*   	ret
04046A             0270*   ; end shl_hlu_log2a
04046A             0034        include "maths.inc"
04046A             0001*   ;------------------------------------------------------------------------
04046A             0002*   ; Scratch area for calculations
04046A             0003*   ;------------------------------------------------------------------------
04046A 00 00 00    0004*   scratch1: dw24 0 ;bit manipulation buffer 1
04046D 00 00 00    0005*   scratch2: dw24 0 ;bit manipulation buffer 2
040470             0006*   
040470             0007*   ; absolute value of hlu
040470             0008*   ; returns: abs(hlu), flags set according to the incoming sign of hlu:
040470             0009*   ;         s1,z0,pv0,n1,c0 if hlu was negative
040470             0010*   ;         s0,z1,pv0,n1,c0 if hlu was zero
040470             0011*   ;         s0,z0,pv0,n1,c0 if hlu was positive
040470             0012*   ; destroys: a
040470             0013*   hlu_abs:
040470 19          0014*       add hl,de
040471 B7          0015*       or a
040472 ED 52       0016*       sbc hl,de
040474 FA 79 04 04 0017*       jp m,@is_neg
040478 C9          0018*       ret ; hlu is positive or zero so we're done
040479             0019*   @is_neg:
040479 F5          0020*       push af ; otherwise, save current flags for return
04047A CD 80 04 04 0021*       call neg_hlu ; negate hlu
04047E F1          0022*       pop af ; get back flags
04047F C9          0023*       ret
040480             0024*   
040480             0025*   ; flip the sign of hlu
040480             0026*   ; inputs: hlu
040480             0027*   ; returns: 0-hlu, flags set appropriately for the result:
040480             0028*   ;         s1,z0,pv0,n1,c1 if result is negative
040480             0029*   ;         s0,z1,pv0,n1,c0 if result is zero
040480             0030*   ;         s0,z0,pv0,n1,c1 if result is positive
040480             0031*   ; destroys a
040480             0032*   neg_hlu:
040480 D5          0033*       push de ; save de
040481 EB          0034*       ex de,hl ; put hl into de
040482 21 00 00 00 0035*       ld hl,0 ; clear hl
040486 AF          0036*       xor a ; clear carry
040487 ED 52       0037*       sbc hl,de ; 0-hlu = -hlu
040489 D1          0038*       pop de ; get de back
04048A C9          0039*       ret ; easy peasy
04048B             0040*   
04048B             0041*   ;------------------------------------------------------------------------
04048B             0042*   ; divide hlu by 2, inspired by above
04048B             0043*   ;------------------------------------------------------------------------
04048B             0044*   hlu_div2:
04048B 22 6A 04 04 0045*       ld (scratch1),hl
04048F 21 6C 04 04 0046*       ld hl,scratch1+2
040493 CB 1E       0047*       rr (hl)
040495 2B          0048*       dec hl
040496 CB 1E       0049*       rr (hl)
040498 2B          0050*       dec hl
040499 CB 1E       0051*       rr (hl)
04049B 23          0052*       inc hl
04049C 23          0053*       inc hl
04049D 2A 6A 04 04 0054*       ld hl,(scratch1)
0404A1 C9          0055*       ret
0404A2             0056*   
0404A2             0057*   ; this is my little hack to divide by 16
0404A2             0058*   hlu_div16:
0404A2 AF          0059*       xor a
0404A3 29          0060*       add hl,hl
0404A4 17          0061*       rla
0404A5 29          0062*       add hl,hl
0404A6 17          0063*       rla
0404A7 29          0064*       add hl,hl
0404A8 17          0065*       rla
0404A9 29          0066*       add hl,hl
0404AA 17          0067*       rla
0404AB 22 B8 04 04 0068*       ld (@scratch),hl
0404AF 32 BB 04 04 0069*       ld (@scratch+3),a
0404B3 2A B9 04 04 0070*       ld hl,(@scratch+1)
0404B7 C9          0071*       ret
0404B8             0072*   @scratch: ds 4
0404BC             0073*   
0404BC             0074*   ; hlu signed division by 256
0404BC             0075*   ; returns: hlu / 256
0404BC             0076*   ; destroys: af
0404BC             0077*   hlu_sdiv256:
       FF FF FF FF 
0404BC AF          0078*       xor a ; assume hl is positive
0404BD 22 D3 04 04 0079*       ld (@buffer),hl
0404C1             0080*       SIGN_HLU
0404C1 19          0001*M1     add hl,de ; 1 cycle
0404C2 B7          0002*M1     or a ; clear flags ; 1 cycle
0404C3 ED 52       0003*M1     sbc hl,de ; 2 cycles
0404C5             0004*M1     ; 4 cycles total
0404C5 F2 CA 04 04 0081*       jp p,@hl_pos
0404C9 3D          0082*       dec a
0404CA             0083*   @hl_pos:
0404CA 32 D6 04 04 0084*       ld (@buffer+3),a
0404CE 2A D4 04 04 0085*       ld hl,(@buffer+1)
0404D2 C9          0086*       ret
0404D3             0087*   @buffer: ds 4
0404D7             0088*   
0404D7             0089*   ; hlu 1 byte right shift, unsigned
0404D7             0090*   ; returns: hlu / 256, fractional portion in a
0404D7             0091*   ; destroys: af
0404D7             0092*   hlu_udiv256:
       FF FF FF FF 
0404D7 AF          0093*       xor a
0404D8 32 E9 04 04 0094*       ld (@buffer+3),a
0404DC 7D          0095*       ld a,l ; save the fractional portion
0404DD 22 E6 04 04 0096*       ld (@buffer),hl
0404E1 2A E7 04 04 0097*       ld hl,(@buffer+1)
0404E5 C9          0098*       ret
0404E6             0099*   @buffer: ds 4
0404EA             0100*   
0404EA             0101*   ; floor(value,n)
0404EA             0102*   ; inputs: hl = value to floor, de = n
0404EA             0103*   ; outputs: hl = value floored to n
0404EA             0104*   ; destroys: af, hl, bc, de
0404EA             0105*   hlu_floor:
       FF FF FF FF 
0404EA D5          0106*       push de ; save n
0404EB CD 80 03 04 0107*       call udiv24 ; de = quotient, hl = remainder
0404EF E1          0108*       pop hl ; get n back (was de)
0404F0 CD 67 03 04 0109*       call umul24 ; hl = n * quotient
0404F4 C9          0110*       ret
0404F5             0111*   ; end hlu_floor
0404F5             0112*   
0404F5             0113*   ; ceil(value,n)
0404F5             0114*   ; inputs: hl = value to ceil, de = n
0404F5             0115*   ; outputs: hl = value ceiled to n
0404F5             0116*   ; destroys: af, hl, bc, de
0404F5             0117*   hlu_ceiling:
0404F5 D5          0118*       push de ; save n
0404F6 CD 80 03 04 0119*       call udiv24 ; de = quotient, hl = remainder
0404FA             0120*       SIGN_HLU ; test remaider for zero
0404FA 19          0001*M1     add hl,de ; 1 cycle
0404FB B7          0002*M1     or a ; clear flags ; 1 cycle
0404FC ED 52       0003*M1     sbc hl,de ; 2 cycles
0404FE             0004*M1     ; 4 cycles total
0404FE CA 03 05 04 0121*       jp z,@F ; if zero, nothing to add
040502 13          0122*       inc de ; add 1 to quotient for the ceiling
040503             0123*   @@:
040503 E1          0124*       pop hl ; get n back (was de)
040504 CD 67 03 04 0125*       call umul24 ; hl = n * quotient
040508 C9          0126*       ret
040509             0127*   ; end hlu_ceiling
040509             0128*   
040509 C9          0129*       ret
04050A             0130*   
04050A 00 00 00 00 0131*   add_bcd_arg1: db #00,#00,#00,#00
04050E 00 00 00 00 0132*   add_bcd_arg2: db #00,#00,#00,#00
040512             0133*   
040512             0134*   ; set bcd values in a scratch memory address from registers bcde
040512             0135*   ; input: hl; scratch address,bcde; 8-place bcd number
040512             0136*   ; destroys ; hl
040512             0137*   set_bcd:
040512 73          0138*       ld (hl),e
040513 23          0139*       inc hl
040514 72          0140*       ld (hl),d
040515 23          0141*       inc hl
040516 71          0142*       ld (hl),c
040517 23          0143*       inc hl
040518 70          0144*       ld (hl),b
040519 C9          0145*       ret
04051A             0146*   
04051A             0147*   ; load bcd values from a scratch memory address to bcde
04051A             0148*   ; input: hl; scratch address
04051A             0149*   ; output: bcde; 8-place bcd number
04051A             0150*   ; destroys: hl
04051A             0151*   get_bcd:
04051A 5E          0152*       ld e,(hl)
04051B 23          0153*       inc hl
04051C 56          0154*       ld d,(hl)
04051D 23          0155*       inc hl
04051E 4E          0156*       ld c,(hl)
04051F 23          0157*       inc hl
040520 46          0158*       ld b,(hl)
040521 C9          0159*       ret
040522             0160*   
040522             0161*   ; BCD addition
040522             0162*   ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
040522             0163*   ;       a is the number of bytes holding each number (number of places/2)
040522             0164*   ; outputs: (hl) + (de) --> (hl)
040522             0165*   ; destroys: a,b,de,hl
040522             0166*   add_bcd:
040522 47          0167*       ld b,a ; loop counter
040523 AF          0168*       xor a ; reset a, clear carry flag
040524             0169*   adcec:
040524 1A          0170*       ld a,(de) ; addend to acc
040525 8E          0171*       adc a,(hl) ; add (hl) to acc
040526 27          0172*       daa ; adjust result to bcd
040527 77          0173*       ld (hl),a ; store result
040528 23          0174*       inc hl ; advance memory pointers
040529 13          0175*       inc de
04052A 10 F8       0176*       djnz adcec ; loop until b == 0
04052C C9          0177*       ret
04052D             0178*   
04052D             0179*   ; BCD subtraction
04052D             0180*   ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
04052D             0181*   ;       a is the number of bytes holding each number (number of places/2)
04052D             0182*   ; outputs: (hl) - (de) --> (hl)
04052D             0183*   ; destroys: a,b,de,hl
04052D             0184*   sub_bcd:
04052D 47          0185*       ld b,a ; loop counter
04052E AF          0186*       xor a ; reset a,clear carry flag
04052F             0187*   subdec:
04052F 1A          0188*       ld a,(de) ; subtrahend to acc
040530 9E          0189*       sbc a,(hl) ; subtract (hl) from acc
040531 27          0190*       daa ; adjust result to bcd
040532 77          0191*       ld (hl),a ; store result
040533 23          0192*       inc hl ; advance memory pointers
040534 13          0193*       inc de
040535 10 F8       0194*       djnz subdec ; loop until b == 0
040537 C9          0195*       ret
040538             0196*   
040538             0197*   ; http://www.z80.info/pseudo-random.txt
040538             0198*   rand_8:
040538 C5          0199*       push bc
040539 3A 4C 05 04 0200*       ld a,(r_seed)
04053D 4F          0201*       ld c,a
04053E             0202*   
04053E 0F          0203*       rrca ; multiply by 32
04053F 0F          0204*       rrca
040540 0F          0205*       rrca
040541 EE 1F       0206*       xor 0x1f
040543             0207*   
040543 81          0208*       add a,c
040544 DE FF       0209*       sbc a,255 ; carry
040546             0210*   
040546 32 4C 05 04 0211*       ld (r_seed),a
04054A C1          0212*       pop bc
04054B C9          0213*       ret
04054C 50          0214*   r_seed: defb $50
04054D             0215*   
04054D             0216*   ; https://www.omnimaga.org/asm-language/ez80-optimized-routines/msg399325/#msg399325
04054D             0217*   prng24:
04054D             0218*   ;;Expects ADL mode.
04054D             0219*   ;;Output: HL
04054D             0220*   ;;50cc
04054D             0221*   ;;33 bytes
04054D             0222*   ;;cycle length: 281,474,959,933,440 (about 2.8 trillion)
04054D ED 5B 6E 05 0223*       ld de,(seed1)
       04          
040552 B7          0224*       or a
040553 ED 62       0225*       sbc hl,hl
040555 19          0226*       add hl,de
040556 29          0227*       add hl,hl
040557 29          0228*       add hl,hl
040558 2C          0229*       inc l
040559 19          0230*       add hl,de
04055A 22 6E 05 04 0231*       ld (seed1),hl
04055E 2A 71 05 04 0232*       ld hl,(seed2)
040562 29          0233*       add hl,hl
040563 9F          0234*       sbc a,a
040564 E6 1B       0235*       and %00011011
040566 AD          0236*       xor l
040567 6F          0237*       ld l,a
040568 22 71 05 04 0238*       ld (seed2),hl
04056C 19          0239*       add hl,de
04056D C9          0240*       ret
04056E 00 00 00    0241*   seed1: dl 0
040571 00 00 00    0242*   seed2: dl 0
040574             0035        include "fonts.inc"
040574             0001*   fonts_load:
040574 DD 21 A5 05 0002*       ld ix,font_list ; pointer to font list lookup
       04          
040579 06 1D       0003*       ld b,num_fonts ; loop counter
04057B             0004*   
04057B             0005*   @load_loop:
04057B C5          0006*       push bc ; save loop counter
04057C             0007*   
04057C             0008*   ; load font into a buffer
04057C DD 27 06    0009*       ld hl,(ix+font_list_bufferId)
04057F DD 31 09    0010*       ld iy,(ix+font_list_filename)
040582 CD 04 19 04 0011*       call vdu_load_buffer_from_file
040586             0012*   
040586             0013*   ; create font from buffer
040586 DD 27 06    0014*       ld hl,(ix+font_list_bufferId)
040589 DD 5E 00    0015*       ld e,(ix+font_list_width)
04058C DD 56 03    0016*       ld d,(ix+font_list_height)
04058F 3E 00       0017*       ld a,0 ; flags
040591 CD 57 1B 04 0018*       call vdu_font_create
040595             0019*   
040595             0020*   ; select font
040595 DD 27 06    0021*       ld hl,(ix+font_list_bufferId)
040598 3E 01       0022*       ld a,1 ; flags
04059A CD 3D 1B 04 0023*       call vdu_font_select
04059E             0024*   
04059E             0025*   ; ; debug print filename
04059E             0026*   ;     call printNewLine
04059E             0027*   ;     ld hl,(ix+font_list_filename)
04059E             0028*   ;     call printString
04059E             0029*   
04059E             0030*   ; advance font_list pointer to next record
04059E ED 32 0C    0031*       lea ix,ix+font_list_record_size
0405A1             0032*   
0405A1             0033*   ; restore loop counter
0405A1 C1          0034*       pop bc
0405A2 10 D7       0035*       djnz @load_loop
0405A4             0036*   
0405A4             0037*   ; all done
0405A4 C9          0038*       ret
0405A5             0036        include "fonts_list.inc"
0405A5             0001*   ; Generated by asm_config_editor.py
0405A5             0002*   font_list_record_size: equ 12
0405A5             0003*   font_list_width: equ 0
0405A5             0004*   font_list_height: equ 3
0405A5             0005*   font_list_bufferId: equ 6
0405A5             0006*   font_list_filename: equ 9
0405A5             0007*   
0405A5             0008*   num_fonts: equ 29
0405A5             0009*   
0405A5             0010*   ; Index list:
0405A5             0011*   amiga_forever_16x16: equ 64000
0405A5             0012*   amiga_forever_16x24: equ 64001
0405A5             0013*   amiga_forever_8x16: equ 64002
0405A5             0014*   amiga_forever_8x8: equ 64003
0405A5             0015*   computer_pixel_7_10x15: equ 64004
0405A5             0016*   computer_pixel_7_10x24: equ 64005
0405A5             0017*   computer_pixel_7_8x12: equ 64006
0405A5             0018*   computer_pixel_7_8x14: equ 64007
0405A5             0019*   computer_pixel_7_8x16: equ 64008
0405A5             0020*   dopecre_8x8: equ 64009
0405A5             0021*   gamer_2_8x8: equ 64010
0405A5             0022*   Lat15_VGA8_8x8: equ 64011
0405A5             0023*   Lat2_Terminus12x6_6x12: equ 64012
0405A5             0024*   Lat2_TerminusBold14_8x14: equ 64013
0405A5             0025*   Lat2_VGA14_8x14: equ 64014
0405A5             0026*   Lat2_VGA16_8x16: equ 64015
0405A5             0027*   Lat2_VGA8_8x8: equ 64016
0405A5             0028*   Lat38_VGA8_8x8: equ 64017
0405A5             0029*   Lat7_Fixed13_8x13: equ 64018
0405A5             0030*   Lat7_Terminus12x6_6x12: equ 64019
0405A5             0031*   Lat7_TerminusBold16_8x16: equ 64020
0405A5             0032*   Lat7_VGA14_8x14: equ 64021
0405A5             0033*   Lat7_VGA16_8x16: equ 64022
0405A5             0034*   Lat7_VGA8_8x8: equ 64023
0405A5             0035*   planetary_contact_8x8: equ 64024
0405A5             0036*   scriptorium_12x14: equ 64025
0405A5             0037*   Squarewave_Bold_8x12: equ 64026
0405A5             0038*   super_mario_bros_2_8x8: equ 64027
0405A5             0039*   wendy_neue_6x6: equ 64028
0405A5             0040*   
0405A5             0041*   font_list: ; width; height; bufferId; filename;:
0405A5 10 00 00 10 0042*   	dl 16, 16, 64000, fn_amiga_forever_16x16
       00 00 00 FA 
       00 01 07 04 
0405B1 10 00 00 18 0043*   	dl 16, 24, 64001, fn_amiga_forever_16x24
       00 00 01 FA 
       00 1F 07 04 
0405BD 08 00 00 10 0044*   	dl 8, 16, 64002, fn_amiga_forever_8x16
       00 00 02 FA 
       00 3D 07 04 
0405C9 08 00 00 08 0045*   	dl 8, 8, 64003, fn_amiga_forever_8x8
       00 00 03 FA 
       00 5A 07 04 
0405D5 0A 00 00 0F 0046*   	dl 10, 15, 64004, fn_computer_pixel_7_10x15
       00 00 04 FA 
       00 76 07 04 
0405E1 0A 00 00 18 0047*   	dl 10, 24, 64005, fn_computer_pixel_7_10x24
       00 00 05 FA 
       00 97 07 04 
0405ED 08 00 00 0C 0048*   	dl 8, 12, 64006, fn_computer_pixel_7_8x12
       00 00 06 FA 
       00 B8 07 04 
0405F9 08 00 00 0E 0049*   	dl 8, 14, 64007, fn_computer_pixel_7_8x14
       00 00 07 FA 
       00 D8 07 04 
040605 08 00 00 10 0050*   	dl 8, 16, 64008, fn_computer_pixel_7_8x16
       00 00 08 FA 
       00 F8 07 04 
040611 08 00 00 08 0051*   	dl 8, 8, 64009, fn_dopecre_8x8
       00 00 09 FA 
       00 18 08 04 
04061D 08 00 00 08 0052*   	dl 8, 8, 64010, fn_gamer_2_8x8
       00 00 0A FA 
       00 2E 08 04 
040629 08 00 00 08 0053*   	dl 8, 8, 64011, fn_Lat15_VGA8_8x8
       00 00 0B FA 
       00 44 08 04 
040635 06 00 00 0C 0054*   	dl 6, 12, 64012, fn_Lat2_Terminus12x6_6x12
       00 00 0C FA 
       00 5D 08 04 
040641 08 00 00 0E 0055*   	dl 8, 14, 64013, fn_Lat2_TerminusBold14_8x14
       00 00 0D FA 
       00 7E 08 04 
04064D 08 00 00 0E 0056*   	dl 8, 14, 64014, fn_Lat2_VGA14_8x14
       00 00 0E FA 
       00 A1 08 04 
040659 08 00 00 10 0057*   	dl 8, 16, 64015, fn_Lat2_VGA16_8x16
       00 00 0F FA 
       00 BB 08 04 
040665 08 00 00 08 0058*   	dl 8, 8, 64016, fn_Lat2_VGA8_8x8
       00 00 10 FA 
       00 D5 08 04 
040671 08 00 00 08 0059*   	dl 8, 8, 64017, fn_Lat38_VGA8_8x8
       00 00 11 FA 
       00 ED 08 04 
04067D 08 00 00 0D 0060*   	dl 8, 13, 64018, fn_Lat7_Fixed13_8x13
       00 00 12 FA 
       00 06 09 04 
040689 06 00 00 0C 0061*   	dl 6, 12, 64019, fn_Lat7_Terminus12x6_6x12
       00 00 13 FA 
       00 22 09 04 
040695 08 00 00 10 0062*   	dl 8, 16, 64020, fn_Lat7_TerminusBold16_8x16
       00 00 14 FA 
       00 43 09 04 
0406A1 08 00 00 0E 0063*   	dl 8, 14, 64021, fn_Lat7_VGA14_8x14
       00 00 15 FA 
       00 66 09 04 
0406AD 08 00 00 10 0064*   	dl 8, 16, 64022, fn_Lat7_VGA16_8x16
       00 00 16 FA 
       00 80 09 04 
0406B9 08 00 00 08 0065*   	dl 8, 8, 64023, fn_Lat7_VGA8_8x8
       00 00 17 FA 
       00 9A 09 04 
0406C5 08 00 00 08 0066*   	dl 8, 8, 64024, fn_planetary_contact_8x8
       00 00 18 FA 
       00 B2 09 04 
0406D1 0C 00 00 0E 0067*   	dl 12, 14, 64025, fn_scriptorium_12x14
       00 00 19 FA 
       00 D2 09 04 
0406DD 08 00 00 0C 0068*   	dl 8, 12, 64026, fn_Squarewave_Bold_8x12
       00 00 1A FA 
       00 EE 09 04 
0406E9 08 00 00 08 0069*   	dl 8, 8, 64027, fn_super_mario_bros_2_8x8
       00 00 1B FA 
       00 0D 0A 04 
0406F5 06 00 00 06 0070*   	dl 6, 6, 64028, fn_wendy_neue_6x6
       00 00 1C FA 
       00 2E 0A 04 
040701             0071*   
040701             0072*   ; files_list: ; filename:
040701 66 6F 6E 74 0073*   fn_amiga_forever_16x16: db "fontsamiga_forever_16x16.font",0
       73 61 6D 69 
       67 61 5F 66 
       6F 72 65 76 
       65 72 5F 31 
       36 78 31 36 
       2E 66 6F 6E 
       74 00       
04071F 66 6F 6E 74 0074*   fn_amiga_forever_16x24: db "fontsamiga_forever_16x24.font",0
       73 61 6D 69 
       67 61 5F 66 
       6F 72 65 76 
       65 72 5F 31 
       36 78 32 34 
       2E 66 6F 6E 
       74 00       
04073D 66 6F 6E 74 0075*   fn_amiga_forever_8x16: db "fontsamiga_forever_8x16.font",0
       73 61 6D 69 
       67 61 5F 66 
       6F 72 65 76 
       65 72 5F 38 
       78 31 36 2E 
       66 6F 6E 74 
       00          
04075A 66 6F 6E 74 0076*   fn_amiga_forever_8x8: db "fontsamiga_forever_8x8.font",0
       73 61 6D 69 
       67 61 5F 66 
       6F 72 65 76 
       65 72 5F 38 
       78 38 2E 66 
       6F 6E 74 00 
040776 66 6F 6E 74 0077*   fn_computer_pixel_7_10x15: db "fontscomputer_pixel_7_10x15.font",0
       73 63 6F 6D 
       70 75 74 65 
       72 5F 70 69 
       78 65 6C 5F 
       37 5F 31 30 
       78 31 35 2E 
       66 6F 6E 74 
       00          
040797 66 6F 6E 74 0078*   fn_computer_pixel_7_10x24: db "fontscomputer_pixel_7_10x24.font",0
       73 63 6F 6D 
       70 75 74 65 
       72 5F 70 69 
       78 65 6C 5F 
       37 5F 31 30 
       78 32 34 2E 
       66 6F 6E 74 
       00          
0407B8 66 6F 6E 74 0079*   fn_computer_pixel_7_8x12: db "fontscomputer_pixel_7_8x12.font",0
       73 63 6F 6D 
       70 75 74 65 
       72 5F 70 69 
       78 65 6C 5F 
       37 5F 38 78 
       31 32 2E 66 
       6F 6E 74 00 
0407D8 66 6F 6E 74 0080*   fn_computer_pixel_7_8x14: db "fontscomputer_pixel_7_8x14.font",0
       73 63 6F 6D 
       70 75 74 65 
       72 5F 70 69 
       78 65 6C 5F 
       37 5F 38 78 
       31 34 2E 66 
       6F 6E 74 00 
0407F8 66 6F 6E 74 0081*   fn_computer_pixel_7_8x16: db "fontscomputer_pixel_7_8x16.font",0
       73 63 6F 6D 
       70 75 74 65 
       72 5F 70 69 
       78 65 6C 5F 
       37 5F 38 78 
       31 36 2E 66 
       6F 6E 74 00 
040818 66 6F 6E 74 0082*   fn_dopecre_8x8: db "fontsdopecre_8x8.font",0
       73 64 6F 70 
       65 63 72 65 
       5F 38 78 38 
       2E 66 6F 6E 
       74 00       
04082E 66 6F 6E 74 0083*   fn_gamer_2_8x8: db "fontsgamer_2_8x8.font",0
       73 67 61 6D 
       65 72 5F 32 
       5F 38 78 38 
       2E 66 6F 6E 
       74 00       
040844 66 6F 6E 74 0084*   fn_Lat15_VGA8_8x8: db "fontsLat15-VGA8_8x8.font",0
       73 4C 61 74 
       31 35 2D 56 
       47 41 38 5F 
       38 78 38 2E 
       66 6F 6E 74 
       00          
04085D 66 6F 6E 74 0085*   fn_Lat2_Terminus12x6_6x12: db "fontsLat2-Terminus12x6_6x12.font",0
       73 4C 61 74 
       32 2D 54 65 
       72 6D 69 6E 
       75 73 31 32 
       78 36 5F 36 
       78 31 32 2E 
       66 6F 6E 74 
       00          
04087E 66 6F 6E 74 0086*   fn_Lat2_TerminusBold14_8x14: db "fontsLat2-TerminusBold14_8x14.font",0
       73 4C 61 74 
       32 2D 54 65 
       72 6D 69 6E 
       75 73 42 6F 
       6C 64 31 34 
       5F 38 78 31 
       34 2E 66 6F 
       6E 74 00    
0408A1 66 6F 6E 74 0087*   fn_Lat2_VGA14_8x14: db "fontsLat2-VGA14_8x14.font",0
       73 4C 61 74 
       32 2D 56 47 
       41 31 34 5F 
       38 78 31 34 
       2E 66 6F 6E 
       74 00       
0408BB 66 6F 6E 74 0088*   fn_Lat2_VGA16_8x16: db "fontsLat2-VGA16_8x16.font",0
       73 4C 61 74 
       32 2D 56 47 
       41 31 36 5F 
       38 78 31 36 
       2E 66 6F 6E 
       74 00       
0408D5 66 6F 6E 74 0089*   fn_Lat2_VGA8_8x8: db "fontsLat2-VGA8_8x8.font",0
       73 4C 61 74 
       32 2D 56 47 
       41 38 5F 38 
       78 38 2E 66 
       6F 6E 74 00 
0408ED 66 6F 6E 74 0090*   fn_Lat38_VGA8_8x8: db "fontsLat38-VGA8_8x8.font",0
       73 4C 61 74 
       33 38 2D 56 
       47 41 38 5F 
       38 78 38 2E 
       66 6F 6E 74 
       00          
040906 66 6F 6E 74 0091*   fn_Lat7_Fixed13_8x13: db "fontsLat7-Fixed13_8x13.font",0
       73 4C 61 74 
       37 2D 46 69 
       78 65 64 31 
       33 5F 38 78 
       31 33 2E 66 
       6F 6E 74 00 
040922 66 6F 6E 74 0092*   fn_Lat7_Terminus12x6_6x12: db "fontsLat7-Terminus12x6_6x12.font",0
       73 4C 61 74 
       37 2D 54 65 
       72 6D 69 6E 
       75 73 31 32 
       78 36 5F 36 
       78 31 32 2E 
       66 6F 6E 74 
       00          
040943 66 6F 6E 74 0093*   fn_Lat7_TerminusBold16_8x16: db "fontsLat7-TerminusBold16_8x16.font",0
       73 4C 61 74 
       37 2D 54 65 
       72 6D 69 6E 
       75 73 42 6F 
       6C 64 31 36 
       5F 38 78 31 
       36 2E 66 6F 
       6E 74 00    
040966 66 6F 6E 74 0094*   fn_Lat7_VGA14_8x14: db "fontsLat7-VGA14_8x14.font",0
       73 4C 61 74 
       37 2D 56 47 
       41 31 34 5F 
       38 78 31 34 
       2E 66 6F 6E 
       74 00       
040980 66 6F 6E 74 0095*   fn_Lat7_VGA16_8x16: db "fontsLat7-VGA16_8x16.font",0
       73 4C 61 74 
       37 2D 56 47 
       41 31 36 5F 
       38 78 31 36 
       2E 66 6F 6E 
       74 00       
04099A 66 6F 6E 74 0096*   fn_Lat7_VGA8_8x8: db "fontsLat7-VGA8_8x8.font",0
       73 4C 61 74 
       37 2D 56 47 
       41 38 5F 38 
       78 38 2E 66 
       6F 6E 74 00 
0409B2 66 6F 6E 74 0097*   fn_planetary_contact_8x8: db "fontsplanetary_contact_8x8.font",0
       73 70 6C 61 
       6E 65 74 61 
       72 79 5F 63 
       6F 6E 74 61 
       63 74 5F 38 
       78 38 2E 66 
       6F 6E 74 00 
0409D2 66 6F 6E 74 0098*   fn_scriptorium_12x14: db "fontsscriptorium_12x14.font",0
       73 73 63 72 
       69 70 74 6F 
       72 69 75 6D 
       5F 31 32 78 
       31 34 2E 66 
       6F 6E 74 00 
0409EE 66 6F 6E 74 0099*   fn_Squarewave_Bold_8x12: db "fontsSquarewave_Bold_8x12.font",0
       73 53 71 75 
       61 72 65 77 
       61 76 65 5F 
       42 6F 6C 64 
       5F 38 78 31 
       32 2E 66 6F 
       6E 74 00    
040A0D 66 6F 6E 74 0100*   fn_super_mario_bros_2_8x8: db "fontssuper_mario_bros_2_8x8.font",0
       73 73 75 70 
       65 72 5F 6D 
       61 72 69 6F 
       5F 62 72 6F 
       73 5F 32 5F 
       38 78 38 2E 
       66 6F 6E 74 
       00          
040A2E 66 6F 6E 74 0101*   fn_wendy_neue_6x6: db "fontswendy_neue_6x6.font",0
       73 77 65 6E 
       64 79 5F 6E 
       65 75 65 5F 
       36 78 36 2E 
       66 6F 6E 74 
       00          
040A47             0037        include "fixed168.inc"
040A47             0001*   ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
040A47             0002*   ; uses EZ80 MLT instruction for speed
040A47             0003*   ; operation: UHL * A --> UHL
040A47             0004*   ; destroys: AF, HL
040A47             0005*   smul24x8:
040A47             0006*   ; make hl positive and store sign flag
040A47 CD 70 04 04 0007*       call hlu_abs
040A4B F5          0008*       push af
040A4C             0009*   ; do the division
040A4C CD 57 0A 04 0010*       call mul24x8 ; hl = product
040A50             0011*   ; adjust sign of result
040A50 F1          0012*       pop af ; sign de
040A51 F0          0013*       ret p ; hl was positive, nothing to do
040A52 CD 80 04 04 0014*       call neg_hlu ; result is negative
040A56 C9          0015*       ret
040A57             0016*   
040A57             0017*   ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
040A57             0018*   ; uses EZ80 MLT instruction for speed
040A57             0019*   ; operation: UHL * A --> AUHL
040A57             0020*   ; destroys: AF, HL
040A57             0021*   mul24x8:
040A57 D5          0022*       push de ; preserve de
040A58             0023*   ; low byte
040A58 5D          0024*       ld e,l
040A59 57          0025*       ld d,a
040A5A ED 5C       0026*       mlt de
040A5C 6B          0027*       ld l,e ; product low byte
040A5D 08          0028*       ex af,af' ; save multiplier
040A5E 7A          0029*       ld a,d ; carry
040A5F 08          0030*       ex af,af' ; save carry, restore multiplier
040A60             0031*   ; high byte
040A60 5C          0032*       ld e,h
040A61 57          0033*       ld d,a
040A62 ED 5C       0034*       mlt de
040A64 08          0035*       ex af,af' ; save multiplier, restore carry
040A65 83          0036*       add a,e ; add carry
040A66 67          0037*       ld h,a ; product middle byte
040A67 7A          0038*       ld a,d ; carry
040A68 08          0039*       ex af,af' ; save carry, restore multiplier
040A69             0040*   ; upper byte
040A69 22 84 0A 04 0041*       ld (@scratch),hl ; 7 cycles
040A6D 5F          0042*       ld e,a
040A6E 3A 86 0A 04 0043*       ld a,(@scratch+2)
040A72 57          0044*       ld d,a
040A73 ED 5C       0045*       mlt de
040A75 08          0046*       ex af,af' ; restore carry
040A76 8B          0047*       adc a,e ; add carry
040A77 32 86 0A 04 0048*       ld (@scratch+2),a ; 5 cycles
040A7B 2A 84 0A 04 0049*       ld hl,(@scratch) ; 7 cycles
040A7F             0050*   ; highest byte
040A7F 3E 00       0051*       ld a,0 ; preserve carry flag
040A81 8A          0052*       adc a,d ; product highest byte
040A82 D1          0053*       pop de ; restore de
040A83 C9          0054*       ret
040A84             0055*   @scratch: ds 3
040A87             0056*   
       FF FF FF 
040A87 00 00 00 00 0057*   mul24out: blkb 6,0
       00 00       
040A8D             0058*   
040A8D             0059*   ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
040A8D             0060*   ; operation: UHL * UDE --> mul24out
040A8D             0061*   mul24:
040A8D DD E5       0062*       push ix ; preserve
040A8F             0063*   ; point to output buffer and clear it
040A8F DD 21 87 0A 0064*       ld ix,mul24out
       04          
040A94 C5          0065*       push bc
040A95 01 00 00 00 0066*       ld bc,0
040A99 DD 0F 00    0067*       ld (ix),bc
040A9C DD 0F 03    0068*       ld (ix+3),bc
040A9F C1          0069*       pop bc
040AA0             0070*   ; STEP 1: UHL * E
040AA0 7B          0071*       ld a,e
040AA1 E5          0072*       push hl
040AA2 CD 57 0A 04 0073*       call mul24x8
040AA6 DD 2F 00    0074*       ld (ix+0),hl
040AA9 DD 77 03    0075*       ld (ix+3),a
040AAC             0076*   ; STEP 2: UHL * D
040AAC E1          0077*       pop hl
040AAD E5          0078*       push hl
040AAE 7A          0079*       ld a,d
040AAF CD 57 0A 04 0080*       call mul24x8
040AB3 CD CC 0A 04 0081*       call @accumulate
040AB7             0082*   ; STEP 3: UHL * DEU
040AB7 E1          0083*       pop hl
040AB8 ED 53 FC 0A 0084*       ld (@de),de
       04          
040ABD 3A FE 0A 04 0085*       ld a,(@de+2)
040AC1 CD 57 0A 04 0086*       call mul24x8
040AC5 CD CC 0A 04 0087*       call @accumulate
040AC9             0088*   ; all done
040AC9 DD E1       0089*       pop ix ; restore
040ACB C9          0090*       ret
040ACC             0091*   @accumulate:
040ACC DD 23       0092*       inc ix
040ACE             0093*   ; highest byte of product to carry
040ACE DD 77 03    0094*       ld (ix+3),a
040AD1             0095*   ; low byte of product
040AD1 7D          0096*       ld a,l
040AD2 DD 86 00    0097*       add a,(ix+0)
040AD5 DD 77 00    0098*       ld (ix+0),a
040AD8             0099*   ; high byte of product
040AD8 7C          0100*       ld a,h
040AD9 DD 8E 01    0101*       adc a,(ix+1)
040ADC DD 77 01    0102*       ld (ix+1),a
040ADF             0103*   ; uppper byte of product
040ADF 22 F9 0A 04 0104*       ld (@hl),hl
040AE3 3A FB 0A 04 0105*       ld a,(@hl+2)
040AE7 DD 8E 02    0106*       adc a,(ix+2)
040AEA DD 77 02    0107*       ld (ix+2),a
040AED             0108*   ; carry
040AED 3E 00       0109*       ld a,0 ; preserve flags
040AEF DD 8E 03    0110*       adc a,(ix+3)
040AF2 DD 77 03    0111*       ld (ix+3),a
040AF5 C9          0112*       ret
040AF6             0113*   
040AF6 00 00 00    0114*   @ix: dl 0
040AF9 00 00 00    0115*   @hl: dl 0
040AFC 00 00 00    0116*   @de: dl 0
040AFF             0117*   
040AFF             0118*   ; ; UHL * UDE --> UHL (unsigned)
040AFF             0119*   ; umul24:
040AFF             0120*   ;     call mul24
040AFF             0121*   ;     ld hl,(mul24out)
040AFF             0122*   ;     ret
040AFF             0123*   
040AFF             0124*   ; UH.L = UH.L*UD.E (unsigned)
040AFF             0125*   umul168:
040AFF CD 8D 0A 04 0126*       call mul24
040B03 2A 88 0A 04 0127*       ld hl,(mul24out+1)
040B07 C9          0128*       ret
040B08             0129*   
040B08             0130*   ; UH.L * UD.E --> UH.L (signed)
040B08             0131*   smul168:
040B08             0132*   ; make everything positive and store sign flags
040B08 CD 70 04 04 0133*       call hlu_abs
040B0C F5          0134*       push af
040B0D EB          0135*       ex de,hl
040B0E CD 70 04 04 0136*       call hlu_abs
040B12 EB          0137*       ex de,hl
040B13 F5          0138*       push af
040B14             0139*   ; do the division
040B14 CD FF 0A 04 0140*       call umul168 ; hl = product
040B18             0141*   ; adjust sign of result
040B18 F1          0142*       pop af ; sign de
040B19 FA 24 0B 04 0143*       jp m,@de_neg
040B1D F1          0144*       pop af ; sign hl
040B1E F0          0145*       ret p ; both positive, nothing to do
040B1F             0146*   @hl_neg:
040B1F CD 80 04 04 0147*       call neg_hlu ; de pos, hl neg, result is negative
040B23 C9          0148*       ret
040B24             0149*   @de_neg:
040B24 F1          0150*       pop af
040B25 F8          0151*       ret m ; both negative, nothing to do
040B26 CD 80 04 04 0152*       call neg_hlu ; result is negative
040B2A C9          0153*       ret
040B2B             0154*   
040B2B             0155*   ; UH.L / UD.E --> UD.E rem UHL (unsigned)
040B2B             0156*   ; perform unsigned division of 16.8 fixed place values
040B2B             0157*   ; with an unsigned 16.8 fixed place result and 24-bit remainder
040B2B             0158*   udiv168:
040B2B             0159*   ; back up divisor
040B2B ED 53 62 0B 0160*       ld (@ude),de
       04          
040B30             0161*   ; get the 16-bit integer part of the quotient
040B30 CD 80 03 04 0162*       call udiv24 ; de = quotient, hl = remainder
040B34             0163*   ; load quotient to upper three bytes of output
040B34 ED 53 69 0B 0164*       ld (div168_out+1),de
       04          
040B39             0165*   @div256:
040B39             0166*   ; multiply remainder by 256
040B39             0167*       hlu_mul256
040B39 29          0001*M1     add hl,hl ; * 2
040B3A 29          0002*M1     add hl,hl ; * 4
040B3B 29          0003*M1     add hl,hl ; * 8
040B3C 29          0004*M1     add hl,hl ; * 16
040B3D 29          0005*M1     add hl,hl ; * 32
040B3E 29          0006*M1     add hl,hl ; * 64
040B3F 29          0007*M1     add hl,hl ; * 128
040B40 29          0008*M1     add hl,hl ; * 256
040B41             0168*   ; skip fractional computation if remainder is zero
040B41             0169*       SIGN_HLU
040B41 19          0001*M1     add hl,de ; 1 cycle
040B42 B7          0002*M1     or a ; clear flags ; 1 cycle
040B43 ED 52       0003*M1     sbc hl,de ; 2 cycles
040B45             0004*M1     ; 4 cycles total
040B45 20 03       0170*       jr nz,@div_frac
040B47 AF          0171*       xor a
040B48 18 0A       0172*       jr @write_frac
040B4A             0173*   ; now divide the shifted remainder by the divisor
040B4A             0174*   @div_frac:
040B4A ED 5B 62 0B 0175*       ld de,(@ude) ; get back divisor
       04          
040B4F CD 80 03 04 0176*       call udiv24 ; de = quotient, hl = remainder
040B53             0177*   ; load low byte of quotient to low byte of output
040B53 7B          0178*       ld a,e
040B54             0179*   @write_frac:
040B54 32 68 0B 04 0180*       ld (div168_out),a
040B58             0181*   ; load de with return value
040B58 ED 5B 68 0B 0182*       ld de,(div168_out)
       04          
040B5D             0183*   ; load a with any overflow
040B5D 3A 6B 0B 04 0184*       ld a,(div168_out+3)
040B61 C9          0185*       ret ; ud.e is the 16.8 result
040B62             0186*   @ude: ds 6
040B68             0187*   div168_out: ds 4 ; the extra byte is for overflow
040B6C             0188*   
040B6C             0189*   ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
040B6C             0190*   ; perform signed division of 16.8 fixed place values
040B6C             0191*   ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
040B6C             0192*   sdiv168:
040B6C             0193*   ; make everything positive and store sign flags
       FF FF FF FF 
       FF FF FF FF 
       FF FF 
040B6C CD 70 04 04 0194*       call hlu_abs
040B70 F5          0195*       push af
040B71 EB          0196*       ex de,hl
040B72 CD 70 04 04 0197*       call hlu_abs
040B76 EB          0198*       ex de,hl
040B77 F5          0199*       push af
040B78             0200*   ; do the division
040B78 CD 2B 0B 04 0201*       call udiv168 ; de = quotient, hl = remainder
040B7C             0202*   ; adjust sign of result
040B7C F1          0203*       pop af ; sign de
040B7D FA 8A 0B 04 0204*       jp m,@de_neg
040B81 F1          0205*       pop af ; sign hl
040B82 F0          0206*       ret p ; both positive, nothing to do
040B83             0207*   @hl_neg:
040B83 EB          0208*       ex de,hl ; hl = quotient, de = remainder
040B84 CD 80 04 04 0209*       call neg_hlu ; de pos, hl neg, result is negative
040B88 EB          0210*       ex de,hl ; de = negated quotient, hl = remainder
040B89 C9          0211*       ret
040B8A             0212*   @de_neg:
040B8A F1          0213*       pop af
040B8B F8          0214*       ret m ; both negative, nothing to do
040B8C EB          0215*       ex de,hl ; hl = quotient, de = remainder
040B8D CD 80 04 04 0216*       call neg_hlu ; result is negative
040B91 EB          0217*       ex de,hl ; de = negated quotient, hl = remainder
040B92 C9          0218*       ret
040B93             0219*   
040B93             0220*   ; convert signed angles from a 360 to 256 degree circle
040B93             0221*   ; inputs: uh.l is the angle360 in 16.8 fixed format
040B93             0222*   ; outputs: uh.l is the angle256 in 16.8 fixed format
040B93             0223*   ; destroys: TODO
040B93             0224*   deg_360_to_256:
040B93 D5          0225*       push de ; preserve de
040B94             0226*   ; make angle positive and store sign flag
040B94 CD 70 04 04 0227*       call hlu_abs
040B98 F5          0228*       push af
040B99             0229*   ; multiply by coversion factor of 256/360
040B99 11 B6 00 00 0230*       ld de,0x0000B6 ; 0.711
040B9D CD FF 0A 04 0231*       call umul168 ; uh.l = uh.l * 0.711
040BA1             0232*   ; restore sign flag and adjust output accordingly
040BA1 F1          0233*       pop af
040BA2 F2 AA 0B 04 0234*       jp p,@pos ; positive number
040BA6 CD 80 04 04 0235*       call neg_hlu
040BAA             0236*   @pos:
040BAA             0237*   ; restore de and return uh.l as the result
040BAA D1          0238*       pop de
040BAB C9          0239*       ret
040BAC             0240*   
040BAC             0241*   ; convert signed angles from a 256 to 360 degree circle
040BAC             0242*   ; inputs: uh.l is the angle256 in 16.8 fixed format
040BAC             0243*   ; outputs: uh.l is the angle360 in 16.8 fixed format
040BAC             0244*   ; destroys: TODO
040BAC             0245*   deg_256_to_360:
040BAC D5          0246*       push de ; preserve de
040BAD             0247*   ; make angle positive and store sign flag
040BAD CD 70 04 04 0248*       call hlu_abs
040BB1 F5          0249*       push af
040BB2             0250*   ; multiply by coversion factor of 360/256
040BB2 11 68 01 00 0251*       ld de,0x000168 ; 1.406
040BB6 CD FF 0A 04 0252*       call umul168 ; uh.l = uh.l * 1.406
040BBA             0253*   ; restore sign flag and adjust output accordingly
040BBA F1          0254*       pop af
040BBB F2 C3 0B 04 0255*       jp p,@pos ; positive number
040BBF CD 80 04 04 0256*       call neg_hlu
040BC3             0257*   @pos:
040BC3             0258*   ; restore de and return uh.l as the result
040BC3 D1          0259*       pop de
040BC4 C9          0260*       ret
040BC5             0261*   
040BC5             0262*   ; fixed 16.8 routine
040BC5             0263*   ; cos(uh.l) --> uh.l
040BC5             0264*   ; destroys: f, hl
040BC5             0265*   cos168:
040BC5 D5          0266*       push de ; preserve de
040BC6             0267*   ; for cos we simply increment the angle by 90 degrees
040BC6             0268*   ; or 0x004000 in 16.8 degrees256
040BC6             0269*   ; which makes it a sin problem
040BC6 11 00 40 00 0270*       ld de,0x004000
040BCA 19          0271*       add hl,de ; modulo 256 happens below
040BCB D1          0272*       pop de ; restore de
040BCC             0273*   ; fall through to sin168
040BCC             0274*   
040BCC             0275*   ; ---------------------
040BCC             0276*   ; fixed 16.8 routine
040BCC             0277*   ; sin(uh.l) --> uh.l
040BCC             0278*   ; destroys: f, hl
040BCC             0279*   sin168:
040BCC D5          0280*       push de
040BCD             0281*   ; handle negative angles appropriately
040BCD CD 70 04 04 0282*       call hlu_abs
040BD1 F2 DA 0B 04 0283*       jp p,@F
040BD5 11 00 00 FF 0284*       ld de,-256*256
040BD9 19          0285*       add hl,de
040BDA             0286*   @@:
040BDA 2E 03       0287*       ld l,3 ; multiply by 3 to get our lookup index
040BDC ED 6C       0288*       mlt hl
040BDE 11 92 0E 04 0289*       ld de,sin_lut_168 ; grab the lut address
040BE2 19          0290*       add hl,de ; bump hl by the index
040BE3 ED 27       0291*       ld hl,(hl) ; don't try this on a z80!
040BE5 D1          0292*       pop de
040BE6 C9          0293*       ret
040BE7             0294*   
040BE7             0295*   ; 16.8 fixed inputs / outputs
040BE7             0296*   ; takes: uh.l as angle in degrees 256
040BE7             0297*   ;        ud.e as radius
040BE7             0298*   ; returns ub.c as dx, ud.e as dy, uh.l as radius
040BE7             0299*   ;        displacements from origin (0,0)
040BE7             0300*   ; destroys: everything except indexes
040BE7             0301*   polar_to_cartesian:
040BE7             0302*   ; back up input parameters
040BE7 22 16 0C 04 0303*       ld (@angle), hl
040BEB ED 53 19 0C 0304*       ld (@radius), de
       04          
040BF0             0305*   ; compute dx = sin(uh.l) * ud.e
040BF0 CD CC 0B 04 0306*       call sin168 ; uh.l = sin(uh.l)
040BF4 ED 5B 19 0C 0307*       ld de,(@radius)
       04          
040BF9 CD 08 0B 04 0308*       call smul168 ; uh.l = dx
040BFD E5          0309*       push hl
040BFE             0310*   ; compute dy = -cos(uh.l) * ud.e
040BFE 2A 16 0C 04 0311*       ld hl,(@angle)
040C02 CD C5 0B 04 0312*       call cos168 ; uh.l = cos(uh.l)
040C06 ED 5B 19 0C 0313*       ld de,(@radius)
       04          
040C0B CD 08 0B 04 0314*       call smul168 ; uh.l = dy
040C0F CD 80 04 04 0315*       call neg_hlu ; invert dy for screen coords convention
040C13 EB          0316*       ex de,hl ; de = dy for output
040C14 C1          0317*       pop bc ; bc = dx for output
040C15             0318*   ; and out
040C15 C9          0319*       ret
040C16             0320*   @angle: ds 3
040C19             0321*   @radius: ds 3
040C1C             0322*   
040C1C             0323*   ; 16.8 fixed inputs / outputs
040C1C             0324*   ; inputs: ub.c as dx, ud.e as dy
040C1C             0325*   ;        displacements from origin (0,0)
040C1C             0326*   ; returns: uh.l as angle in degrees 256
040C1C             0327*   ;        ud.e as radius
040C1C             0328*   ; destroys: everything except indexes
040C1C             0329*   cartesian_to_polar:
       FF FF FF FF 
       FF FF 
040C1C ED 43 75 0C 0330*       ld (dx168),bc ; dx argument for distance168
       04          
040C21 ED 53 7B 0C 0331*       ld (dy168),de ; dy argument for distance168
       04          
040C26             0332*   ; compute radius
040C26 CD 81 0C 04 0333*       call distance168 ; uh.l = radius
040C2A E5          0334*       push hl ; save radius
040C2B             0335*   ; compute angle
040C2B ED 4B 75 0C 0336*       ld bc,(dx168) ; dx argument for atan2_168fast
       04          
040C30 ED 5B 7B 0C 0337*       ld de,(dy168) ; dy argument for atan2_168fast
       04          
040C35 CD E1 0C 04 0338*       call atan2_168fast ; uh.l = angle
040C39             0339*   ; return result
040C39 D1          0340*       pop de ; de = radius (was hl)
040C3A C9          0341*       ret
040C3B             0342*   ; end cartesian_to_polar
040C3B             0343*   
040C3B             0344*   ; 16.8 fixed inputs / outputs
040C3B             0345*   ; inputs: ub.c as dx, ud.e as dy
040C3B             0346*   ;        displacements from origin (0,0)
040C3B             0347*   ; returns: uh.l as angle in degrees 256
040C3B             0348*   ;        ud.e as radius
040C3B             0349*   ; destroys: everything except indexes
040C3B             0350*   ; note: uses distance168sm which is more accurate for small deltas
040C3B             0351*   cartesian_to_polar_sm:
040C3B ED 43 75 0C 0352*       ld (dx168),bc ; dx argument for distance168
       04          
040C40 ED 53 7B 0C 0353*       ld (dy168),de ; dy argument for distance168
       04          
040C45             0354*   ; compute radius
040C45 CD BC 0C 04 0355*       call distance168sm ; uh.l = radius
040C49 E5          0356*       push hl ; save radius
040C4A             0357*   ; compute angle
040C4A ED 4B 75 0C 0358*       ld bc,(dx168) ; dx argument for atan2_168fast
       04          
040C4F ED 5B 7B 0C 0359*       ld de,(dy168) ; dy argument for atan2_168fast
       04          
040C54 CD E1 0C 04 0360*       call atan2_168fast ; uh.l = angle
040C58             0361*   ; return result
040C58 D1          0362*       pop de ; de = radius (was hl)
040C59 C9          0363*       ret
040C5A             0364*   ; end cartesian_to_polar
040C5A             0365*   
040C5A             0366*   ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
040C5A             0367*   ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
040C5A             0368*   ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
040C5A             0369*   ;         also populates scratch locations dx168 and dy168
040C5A             0370*   ; destroys: a,hl,bc,de
040C5A             0371*   dxy168:
040C5A             0372*   ; compute dx = x1-x0
040C5A AF          0373*       xor a ; clear carry
040C5B DD E5       0374*       push ix ; move ix to hl via the stack
040C5D E1          0375*       pop hl ; hl = x1
040C5E ED 42       0376*       sbc hl,bc ; hl = dx
040C60 22 75 0C 04 0377*       ld (dx168),hl ; dx to scratch
040C64             0378*   ; compute dy = y1-y0
040C64 AF          0379*       xor a ; clear carry
040C65 FD E5       0380*       push iy ; move iy to hl via the stack
040C67 E1          0381*       pop hl ; hl = y1
040C68 ED 52       0382*       sbc hl,de ; hl = dy
040C6A 22 7B 0C 04 0383*       ld (dy168),hl ; dy to scratch
040C6E             0384*   ; populate output registers and return
040C6E EB          0385*       ex de,hl ; ud.e = dy
040C6F ED 4B 75 0C 0386*       ld bc,(dx168) ; ub.c = dx
       04          
040C74 C9          0387*       ret
040C75 00 00 00 00 0388*   dx168: blkb 6,0
       00 00       
040C7B 00 00 00 00 0389*   dy168: blkb 6,0
       00 00       
040C81             0390*   
040C81             0391*   ; compute the euclidian distance between two cartesian coordinates
040C81             0392*   ; using the formula d = sqrt(dx^2+dy^2)
040C81             0393*   ; inputs: dx168 and dy168 are dx and dy in 16.8 fixed format
040C81             0394*   ; output; uh.l is the 16.8 fixed format distance
040C81             0395*   ;         also populates scratch locations dx168 and dy168
040C81             0396*   ; destroys: a,hl,bc,de
040C81             0397*   ; NOTE: rounds both deltas down to the nearest integer to avoid overflow when squaring,
040C81             0398*   ;       thus the result will always be an integer, albeit in 16.8 format
040C81             0399*   distance168:
040C81             0400*   ; compute dy^2
040C81 2A 7B 0C 04 0401*       ld hl,(dy168)
040C85 CD 70 04 04 0402*       call hlu_abs
040C89             0403*       ; call hlu_udiv256 ; make integer to avoid overflow
040C89             0404*       SRL_UHL ; make integer to avoid overflow
040C89 3B          0001*M1     dec sp ; 1 cycle
040C8A E5          0002*M1     push hl ; 4 cycles
040C8B 33          0003*M1     inc sp ; 1 cycle
040C8C E1          0004*M1     pop hl ; 4 cycles
040C8D 23          0005*M1     inc hl ; 1 cycle
040C8E 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
040C90             0007*M1     ; 13 cycles total
040C90 E5          0405*       push hl
040C91 D1          0406*       pop de
040C92 CD 67 03 04 0407*       call umul24 ; hl = dy^2
040C96 E5          0408*       push hl ; save dy^2
040C97             0409*   ; compute dx^2
040C97 2A 75 0C 04 0410*       ld hl,(dx168)
040C9B CD 70 04 04 0411*       call hlu_abs
040C9F             0412*       ; call hlu_udiv256 ; make integer to avoid overflow
040C9F             0413*       SRL_UHL ; make integer to avoid overflow
040C9F 3B          0001*M1     dec sp ; 1 cycle
040CA0 E5          0002*M1     push hl ; 4 cycles
040CA1 33          0003*M1     inc sp ; 1 cycle
040CA2 E1          0004*M1     pop hl ; 4 cycles
040CA3 23          0005*M1     inc hl ; 1 cycle
040CA4 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
040CA6             0007*M1     ; 13 cycles total
040CA6 E5          0414*       push hl
040CA7 D1          0415*       pop de
040CA8 CD 67 03 04 0416*       call umul24 ; hl = dx^2
040CAC             0417*   ; add dx^2 and dy^2
040CAC D1          0418*       pop de ; de = dy^2 (was hl)
040CAD 19          0419*       add hl,de ; hl = dx^2 + dy^2
040CAE             0420*   ; compute the square root
040CAE CD AC 0D 04 0421*       call sqrt24 ; de = sqrt(dx^2 + dy^2)
040CB2 EB          0422*       ex de,hl ; hl = distance
040CB3             0423*       hlu_mul256 ; convert back to 16.8 fixed
040CB3 29          0001*M1     add hl,hl ; * 2
040CB4 29          0002*M1     add hl,hl ; * 4
040CB5 29          0003*M1     add hl,hl ; * 8
040CB6 29          0004*M1     add hl,hl ; * 16
040CB7 29          0005*M1     add hl,hl ; * 32
040CB8 29          0006*M1     add hl,hl ; * 64
040CB9 29          0007*M1     add hl,hl ; * 128
040CBA 29          0008*M1     add hl,hl ; * 256
040CBB C9          0424*       ret
040CBC             0425*   
040CBC             0426*   ; compute the euclidian distance between two cartesian coordinates
040CBC             0427*   ; using the formula d = sqrt(dx^2+dy^2)
040CBC             0428*   ; inputs: dx168 and dy168 are dx and dy in 16.8 fixed format
040CBC             0429*   ; output; uh.l is the 16.8 fixed format distance
040CBC             0430*   ;         also populates scratch locations dx168 and dy168
040CBC             0431*   ; destroys: a,hl,bc,de
040CBC             0432*   ; NOTE: sm means 'small' because it doesn't round down the deltas
040CBC             0433*   ;       making it more accurate for small deltas,
040CBC             0434*   ;       but will overflow if used for screen-sized deltas
040CBC             0435*   distance168sm:
040CBC             0436*   ; compute dy^2
040CBC 2A 7B 0C 04 0437*       ld hl,(dy168)
040CC0 CD 70 04 04 0438*       call hlu_abs
040CC4 E5          0439*       push hl
040CC5 D1          0440*       pop de
040CC6 CD 67 03 04 0441*       call umul24 ; hl = dy^2
040CCA E5          0442*       push hl ; save dy^2
040CCB             0443*   ; compute dx^2
040CCB 2A 75 0C 04 0444*       ld hl,(dx168)
040CCF CD 70 04 04 0445*       call hlu_abs
040CD3 E5          0446*       push hl
040CD4 D1          0447*       pop de
040CD5 CD 67 03 04 0448*       call umul24 ; hl = dx^2
040CD9             0449*   ; add dx^2 and dy^2
040CD9 D1          0450*       pop de ; de = dy^2 (was hl)
040CDA 19          0451*       add hl,de ; hl = dx^2 + dy^2
040CDB             0452*   ; compute the square root
040CDB CD AC 0D 04 0453*       call sqrt24 ; de = sqrt(dx^2 + dy^2)
040CDF EB          0454*       ex de,hl ; hl = distance
040CE0 C9          0455*       ret
040CE1             0456*   
040CE1             0457*   ; atan2_(ub.c,ud.e) --> uh.l
040CE1             0458*   ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040CE1             0459*   ;   whether inputs are integers or fractional doesn't matter
040CE1             0460*   ;   so long as the sign bit of the upper byte is correct
040CE1             0461*   ; output: uh.l is the 16.8 fixed angle in degrees 256
040CE1             0462*   ; angles are COMPASS HEADINGS based on
040CE1             0463*   ; screen coordinate conventions,where the y axis is flipped
040CE1             0464*   ; #E0 224      0       32 #20
040CE1             0465*   ;        -x,-y | +x,-y
040CE1             0466*   ; #C0 192------+------ 64 #40
040CE1             0467*   ;        -x,+y | +x,+y
040CE1             0468*   ; #A0 160   128 #80   96 #60
040CE1             0469*   atan2_168fast:
040CE1             0470*   ; get signs and make everything positive
040CE1             0471*   ; get abs(x) and store its original sign
040CE1 C5          0472*       push bc
040CE2 E1          0473*       pop hl
040CE3 CD 70 04 04 0474*       call hlu_abs ; if x was negative this also sets the sign flag
040CE7 E5          0475*       push hl ; store abs(x)
040CE8 C1          0476*       pop bc ; bc = abs(x)
040CE9 F5          0477*       push af ; store sign of x
040CEA             0478*   ; get abs(y) and store its original sign
040CEA EB          0479*       ex de,hl ; hl = y
040CEB CD 70 04 04 0480*       call hlu_abs ; if y was negative this also sets the sign flag
040CEF EB          0481*       ex de,hl ; de = abs(y)
040CF0 F5          0482*       push af ; store sign of y
040CF1             0483*   ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
040CF1             0484*   ; this ensures that our lookup value is between 0 and 1 inclusive
040CF1 AF          0485*       xor a ; clear the carry flag
040CF2 D5          0486*       push de
040CF3 E1          0487*       pop hl
040CF4 ED 42       0488*       sbc hl,bc
040CF6 F5          0489*       push af ; save sign of de - bc
040CF7 F2 00 0D 04 0490*       jp p,@1 ; bc <= de, so we skip ahead
040CFB             0491*   ; otherwise we swap bc and de
040CFB C5          0492*       push bc
040CFC E1          0493*       pop hl
040CFD EB          0494*       ex de,hl
040CFE E5          0495*       push hl
040CFF C1          0496*       pop bc
040D00             0497*   @1:
040D00             0498*   ; now we're ready to snag our preliminary result
040D00 C5          0499*       push bc
040D01 E1          0500*       pop hl
040D02 CD 70 0D 04 0501*       call atan_168fast ; uh.l comes back with prelim result
040D06             0502*   ; now we adjust uh.l based on sign of de - bc
040D06 F1          0503*       pop af
040D07 F2 13 0D 04 0504*       jp p,@2 ; bc <= de,so we skip ahead
040D0B EB          0505*       ex de,hl
040D0C 21 00 40 00 0506*       ld hl,64*256 ; subtract from 64 (90) degrees
040D10 AF          0507*       xor a ; clear the carry flag
040D11 ED 52       0508*       sbc hl,de
040D13             0509*   @2:
040D13             0510*   ; adjust the result based on quadrant
040D13             0511*   ; #E0 224      0       32 #20
040D13             0512*   ;        -x,-y | +x,-y
040D13             0513*   ; #C0 192------+------ 64 #40
040D13             0514*   ;        -x,+y | +x,+y
040D13             0515*   ; #A0 160   128 #80   96 #60
040D13 F1          0516*       pop af ; sign of y
040D14 CA 51 0D 04 0517*       jp z,@y_zero
040D18 F2 31 0D 04 0518*       jp p,@y_pos
040D1C             0519*   ; y neg,check x
040D1C F1          0520*       pop af ; sign of x
040D1D CA 2B 0D 04 0521*       jp z,@y_neg_x_zero
040D21 F2 30 0D 04 0522*       jp p,@y_neg_x_pos
040D25             0523*   ; y neg,x neg
040D25             0524*   ; angle is 128 to 256 (270 to 360)
040D25             0525*   ; negating the intermediate does the trick
040D25 CD 80 04 04 0526*       call neg_hlu
040D29 18 31       0527*       jr @zero_hlu
040D2B             0528*   
040D2B             0529*   @y_neg_x_zero:
040D2B             0530*   ; y neg,x zero
040D2B             0531*   ; angle is 0
040D2B 21 00 00 00 0532*       ld hl,0
040D2F C9          0533*       ret
040D30             0534*   @y_neg_x_pos:
040D30             0535*   ; y neg,x pos
040D30             0536*   ; angle is 0 to 64 (0 to 90)
040D30             0537*   ; so we're good
040D30 C9          0538*       ret
040D31             0539*   
040D31             0540*   @y_pos:
040D31 F1          0541*       pop af ; sign of x
040D32 CA 41 0D 04 0542*       jp z,@y_pos_x_zero
040D36 F2 46 0D 04 0543*       jp p,@y_pos_x_pos
040D3A             0544*   ; y pos,x neg
040D3A             0545*   ; angle is 128 to 192 (180-270)
040D3A             0546*   ; so we add 128 to intermediate
040D3A 11 00 80 00 0547*       ld de,128*256
040D3E 19          0548*       add hl,de
040D3F 18 1B       0549*       jr @zero_hlu
040D41             0550*   @y_pos_x_zero:
040D41             0551*   ; y pos,x zero
040D41             0552*   ; angle is 128 (180)
040D41 21 00 80 00 0553*       ld hl,128*256
040D45 C9          0554*       ret
040D46             0555*   @y_pos_x_pos:
040D46             0556*   ; y pos,x pos
040D46             0557*   ; angle is 64 to 128 (90 to 180)
040D46             0558*   ; neg the intermediate and add 180 degrees
040D46 CD 80 04 04 0559*       call neg_hlu
040D4A 11 00 80 00 0560*       ld de,128*256
040D4E 19          0561*       add hl,de
040D4F 18 0B       0562*       jr @zero_hlu
040D51             0563*   
040D51             0564*   @y_zero:
040D51 F1          0565*       pop af ; sign of x
040D52 FA 57 0D 04 0566*       jp m,@y_zero_x_neg
040D56             0567*   ; y zero,x pos
040D56             0568*   ; angle is 64 (90),nothing to do
040D56 C9          0569*       ret
040D57             0570*   @y_zero_x_neg:
040D57             0571*   ; y zero ,x neg
040D57             0572*   ; angle is 192 (270)
040D57 21 00 C0 00 0573*       ld hl,192*256
040D5B C9          0574*       ret
040D5C             0575*   @zero_hlu:
040D5C AF          0576*       xor a
040D5D 22 6A 0D 04 0577*       ld (@scratch),hl
040D61 32 6C 0D 04 0578*       ld (@scratch+2),a
040D65 2A 6A 0D 04 0579*       ld hl,(@scratch)
040D69 C9          0580*       ret
040D6A             0581*   @scratch: ds 6
040D70             0582*   
040D70             0583*   ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040D70             0584*   ; output: uh.l is the 16.8 fixed format angle in degrees 256
040D70             0585*   ; destroys: a,hl,bc,de
040D70             0586*   ; note: only works for angles from 0 to 32 (45) degrees
040D70             0587*   ;   use atan2_168fast (which calls this proc) to handle the full 256 (360) degrees
040D70             0588*   atan_168fast:
040D70             0589*   ; because we use compass headings instead of geometric angles
040D70             0590*   ; we compute dx/dy which is 1/tan(theta) in the maths world
040D70             0591*   ; we can do faster unsigned division here because we know dx and dy are positive
       FF FF FF FF 
       FF FF 
040D70 CD 2B 0B 04 0592*       call udiv168 ; ud.e = dx/dy
040D74 EB          0593*       ex de,hl ; uh.l = dx/dy
040D75             0594*   ; test uh.l for 0
040D75 19          0595*       add hl,de
040D76 B7          0596*       or a
040D77 ED 52       0597*       sbc hl,de
040D79 28 22       0598*       jr z,@is_zero
040D7B             0599*   ; test uh.l for 1
040D7B AF          0600*       xor a ; clear carry
040D7C EB          0601*       ex de,hl
040D7D 21 00 01 00 0602*       ld hl,1*256 ; 1 in 16.8 fixed format
040D81 ED 52       0603*       sbc hl,de
040D83 28 13       0604*       jr z,@is_45
040D85 EB          0605*       ex de,hl
040D86             0606*   ; no special cases so we move on
040D86             0607*   ; l contains the fractional portion of tan(uh.l)
040D86             0608*   ; we multiply it by three to get our lookup table index
040D86 26 03       0609*       ld h,3
040D88 ED 6C       0610*       mlt hl ; index into lut
040D8A 11 00 00 00 0611*       ld de,0 ; clear deu
040D8E 54          0612*       ld d,h ; copy hl to de
040D8F 5D          0613*       ld e,l ; de contains our index
040D90 21 95 11 04 0614*       ld hl,atan_lut_168 ; grab the lut address
040D94 19          0615*       add hl,de ; bump hl by the index
040D95 ED 27       0616*       ld hl,(hl) ; don't try this on a z80!
040D97 C9          0617*       ret ; and out
040D98             0618*   @is_45:
040D98 21 00 20 00 0619*       ld hl,32*256
040D9C C9          0620*       ret
040D9D             0621*   ; for the case tan(0)
040D9D             0622*   @is_zero:
040D9D 21 00 00 00 0623*       ld hl,0*256
040DA1 C9          0624*       ret
040DA2             0625*   
040DA2             0626*   ; Expects  ADL mode
040DA2             0627*   ; Inputs:  UH.L
040DA2             0628*   ; Outputs: UH.L is the 16.8 square root
040DA2             0629*   ;          UDE is the integer difference inputHL-DE^2
040DA2             0630*   sqrt168:
040DA2 CD AC 0D 04 0631*       call sqrt24
040DA6 EB          0632*       ex de,hl
040DA7 29          0633*       add hl,hl
040DA8 29          0634*       add hl,hl
040DA9 29          0635*       add hl,hl
040DAA 29          0636*       add hl,hl
040DAB C9          0637*       ret
040DAC             0638*   
040DAC             0639*   ; credit: xeda112358
040DAC             0640*   ; https://www.cemetech.net/forum/viewtopic.php?t=11178&postdays=0&postorder=asc&start=0
040DAC             0641*   sqrt24:
040DAC             0642*   ; Expects ADL mode
040DAC             0643*   ; Inputs: HL
040DAC             0644*   ; Outputs: DE is the integer square root
040DAC             0645*   ;  HL is the difference inputHL-DE^2
040DAC             0646*   ;  c flag reset
040DAC 01 00 00 00 0647*       ld bc,0 ; clear bcu
040DB0 11 00 00 00 0648*       ld de,0 ; clear deu
040DB4 AF          0649*       xor a
040DB5 45          0650*       ld b,l
040DB6 C5          0651*       push bc
040DB7 47          0652*       ld b,a
040DB8 6F          0653*       ld l,a
040DB9             0654*   ; Iteration 1
040DB9 29          0655*       add hl,hl
040DBA CB 11       0656*       rl c
040DBC 29          0657*       add hl,hl
040DBD CB 11       0658*       rl c
040DBF 91          0659*       sub c
040DC0 30 04       0660*       jr nc,$+6
040DC2 1C          0661*       inc e
040DC3 1C          0662*       inc e
040DC4 2F          0663*       cpl
040DC5 4F          0664*       ld c,a
040DC6             0665*   ; Iteration 2
040DC6 29          0666*       add hl,hl
040DC7 CB 11       0667*       rl c
040DC9 29          0668*       add hl,hl
040DCA CB 11       0669*       rl c
040DCC CB 13       0670*       rl e
040DCE 7B          0671*       ld a,e
040DCF 91          0672*       sub c
040DD0 30 04       0673*       jr nc,$+6
040DD2 1C          0674*       inc e
040DD3 1C          0675*       inc e
040DD4 2F          0676*       cpl
040DD5 4F          0677*       ld c,a
040DD6             0678*   ; Iteration 3
040DD6 29          0679*       add hl,hl
040DD7 CB 11       0680*       rl c
040DD9 29          0681*       add hl,hl
040DDA CB 11       0682*       rl c
040DDC CB 13       0683*       rl e
040DDE 7B          0684*       ld a,e
040DDF 91          0685*       sub c
040DE0 30 04       0686*       jr nc,$+6
040DE2 1C          0687*       inc e
040DE3 1C          0688*       inc e
040DE4 2F          0689*       cpl
040DE5 4F          0690*       ld c,a
040DE6             0691*   ; Iteration 4
040DE6 29          0692*       add hl,hl
040DE7 CB 11       0693*       rl c
040DE9 29          0694*       add hl,hl
040DEA CB 11       0695*       rl c
040DEC CB 13       0696*       rl e
040DEE 7B          0697*       ld a,e
040DEF 91          0698*       sub c
040DF0 30 04       0699*       jr nc,$+6
040DF2 1C          0700*       inc e
040DF3 1C          0701*       inc e
040DF4 2F          0702*       cpl
040DF5 4F          0703*       ld c,a
040DF6             0704*   ; Iteration 5
040DF6 29          0705*       add hl,hl
040DF7 CB 11       0706*       rl c
040DF9 29          0707*       add hl,hl
040DFA CB 11       0708*       rl c
040DFC CB 13       0709*       rl e
040DFE 7B          0710*       ld a,e
040DFF 91          0711*       sub c
040E00 30 04       0712*       jr nc,$+6
040E02 1C          0713*       inc e
040E03 1C          0714*       inc e
040E04 2F          0715*       cpl
040E05 4F          0716*       ld c,a
040E06             0717*   ; Iteration 6
040E06 29          0718*       add hl,hl
040E07 CB 11       0719*       rl c
040E09 29          0720*       add hl,hl
040E0A CB 11       0721*       rl c
040E0C CB 13       0722*       rl e
040E0E 7B          0723*       ld a,e
040E0F 91          0724*       sub c
040E10 30 04       0725*       jr nc,$+6
040E12 1C          0726*       inc e
040E13 1C          0727*       inc e
040E14 2F          0728*       cpl
040E15 4F          0729*       ld c,a
040E16             0730*   ; Iteration 7
040E16 29          0731*       add hl,hl
040E17 CB 11       0732*       rl c
040E19 29          0733*       add hl,hl
040E1A CB 11       0734*       rl c
040E1C CB 10       0735*       rl b
040E1E EB          0736*       ex de,hl
040E1F 29          0737*       add hl,hl
040E20 E5          0738*       push hl
040E21 ED 42       0739*       sbc hl,bc
040E23 30 06       0740*       jr nc,$+8
040E25 7C          0741*       ld a,h
040E26 2F          0742*       cpl
040E27 47          0743*       ld b,a
040E28 7D          0744*       ld a,l
040E29 2F          0745*       cpl
040E2A 4F          0746*       ld c,a
040E2B E1          0747*       pop hl
040E2C 30 02       0748*       jr nc,$+4
040E2E 23          0749*       inc hl
040E2F 23          0750*       inc hl
040E30 EB          0751*       ex de,hl
040E31             0752*   ; Iteration 8
040E31 29          0753*       add hl,hl
040E32 69          0754*       ld l,c
040E33 60          0755*       ld h,b
040E34 ED 6A       0756*       adc hl,hl
040E36 ED 6A       0757*       adc hl,hl
040E38 EB          0758*       ex de,hl
040E39 29          0759*       add hl,hl
040E3A ED 52       0760*       sbc hl,de
040E3C 19          0761*       add hl,de
040E3D EB          0762*       ex de,hl
040E3E 30 04       0763*       jr nc,$+6
040E40 ED 52       0764*       sbc hl,de
040E42 13          0765*       inc de
040E43 13          0766*       inc de
040E44             0767*   ; Iteration 9
040E44 F1          0768*       pop af
040E45 17          0769*       rla
040E46 ED 6A       0770*       adc hl,hl
040E48 17          0771*       rla
040E49 ED 6A       0772*       adc hl,hl
040E4B EB          0773*       ex de,hl
040E4C 29          0774*       add hl,hl
040E4D ED 52       0775*       sbc hl,de
040E4F 19          0776*       add hl,de
040E50 EB          0777*       ex de,hl
040E51 30 04       0778*       jr nc,$+6
040E53 ED 52       0779*       sbc hl,de
040E55 13          0780*       inc de
040E56 13          0781*       inc de
040E57             0782*   ; Iteration 10
040E57 17          0783*       rla
040E58 ED 6A       0784*       adc hl,hl
040E5A 17          0785*       rla
040E5B ED 6A       0786*       adc hl,hl
040E5D EB          0787*       ex de,hl
040E5E 29          0788*       add hl,hl
040E5F ED 52       0789*       sbc hl,de
040E61 19          0790*       add hl,de
040E62 EB          0791*       ex de,hl
040E63 30 04       0792*       jr nc,$+6
040E65 ED 52       0793*       sbc hl,de
040E67 13          0794*       inc de
040E68 13          0795*       inc de
040E69             0796*   ; Iteration 11
040E69 17          0797*       rla
040E6A ED 6A       0798*       adc hl,hl
040E6C 17          0799*       rla
040E6D ED 6A       0800*       adc hl,hl
040E6F EB          0801*       ex de,hl
040E70 29          0802*       add hl,hl
040E71 ED 52       0803*       sbc hl,de
040E73 19          0804*       add hl,de
040E74 EB          0805*       ex de,hl
040E75 30 04       0806*       jr nc,$+6
040E77 ED 52       0807*       sbc hl,de
040E79 13          0808*       inc de
040E7A 13          0809*       inc de
040E7B             0810*   ; Iteration 12
040E7B 17          0811*       rla
040E7C ED 6A       0812*       adc hl,hl
040E7E 17          0813*       rla
040E7F ED 6A       0814*       adc hl,hl
040E81 EB          0815*       ex de,hl
040E82 29          0816*       add hl,hl
040E83 ED 52       0817*       sbc hl,de
040E85 19          0818*       add hl,de
040E86 EB          0819*       ex de,hl
040E87 30 04       0820*       jr nc,$+6
040E89 ED 52       0821*       sbc hl,de
040E8B 13          0822*       inc de
040E8C 13          0823*       inc de
040E8D CB 1A       0824*       rr d
040E8F CB 1B       0825*       rr e
040E91 C9          0826*       ret
040E92             0827*   
040E92             0828*   sin_lut_168:
040E92 00 00 00    0829*       dl 0x000000 ; 0.000 00, 0.000
040E95 06 00 00    0830*       dl 0x000006 ; 1.406 01, 0.025
040E98 0C 00 00    0831*       dl 0x00000C ; 2.813 02, 0.049
040E9B 12 00 00    0832*       dl 0x000012 ; 4.219 03, 0.074
040E9E 19 00 00    0833*       dl 0x000019 ; 5.625 04, 0.098
040EA1 1F 00 00    0834*       dl 0x00001F ; 7.031 05, 0.122
040EA4 25 00 00    0835*       dl 0x000025 ; 8.438 06, 0.147
040EA7 2B 00 00    0836*       dl 0x00002B ; 9.844 07, 0.171
040EAA 31 00 00    0837*       dl 0x000031 ; 11.250 08, 0.195
040EAD 38 00 00    0838*       dl 0x000038 ; 12.656 09, 0.219
040EB0 3E 00 00    0839*       dl 0x00003E ; 14.063 0A, 0.243
040EB3 44 00 00    0840*       dl 0x000044 ; 15.469 0B, 0.267
040EB6 4A 00 00    0841*       dl 0x00004A ; 16.875 0C, 0.290
040EB9 50 00 00    0842*       dl 0x000050 ; 18.281 0D, 0.314
040EBC 56 00 00    0843*       dl 0x000056 ; 19.688 0E, 0.337
040EBF 5C 00 00    0844*       dl 0x00005C ; 21.094 0F, 0.360
040EC2 61 00 00    0845*       dl 0x000061 ; 22.500 10, 0.383
040EC5 67 00 00    0846*       dl 0x000067 ; 23.906 11, 0.405
040EC8 6D 00 00    0847*       dl 0x00006D ; 25.313 12, 0.428
040ECB 73 00 00    0848*       dl 0x000073 ; 26.719 13, 0.450
040ECE 78 00 00    0849*       dl 0x000078 ; 28.125 14, 0.471
040ED1 7E 00 00    0850*       dl 0x00007E ; 29.531 15, 0.493
040ED4 83 00 00    0851*       dl 0x000083 ; 30.938 16, 0.514
040ED7 88 00 00    0852*       dl 0x000088 ; 32.344 17, 0.535
040EDA 8E 00 00    0853*       dl 0x00008E ; 33.750 18, 0.556
040EDD 93 00 00    0854*       dl 0x000093 ; 35.156 19, 0.576
040EE0 98 00 00    0855*       dl 0x000098 ; 36.563 1A, 0.596
040EE3 9D 00 00    0856*       dl 0x00009D ; 37.969 1B, 0.615
040EE6 A2 00 00    0857*       dl 0x0000A2 ; 39.375 1C, 0.634
040EE9 A7 00 00    0858*       dl 0x0000A7 ; 40.781 1D, 0.653
040EEC AB 00 00    0859*       dl 0x0000AB ; 42.188 1E, 0.672
040EEF B0 00 00    0860*       dl 0x0000B0 ; 43.594 1F, 0.690
040EF2 B5 00 00    0861*       dl 0x0000B5 ; 45.000 20, 0.707
040EF5 B9 00 00    0862*       dl 0x0000B9 ; 46.406 21, 0.724
040EF8 BD 00 00    0863*       dl 0x0000BD ; 47.813 22, 0.741
040EFB C1 00 00    0864*       dl 0x0000C1 ; 49.219 23, 0.757
040EFE C5 00 00    0865*       dl 0x0000C5 ; 50.625 24, 0.773
040F01 C9 00 00    0866*       dl 0x0000C9 ; 52.031 25, 0.788
040F04 CD 00 00    0867*       dl 0x0000CD ; 53.438 26, 0.803
040F07 D1 00 00    0868*       dl 0x0000D1 ; 54.844 27, 0.818
040F0A D4 00 00    0869*       dl 0x0000D4 ; 56.250 28, 0.831
040F0D D8 00 00    0870*       dl 0x0000D8 ; 57.656 29, 0.845
040F10 DB 00 00    0871*       dl 0x0000DB ; 59.063 2A, 0.858
040F13 DE 00 00    0872*       dl 0x0000DE ; 60.469 2B, 0.870
040F16 E1 00 00    0873*       dl 0x0000E1 ; 61.875 2C, 0.882
040F19 E4 00 00    0874*       dl 0x0000E4 ; 63.281 2D, 0.893
040F1C E7 00 00    0875*       dl 0x0000E7 ; 64.688 2E, 0.904
040F1F EA 00 00    0876*       dl 0x0000EA ; 66.094 2F, 0.914
040F22 EC 00 00    0877*       dl 0x0000EC ; 67.500 30, 0.924
040F25 EE 00 00    0878*       dl 0x0000EE ; 68.906 31, 0.933
040F28 F1 00 00    0879*       dl 0x0000F1 ; 70.313 32, 0.942
040F2B F3 00 00    0880*       dl 0x0000F3 ; 71.719 33, 0.950
040F2E F4 00 00    0881*       dl 0x0000F4 ; 73.125 34, 0.957
040F31 F6 00 00    0882*       dl 0x0000F6 ; 74.531 35, 0.964
040F34 F8 00 00    0883*       dl 0x0000F8 ; 75.938 36, 0.970
040F37 F9 00 00    0884*       dl 0x0000F9 ; 77.344 37, 0.976
040F3A FB 00 00    0885*       dl 0x0000FB ; 78.750 38, 0.981
040F3D FC 00 00    0886*       dl 0x0000FC ; 80.156 39, 0.985
040F40 FD 00 00    0887*       dl 0x0000FD ; 81.563 3A, 0.989
040F43 FE 00 00    0888*       dl 0x0000FE ; 82.969 3B, 0.992
040F46 FE 00 00    0889*       dl 0x0000FE ; 84.375 3C, 0.995
040F49 FF 00 00    0890*       dl 0x0000FF ; 85.781 3D, 0.997
040F4C FF 00 00    0891*       dl 0x0000FF ; 87.188 3E, 0.999
040F4F FF 00 00    0892*       dl 0x0000FF ; 88.594 3F, 1.000
040F52 00 01 00    0893*       dl 0x000100 ; 90.000 40, 1.000
040F55 FF 00 00    0894*       dl 0x0000FF ; 91.406 41, 1.000
040F58 FF 00 00    0895*       dl 0x0000FF ; 92.813 42, 0.999
040F5B FF 00 00    0896*       dl 0x0000FF ; 94.219 43, 0.997
040F5E FE 00 00    0897*       dl 0x0000FE ; 95.625 44, 0.995
040F61 FE 00 00    0898*       dl 0x0000FE ; 97.031 45, 0.992
040F64 FD 00 00    0899*       dl 0x0000FD ; 98.438 46, 0.989
040F67 FC 00 00    0900*       dl 0x0000FC ; 99.844 47, 0.985
040F6A FB 00 00    0901*       dl 0x0000FB ; 101.250 48, 0.981
040F6D F9 00 00    0902*       dl 0x0000F9 ; 102.656 49, 0.976
040F70 F8 00 00    0903*       dl 0x0000F8 ; 104.063 4A, 0.970
040F73 F6 00 00    0904*       dl 0x0000F6 ; 105.469 4B, 0.964
040F76 F4 00 00    0905*       dl 0x0000F4 ; 106.875 4C, 0.957
040F79 F3 00 00    0906*       dl 0x0000F3 ; 108.281 4D, 0.950
040F7C F1 00 00    0907*       dl 0x0000F1 ; 109.688 4E, 0.942
040F7F EE 00 00    0908*       dl 0x0000EE ; 111.094 4F, 0.933
040F82 EC 00 00    0909*       dl 0x0000EC ; 112.500 50, 0.924
040F85 EA 00 00    0910*       dl 0x0000EA ; 113.906 51, 0.914
040F88 E7 00 00    0911*       dl 0x0000E7 ; 115.313 52, 0.904
040F8B E4 00 00    0912*       dl 0x0000E4 ; 116.719 53, 0.893
040F8E E1 00 00    0913*       dl 0x0000E1 ; 118.125 54, 0.882
040F91 DE 00 00    0914*       dl 0x0000DE ; 119.531 55, 0.870
040F94 DB 00 00    0915*       dl 0x0000DB ; 120.938 56, 0.858
040F97 D8 00 00    0916*       dl 0x0000D8 ; 122.344 57, 0.845
040F9A D4 00 00    0917*       dl 0x0000D4 ; 123.750 58, 0.831
040F9D D1 00 00    0918*       dl 0x0000D1 ; 125.156 59, 0.818
040FA0 CD 00 00    0919*       dl 0x0000CD ; 126.563 5A, 0.803
040FA3 C9 00 00    0920*       dl 0x0000C9 ; 127.969 5B, 0.788
040FA6 C5 00 00    0921*       dl 0x0000C5 ; 129.375 5C, 0.773
040FA9 C1 00 00    0922*       dl 0x0000C1 ; 130.781 5D, 0.757
040FAC BD 00 00    0923*       dl 0x0000BD ; 132.188 5E, 0.741
040FAF B9 00 00    0924*       dl 0x0000B9 ; 133.594 5F, 0.724
040FB2 B5 00 00    0925*       dl 0x0000B5 ; 135.000 60, 0.707
040FB5 B0 00 00    0926*       dl 0x0000B0 ; 136.406 61, 0.690
040FB8 AB 00 00    0927*       dl 0x0000AB ; 137.813 62, 0.672
040FBB A7 00 00    0928*       dl 0x0000A7 ; 139.219 63, 0.653
040FBE A2 00 00    0929*       dl 0x0000A2 ; 140.625 64, 0.634
040FC1 9D 00 00    0930*       dl 0x00009D ; 142.031 65, 0.615
040FC4 98 00 00    0931*       dl 0x000098 ; 143.438 66, 0.596
040FC7 93 00 00    0932*       dl 0x000093 ; 144.844 67, 0.576
040FCA 8E 00 00    0933*       dl 0x00008E ; 146.250 68, 0.556
040FCD 88 00 00    0934*       dl 0x000088 ; 147.656 69, 0.535
040FD0 83 00 00    0935*       dl 0x000083 ; 149.063 6A, 0.514
040FD3 7E 00 00    0936*       dl 0x00007E ; 150.469 6B, 0.493
040FD6 78 00 00    0937*       dl 0x000078 ; 151.875 6C, 0.471
040FD9 73 00 00    0938*       dl 0x000073 ; 153.281 6D, 0.450
040FDC 6D 00 00    0939*       dl 0x00006D ; 154.688 6E, 0.428
040FDF 67 00 00    0940*       dl 0x000067 ; 156.094 6F, 0.405
040FE2 61 00 00    0941*       dl 0x000061 ; 157.500 70, 0.383
040FE5 5C 00 00    0942*       dl 0x00005C ; 158.906 71, 0.360
040FE8 56 00 00    0943*       dl 0x000056 ; 160.313 72, 0.337
040FEB 50 00 00    0944*       dl 0x000050 ; 161.719 73, 0.314
040FEE 4A 00 00    0945*       dl 0x00004A ; 163.125 74, 0.290
040FF1 44 00 00    0946*       dl 0x000044 ; 164.531 75, 0.267
040FF4 3E 00 00    0947*       dl 0x00003E ; 165.938 76, 0.243
040FF7 38 00 00    0948*       dl 0x000038 ; 167.344 77, 0.219
040FFA 31 00 00    0949*       dl 0x000031 ; 168.750 78, 0.195
040FFD 2B 00 00    0950*       dl 0x00002B ; 170.156 79, 0.171
041000 25 00 00    0951*       dl 0x000025 ; 171.563 7A, 0.147
041003 1F 00 00    0952*       dl 0x00001F ; 172.969 7B, 0.122
041006 19 00 00    0953*       dl 0x000019 ; 174.375 7C, 0.098
041009 12 00 00    0954*       dl 0x000012 ; 175.781 7D, 0.074
04100C 0C 00 00    0955*       dl 0x00000C ; 177.188 7E, 0.049
04100F 06 00 00    0956*       dl 0x000006 ; 178.594 7F, 0.025
041012 00 00 00    0957*       dl 0x000000 ; 180.000 80, 0.000
041015 FA FF FF    0958*       dl 0xFFFFFA ; 181.406 81, -0.025
041018 F4 FF FF    0959*       dl 0xFFFFF4 ; 182.813 82, -0.049
04101B EE FF FF    0960*       dl 0xFFFFEE ; 184.219 83, -0.074
04101E E7 FF FF    0961*       dl 0xFFFFE7 ; 185.625 84, -0.098
041021 E1 FF FF    0962*       dl 0xFFFFE1 ; 187.031 85, -0.122
041024 DB FF FF    0963*       dl 0xFFFFDB ; 188.438 86, -0.147
041027 D5 FF FF    0964*       dl 0xFFFFD5 ; 189.844 87, -0.171
04102A CF FF FF    0965*       dl 0xFFFFCF ; 191.250 88, -0.195
04102D C8 FF FF    0966*       dl 0xFFFFC8 ; 192.656 89, -0.219
041030 C2 FF FF    0967*       dl 0xFFFFC2 ; 194.063 8A, -0.243
041033 BC FF FF    0968*       dl 0xFFFFBC ; 195.469 8B, -0.267
041036 B6 FF FF    0969*       dl 0xFFFFB6 ; 196.875 8C, -0.290
041039 B0 FF FF    0970*       dl 0xFFFFB0 ; 198.281 8D, -0.314
04103C AA FF FF    0971*       dl 0xFFFFAA ; 199.688 8E, -0.337
04103F A4 FF FF    0972*       dl 0xFFFFA4 ; 201.094 8F, -0.360
041042 9F FF FF    0973*       dl 0xFFFF9F ; 202.500 90, -0.383
041045 99 FF FF    0974*       dl 0xFFFF99 ; 203.906 91, -0.405
041048 93 FF FF    0975*       dl 0xFFFF93 ; 205.313 92, -0.428
04104B 8D FF FF    0976*       dl 0xFFFF8D ; 206.719 93, -0.450
04104E 88 FF FF    0977*       dl 0xFFFF88 ; 208.125 94, -0.471
041051 82 FF FF    0978*       dl 0xFFFF82 ; 209.531 95, -0.493
041054 7D FF FF    0979*       dl 0xFFFF7D ; 210.938 96, -0.514
041057 78 FF FF    0980*       dl 0xFFFF78 ; 212.344 97, -0.535
04105A 72 FF FF    0981*       dl 0xFFFF72 ; 213.750 98, -0.556
04105D 6D FF FF    0982*       dl 0xFFFF6D ; 215.156 99, -0.576
041060 68 FF FF    0983*       dl 0xFFFF68 ; 216.563 9A, -0.596
041063 63 FF FF    0984*       dl 0xFFFF63 ; 217.969 9B, -0.615
041066 5E FF FF    0985*       dl 0xFFFF5E ; 219.375 9C, -0.634
041069 59 FF FF    0986*       dl 0xFFFF59 ; 220.781 9D, -0.653
04106C 55 FF FF    0987*       dl 0xFFFF55 ; 222.188 9E, -0.672
04106F 50 FF FF    0988*       dl 0xFFFF50 ; 223.594 9F, -0.690
041072 4B FF FF    0989*       dl 0xFFFF4B ; 225.000 A0, -0.707
041075 47 FF FF    0990*       dl 0xFFFF47 ; 226.406 A1, -0.724
041078 43 FF FF    0991*       dl 0xFFFF43 ; 227.813 A2, -0.741
04107B 3F FF FF    0992*       dl 0xFFFF3F ; 229.219 A3, -0.757
04107E 3B FF FF    0993*       dl 0xFFFF3B ; 230.625 A4, -0.773
041081 37 FF FF    0994*       dl 0xFFFF37 ; 232.031 A5, -0.788
041084 33 FF FF    0995*       dl 0xFFFF33 ; 233.438 A6, -0.803
041087 2F FF FF    0996*       dl 0xFFFF2F ; 234.844 A7, -0.818
04108A 2C FF FF    0997*       dl 0xFFFF2C ; 236.250 A8, -0.831
04108D 28 FF FF    0998*       dl 0xFFFF28 ; 237.656 A9, -0.845
041090 25 FF FF    0999*       dl 0xFFFF25 ; 239.063 AA, -0.858
041093 22 FF FF    1000*       dl 0xFFFF22 ; 240.469 AB, -0.870
041096 1F FF FF    1001*       dl 0xFFFF1F ; 241.875 AC, -0.882
041099 1C FF FF    1002*       dl 0xFFFF1C ; 243.281 AD, -0.893
04109C 19 FF FF    1003*       dl 0xFFFF19 ; 244.688 AE, -0.904
04109F 16 FF FF    1004*       dl 0xFFFF16 ; 246.094 AF, -0.914
0410A2 14 FF FF    1005*       dl 0xFFFF14 ; 247.500 B0, -0.924
0410A5 12 FF FF    1006*       dl 0xFFFF12 ; 248.906 B1, -0.933
0410A8 0F FF FF    1007*       dl 0xFFFF0F ; 250.313 B2, -0.942
0410AB 0D FF FF    1008*       dl 0xFFFF0D ; 251.719 B3, -0.950
0410AE 0C FF FF    1009*       dl 0xFFFF0C ; 253.125 B4, -0.957
0410B1 0A FF FF    1010*       dl 0xFFFF0A ; 254.531 B5, -0.964
0410B4 08 FF FF    1011*       dl 0xFFFF08 ; 255.938 B6, -0.970
0410B7 07 FF FF    1012*       dl 0xFFFF07 ; 257.344 B7, -0.976
0410BA 05 FF FF    1013*       dl 0xFFFF05 ; 258.750 B8, -0.981
0410BD 04 FF FF    1014*       dl 0xFFFF04 ; 260.156 B9, -0.985
0410C0 03 FF FF    1015*       dl 0xFFFF03 ; 261.563 BA, -0.989
0410C3 02 FF FF    1016*       dl 0xFFFF02 ; 262.969 BB, -0.992
0410C6 02 FF FF    1017*       dl 0xFFFF02 ; 264.375 BC, -0.995
0410C9 01 FF FF    1018*       dl 0xFFFF01 ; 265.781 BD, -0.997
0410CC 01 FF FF    1019*       dl 0xFFFF01 ; 267.188 BE, -0.999
0410CF 01 FF FF    1020*       dl 0xFFFF01 ; 268.594 BF, -1.000
0410D2 00 FF FF    1021*       dl 0xFFFF00 ; 270.000 C0, -1.000
0410D5 01 FF FF    1022*       dl 0xFFFF01 ; 271.406 C1, -1.000
0410D8 01 FF FF    1023*       dl 0xFFFF01 ; 272.813 C2, -0.999
0410DB 01 FF FF    1024*       dl 0xFFFF01 ; 274.219 C3, -0.997
0410DE 02 FF FF    1025*       dl 0xFFFF02 ; 275.625 C4, -0.995
0410E1 02 FF FF    1026*       dl 0xFFFF02 ; 277.031 C5, -0.992
0410E4 03 FF FF    1027*       dl 0xFFFF03 ; 278.438 C6, -0.989
0410E7 04 FF FF    1028*       dl 0xFFFF04 ; 279.844 C7, -0.985
0410EA 05 FF FF    1029*       dl 0xFFFF05 ; 281.250 C8, -0.981
0410ED 07 FF FF    1030*       dl 0xFFFF07 ; 282.656 C9, -0.976
0410F0 08 FF FF    1031*       dl 0xFFFF08 ; 284.063 CA, -0.970
0410F3 0A FF FF    1032*       dl 0xFFFF0A ; 285.469 CB, -0.964
0410F6 0C FF FF    1033*       dl 0xFFFF0C ; 286.875 CC, -0.957
0410F9 0D FF FF    1034*       dl 0xFFFF0D ; 288.281 CD, -0.950
0410FC 0F FF FF    1035*       dl 0xFFFF0F ; 289.688 CE, -0.942
0410FF 12 FF FF    1036*       dl 0xFFFF12 ; 291.094 CF, -0.933
041102 14 FF FF    1037*       dl 0xFFFF14 ; 292.500 D0, -0.924
041105 16 FF FF    1038*       dl 0xFFFF16 ; 293.906 D1, -0.914
041108 19 FF FF    1039*       dl 0xFFFF19 ; 295.313 D2, -0.904
04110B 1C FF FF    1040*       dl 0xFFFF1C ; 296.719 D3, -0.893
04110E 1F FF FF    1041*       dl 0xFFFF1F ; 298.125 D4, -0.882
041111 22 FF FF    1042*       dl 0xFFFF22 ; 299.531 D5, -0.870
041114 25 FF FF    1043*       dl 0xFFFF25 ; 300.938 D6, -0.858
041117 28 FF FF    1044*       dl 0xFFFF28 ; 302.344 D7, -0.845
04111A 2C FF FF    1045*       dl 0xFFFF2C ; 303.750 D8, -0.831
04111D 2F FF FF    1046*       dl 0xFFFF2F ; 305.156 D9, -0.818
041120 33 FF FF    1047*       dl 0xFFFF33 ; 306.563 DA, -0.803
041123 37 FF FF    1048*       dl 0xFFFF37 ; 307.969 DB, -0.788
041126 3B FF FF    1049*       dl 0xFFFF3B ; 309.375 DC, -0.773
041129 3F FF FF    1050*       dl 0xFFFF3F ; 310.781 DD, -0.757
04112C 43 FF FF    1051*       dl 0xFFFF43 ; 312.188 DE, -0.741
04112F 47 FF FF    1052*       dl 0xFFFF47 ; 313.594 DF, -0.724
041132 4B FF FF    1053*       dl 0xFFFF4B ; 315.000 E0, -0.707
041135 50 FF FF    1054*       dl 0xFFFF50 ; 316.406 E1, -0.690
041138 55 FF FF    1055*       dl 0xFFFF55 ; 317.813 E2, -0.672
04113B 59 FF FF    1056*       dl 0xFFFF59 ; 319.219 E3, -0.653
04113E 5E FF FF    1057*       dl 0xFFFF5E ; 320.625 E4, -0.634
041141 63 FF FF    1058*       dl 0xFFFF63 ; 322.031 E5, -0.615
041144 68 FF FF    1059*       dl 0xFFFF68 ; 323.438 E6, -0.596
041147 6D FF FF    1060*       dl 0xFFFF6D ; 324.844 E7, -0.576
04114A 72 FF FF    1061*       dl 0xFFFF72 ; 326.250 E8, -0.556
04114D 78 FF FF    1062*       dl 0xFFFF78 ; 327.656 E9, -0.535
041150 7D FF FF    1063*       dl 0xFFFF7D ; 329.063 EA, -0.514
041153 82 FF FF    1064*       dl 0xFFFF82 ; 330.469 EB, -0.493
041156 88 FF FF    1065*       dl 0xFFFF88 ; 331.875 EC, -0.471
041159 8D FF FF    1066*       dl 0xFFFF8D ; 333.281 ED, -0.450
04115C 93 FF FF    1067*       dl 0xFFFF93 ; 334.688 EE, -0.428
04115F 99 FF FF    1068*       dl 0xFFFF99 ; 336.094 EF, -0.405
041162 9F FF FF    1069*       dl 0xFFFF9F ; 337.500 F0, -0.383
041165 A4 FF FF    1070*       dl 0xFFFFA4 ; 338.906 F1, -0.360
041168 AA FF FF    1071*       dl 0xFFFFAA ; 340.313 F2, -0.337
04116B B0 FF FF    1072*       dl 0xFFFFB0 ; 341.719 F3, -0.314
04116E B6 FF FF    1073*       dl 0xFFFFB6 ; 343.125 F4, -0.290
041171 BC FF FF    1074*       dl 0xFFFFBC ; 344.531 F5, -0.267
041174 C2 FF FF    1075*       dl 0xFFFFC2 ; 345.938 F6, -0.243
041177 C8 FF FF    1076*       dl 0xFFFFC8 ; 347.344 F7, -0.219
04117A CF FF FF    1077*       dl 0xFFFFCF ; 348.750 F8, -0.195
04117D D5 FF FF    1078*       dl 0xFFFFD5 ; 350.156 F9, -0.171
041180 DB FF FF    1079*       dl 0xFFFFDB ; 351.563 FA, -0.147
041183 E1 FF FF    1080*       dl 0xFFFFE1 ; 352.969 FB, -0.122
041186 E7 FF FF    1081*       dl 0xFFFFE7 ; 354.375 FC, -0.098
041189 EE FF FF    1082*       dl 0xFFFFEE ; 355.781 FD, -0.074
04118C F4 FF FF    1083*       dl 0xFFFFF4 ; 357.188 FE, -0.049
04118F FA FF FF    1084*       dl 0xFFFFFA ; 358.594 FF, -0.025
041192 00 00 00    1085*       dl 0x000000 ; 0.000 00, 0.000 for interpolation
041195             1086*   
041195             1087*   atan_lut_168:
041195 00 00 00    1088*       dl 0x000000 ; 000000, 0.000
041198 28 00 00    1089*       dl 0x000028 ; 000001, 0.224
04119B 51 00 00    1090*       dl 0x000051 ; 000002, 0.448
04119E 7A 00 00    1091*       dl 0x00007A ; 000003, 0.671
0411A1 A2 00 00    1092*       dl 0x0000A2 ; 000004, 0.895
0411A4 CB 00 00    1093*       dl 0x0000CB ; 000005, 1.119
0411A7 F4 00 00    1094*       dl 0x0000F4 ; 000006, 1.343
0411AA 1D 01 00    1095*       dl 0x00011D ; 000007, 1.566
0411AD 45 01 00    1096*       dl 0x000145 ; 000008, 1.790
0411B0 6E 01 00    1097*       dl 0x00016E ; 000009, 2.013
0411B3 97 01 00    1098*       dl 0x000197 ; 00000A, 2.237
0411B6 BF 01 00    1099*       dl 0x0001BF ; 00000B, 2.460
0411B9 E8 01 00    1100*       dl 0x0001E8 ; 00000C, 2.684
0411BC 11 02 00    1101*       dl 0x000211 ; 00000D, 2.907
0411BF 39 02 00    1102*       dl 0x000239 ; 00000E, 3.130
0411C2 62 02 00    1103*       dl 0x000262 ; 00000F, 3.353
0411C5 8B 02 00    1104*       dl 0x00028B ; 000010, 3.576
0411C8 B3 02 00    1105*       dl 0x0002B3 ; 000011, 3.799
0411CB DC 02 00    1106*       dl 0x0002DC ; 000012, 4.022
0411CE 04 03 00    1107*       dl 0x000304 ; 000013, 4.245
0411D1 2D 03 00    1108*       dl 0x00032D ; 000014, 4.467
0411D4 55 03 00    1109*       dl 0x000355 ; 000015, 4.690
0411D7 7E 03 00    1110*       dl 0x00037E ; 000016, 4.912
0411DA A6 03 00    1111*       dl 0x0003A6 ; 000017, 5.134
0411DD CE 03 00    1112*       dl 0x0003CE ; 000018, 5.356
0411E0 F7 03 00    1113*       dl 0x0003F7 ; 000019, 5.578
0411E3 1F 04 00    1114*       dl 0x00041F ; 00001A, 5.799
0411E6 48 04 00    1115*       dl 0x000448 ; 00001B, 6.021
0411E9 70 04 00    1116*       dl 0x000470 ; 00001C, 6.242
0411EC 98 04 00    1117*       dl 0x000498 ; 00001D, 6.463
0411EF C0 04 00    1118*       dl 0x0004C0 ; 00001E, 6.684
0411F2 E8 04 00    1119*       dl 0x0004E8 ; 00001F, 6.905
0411F5 11 05 00    1120*       dl 0x000511 ; 000020, 7.125
0411F8 39 05 00    1121*       dl 0x000539 ; 000021, 7.345
0411FB 61 05 00    1122*       dl 0x000561 ; 000022, 7.565
0411FE 89 05 00    1123*       dl 0x000589 ; 000023, 7.785
041201 B1 05 00    1124*       dl 0x0005B1 ; 000024, 8.005
041204 D9 05 00    1125*       dl 0x0005D9 ; 000025, 8.224
041207 01 06 00    1126*       dl 0x000601 ; 000026, 8.443
04120A 28 06 00    1127*       dl 0x000628 ; 000027, 8.662
04120D 50 06 00    1128*       dl 0x000650 ; 000028, 8.881
041210 78 06 00    1129*       dl 0x000678 ; 000029, 9.099
041213 A0 06 00    1130*       dl 0x0006A0 ; 00002A, 9.317
041216 C7 06 00    1131*       dl 0x0006C7 ; 00002B, 9.535
041219 EF 06 00    1132*       dl 0x0006EF ; 00002C, 9.752
04121C 16 07 00    1133*       dl 0x000716 ; 00002D, 9.970
04121F 3E 07 00    1134*       dl 0x00073E ; 00002E, 10.187
041222 65 07 00    1135*       dl 0x000765 ; 00002F, 10.403
041225 8D 07 00    1136*       dl 0x00078D ; 000030, 10.620
041228 B4 07 00    1137*       dl 0x0007B4 ; 000031, 10.836
04122B DB 07 00    1138*       dl 0x0007DB ; 000032, 11.051
04122E 03 08 00    1139*       dl 0x000803 ; 000033, 11.267
041231 2A 08 00    1140*       dl 0x00082A ; 000034, 11.482
041234 51 08 00    1141*       dl 0x000851 ; 000035, 11.697
041237 78 08 00    1142*       dl 0x000878 ; 000036, 11.911
04123A 9F 08 00    1143*       dl 0x00089F ; 000037, 12.125
04123D C6 08 00    1144*       dl 0x0008C6 ; 000038, 12.339
041240 ED 08 00    1145*       dl 0x0008ED ; 000039, 12.553
041243 13 09 00    1146*       dl 0x000913 ; 00003A, 12.766
041246 3A 09 00    1147*       dl 0x00093A ; 00003B, 12.978
041249 61 09 00    1148*       dl 0x000961 ; 00003C, 13.191
04124C 87 09 00    1149*       dl 0x000987 ; 00003D, 13.403
04124F AE 09 00    1150*       dl 0x0009AE ; 00003E, 13.614
041252 D4 09 00    1151*       dl 0x0009D4 ; 00003F, 13.825
041255 FB 09 00    1152*       dl 0x0009FB ; 000040, 14.036
041258 21 0A 00    1153*       dl 0x000A21 ; 000041, 14.247
04125B 47 0A 00    1154*       dl 0x000A47 ; 000042, 14.457
04125E 6D 0A 00    1155*       dl 0x000A6D ; 000043, 14.666
041261 94 0A 00    1156*       dl 0x000A94 ; 000044, 14.876
041264 BA 0A 00    1157*       dl 0x000ABA ; 000045, 15.085
041267 E0 0A 00    1158*       dl 0x000AE0 ; 000046, 15.293
04126A 05 0B 00    1159*       dl 0x000B05 ; 000047, 15.501
04126D 2B 0B 00    1160*       dl 0x000B2B ; 000048, 15.709
041270 51 0B 00    1161*       dl 0x000B51 ; 000049, 15.916
041273 77 0B 00    1162*       dl 0x000B77 ; 00004A, 16.123
041276 9C 0B 00    1163*       dl 0x000B9C ; 00004B, 16.329
041279 C2 0B 00    1164*       dl 0x000BC2 ; 00004C, 16.535
04127C E7 0B 00    1165*       dl 0x000BE7 ; 00004D, 16.740
04127F 0C 0C 00    1166*       dl 0x000C0C ; 00004E, 16.945
041282 32 0C 00    1167*       dl 0x000C32 ; 00004F, 17.150
041285 57 0C 00    1168*       dl 0x000C57 ; 000050, 17.354
041288 7C 0C 00    1169*       dl 0x000C7C ; 000051, 17.558
04128B A1 0C 00    1170*       dl 0x000CA1 ; 000052, 17.761
04128E C6 0C 00    1171*       dl 0x000CC6 ; 000053, 17.964
041291 EB 0C 00    1172*       dl 0x000CEB ; 000054, 18.166
041294 0F 0D 00    1173*       dl 0x000D0F ; 000055, 18.368
041297 34 0D 00    1174*       dl 0x000D34 ; 000056, 18.569
04129A 58 0D 00    1175*       dl 0x000D58 ; 000057, 18.770
04129D 7D 0D 00    1176*       dl 0x000D7D ; 000058, 18.970
0412A0 A1 0D 00    1177*       dl 0x000DA1 ; 000059, 19.170
0412A3 C6 0D 00    1178*       dl 0x000DC6 ; 00005A, 19.370
0412A6 EA 0D 00    1179*       dl 0x000DEA ; 00005B, 19.569
0412A9 0E 0E 00    1180*       dl 0x000E0E ; 00005C, 19.767
0412AC 32 0E 00    1181*       dl 0x000E32 ; 00005D, 19.965
0412AF 56 0E 00    1182*       dl 0x000E56 ; 00005E, 20.163
0412B2 7A 0E 00    1183*       dl 0x000E7A ; 00005F, 20.360
0412B5 9E 0E 00    1184*       dl 0x000E9E ; 000060, 20.556
0412B8 C1 0E 00    1185*       dl 0x000EC1 ; 000061, 20.752
0412BB E5 0E 00    1186*       dl 0x000EE5 ; 000062, 20.947
0412BE 08 0F 00    1187*       dl 0x000F08 ; 000063, 21.142
0412C1 2C 0F 00    1188*       dl 0x000F2C ; 000064, 21.337
0412C4 4F 0F 00    1189*       dl 0x000F4F ; 000065, 21.531
0412C7 72 0F 00    1190*       dl 0x000F72 ; 000066, 21.724
0412CA 95 0F 00    1191*       dl 0x000F95 ; 000067, 21.917
0412CD B8 0F 00    1192*       dl 0x000FB8 ; 000068, 22.109
0412D0 DB 0F 00    1193*       dl 0x000FDB ; 000069, 22.301
0412D3 FE 0F 00    1194*       dl 0x000FFE ; 00006A, 22.493
0412D6 21 10 00    1195*       dl 0x001021 ; 00006B, 22.683
0412D9 44 10 00    1196*       dl 0x001044 ; 00006C, 22.874
0412DC 66 10 00    1197*       dl 0x001066 ; 00006D, 23.063
0412DF 89 10 00    1198*       dl 0x001089 ; 00006E, 23.253
0412E2 AB 10 00    1199*       dl 0x0010AB ; 00006F, 23.441
0412E5 CD 10 00    1200*       dl 0x0010CD ; 000070, 23.629
0412E8 EF 10 00    1201*       dl 0x0010EF ; 000071, 23.817
0412EB 11 11 00    1202*       dl 0x001111 ; 000072, 24.004
0412EE 33 11 00    1203*       dl 0x001133 ; 000073, 24.191
0412F1 55 11 00    1204*       dl 0x001155 ; 000074, 24.376
0412F4 77 11 00    1205*       dl 0x001177 ; 000075, 24.562
0412F7 99 11 00    1206*       dl 0x001199 ; 000076, 24.747
0412FA BA 11 00    1207*       dl 0x0011BA ; 000077, 24.931
0412FD DC 11 00    1208*       dl 0x0011DC ; 000078, 25.115
041300 FD 11 00    1209*       dl 0x0011FD ; 000079, 25.298
041303 1E 12 00    1210*       dl 0x00121E ; 00007A, 25.481
041306 3F 12 00    1211*       dl 0x00123F ; 00007B, 25.663
041309 60 12 00    1212*       dl 0x001260 ; 00007C, 25.844
04130C 81 12 00    1213*       dl 0x001281 ; 00007D, 26.025
04130F A2 12 00    1214*       dl 0x0012A2 ; 00007E, 26.206
041312 C3 12 00    1215*       dl 0x0012C3 ; 00007F, 26.386
041315 E4 12 00    1216*       dl 0x0012E4 ; 000080, 26.565
041318 04 13 00    1217*       dl 0x001304 ; 000081, 26.744
04131B 25 13 00    1218*       dl 0x001325 ; 000082, 26.922
04131E 45 13 00    1219*       dl 0x001345 ; 000083, 27.100
041321 65 13 00    1220*       dl 0x001365 ; 000084, 27.277
041324 85 13 00    1221*       dl 0x001385 ; 000085, 27.453
041327 A5 13 00    1222*       dl 0x0013A5 ; 000086, 27.629
04132A C5 13 00    1223*       dl 0x0013C5 ; 000087, 27.805
04132D E5 13 00    1224*       dl 0x0013E5 ; 000088, 27.979
041330 05 14 00    1225*       dl 0x001405 ; 000089, 28.154
041333 24 14 00    1226*       dl 0x001424 ; 00008A, 28.327
041336 44 14 00    1227*       dl 0x001444 ; 00008B, 28.501
041339 63 14 00    1228*       dl 0x001463 ; 00008C, 28.673
04133C 83 14 00    1229*       dl 0x001483 ; 00008D, 28.845
04133F A2 14 00    1230*       dl 0x0014A2 ; 00008E, 29.017
041342 C1 14 00    1231*       dl 0x0014C1 ; 00008F, 29.187
041345 E0 14 00    1232*       dl 0x0014E0 ; 000090, 29.358
041348 FF 14 00    1233*       dl 0x0014FF ; 000091, 29.527
04134B 1E 15 00    1234*       dl 0x00151E ; 000092, 29.697
04134E 3C 15 00    1235*       dl 0x00153C ; 000093, 29.865
041351 5B 15 00    1236*       dl 0x00155B ; 000094, 30.033
041354 79 15 00    1237*       dl 0x001579 ; 000095, 30.201
041357 98 15 00    1238*       dl 0x001598 ; 000096, 30.368
04135A B6 15 00    1239*       dl 0x0015B6 ; 000097, 30.534
04135D D4 15 00    1240*       dl 0x0015D4 ; 000098, 30.700
041360 F2 15 00    1241*       dl 0x0015F2 ; 000099, 30.865
041363 10 16 00    1242*       dl 0x001610 ; 00009A, 31.030
041366 2E 16 00    1243*       dl 0x00162E ; 00009B, 31.194
041369 4C 16 00    1244*       dl 0x00164C ; 00009C, 31.357
04136C 6A 16 00    1245*       dl 0x00166A ; 00009D, 31.520
04136F 87 16 00    1246*       dl 0x001687 ; 00009E, 31.682
041372 A5 16 00    1247*       dl 0x0016A5 ; 00009F, 31.844
041375 C2 16 00    1248*       dl 0x0016C2 ; 0000A0, 32.005
041378 DF 16 00    1249*       dl 0x0016DF ; 0000A1, 32.166
04137B FC 16 00    1250*       dl 0x0016FC ; 0000A2, 32.326
04137E 19 17 00    1251*       dl 0x001719 ; 0000A3, 32.486
041381 36 17 00    1252*       dl 0x001736 ; 0000A4, 32.645
041384 53 17 00    1253*       dl 0x001753 ; 0000A5, 32.803
041387 70 17 00    1254*       dl 0x001770 ; 0000A6, 32.961
04138A 8C 17 00    1255*       dl 0x00178C ; 0000A7, 33.118
04138D A9 17 00    1256*       dl 0x0017A9 ; 0000A8, 33.275
041390 C5 17 00    1257*       dl 0x0017C5 ; 0000A9, 33.431
041393 E2 17 00    1258*       dl 0x0017E2 ; 0000AA, 33.587
041396 FE 17 00    1259*       dl 0x0017FE ; 0000AB, 33.742
041399 1A 18 00    1260*       dl 0x00181A ; 0000AC, 33.896
04139C 36 18 00    1261*       dl 0x001836 ; 0000AD, 34.050
04139F 52 18 00    1262*       dl 0x001852 ; 0000AE, 34.203
0413A2 6E 18 00    1263*       dl 0x00186E ; 0000AF, 34.356
0413A5 8A 18 00    1264*       dl 0x00188A ; 0000B0, 34.509
0413A8 A5 18 00    1265*       dl 0x0018A5 ; 0000B1, 34.660
0413AB C1 18 00    1266*       dl 0x0018C1 ; 0000B2, 34.811
0413AE DC 18 00    1267*       dl 0x0018DC ; 0000B3, 34.962
0413B1 F7 18 00    1268*       dl 0x0018F7 ; 0000B4, 35.112
0413B4 13 19 00    1269*       dl 0x001913 ; 0000B5, 35.262
0413B7 2E 19 00    1270*       dl 0x00192E ; 0000B6, 35.410
0413BA 49 19 00    1271*       dl 0x001949 ; 0000B7, 35.559
0413BD 64 19 00    1272*       dl 0x001964 ; 0000B8, 35.707
0413C0 7F 19 00    1273*       dl 0x00197F ; 0000B9, 35.854
0413C3 99 19 00    1274*       dl 0x001999 ; 0000BA, 36.001
0413C6 B4 19 00    1275*       dl 0x0019B4 ; 0000BB, 36.147
0413C9 CE 19 00    1276*       dl 0x0019CE ; 0000BC, 36.293
0413CC E9 19 00    1277*       dl 0x0019E9 ; 0000BD, 36.438
0413CF 03 1A 00    1278*       dl 0x001A03 ; 0000BE, 36.582
0413D2 1D 1A 00    1279*       dl 0x001A1D ; 0000BF, 36.726
0413D5 37 1A 00    1280*       dl 0x001A37 ; 0000C0, 36.870
0413D8 51 1A 00    1281*       dl 0x001A51 ; 0000C1, 37.013
0413DB 6B 1A 00    1282*       dl 0x001A6B ; 0000C2, 37.155
0413DE 85 1A 00    1283*       dl 0x001A85 ; 0000C3, 37.297
0413E1 9F 1A 00    1284*       dl 0x001A9F ; 0000C4, 37.439
0413E4 B9 1A 00    1285*       dl 0x001AB9 ; 0000C5, 37.579
0413E7 D2 1A 00    1286*       dl 0x001AD2 ; 0000C6, 37.720
0413EA EC 1A 00    1287*       dl 0x001AEC ; 0000C7, 37.859
0413ED 05 1B 00    1288*       dl 0x001B05 ; 0000C8, 37.999
0413F0 1E 1B 00    1289*       dl 0x001B1E ; 0000C9, 38.137
0413F3 37 1B 00    1290*       dl 0x001B37 ; 0000CA, 38.276
0413F6 50 1B 00    1291*       dl 0x001B50 ; 0000CB, 38.413
0413F9 69 1B 00    1292*       dl 0x001B69 ; 0000CC, 38.550
0413FC 82 1B 00    1293*       dl 0x001B82 ; 0000CD, 38.687
0413FF 9B 1B 00    1294*       dl 0x001B9B ; 0000CE, 38.823
041402 B4 1B 00    1295*       dl 0x001BB4 ; 0000CF, 38.959
041405 CC 1B 00    1296*       dl 0x001BCC ; 0000D0, 39.094
041408 E5 1B 00    1297*       dl 0x001BE5 ; 0000D1, 39.228
04140B FD 1B 00    1298*       dl 0x001BFD ; 0000D2, 39.362
04140E 16 1C 00    1299*       dl 0x001C16 ; 0000D3, 39.496
041411 2E 1C 00    1300*       dl 0x001C2E ; 0000D4, 39.629
041414 46 1C 00    1301*       dl 0x001C46 ; 0000D5, 39.762
041417 5E 1C 00    1302*       dl 0x001C5E ; 0000D6, 39.894
04141A 76 1C 00    1303*       dl 0x001C76 ; 0000D7, 40.025
04141D 8E 1C 00    1304*       dl 0x001C8E ; 0000D8, 40.156
041420 A5 1C 00    1305*       dl 0x001CA5 ; 0000D9, 40.286
041423 BD 1C 00    1306*       dl 0x001CBD ; 0000DA, 40.416
041426 D5 1C 00    1307*       dl 0x001CD5 ; 0000DB, 40.546
041429 EC 1C 00    1308*       dl 0x001CEC ; 0000DC, 40.675
04142C 04 1D 00    1309*       dl 0x001D04 ; 0000DD, 40.803
04142F 1B 1D 00    1310*       dl 0x001D1B ; 0000DE, 40.931
041432 32 1D 00    1311*       dl 0x001D32 ; 0000DF, 41.059
041435 49 1D 00    1312*       dl 0x001D49 ; 0000E0, 41.186
041438 60 1D 00    1313*       dl 0x001D60 ; 0000E1, 41.312
04143B 77 1D 00    1314*       dl 0x001D77 ; 0000E2, 41.438
04143E 8E 1D 00    1315*       dl 0x001D8E ; 0000E3, 41.564
041441 A5 1D 00    1316*       dl 0x001DA5 ; 0000E4, 41.689
041444 BB 1D 00    1317*       dl 0x001DBB ; 0000E5, 41.814
041447 D2 1D 00    1318*       dl 0x001DD2 ; 0000E6, 41.938
04144A E9 1D 00    1319*       dl 0x001DE9 ; 0000E7, 42.061
04144D FF 1D 00    1320*       dl 0x001DFF ; 0000E8, 42.184
041450 15 1E 00    1321*       dl 0x001E15 ; 0000E9, 42.307
041453 2C 1E 00    1322*       dl 0x001E2C ; 0000EA, 42.429
041456 42 1E 00    1323*       dl 0x001E42 ; 0000EB, 42.551
041459 58 1E 00    1324*       dl 0x001E58 ; 0000EC, 42.672
04145C 6E 1E 00    1325*       dl 0x001E6E ; 0000ED, 42.793
04145F 84 1E 00    1326*       dl 0x001E84 ; 0000EE, 42.913
041462 99 1E 00    1327*       dl 0x001E99 ; 0000EF, 43.033
041465 AF 1E 00    1328*       dl 0x001EAF ; 0000F0, 43.152
041468 C5 1E 00    1329*       dl 0x001EC5 ; 0000F1, 43.271
04146B DA 1E 00    1330*       dl 0x001EDA ; 0000F2, 43.390
04146E F0 1E 00    1331*       dl 0x001EF0 ; 0000F3, 43.508
041471 05 1F 00    1332*       dl 0x001F05 ; 0000F4, 43.625
041474 1B 1F 00    1333*       dl 0x001F1B ; 0000F5, 43.742
041477 30 1F 00    1334*       dl 0x001F30 ; 0000F6, 43.859
04147A 45 1F 00    1335*       dl 0x001F45 ; 0000F7, 43.975
04147D 5A 1F 00    1336*       dl 0x001F5A ; 0000F8, 44.091
041480 6F 1F 00    1337*       dl 0x001F6F ; 0000F9, 44.206
041483 84 1F 00    1338*       dl 0x001F84 ; 0000FA, 44.321
041486 99 1F 00    1339*       dl 0x001F99 ; 0000FB, 44.435
041489 AD 1F 00    1340*       dl 0x001FAD ; 0000FC, 44.549
04148C C2 1F 00    1341*       dl 0x001FC2 ; 0000FD, 44.662
04148F D7 1F 00    1342*       dl 0x001FD7 ; 0000FE, 44.775
041492 EB 1F 00    1343*       dl 0x001FEB ; 0000FF, 44.888
041495 00 20 00    1344*       dl 0x002000 ; 000100, 45.000 only needed for interpolation
041498             0038        include "timer.inc"
041498             0001*   ; Table 32. Timer Control Registers
041498             0002*   TMR0_CTL: equ 80h
041498             0003*   TMR1_CTL: equ 83h
041498             0004*   TMR2_CTL: equ 86h
041498             0005*   TMR3_CTL: equ 89h
041498             0006*   TMR4_CTL: equ 8Ch
041498             0007*   TMR5_CTL: equ 8Fh
041498             0008*   
041498             0009*   ; each timer register takes three bytes:
041498             0010*   ;   0: control register
041498             0011*   ;   1: low byte of timer reset value
041498             0012*   ;   2: high byte of timer reset value
041498             0013*   ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
041498             0014*   ; which correctly force the high and upper bytes of the address bus to zero
041498             0015*   
041498             0016*   TMR_REG_CTL: equ 0
041498             0017*   TMR_RES_LOW: equ 1
041498             0018*   TMR_RES_HIGH: equ 2
041498             0019*   
041498             0020*   ; Timer Control Register Bit Definitions
041498             0021*   PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
041498             0022*                               ; This bit is reset to 0 every time the TMRx_CTL register is read.
041498             0023*   PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
041498             0024*                               ; an interrupt signal is sent to the CPU. This bit remains 1 until
041498             0025*                               ; the TMRx_CTL register is read.
041498             0026*   
041498             0027*   IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
041498             0028*   IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
041498             0029*   
041498             0030*   PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
041498             0031*                               ;  0,and counting stops when the end-of-count value is reached.
041498             0032*   PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
041498             0033*                               ; written to the counter when the end-of-count value is reached.
041498             0034*   
041498             0035*   ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
041498             0036*   CLK_DIV_256:  equ %00001100 ;
041498             0037*   CLK_DIV_64:   equ %00001000 ;
041498             0038*   CLK_DIV_16:   equ %00000100 ;
041498             0039*   CLK_DIV_4:    equ %00000000 ;
041498             0040*   
041498             0041*   RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
041498             0042*   RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
041498             0043*                               ; When a 1 is written to this bit,the values in the reload registers
041498             0044*                               ;  are loaded into the downcounter when the timer restarts. The
041498             0045*                               ; programmer must ensure that this bit is set to 1 each time
041498             0046*                               ; SINGLE-PASS mode is used.
041498             0047*   
041498             0048*   ; disable/enable the programmable reload timer
041498             0049*   PRT_EN_0:     equ %00000000 ;
041498             0050*   PRT_EN_1:     equ %00000001 ;
041498             0051*   
041498             0052*   ; Table 37. Timer Input Source Select Register
041498             0053*   ; Each of the 4 timers are allocated two bits of the 8-bit register
041498             0054*   ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
041498             0055*   ;   00: System clock / CLK_DIV
041498             0056*   ;   01: RTC / CLK_DIV
041498             0057*   ;   NOTE: these are the values given in the manual,but it may be a typo
041498             0058*   ;   10: GPIO port B pin 1.
041498             0059*   ;   11: GPIO port B pin 1.
041498             0060*   TMR_ISS:   equ 92h ; register address
041498             0061*   
041498             0062*   ; Table 51. Real-Time Clock Control Register
041498             0063*   RTC_CTRL: equ EDh ; register address
041498             0064*   
041498             0065*   ; alarm interrupt disable/enable
041498             0066*   RTC_ALARM_0:    equ %00000000
041498             0067*   RTC_ALARM_1:    equ %10000000
041498             0068*   
041498             0069*   ; interrupt on alarm disable/enable
041498             0070*   RTC_INT_ENT_0:  equ %00000000
041498             0071*   RTC_INT_ENT_1:  equ %01000000
041498             0072*   
041498             0073*   RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
041498             0074*   RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
041498             0075*   
041498             0076*   RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
041498             0077*                                   ; On-chip 32768 Hz oscillator is enabled.
041498             0078*   RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
041498             0079*                                   ; On-chip 32768 Hz oscillator is disabled.
041498             0080*   
041498             0081*   RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
041498             0082*   RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
041498             0083*   
041498             0084*   RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
041498             0085*   RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
041498             0086*   
041498             0087*   RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
041498             0088*                                   ; RTC counter is enabled.
041498             0089*   RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
041498             0090*                                   ; RTC counter is disabled.
041498             0091*   
041498             0092*   ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
041498             0093*   
041498             0094*   prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
041498             0095*   prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
041498 00 00 00    0096*   prt_reload: dl 0x000000
04149B             0097*   
04149B             0098*   ; returns: a = 0 if running on hardware,1 if running on emulator
04149B             0099*   ;          de = number PRT interrupts during test interval
04149B             0100*   prt_calibrate:
04149B CD 6A 17 04 0101*       call vdu_vblank
04149F             0102*   ; set a MOS timer
04149F 21 78 00 00 0103*       ld hl,120*1 ; 1 second
0414A3 FD 21 23 16 0104*       ld iy,tmr_test
       04          
0414A8 CD 01 16 04 0105*       call tmr_set
0414AC             0106*   ; set a PRT timer
0414AC             0107*       ; ld hl,prt_reload_hardware
0414AC             0108*       ; ld hl,prt_reload_emulator
0414AC 21 05 2D 00 0109*       ld hl,prt_reload_emulator + prt_reload_hardware / 2
0414B0 22 98 14 04 0110*       ld (prt_reload),hl
0414B4 CD 3C 15 04 0111*       call prt_set
0414B8             0112*   @loop:
0414B8             0113*   ; check time remaining on MOS timer
0414B8 CD 0F 16 04 0114*       call tmr_get
0414BC CA C6 14 04 0115*       jp z,@done ; time expired,so quit
0414C0 FA C6 14 04 0116*       jp m,@done ; time past expiration (negative),so quit
0414C4 18 F2       0117*       jr @loop
0414C6             0118*   @done:
0414C6 ED 5B 8A 15 0119*       ld de,(prt_irq_counter)
       04          
0414CB 01 0C 2D 00 0120*       ld bc,prt_reload_hardware ; default value for running on hardware
0414CF ED 43 98 14 0121*       ld (prt_reload),bc
       04          
0414D4 21 64 00 00 0122*       ld hl,100 ; halfway between 101 for real hardware and 99 for emulator
0414D8 AF          0123*       xor a ; clear carry,zero is default value for running on hardware
0414D9 32 FB 14 04 0124*       ld (is_emulator),a
0414DD ED 52       0125*       sbc hl,de
0414DF 21 FC 14 04 0126*       ld hl,on_hardware ; default message for running on hardware
0414E3 CA 9B 14 04 0127*       jp z,prt_calibrate ; zero result is indeterminate so we try again
0414E7 F8          0128*       ret m ; negative result means we're on hardware
0414E8 3C          0129*       inc a ; we're on emulator
0414E9 32 FB 14 04 0130*       ld (is_emulator),a
0414ED 01 FF 2C 00 0131*       ld bc,prt_reload_emulator
0414F1 ED 43 98 14 0132*       ld (prt_reload),bc
       04          
0414F6 21 12 15 04 0133*       ld hl,on_emulator
0414FA C9          0134*       ret
0414FB 00          0135*   is_emulator: db 0
0414FC 52 75 6E 6E 0136*   on_hardware: defb "Running on hardware\r\n",0
       69 6E 67 20 
       6F 6E 20 68 
       61 72 64 77 
       61 72 65 0D 
       0A 00       
041512 52 75 6E 6E 0137*   on_emulator: defb "Running on emulator\r\n",0
       69 6E 67 20 
       6F 6E 20 65 
       6D 75 6C 61 
       74 6F 72 0D 
       0A 00       
041528             0138*   
041528 43 61 6C 69 0139*   calibrating_timer: defb "Calibrating timer\r\n",0
       62 72 61 74 
       69 6E 67 20 
       74 69 6D 65 
       72 0D 0A 00 
04153C             0140*   
04153C             0141*   ; set PRT timer
04153C             0142*   prt_set:
04153C 21 00 00 00 0143*       ld hl,0
041540 22 8A 15 04 0144*       ld (prt_irq_counter),hl
041544 2A 98 14 04 0145*       ld hl,(prt_reload)
041548 ED 29 84    0146*       out0 (TMR1_CTL+TMR_RES_LOW),l
04154B ED 21 85    0147*   	out0 (TMR1_CTL+TMR_RES_HIGH),h
04154E             0148*   ; disable timer
04154E 3E 06       0149*       ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
041550 ED 39 83    0150*   	out0 (TMR1_CTL+TMR_REG_CTL),a
041553             0151*   ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
041553 3E 57       0152*       ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
041555 ED 39 83    0153*   	out0 (TMR1_CTL+TMR_REG_CTL),a
041558 C9          0154*       ret
041559             0155*   
041559             0156*   ; ===============================================
041559             0157*   ; PRT Timer Interrupt Handling
041559             0158*   ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.asm
041559             0159*   ; -----------------------------------------------
041559             0160*   prt_irq_init:
041559             0161*       ; set up interrupt vector table 2
041559 21 00 00 00 0162*   	ld hl,0
04155D 3A 0C 01 00 0163*   	ld a,($10c)
041561 6F          0164*   	ld l,a
041562 3A 0D 01 00 0165*   	ld a,($10d)
041566 67          0166*   	ld h,a
041567             0167*   
041567             0168*   	; skip over CALL ($c3)
041567 23          0169*   	inc hl
041568             0170*   	; load address of jump into vector table 2 (in ram)
041568 ED 27       0171*   	ld hl,(hl)
04156A             0172*   
04156A             0173*   	; write CALL prt_irq_handler to vector table 2
04156A 3E C3       0174*   	ld a,$c3
04156C 77          0175*   	ld (hl),a
04156D 23          0176*   	inc hl
04156E 11 75 15 04 0177*   	ld de,prt_irq_handler
041572 ED 1F       0178*   	ld (hl),de
041574             0179*   
041574 C9          0180*       ret
041575             0181*   
041575             0182*   prt_irq_handler:
041575 F3          0183*   	di
041576 F5          0184*   	push af
041577 E5          0185*       push hl
041578 ED 38 83    0186*   	in0 a,(TMR1_CTL+TMR_REG_CTL)
04157B 2A 8A 15 04 0187*   	ld hl,(prt_irq_counter)
04157F 23          0188*   	inc hl
041580 22 8A 15 04 0189*   	ld (prt_irq_counter),hl
041584 E1          0190*       pop hl
041585 F1          0191*   	pop af
041586 FB          0192*   	ei
041587 5B ED 4D    0193*   	reti.l
04158A             0194*   
04158A             0195*   prt_irq_counter:
04158A 00 00 00    0196*   	.dl 0
04158D             0197*   prt_irq_counter_saved:
04158D 00 00 00    0198*       .dl 0
041590             0199*   
041590             0200*   prt_loop_reset:
041590 E5          0201*       push hl
041591 21 00 00 00 0202*   	ld hl,0
041595 22 8A 15 04 0203*   	ld (prt_irq_counter),hl
041599 22 FB 15 04 0204*       ld (prt_loop_counter),hl
04159D 22 FE 15 04 0205*       ld (prt_loops),hl
0415A1 CD 3C 15 04 0206*       call prt_set
0415A5 E1          0207*       pop hl
0415A6 C9          0208*       ret
0415A7             0209*   
0415A7             0210*   prt_loop_start:
0415A7 E5          0211*       push hl
0415A8 21 00 00 00 0212*   	ld hl,0
0415AC 22 8A 15 04 0213*   	ld (prt_irq_counter),hl
0415B0 E1          0214*       pop hl
0415B1 C9          0215*       ret
0415B2             0216*   
0415B2             0217*   prt_loop_stop:
0415B2 E5          0218*       push hl
0415B3 D5          0219*       push de
0415B4 2A 8A 15 04 0220*       ld hl,(prt_irq_counter)
0415B8 ED 5B FB 15 0221*       ld de,(prt_loop_counter)
       04          
0415BD 19          0222*       add hl,de
0415BE 22 FB 15 04 0223*       ld (prt_loop_counter),hl
0415C2 21 00 00 00 0224*       ld hl,0
0415C6 22 8A 15 04 0225*       ld (prt_irq_counter),hl
0415CA 2A FE 15 04 0226*       ld hl,(prt_loops)
0415CE 23          0227*       inc hl
0415CF 22 FE 15 04 0228*       ld (prt_loops),hl
0415D3 D1          0229*       pop de
0415D4 E1          0230*       pop hl
0415D5 C9          0231*       ret
0415D6             0232*   
0415D6             0233*   ; inputs: bc = y,x text coordinates to print
0415D6             0234*   prt_loop_print:
0415D6 F5          0235*       push af
0415D7 E5          0236*       push hl
0415D8 C5          0237*       push bc
0415D9 D5          0238*       push de
0415DA DD E5       0239*       push ix
0415DC FD E5       0240*       push iy
0415DE CD E2 16 04 0241*       call vdu_move_cursor
0415E2             0242*   
0415E2 2A FB 15 04 0243*       ld hl,(prt_loop_counter)
0415E6 CD CC 00 04 0244*       call printDec
0415EA             0245*   
0415EA 2A FE 15 04 0246*       ld hl,(prt_loops)
0415EE CD CC 00 04 0247*       call printDec
0415F2             0248*   
0415F2 FD E1       0249*       pop iy
0415F4 DD E1       0250*       pop ix
0415F6 D1          0251*       pop de
0415F7 C1          0252*       pop bc
0415F8 E1          0253*       pop hl
0415F9 F1          0254*       pop af
0415FA C9          0255*       ret
0415FB             0256*   
0415FB             0257*   prt_loop_counter:
0415FB 00 00 00    0258*       .dl 0
0415FE             0259*   prt_loops:
0415FE 00 00 00    0260*       .dl 0
041601             0261*   
041601             0262*   ; ===============================================
041601             0263*   ; Timer functions
041601             0264*   ; -----------------------------------------------
041601             0265*   ; set a countdown timer
041601             0266*   ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
041601             0267*   ; returns: hl = current time
041601             0268*   tmr_set:
041601 FD 2F 03    0269*       ld (iy+3),hl            ; set time remaining
041604             0270*       MOSCALL mos_sysvars     ; ix points to syvars table
041604 3E 08       0001*M1 			LD	A, function
041606 5B CF       0002*M1 			RST.LIL	08h
041608 DD 27 00    0271*       ld hl,(ix+sysvar_time)  ; get current time
04160B FD 2F 00    0272*       ld (iy+0),hl            ; set start time
04160E C9          0273*       ret
04160F             0274*   
04160F             0275*   ; gets time remaining on a countdown timer
04160F             0276*   ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
04160F             0277*   ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
04160F             0278*   ;          sign flags: pos = time not expired,zero or neg = time expired
04160F             0279*   tmr_get:
04160F             0280*       MOSCALL mos_sysvars     ; ix points to syvars table
04160F 3E 08       0001*M1 			LD	A, function
041611 5B CF       0002*M1 			RST.LIL	08h
041613 DD 17 00    0281*       ld de,(ix+sysvar_time)  ; get current time
041616 FD 27 00    0282*       ld hl,(iy+0)            ; get start time
041619 AF          0283*       xor a                   ; clear carry
04161A ED 52       0284*       sbc hl,de               ; hl = time elapsed (will always be zero or negative)
04161C FD 17 03    0285*       ld de,(iy+3)            ; get timer set value
04161F AF          0286*       xor a                   ; clear carry
041620 ED 5A       0287*       adc hl,de               ; hl = time remaining
041622             0288*                               ; (we do adc because add hl,rr doesn't set sign or zero flags)
041622 C9          0289*       ret
041623             0290*   
041623             0291*   tmr_test: ds 6 ; example of a buffer to hold timer data
041629             0292*   
       FF FF FF FF 
       FF FF 
041629 00 00 00    0293*   timestamp_now: dl 0
04162C 00 00 00    0294*   timestamp_old: dl 0
04162F 00 00 00    0295*   timestamp_chg: dl 0
041632             0296*   
041632             0297*   ; update the global timestamp from the system clock
041632             0298*   ; inputs: none
041632             0299*   ; returns: hl = time elapsed in 1/120ths of a second
041632             0300*   ;          de = current time
041632             0301*   ;          ix = pointer to syvars table
041632             0302*   ; destroys: af,hl,de,ix
041632             0303*   timestamp_tick:
041632 ED 5B 29 16 0304*       ld de,(timestamp_now)   ; get previous time
       04          
041637 ED 53 2C 16 0305*       ld (timestamp_old),de   ; save previous time
       04          
04163C             0306*       MOSCALL mos_sysvars     ; ix points to syvars table
04163C 3E 08       0001*M1 			LD	A, function
04163E 5B CF       0002*M1 			RST.LIL	08h
041640 DD 27 00    0307*       ld hl,(ix+sysvar_time)  ; get current time
041643 22 29 16 04 0308*       ld (timestamp_now),hl   ; save current time
041647 AF          0309*       xor a                   ; clear carry
041648 ED 52       0310*       sbc hl,de               ; hl = time elapsed
04164A 22 2F 16 04 0311*       ld (timestamp_chg),hl   ; save elapsed time
04164E C9          0312*       ret
04164F             0313*   
04164F             0314*   ; set a countdown timer
04164F             0315*   ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
04164F             0316*   ; requires: timestamp_tick to be called at least once before this function
04164F             0317*   ; returns: hl = current time
04164F             0318*   ; destroys: hl
04164F             0319*   timestamp_tmr_set:
04164F FD 2F 03    0320*       ld (iy+3),hl            ; set time remaining
041652 2A 29 16 04 0321*       ld hl,(timestamp_now)   ; get current timestamp
041656 FD 2F 00    0322*       ld (iy+0),hl            ; set start time
041659 C9          0323*       ret
04165A             0324*   
04165A             0325*   ; gets time remaining on a countdown timer following the global timestamp
04165A             0326*   ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
04165A             0327*   ; requires: timestamp_tick to be called at least once before this function
04165A             0328*   ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
04165A             0329*   ;          sign flags: pos = time not expired,zero or neg = time expired
04165A             0330*   ; destroys: af,hl,de
04165A             0331*   timestamp_tmr_get:
04165A ED 5B 29 16 0332*       ld de,(timestamp_now)   ; get current timestamp
       04          
04165F FD 27 00    0333*       ld hl,(iy+0)            ; get start time
041662 AF          0334*       xor a                   ; clear carry
041663 ED 52       0335*       sbc hl,de               ; hl = time elapsed (will always be zero or negative)
041665 FD 17 03    0336*       ld de,(iy+3)            ; get timer set value
041668 AF          0337*       xor a                   ; clear carry
041669 ED 5A       0338*       adc hl,de               ; hl = time remaining
04166B             0339*                               ; (we do adc because add hl,rr doesn't set sign or zero flags)
04166B C9          0340*       ret
04166C             0341*   
04166C             0342*   ; set a stopwatch
04166C             0343*   ; returns: hl = start time
04166C             0344*   ; destroys: hl,ix
04166C             0345*   stopwatch_set:
04166C             0346*       MOSCALL mos_sysvars     ; ix points to syvars table
04166C 3E 08       0001*M1 			LD	A, function
04166E 5B CF       0002*M1 			RST.LIL	08h
041670 DD 27 00    0347*       ld hl,(ix+sysvar_time)  ; get current time
041673 22 88 16 04 0348*       ld (stopwatch_started),hl            ; set start time
041677 C9          0349*       ret
041678             0350*   
041678             0351*   ; gets time elapsed on a stopwatch
041678             0352*   ; returns: hl = time elapsed in 1/120ths of a second
041678             0353*   ; destroys: af,hl,de,ix
041678             0354*   stopwatch_get:
041678             0355*       MOSCALL mos_sysvars     ; ix points to syvars table
041678 3E 08       0001*M1 			LD	A, function
04167A 5B CF       0002*M1 			RST.LIL	08h
04167C DD 27 00    0356*       ld hl,(ix+sysvar_time)  ; get current time
04167F ED 5B 88 16 0357*       ld de,(stopwatch_started)            ; get start time
       04          
041684 AF          0358*       xor a                   ; clear carry
041685 ED 52       0359*       sbc hl,de               ; hl = time elapsed (will always be zero or positive)
041687 C9          0360*       ret
041688             0361*   
041688             0362*   stopwatch_started: ds 3 ; buffer to hold stopwatch start time
04168B             0363*   
04168B             0364*   ; ------------------
04168B             0365*   ; delay routine
04168B             0366*   ; Author: Richard Turrnidge
04168B             0367*   ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.asm
04168B             0368*   ; routine waits a fixed time,then returns
04168B             0369*   ; arrive with A =  the delay byte. One bit to be set only.
04168B             0370*   ; eg. ld A,00000100b
04168B             0371*   
04168B             0372*   multiPurposeDelay:
       FF FF FF 
04168B F5          0373*       push af
04168C C5          0374*       push bc
04168D DD E5       0375*       push ix
04168F 47          0376*       ld b,a
041690 3E 08       0377*       ld a,$08
041692 5B CF       0378*       RST.LIL	08h                 ; get IX pointer to sysvars
041694             0379*   
041694             0380*   waitLoop:
041694             0381*   
041694 DD 7E 00    0382*       ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
041697             0383*   
041697             0384*                                   ;   we check if bit set is same as last time we checked.
041697             0385*                                   ;   bit 0 - don't use
041697             0386*                                   ;   bit 1 - changes 64 times per second
041697             0387*                                   ;   bit 2 - changes 32 times per second
041697             0388*                                   ;   bit 3 - changes 16 times per second
041697             0389*   
041697             0390*                                   ;   bit 4 - changes 8 times per second
041697             0391*                                   ;   bit 5 - changes 4 times per second
041697             0392*                                   ;   bit 6 - changes 2 times per second
041697             0393*                                   ;   bit 7 - changes 1 times per second
041697 A0          0394*       and b
041698 4F          0395*       ld c,a
041699 3A AA 16 04 0396*       ld a,(oldTimeStamp)
04169D B9          0397*       cp c                        ; is A same as last value?
04169E 28 F4       0398*       jr z,waitLoop              ; loop here if it is
0416A0 79          0399*       ld a,c
0416A1 32 AA 16 04 0400*       ld (oldTimeStamp),a        ; set new value
0416A5             0401*   
0416A5 DD E1       0402*       pop ix
0416A7 C1          0403*       pop bc
0416A8 F1          0404*       pop af
0416A9 C9          0405*       ret
0416AA             0406*   
0416AA 00          0407*   oldTimeStamp:   .db 00h
0416AB             0039        include "vdu.inc"
0416AB             0001*   ; VDU 30: Home cursor
0416AB             0002*   vdu_home_cursor:
0416AB 3E 1E       0003*       ld a,30
0416AD 5B D7       0004*   	rst.lil $10
0416AF C9          0005*   	ret
0416B0             0006*   
0416B0             0007*   vdu_cursor_on:
0416B0 21 BB 16 04 0008*   	ld hl,@cmd
0416B4 01 03 00 00 0009*   	ld bc,@end-@cmd
0416B8 5B DF       0010*   	rst.lil $18
0416BA C9          0011*   	ret
0416BB             0012*   @cmd:
0416BB 17 01 01    0013*   	db 23,1,1
0416BE             0014*   @end:
0416BE             0015*   
0416BE             0016*   vdu_cursor_off:
0416BE 21 C9 16 04 0017*   	ld hl,@cmd
0416C2 01 03 00 00 0018*   	ld bc,@end-@cmd
0416C6 5B DF       0019*   	rst.lil $18
0416C8 C9          0020*   	ret
0416C9             0021*   @cmd:
0416C9 17 01 00    0022*   	db 23,1,0
0416CC             0023*   @end:
0416CC             0024*   
0416CC             0025*   ; VDU 5: Write text at graphics cursor
0416CC             0026*   ; inputs: a is the character to write to the screen
0416CC             0027*   ; prerequisites: the graphics cursor at the intended position on screen
0416CC             0028*   ; outputs: see the name of the function
0416CC             0029*   ; destroys: a, hl, bc
0416CC             0030*   vdu_char_to_gfx_cursor:
0416CC 32 DC 16 04 0031*   	ld (@arg),a
0416D0 21 DB 16 04 0032*   	ld hl,@cmd
0416D4 01 02 00 00 0033*   	ld bc,@end-@cmd
0416D8 5B DF       0034*   	rst.lil $18
0416DA C9          0035*   	ret
0416DB 05          0036*   @cmd: db 5
0416DC 00          0037*   @arg: db 0
0416DD             0038*   @end:
0416DD             0039*   ; VDU 9: Move cursor forward one character
0416DD             0040*   vdu_cursor_forward:
0416DD 3E 09       0041*       ld a,9
0416DF 5B D7       0042*   	rst.lil $10
0416E1 C9          0043*   	ret
0416E2             0044*   
0416E2             0045*   ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
0416E2             0046*   ; inputs: c=x, b=y 8-bit unsigned integers
0416E2             0047*   vdu_move_cursor:
0416E2 ED 43 F3 16 0048*       ld (@x0),bc
       04          
0416E7 21 F2 16 04 0049*   	ld hl,@cmd
0416EB 01 03 00 00 0050*   	ld bc,@end-@cmd
0416EF 5B DF       0051*   	rst.lil $18
0416F1 C9          0052*   	ret
0416F2 1F          0053*   @cmd: 	db 31
0416F3 00          0054*   @x0:	db 0
0416F4 00          0055*   @y0: 	db 0
0416F5 00          0056*   @end: 	db 0 ; padding
0416F6             0057*   
0416F6             0058*   ; VDU 12: Clear text area (CLS)
0416F6             0059*   vdu_cls:
0416F6 3E 0C       0060*       ld a,12
0416F8 5B D7       0061*   	rst.lil $10
0416FA C9          0062*   	ret
0416FB             0063*   
0416FB             0064*   vdu_flip:
0416FB 21 06 17 04 0065*   	ld hl,@cmd
0416FF 01 03 00 00 0066*   	ld bc,@end-@cmd
041703 5B DF       0067*   	rst.lil $18
041705 C9          0068*   	ret
041706 17 00 C3    0069*   @cmd: db 23,0,0xC3
041709             0070*   @end:
041709             0071*   
041709             0072*   ; VDU 16: Clear graphics area (CLG)
041709             0073*   vdu_clg:
041709 3E 10       0074*       ld a,16
04170B 5B D7       0075*   	rst.lil $10
04170D C9          0076*   	ret
04170E             0077*   
04170E             0078*   ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
04170E             0079*   ; VDU 23, 7: Scrolling
04170E             0080*   ;     VDU 23, 7, extent, direction, speed: Scroll the screen
04170E             0081*   ; inputs: a, extent; l, direction; h; speed
04170E             0082*   vdu_scroll_down:
04170E 32 23 17 04 0083*   	ld (@extent),a
041712 22 24 17 04 0084*   	ld (@dir),hl ; implicitly populates @speed
041716 21 21 17 04 0085*   	ld hl,@cmd
04171A 01 05 00 00 0086*   	ld bc,@end-@cmd
04171E 5B DF       0087*   	rst.lil $18     ;; Sending command to VDP
041720 C9          0088*   	ret
041721 17 07       0089*   @cmd:       db 23,7
041723 00          0090*   @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
041724 00          0091*   @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
041725 00          0092*   @speed:     db 0x00 ; pixels
041726 00          0093*   @end:		db 0x00 ; padding
041727             0094*   
041727             0095*   ; COLOUR MODES
041727             0096*   ; Mode	Effect
041727             0097*   ; 0	Set on-screen pixel to target colour value
041727             0098*   ; 1	OR value with the on-screen pixel
041727             0099*   ; 2	AND value with the on-screen pixel
041727             0100*   ; 3	XOR value with the on-screen pixel
041727             0101*   ; 4	Invert the on-screen pixel
041727             0102*   ; 5	No operation
041727             0103*   ; 6	AND the inverse of the specified colour with the on-screen pixel
041727             0104*   ; 7	OR the inverse of the specified colour with the on-screen pixel
041727             0105*   
041727             0106*   ; VDU 17, colour: Define text colour (COLOUR)
041727             0107*   vdu_colour_text:
041727 32 37 17 04 0108*   	ld (@arg),a
04172B 21 36 17 04 0109*   	ld hl,@cmd
04172F 01 02 00 00 0110*   	ld bc,@end-@cmd
041733 5B DF       0111*   	rst.lil $18
041735 C9          0112*   	ret
041736 11          0113*   @cmd: db 17
041737 00          0114*   @arg: db 0
041738             0115*   @end:
041738             0116*   
041738             0117*   ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
041738             0118*   ; inputs: a=mode, c=colour (add 128 to set background colour)
041738             0119*   vdu_gcol:
041738 32 4D 17 04 0120*   	ld (@mode),a
04173C 79          0121*       ld a,c
04173D 32 4E 17 04 0122*       ld (@col),a
041741 21 4C 17 04 0123*   	ld hl,@cmd
041745 01 03 00 00 0124*   	ld bc,@end-@cmd
041749 5B DF       0125*   	rst.lil $18
04174B C9          0126*   	ret
04174C 12          0127*   @cmd:  db 18
04174D 00          0128*   @mode: db 0
04174E 00          0129*   @col:  db 0
04174F             0130*   @end:
04174F             0131*   
04174F             0132*   
04174F             0133*   ; VDU 28, left, bottom, right, top: Set text viewport **
04174F             0134*   ; MIND THE LITTLE-ENDIANESS
04174F             0135*   ; inputs: c=left,b=bottom,e=right,d=top
04174F             0136*   ; outputs; nothing
04174F             0137*   ; destroys: a might make it out alive
04174F             0138*   vdu_set_txt_viewport:
04174F ED 43 65 17 0139*       ld (@lb),bc
       04          
041754 ED 53 67 17 0140*   	ld (@rt),de
       04          
041759 21 64 17 04 0141*   	ld hl,@cmd
04175D 01 05 00 00 0142*   	ld bc,@end-@cmd
041761 5B DF       0143*   	rst.lil $18
041763 C9          0144*   	ret
041764 1C          0145*   @cmd:   db 28 ; set text viewport command
041765 00 00       0146*   @lb: 	dw 0x0000 ; set by bc
041767 00 00       0147*   @rt: 	dw 0x0000 ; set by de
041769 00          0148*   @end:   db 0x00	  ; padding
04176A             0149*   
04176A             0150*   ; Wait for VBLANK interrupt
04176A             0151*   vdu_vblank:
04176A DD E5       0152*       PUSH 	IX
04176C             0153*   	MOSCALL	mos_sysvars
04176C 3E 08       0001*M1 			LD	A, function
04176E 5B CF       0002*M1 			RST.LIL	08h
041770 DD 7E 00    0154*   	LD	A, (IX + sysvar_time + 0)
041773             0155*   @wait:
041773 DD BE 00    0156*       CP 	A, (IX + sysvar_time + 0)
041776 28 FB       0157*       JR	Z, @wait
041778 DD E1       0158*       POP	IX
04177A C9          0159*       RET
04177B             0160*   
04177B             0161*   ; VDU 29, x; y;: Set graphics origin
04177B             0162*   ; This command sets the graphics origin.
04177B             0163*   ; The origin is the point on the screen where the coordinates (0,0) are located.
04177B             0164*   ; inputs: bc=x0,de=y0
04177B             0165*   ; outputs; nothing
04177B             0166*   ; destroys: a might make it out alive
04177B             0167*   vdu_set_gfx_origin:
04177B ED 43 91 17 0168*       ld (@x0),bc
       04          
041780 ED 53 93 17 0169*       ld (@y0),de
       04          
041785 21 90 17 04 0170*       ld hl,@cmd
041789 01 05 00 00 0171*       ld bc,@end-@cmd
04178D 5B DF       0172*       rst.lil $18
04178F C9          0173*       ret
041790 1D          0174*   @cmd:   db 29 ; set graphics origin command
041791 00 00       0175*   @x0: 	dw 0x0000 ; set by bc
041793 00 00       0176*   @y0: 	dw 0x0000 ; set by de
041795 00          0177*   @end:   db 0x00	  ; padding
041796             0178*   
041796             0179*   ; VDU 24, left; bottom; right; top;: Set graphics viewport
041796             0180*   ; NOTE: the order of the y-coordinate parameters are inverted
041796             0181*   ; 	because we have turned off logical screen scaling
041796             0182*   ; NOTE: coordinates are relative to current gfx origin
041796             0183*   ; inputs: bc=x0,de=y0,ix=x1,iy=y1
041796             0184*   ; outputs; nothing
041796             0185*   ; destroys: a might make it out alive
041796             0186*   vdu_set_gfx_viewport:
041796 ED 43 B6 17 0187*       ld (@x0),bc
       04          
04179B FD 22 B8 17 0188*       ld (@y1),iy
       04          
0417A0 DD 22 BA 17 0189*   	ld (@x1),ix
       04          
0417A5 ED 53 BC 17 0190*   	ld (@y0),de
       04          
0417AA 21 B5 17 04 0191*   	ld hl,@cmd
0417AE 01 09 00 00 0192*   	ld bc,@end-@cmd
0417B2 5B DF       0193*   	rst.lil $18
0417B4 C9          0194*   	ret
0417B5 18          0195*   @cmd:   db 24 ; set graphics viewport command
0417B6 00 00       0196*   @x0: 	dw 0x0000 ; set by bc
0417B8 00 00       0197*   @y1: 	dw 0x0000 ; set by iy
0417BA 00 00       0198*   @x1: 	dw 0x0000 ; set by ix
0417BC 00 00       0199*   @y0: 	dw 0x0000 ; set by de
0417BE 00          0200*   @end:   db 0x00	  ; padding
0417BF             0201*   
0417BF             0202*   ; VDU 26: Reset graphics and text viewports
0417BF             0203*   vdu_reset_viewports:
0417BF 3E 1A       0204*       ld a,26
0417C1 5B D7       0205*       rst.lil $10
0417C3 C9          0206*       ret
0417C4             0207*   
0417C4             0208*   ; SCREEN MODES
0417C4             0209*   ; ===============================
0417C4             0210*   ; Mode  Horz  Vert  Cols  Refresh
0417C4             0211*   ; ---   ----  ----  ----  -------
0417C4             0212*   ; 11    320   240   2     60hz
0417C4             0213*   ; 139   320   240   2     60hz
0417C4             0214*   ; 23    512   384   2     60hz
0417C4             0215*   ; 151   512   384   2     60hz
0417C4             0216*   ; 6     640   240   2     60hz
0417C4             0217*   ; 134   640   240   2     60hz
0417C4             0218*   ; 2     640   480   2     60hz
0417C4             0219*   ; 130   640   480   2     60hz
0417C4             0220*   ; 17    800   600   2     60hz
0417C4             0221*   ; 145   800   600   2     60hz
0417C4             0222*   ; 18    1024  768   2     60hz
0417C4             0223*   ; 146   1024  768   2     60hz
0417C4             0224*   ; ---   ----  ----  ----  -------
0417C4             0225*   ; 10    320   240   4     60hz
0417C4             0226*   ; 138   320   240   4     60hz
0417C4             0227*   ; 22    512   384   4     60hz
0417C4             0228*   ; 150   512   384   4     60hz
0417C4             0229*   ; 5     640   240   4     60hz
0417C4             0230*   ; 133   640   240   4     60hz
0417C4             0231*   ; 1     640   480   4     60hz
0417C4             0232*   ; 129   640   480   4     60hz
0417C4             0233*   ; 16    800   600   4     60hz
0417C4             0234*   ; 19    1024  768   4     60hz
0417C4             0235*   ; ---   ----  ----  ----  -------
0417C4             0236*   ; 9     320   240   16    60hz
0417C4             0237*   ; 137   320   240   16    60hz
0417C4             0238*   ; 21    512   384   16    60hz
0417C4             0239*   ; 149   512   384   16    60hz
0417C4             0240*   ; 4     640   240   16    60hz
0417C4             0241*   ; 132   640   240   16    60hz
0417C4             0242*   ; 0     640   480   16    60hz
0417C4             0243*   ; 7     n/a   n/a   16    60hz
0417C4             0244*   ; ---   ----  ----  ----  -------
0417C4             0245*   ; 8     320   240   64    60hz
0417C4             0246*   ; 136   320   240   64    60hz
0417C4             0247*   ; 20    512   384   64    60hz
0417C4             0248*   ; 3     640   240   64    60hz
0417C4             0249*   ; ---   ----  ----  ----  -------
0417C4             0250*   vdu_set_screen_mode:
0417C4 32 D4 17 04 0251*   	ld (@arg),a
0417C8 21 D3 17 04 0252*   	ld hl,@cmd
0417CC 01 02 00 00 0253*   	ld bc,@end-@cmd
0417D0 5B DF       0254*   	rst.lil $18
0417D2 C9          0255*   	ret
0417D3 16          0256*   @cmd: db 22 ; set screen mode
0417D4 00          0257*   @arg: db 0  ; screen mode parameter
0417D5             0258*   @end:
0417D5             0259*   
0417D5             0260*   ; get the current screen mode
0417D5             0261*   ; inputs: none
0417D5             0262*   ; outputs: a=screen mode
0417D5             0263*   ; destroys: af, ix
0417D5             0264*   vdu_get_screen_mode:
0417D5             0265*       MOSCALL mos_sysvars
0417D5 3E 08       0001*M1 			LD	A, function
0417D7 5B CF       0002*M1 			RST.LIL	08h
0417D9 DD 7E 27    0266*       ld a,(IX+sysvar_scrMode)
0417DC C9          0267*       ret
0417DD             0268*   ; end vdu_get_screen_mode
0417DD             0269*   
0417DD             0270*   ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
0417DD             0271*   ; inputs: a is scaling mode, 1=on, 0=off
0417DD             0272*   ; note: default setting on boot is scaling ON
0417DD             0273*   vdu_set_scaling:
0417DD 32 EF 17 04 0274*   	ld (@arg),a
0417E1 21 EC 17 04 0275*   	ld hl,@cmd
0417E5 01 04 00 00 0276*   	ld bc,@end-@cmd
0417E9 5B DF       0277*   	rst.lil $18
0417EB C9          0278*   	ret
0417EC 17 00 C0    0279*   @cmd: db 23,0,0xC0
0417EF 00          0280*   @arg: db 0  ; scaling on/off
0417F0             0281*   @end:
0417F0             0282*   
0417F0             0283*   ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
0417F0             0284*   ; inputs: hl=bufferId
0417F0             0285*   vdu_buff_select:
0417F0 22 02 18 04 0286*   	ld (@bufferId),hl
0417F4 21 FF 17 04 0287*   	ld hl,@cmd
0417F8 01 05 00 00 0288*   	ld bc,@end-@cmd
0417FC 5B DF       0289*   	rst.lil $18
0417FE C9          0290*   	ret
0417FF 17 1B 20    0291*   @cmd: db 23,27,0x20
041802 00 00       0292*   @bufferId: dw 0x0000
041804 00          0293*   @end: db 0x00 ; padding
041805             0294*   
041805             0295*   ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
041805             0296*   ; inputs: a=format; bc=width; de=height
041805             0297*   ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
041805             0298*   ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
041805             0299*   ; 0 	RGBA8888 (4-bytes per pixel)
041805             0300*   ; 1 	RGBA2222 (1-bytes per pixel)
041805             0301*   ; 2 	Mono/Mask (1-bit per pixel)
041805             0302*   ; 3 	Reserved for internal use by VDP (â€œnativeâ€ format)
041805             0303*   vdu_bmp_create:
041805 ED 43 21 18 0304*       ld (@width),bc
       04          
04180A ED 53 23 18 0305*       ld (@height),de
       04          
04180F 32 25 18 04 0306*       ld (@fmt),a
041813 21 1E 18 04 0307*   	ld hl,@cmd
041817 01 08 00 00 0308*   	ld bc,@end-@cmd
04181B 5B DF       0309*   	rst.lil $18
04181D C9          0310*   	ret
04181E 17 1B 21    0311*   @cmd:       db 23,27,0x21
041821 00 00       0312*   @width:     dw 0x0000
041823 00 00       0313*   @height:    dw 0x0000
041825 00          0314*   @fmt:       db 0x00
041826             0315*   @end:
041826             0316*   
041826             0317*   ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
041826             0318*   ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
041826             0319*   vdu_load_img_rgba2_to_8:
041826             0320*   ; backup the target buffer id and image dimensions
041826 E5          0321*       push hl
041827 D5          0322*       push de
041828 C5          0323*       push bc
041829             0324*   ; load the rgba2 image to working buffer 65534
041829 21 FE FF 00 0325*       ld hl,65534 ; temporary working buffer id
04182D CD 04 19 04 0326*   	call vdu_load_buffer_from_file
041831             0327*   ; restore the image dimensions and target buffer id
041831 C1          0328*       pop bc
041832 D1          0329*       pop de
041833 E1          0330*       pop hl
041834             0331*   ; fall through to vdu_rgba2_to_8
041834             0332*   
041834             0333*   ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
041834             0334*   ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
041834             0335*   ; the "expand bitmap" command is:
041834             0336*   ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
041834             0337*   ; and then to reverse the byte order to fix endian-ness:
041834             0338*   ; VDU 23,0,&A0,targetBufferID%;24,4,4;
041834             0339*   ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
041834             0340*   ; VDU 23,27,&20,targetBufferID%;
041834             0341*   ; VDU 23,27,&21,width%;height%;0
041834             0342*   ; -------------------------------------------------------------------
041834             0343*   ; inputs: bc,de image width,height ; hl = targetBufferId
041834             0344*   ; prerequisites: rgba2 image data loaded into workingBufferId 65534
041834             0345*   vdu_rgba2_to_8:
041834             0346*   ; load the image dimensions and buffer id parameters
041834 ED 43 90 18 0347*       ld (@width),bc
       04          
041839 ED 53 92 18 0348*       ld (@height),de
       04          
04183E 22 75 18 04 0349*       ld (@bufferId0),hl
041842 22 82 18 04 0350*       ld (@bufferId2),hl
041846 22 8B 18 04 0351*       ld (@bufferId1),hl
04184A             0352*   ; clean up bytes that got stomped on by the ID loads
04184A 3E 48       0353*       ld a,0x48
04184C 32 77 18 04 0354*       ld (@bufferId0+2),a
041850 3E 17       0355*       ld a,23
041852 32 8D 18 04 0356*       ld (@bufferId1+2),a
041856 3E 18       0357*       ld a,24
041858 32 84 18 04 0358*       ld (@bufferId2+2),a
04185C AF          0359*       xor a
04185D 32 94 18 04 0360*       ld (@height+2),a
041861             0361*   ; send the vdu command strings
041861 21 6C 18 04 0362*       ld hl,@beg
041865 01 29 00 00 0363*       ld bc,@end-@beg
041869 5B DF       0364*       rst.lil $18
04186B C9          0365*       ret
04186C             0366*   @beg:
04186C             0367*   ; Command 14: Consolidate blocks in a buffer
04186C             0368*   ; VDU 23, 0, &A0, bufferId; 14
04186C 17 00 A0    0369*       db 23,0,0xA0
04186F FE FF       0370*       dw 65534 ; workingBufferId
041871 0E          0371*       db 14 ; consolidate blocks
041872             0372*   ; the "expand bitmap" command is:
041872             0373*   ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
041872 17 00 A0    0374*       db 23,0,0xA0
041875 00 00       0375*   @bufferId0: dw 0x0000 ; targetBufferId
041877 48          0376*       db 0x48 ; given as decimal command 72 in the docs
041878 02          0377*       db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
041879 FE FF       0378*       dw 65534 ; sourceBufferId
04187B 00 7F BF FF 0379*       db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
04187F             0380*   ; reverse the byte order to fix endian-ness:
04187F             0381*   ; Command 24: Reverse the order of data of blocks within a buffer
04187F             0382*   ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
04187F             0383*   ; VDU 23,0,&A0,targetBufferID%;24,4,4;
04187F 17 00 A0    0384*       db 23,0,0xA0
041882 00 00       0385*   @bufferId2:    dw 0x0000 ; targetBufferId
041884 18          0386*       db 24 ; reverse byte order
041885 04          0387*       db 4 ; option: Reverse data of the value size within chunk of data of the specified size
041886 04 00       0388*       dw 4 ; size (4 bytes)
041888             0389*   ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
041888             0390*   ; VDU 23,27,&20,targetBufferID%;
041888 17 1B 20    0391*       db 23,27,0x20 ; select bitmap
04188B 00 00       0392*   @bufferId1: dw 0x0000 ; targetBufferId
04188D             0393*   ; VDU 23,27,&21,width%;height%;0
04188D 17 1B 21    0394*       db 23,27,0x21 ; create bitmap from buffer
041890 00 00       0395*   @width: dw 0x0000
041892 00 00       0396*   @height: dw 0x0000
041894 00          0397*       db 0x00 ; rgba8888 format
041895             0398*   @end:
041895             0399*   
041895             0400*   ; scratch variables
041895 00 00 00    0401*   bufferId0: dl 0x000000
041898 00 00 00    0402*   bufferId1: dl 0x000000
04189B             0403*   
04189B             0404*   ; load a vdu buffer from local memory
04189B             0405*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
04189B             0406*   vdu_load_buffer:
04189B ED 43 C4 18 0407*       ld (@length),bc
       04          
0418A0 D5          0408*       push de ; save data pointer
0418A1             0409*   ; send the vdu command string
0418A1 7D          0410*       ld a,l
0418A2 32 C1 18 04 0411*       ld (@bufferId),a
0418A6 7C          0412*       ld a,h
0418A7 32 C2 18 04 0413*       ld (@bufferId+1),a
0418AB 21 BE 18 04 0414*       ld hl,@cmd
0418AF 01 08 00 00 0415*       ld bc,@end-@cmd
0418B3 5B DF       0416*       rst.lil $18
0418B5             0417*   ; send the buffer data
0418B5 E1          0418*       pop hl ; pointer to data
0418B6 ED 4B C4 18 0419*       ld bc,(@length)
       04          
0418BB 5B DF       0420*       rst.lil $18 ; send it
0418BD C9          0421*       ret
0418BE             0422*   ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0418BE 17 00 A0    0423*   @cmd:       db 23,0,0xA0
0418C1 00 00       0424*   @bufferId:	dw 0x0000
0418C3 00          0425*   		    db 0 ; load buffer
0418C4 00 00       0426*   @length:	dw 0x0000
0418C6 00          0427*   @end: db 0 ; padding
0418C7             0428*   
0418C7             0429*   ; Command 14: Consolidate blocks in a buffer
0418C7             0430*   vdu_consolidate_buffer:
0418C7             0431*   ; set parameters for vdu call
0418C7 7D          0432*       ld a,l
0418C8 32 DF 18 04 0433*       ld (@bufferId),a
0418CC 7C          0434*       ld a,h
0418CD 32 E0 18 04 0435*       ld (@bufferId+1),a
0418D1 21 DC 18 04 0436*       ld hl,@beg
0418D5 01 06 00 00 0437*       ld bc,@end-@beg
0418D9 5B DF       0438*       rst.lil $18
0418DB C9          0439*       ret
0418DC             0440*   ; VDU 23, 0, &A0, bufferId; 14
0418DC 17 00 A0    0441*   @beg: db 23,0,0xA0
0418DF 00 00       0442*   @bufferId: dw 0x0000
0418E1 0E          0443*              db 14
0418E2             0444*   @end:
0418E2             0445*   
0418E2             0446*   ; load an image file to a buffer and make it a bitmap
0418E2             0447*   ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
0418E2             0448*   vdu_load_img:
0418E2             0449*   ; back up image type and dimension parameters
0418E2 22 95 18 04 0450*       ld (bufferId0),hl
0418E6 F5          0451*       push af
0418E7 C5          0452*   	push bc
0418E8 D5          0453*   	push de
0418E9             0454*   ; load the image
0418E9 CD 04 19 04 0455*   	call vdu_load_buffer_from_file
0418ED             0456*   ; now make it a bitmap
0418ED 2A 95 18 04 0457*       ld hl,(bufferId0)
0418F1 CD C7 18 04 0458*       call vdu_consolidate_buffer
0418F5 2A 95 18 04 0459*       ld hl,(bufferId0)
0418F9 CD F0 17 04 0460*       call vdu_buff_select
0418FD D1          0461*   	pop de ; image height
0418FE C1          0462*   	pop bc ; image width
0418FF F1          0463*   	pop af ; image type
041900 C3 05 18 04 0464*   	jp vdu_bmp_create ; will return to caller from there
041904             0465*   
041904             0466*   ; inputs: hl = bufferId; iy = pointer to filename
041904             0467*   vdu_load_buffer_from_file:
041904 22 95 18 04 0468*       ld (bufferId0),hl
041908             0469*   
041908             0470*   ; clear target buffer
041908 CD B0 1A 04 0471*       call vdu_clear_buffer
04190C             0472*   
04190C             0473*   ; open the file in read mode
04190C             0474*   ; Open a file
04190C             0475*   ; HLU: Filename
04190C             0476*   ;   C: Mode
04190C             0477*   ; Returns:
04190C             0478*   ;   A: Filehandle, or 0 if couldn't open
04190C FD E5       0479*   	push iy ; pointer to filename
04190E E1          0480*   	pop hl
04190F 0E 01       0481*   	ld c,fa_read
041911             0482*       MOSCALL mos_fopen
041911 3E 0A       0001*M1 			LD	A, function
041913 5B CF       0002*M1 			RST.LIL	08h
041915 32 50 19 04 0483*       ld (@filehandle),a
041919             0484*   
041919             0485*   @read_file:
041919             0486*   ; Read a block of data from a file
041919             0487*   ;   C: Filehandle
041919             0488*   ; HLU: Pointer to where to write the data to
041919             0489*   ; DEU: Number of bytes to read
041919             0490*   ; Returns:
041919             0491*   ; DEU: Number of bytes read
041919 3A 50 19 04 0492*       ld a,(@filehandle)
04191D 4F          0493*       ld c,a
04191E 21 00 E0 B7 0494*       ld hl,filedata
041922 11 00 20 00 0495*       ld de,8192 ; max we can read into onboard sram at one time
041926             0496*       MOSCALL mos_fread
041926 3E 1A       0001*M1 			LD	A, function
041928 5B CF       0002*M1 			RST.LIL	08h
04192A             0497*   
04192A             0498*   ; test de for zero bytes read
04192A 21 00 00 00 0499*       ld hl,0
04192E AF          0500*       xor a ; clear carry
04192F ED 52       0501*       sbc hl,de
041931 CA 47 19 04 0502*       jp z,@close_file
041935             0503*   
041935             0504*   ; load a vdu buffer from local memory
041935             0505*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
041935 2A 95 18 04 0506*       ld hl,(bufferId0)
041939 D5          0507*       push de ; chunksize
04193A C1          0508*       pop bc
04193B 11 00 E0 B7 0509*       ld de,filedata
04193F CD 9B 18 04 0510*       call vdu_load_buffer
041943             0511*   
041943             0512*   ; read the next block
041943 C3 19 19 04 0513*       jp @read_file
041947             0514*   
041947             0515*   ; close the file
041947             0516*   @close_file:
041947 3A 50 19 04 0517*       ld a,(@filehandle)
04194B             0518*       MOSCALL mos_fclose
04194B 3E 0B       0001*M1 			LD	A, function
04194D 5B CF       0002*M1 			RST.LIL	08h
04194F C9          0519*       ret ; vdu_load_buffer_from_file
041950             0520*   
041950 00          0521*   @filehandle: db 0 ; file handle
041951 00 00 00    0522*   @fil: dl 0 ; pointer to FIL struct
041954             0523*   
041954 00 00 00    0524*   @chunkpointer: dl 0 ; pointer to current chunk
041957             0525*   
041957             0526*   ; File information structure (FILINFO)
041957             0527*   @filinfo:
041957 00 00 00 00 0528*   @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
04195B 00 00       0529*   @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
04195D 00 00       0530*   @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
04195F 00          0531*   @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
041960 00 00 00 00 0532*   @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
04196D 00 00 00 00 0533*   @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041A6D             0040        include "vdu_buffered_api.inc"
041A6D             0001*   ; https://agonconsole8.github.io/agon-docs/vdp/Buffered-Commands-API/
041A6D             0002*   
041A6D             0003*   ; Command 0: Write block to a buffer
041A6D             0004*   ; VDU 23, 0, &A0, bufferId; 0, length; <buffer-data>
041A6D             0005*   ; inputs: hl = bufferId, bc = length of data, de = pointer to data
041A6D             0006*   vdu_write_block_to_buffer:
041A6D             0007*   ; back up input parameters
041A6D D5          0008*       push de ; pointer to data
041A6E C5          0009*       push bc ; length of data
041A6F             0010*   ; set up the vdu command string
041A6F 22 8F 1A 04 0011*       ld (@bufferId),hl
041A73 ED 43 92 1A 0012*       ld (@length),bc
       04          
041A78 AF          0013*       xor a ; load buffer
041A79 32 91 1A 04 0014*       ld (@bufferId+2),a
041A7D 21 8C 1A 04 0015*       ld hl,@cmd0
041A81 01 08 00 00 0016*       ld bc,@end0-@cmd0
041A85 5B DF       0017*       rst.lil $18
041A87             0018*   ; send the buffer data
041A87 C1          0019*       pop bc ; length of data
041A88 E1          0020*       pop hl ; pointer to data (was de)
041A89 5B DF       0021*       rst.lil $18 ; send it
041A8B C9          0022*       ret
041A8C             0023*   ; command string data
041A8C 17 00 A0    0024*   @cmd0:      db 23,0,0xA0
041A8F 00 00       0025*   @bufferId:	dw 0x0000
041A91 00          0026*               db 0 ; load buffer
041A92 00 00       0027*   @length:	dw 0x0000
041A94 00          0028*   @end0:      db 0x00 ; padding
041A95             0029*   ; end vdu_write_block_to_buffer
041A95             0030*   
041A95             0031*   ; Command 1: Call a buffer
041A95             0032*   ; VDU 23, 0, &A0, bufferId; 1
041A95             0033*   ; inputs: hl = bufferId
041A95             0034*   vdu_call_buffer:
041A95 22 AD 1A 04 0035*       ld (@bufferId),hl
041A99 3E 01       0036*       ld a,1 ; call buffer
041A9B 32 AF 1A 04 0037*       ld (@bufferId+2),a
041A9F 21 AA 1A 04 0038*       ld hl,@cmd
041AA3 01 06 00 00 0039*       ld bc,@end-@cmd
041AA7 5B DF       0040*       rst.lil $18
041AA9 C9          0041*       ret
041AAA 17 00 A0    0042*   @cmd:     db 23,0,0xA0
041AAD 00 00       0043*   @bufferId: dw 0x0000
041AAF 01          0044*              db 1 ; call buffer
041AB0             0045*   @end:
041AB0             0046*   ; end vdu_call_buffer
041AB0             0047*   
041AB0             0048*   ; Command 2: Clear a buffer
041AB0             0049*   ; VDU 23, 0 &A0, bufferId; 2
041AB0             0050*   ; inputs: hl = bufferId
041AB0             0051*   vdu_clear_buffer:
041AB0 22 C8 1A 04 0052*       ld (@bufferId),hl
041AB4 3E 02       0053*       ld a,2 ; clear buffer
041AB6 32 CA 1A 04 0054*       ld (@bufferId+2),a
041ABA 21 C5 1A 04 0055*       ld hl,@cmd
041ABE 01 06 00 00 0056*       ld bc,@end-@cmd
041AC2 5B DF       0057*       rst.lil $18
041AC4 C9          0058*       ret
041AC5 17 00 A0    0059*   @cmd:     db 23,0,0xA0
041AC8 00 00       0060*   @bufferId: dw 0x0000
041ACA 02          0061*              db 2 ; clear buffer
041ACB             0062*   @end:
041ACB             0063*   ; end vdu_clear_buffer
041ACB             0064*   
041ACB             0065*   ; Clear all buffers
041ACB             0066*   ; inputs: none
041ACB             0067*   vdu_clear_all_buffers:
041ACB             0068*   ; clear all buffers
041ACB 21 D6 1A 04 0069*       ld hl,@beg
041ACF 01 06 00 00 0070*       ld bc,@end-@beg
041AD3 5B DF       0071*       rst.lil $18
041AD5 C9          0072*       ret
041AD6 17 00 A0    0073*   @beg: db 23,0,$A0
041AD9 FF FF       0074*         dw -1 ; bufferId -1 (65535) means clear all buffers
041ADB 02          0075*         db 2  ; command 2: clear a buffer
041ADC             0076*   @end:
041ADC             0077*   ; end vdu_clear_all_buffers
041ADC             0078*   
041ADC             0079*   ; Command 3: Create a writeable buffer
041ADC             0080*   ; VDU 23, 0 &A0, bufferId; 3, length;
041ADC             0081*   ; inputs: hl = bufferId, bc = length
041ADC             0082*   vdu_create_writeable_buffer:
041ADC 22 F9 1A 04 0083*       ld (@bufferId),hl
041AE0 ED 43 FC 1A 0084*       ld (@length),bc
       04          
041AE5 3E 03       0085*       ld a,3 ; create writeable buffer
041AE7 32 FB 1A 04 0086*       ld (@bufferId+2),a
041AEB 21 F6 1A 04 0087*       ld hl,@cmd
041AEF 01 08 00 00 0088*       ld bc,@end-@cmd
041AF3 5B DF       0089*       rst.lil $18
041AF5 C9          0090*       ret
041AF6 17 00 A0    0091*   @cmd:     db 23,0,0xA0
041AF9 00 00       0092*   @bufferId: dw 0x0000
041AFB 03          0093*              db 3 ; create writeable buffer
041AFC 00 00       0094*   @length: dw 0x0000
041AFE 00          0095*   @end:     db 0x00 ; padding
041AFF             0096*   ; end vdu_create_writeable_buffer
041AFF             0097*   
041AFF             0098*   ; Command 4: Set output stream to a buffer
041AFF             0099*   ; VDU 23, 0 &A0, bufferId; 4
041AFF             0100*   ; inputs: hl = bufferId
041AFF             0101*   vdu_set_output_stream_buffer:
041AFF 22 17 1B 04 0102*       ld (@bufferId),hl
041B03 3E 04       0103*       ld a,4 ; set output stream to buffer
041B05 32 19 1B 04 0104*       ld (@bufferId+2),a
041B09 21 14 1B 04 0105*       ld hl,@cmd
041B0D 01 06 00 00 0106*       ld bc,@end-@cmd
041B11 5B DF       0107*       rst.lil $18
041B13 C9          0108*       ret
041B14 17 00 A0    0109*   @cmd:     db 23,0,0xA0
041B17 00 00       0110*   @bufferId: dw 0x0000
041B19 04          0111*              db 4 ; set output stream to buffer
041B1A 00          0112*   @end:     db 0x00 ; padding
041B1B             0113*   ; end vdu_set_output_stream_buffer
041B1B             0114*   
041B1B             0115*   ; Command 5: Adjust buffer contents
041B1B             0116*   ; VDU 23, 0, &A0, bufferId; 5, operation, offset; [count;] <operand>, [arguments]
041B1B             0117*   vdu_adjust_buffer:
041B1B C9          0118*       ret ; TODO: implement
041B1C             0119*   ; end vdu_adjust_buffer
041B1C             0120*   
041B1C             0121*   ; Command 6: Conditionally call a buffer
041B1C             0122*   ; VDU 23, 0, &A0, bufferId; 6, operation, checkBufferId; checkOffset; [arguments]
041B1C             0123*   vdu_call_buffer_conditional:
041B1C C9          0124*       ret ; TODO: implement
041B1D             0125*   ; end vdu_call_buffer_conditional
041B1D             0126*   
041B1D             0127*   ; Command 7: Jump to a buffer
041B1D             0128*   ; VDU 23, 0, &A0, bufferId; 7
041B1D             0129*   ; inputs: hl = bufferId
041B1D             0130*   vdu_jump_to_buffer:
041B1D 22 35 1B 04 0131*       ld (@bufferId),hl
041B21 3E 07       0132*       ld a,7 ; jump to buffer
041B23 32 37 1B 04 0133*       ld (@bufferId+2),a
041B27 21 32 1B 04 0134*       ld hl,@cmd
041B2B 01 06 00 00 0135*       ld bc,@end-@cmd
041B2F 5B DF       0136*       rst.lil $18
041B31 C9          0137*       ret
041B32 17 00 A0    0138*   @cmd:     db 23,0,0xA0
041B35 00 00       0139*   @bufferId: dw 0x0000
041B37 07          0140*              db 7 ; jump to buffer
041B38 00          0141*   @end:     db 0x00 ; padding
041B39             0142*   ; end vdu_jump_to_buffer
041B39             0143*   
041B39             0144*   ; Command 8: Conditional Jump to a buffer
041B39             0145*   ; VDU 23, 0, &A0, bufferId; 8, operation, checkBufferId; checkOffset; [arguments]
041B39             0146*   vdu_jump_to_buffer_conditional:
041B39 C9          0147*       ret ; TODO: implement
041B3A             0148*   ; end vdu_jump_to_buffer_conditional
041B3A             0149*   
041B3A             0150*   ; Command 9: Jump to an offset in a buffer
041B3A             0151*   ; VDU 23, 0, &A0, bufferId; 9, offset; offsetHighByte, [blockNumber;]
041B3A             0152*   vdu_jump_to_buffer_offset:
041B3A C9          0153*       ret ; TODO: implement
041B3B             0154*   ; end vdu_jump_to_buffer_offset
041B3B             0155*   
041B3B             0156*   ; Command 10: Conditional jump to an offset in a buffer
041B3B             0157*   ; VDU 23, 0, &A0, bufferId; 10, offset; offsetHighByte, [blockNumber;] [arguments]
041B3B             0158*   vdu_jump_to_buffer_offset_conditional:
041B3B C9          0159*       ret ; TODO: implement
041B3C             0160*   ; end vdu_jump_to_buffer_offset_conditional
041B3C             0161*   
041B3C             0162*   ; Command 11: Call buffer with an offset
041B3C             0163*   ; VDU 23, 0, &A0, bufferId; 11, offset; offsetHighByte, [blockNumber;]
041B3C             0164*   vdu_call_buffer_offset:
041B3C C9          0165*       ret ; TODO: implement
041B3D             0166*   ; end vdu_call_buffer_offset
041B3D             0167*   
041B3D             0041        include "vdu_fonts.inc"
041B3D             0001*   ; select font
041B3D             0002*   ; inputs: hl = bufferId, a = font flags
041B3D             0003*   ; Flags:
041B3D             0004*   ; Bit	Description
041B3D             0005*   ; 0	Adjust cursor position to ensure text baseline is aligned
041B3D             0006*   ;   0: Do not adjust cursor position (best for changing font on a new line)
041B3D             0007*   ;   1: Adjust cursor position (best for changing font in the middle of a line)
041B3D             0008*   ; 1-7	Reserved for future use
041B3D             0009*   ; VDU 23, 0, &95, 0, bufferId; flags: Select font
041B3D             0010*   vdu_font_select:
041B3D 22 54 1B 04 0011*       ld (@bufferId),hl
041B41 32 56 1B 04 0012*       ld (@flags),a
041B45 21 50 1B 04 0013*       ld hl,@cmd
041B49 01 07 00 00 0014*       ld bc,@end-@cmd
041B4D 5B DF       0015*       rst.lil $18
041B4F C9          0016*       ret
041B50 17 00 95 00 0017*   @cmd: db 23, 0, 0x95, 0
041B54 00 00       0018*   @bufferId: dw 0x0000
041B56 00          0019*   @flags: db 0x00
041B57             0020*   @end:
041B57             0021*   
041B57             0022*   ; create font from buffer
041B57             0023*   ; inputs: hl = bufferId, e = width, d = height, d = ascent, a = flags
041B57             0024*   ; VDU 23, 0, &95, 1, bufferId; width, height, ascent, flags: Create font from buffer
041B57             0025*   vdu_font_create:
041B57 22 7C 1B 04 0026*       ld (@bufferId),hl
041B5B ED 53 7E 1B 0027*       ld (@width),de ; also loads height
       04          
041B60 32 81 1B 04 0028*       ld (@flags),a
041B64 7A          0029*       ld a,d ; height
041B65 32 80 1B 04 0030*       ld (@ascent),a ; ascent = height
041B69             0031*   ; consolidate buffer
041B69 CD C7 18 04 0032*       call vdu_consolidate_buffer
041B6D             0033*   ; create font
041B6D 21 78 1B 04 0034*       ld hl,@cmd
041B71 01 0A 00 00 0035*       ld bc,@end-@cmd
041B75 5B DF       0036*       rst.lil $18
041B77 C9          0037*       ret
041B78 17 00 95 01 0038*   @cmd: db 23, 0, 0x95, 1
041B7C 00 00       0039*   @bufferId: dw 0x0000
041B7E 00          0040*   @width: db 0x00
041B7F 00          0041*   @height: db 0x00
041B80 00          0042*   @ascent: db 0x00
041B81 00          0043*   @flags: db 0x00
041B82             0044*   @end:
041B82             0045*   
041B82             0046*   ; set or adjust font property
041B82             0047*   ; inputs: hl = bufferId, a = field, de = value
041B82             0048*   ; VDU 23, 0, &95, 2, bufferId; field, value;: Set or adjust font property
041B82             0049*   vdu_font_property:
041B82 22 9E 1B 04 0050*       ld (@bufferId),hl
041B86 32 A0 1B 04 0051*       ld (@field),a
041B8A ED 53 A1 1B 0052*       ld (@value),de
       04          
041B8F 21 9A 1B 04 0053*       ld hl,@cmd
041B93 01 09 00 00 0054*       ld bc,@end-@cmd
041B97 5B DF       0055*       rst.lil $18
041B99 C9          0056*       ret
041B9A 17 00 95 02 0057*   @cmd: db 23, 0, 0x95, 2
041B9E 00 00       0058*   @bufferId: dw 0x0000
041BA0 00          0059*   @field: db 0x00
041BA1 00 00       0060*   @value: dw 0x0000
041BA3 00          0061*   @end: db 0x00 ; padding
041BA4             0062*   
041BA4             0063*   ; VDU 23, 0, &95, 3, bufferId; [<args>]: Reserved
041BA4             0064*   
041BA4             0065*   ; Clear/Delete font
041BA4             0066*   ; inputs: hl = bufferId
041BA4             0067*   ; VDU 23, 0, &95, 4, bufferId;: Clear/Delete font
041BA4             0068*   vdu_font_clear:
041BA4 22 B7 1B 04 0069*       ld (@bufferId),hl
041BA8 21 B3 1B 04 0070*       ld hl,@cmd
041BAC 01 06 00 00 0071*       ld bc,@end-@cmd
041BB0 5B DF       0072*       rst.lil $18
041BB2 C9          0073*       ret
041BB3 17 00 95 04 0074*   @cmd: db 23, 0, 0x95, 4
041BB7 00 00       0075*   @bufferId: dw 0x0000
041BB9 00          0076*   @end: db 0x00 ; padding
041BBA             0077*   
041BBA             0078*   ; Copy system font to buffer
041BBA             0079*   ; inputs: hl = bufferId
041BBA             0080*   ; VDU 23, 0, &95, 5, bufferId;: Copy system font to buffer
041BBA             0081*   vdu_font_copy_system:
041BBA 22 CD 1B 04 0082*       ld (@bufferId),hl
041BBE 21 C9 1B 04 0083*       ld hl,@cmd
041BC2 01 06 00 00 0084*       ld bc,@end-@cmd
041BC6 5B DF       0085*       rst.lil $18
041BC8 C9          0086*       ret
041BC9 17 00 95 05 0087*   @cmd: db 23, 0, 0x95, 5
041BCD 00 00       0088*   @bufferId: dw 0x0000
041BCF 00          0089*   @end: db 0x00 ; padding
041BD0             0042        include "vdu_plot.inc"
041BD0             0001*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
041BD0             0002*   ; PLOT code 	(Decimal) 	Effect
041BD0             0003*   ; &00-&07 	0-7 	Solid line, includes both ends
041BD0             0004*   plot_sl_both: equ 0x00
041BD0             0005*   
041BD0             0006*   ; &08-&0F 	8-15 	Solid line, final point omitted
041BD0             0007*   plot_sl_first: equ 0x08
041BD0             0008*   
041BD0             0009*   ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
041BD0             0010*   ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
041BD0             0011*   
041BD0             0012*   ; &20-&27 	32-39 	Solid line, first point omitted
041BD0             0013*   plot_sl_last: equ 0x20
041BD0             0014*   
041BD0             0015*   ; &28-&2F 	40-47 	Solid line, both points omitted
041BD0             0016*   plot_sl_none: equ 0x28
041BD0             0017*   
041BD0             0018*   ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
041BD0             0019*   ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
041BD0             0020*   
041BD0             0021*   ; &40-&47 	64-71 	Point plot
041BD0             0022*   plot_pt: equ 0x40
041BD0             0023*   
041BD0             0024*   ; &48-&4F 	72-79 	Line fill left and right to non-background Â§Â§
041BD0             0025*   plot_lf_lr_non_bg: equ 0x48
041BD0             0026*   
041BD0             0027*   ; &50-&57 	80-87 	Triangle fill
041BD0             0028*   plot_tf: equ 0x50
041BD0             0029*   
041BD0             0030*   ; &58-&5F 	88-95 	Line fill right to background Â§Â§
041BD0             0031*   plot_lf_r_bg: equ 0x58
041BD0             0032*   
041BD0             0033*   ; &60-&67 	96-103 	Rectangle fill
041BD0             0034*   plot_rf: equ 0x60
041BD0             0035*   
041BD0             0036*   ; &68-&6F 	104-111 	Line fill left and right to foreground Â§Â§
041BD0             0037*   plot_lf_lr_fg: equ 0x60
041BD0             0038*   
041BD0             0039*   ; &70-&77 	112-119 	Parallelogram fill
041BD0             0040*   plot_pf: equ 0x70
041BD0             0041*   
041BD0             0042*   ; &78-&7F 	120-127 	Line fill right to non-foreground Â§Â§
041BD0             0043*   plot_lf_r_non_fg: equ 0x78
041BD0             0044*   
041BD0             0045*   ; &80-&87 	128-135 	Not supported (Flood until non-background)
041BD0             0046*   ; &88-&8F 	136-143 	Not supported (Flood until foreground)
041BD0             0047*   
041BD0             0048*   ; &90-&97 	144-151 	Circle outline
041BD0             0049*   plot_co: equ 0x90
041BD0             0050*   
041BD0             0051*   ; &98-&9F 	152-159 	Circle fill
041BD0             0052*   plot_cf: equ 0x98
041BD0             0053*   
041BD0             0054*   ; &A0-&A7 	160-167 	Not supported (Circular arc)
041BD0             0055*   ; &A8-&AF 	168-175 	Not supported (Circular segment)
041BD0             0056*   ; &B0-&B7 	176-183 	Not supported (Circular sector)
041BD0             0057*   
041BD0             0058*   ; &B8-&BF 	184-191 	Rectangle copy/move
041BD0             0059*   plot_rcm: equ 0xB8
041BD0             0060*   
041BD0             0061*   ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
041BD0             0062*   ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
041BD0             0063*   ; &D0-&D7 	208-215 	Not defined
041BD0             0064*   ; &D8-&DF 	216-223 	Not defined
041BD0             0065*   ; &E0-&E7 	224-231 	Not defined
041BD0             0066*   
041BD0             0067*   ; &E8-&EF 	232-239 	Bitmap plot Â§
041BD0             0068*   plot_bmp: equ 0xE8
041BD0             0069*   
041BD0             0070*   ; &F0-&F7 	240-247 	Not defined
041BD0             0071*   ; &F8-&FF 	248-255 	Not defined
041BD0             0072*   
041BD0             0073*   ; Â§ Support added in Agon Console8 VDP 2.1.0 Â§Â§ Support added in
041BD0             0074*   ; Agon Console8 VDP 2.2.0
041BD0             0075*   
041BD0             0076*   ; Within each group of eight plot codes, the effects are as follows:
041BD0             0077*   ; Plot code 	Effect
041BD0             0078*   ; 0 	Move relative
041BD0             0079*   mv_rel: equ 0
041BD0             0080*   
041BD0             0081*   ; 1 	Plot relative in current foreground colour
041BD0             0082*   dr_rel_fg: equ 1
041BD0             0083*   
041BD0             0084*   ; 2 	Not supported (Plot relative in logical inverse colour)
041BD0             0085*   ; 3 	Plot relative in current background colour
041BD0             0086*   dr_rel_bg: equ 3
041BD0             0087*   
041BD0             0088*   ; 4 	Move absolute
041BD0             0089*   mv_abs: equ 4
041BD0             0090*   
041BD0             0091*   ; 5 	Plot absolute in current foreground colour
041BD0             0092*   dr_abs_fg: equ 5
041BD0             0093*   
041BD0             0094*   ; 6 	Not supported (Plot absolute in logical inverse colour)
041BD0             0095*   ; 7 	Plot absolute in current background colour
041BD0             0096*   dr_abs_bg: equ 7
041BD0             0097*   
041BD0             0098*   ; Codes 0-3 use the position data provided as part of the command
041BD0             0099*   ; as a relative position, adding the position given to the current
041BD0             0100*   ; graphical cursor position. Codes 4-7 use the position data provided
041BD0             0101*   ; as part of the command as an absolute position, setting the current
041BD0             0102*   ; graphical cursor position to the position given.
041BD0             0103*   
041BD0             0104*   ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
041BD0             0105*   ; current pixel colour. These operations cannot currently be supported
041BD0             0106*   ; by the graphics system the Agon VDP uses, so these codes are not
041BD0             0107*   ; supported. Support for these codes may be added in a future version
041BD0             0108*   ; of the VDP firmware.
041BD0             0109*   
041BD0             0110*   ; 16 colour palette constants
041BD0             0111*   c_black: equ 0
041BD0             0112*   c_red_dk: equ 1
041BD0             0113*   c_green_dk: equ 2
041BD0             0114*   c_yellow_dk: equ 3
041BD0             0115*   c_blue_dk: equ 4
041BD0             0116*   c_magenta_dk: equ 5
041BD0             0117*   c_cyan_dk: equ 6
041BD0             0118*   c_grey: equ 7
041BD0             0119*   c_grey_dk: equ 8
041BD0             0120*   c_red: equ 9
041BD0             0121*   c_green: equ 10
041BD0             0122*   c_yellow: equ 11
041BD0             0123*   c_blue: equ 12
041BD0             0124*   c_magenta: equ 13
041BD0             0125*   c_cyan: equ 14
041BD0             0126*   c_white: equ 15
041BD0             0127*   
041BD0             0128*   ; VDU 25, mode, x; y;: PLOT command
041BD0             0129*   ; inputs: a=mode, bc=x0, de=y0
041BD0             0130*   vdu_plot:
041BD0 32 EA 1B 04 0131*       ld (@mode),a
041BD4 ED 43 EB 1B 0132*       ld (@x0),bc
       04          
041BD9 ED 53 ED 1B 0133*       ld (@y0),de
       04          
041BDE 21 E9 1B 04 0134*   	ld hl,@cmd
041BE2 01 06 00 00 0135*   	ld bc,@end-@cmd
041BE6 5B DF       0136*   	rst.lil $18
041BE8 C9          0137*   	ret
041BE9 19          0138*   @cmd:   db 25
041BEA 00          0139*   @mode:  db 0
041BEB 00 00       0140*   @x0: 	dw 0
041BED 00 00       0141*   @y0: 	dw 0
041BEF 00          0142*   @end:   db 0 ; extra byte to soak up deu
041BF0             0143*   
041BF0             0144*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
041BF0             0145*   ; &E8-&EF 	232-239 	Bitmap plot Â§
041BF0             0146*   ; VDU 25, mode, x; y;: PLOT command
041BF0             0147*   ; inputs: bc=x0, de=y0
041BF0             0148*   ; prerequisites: vdu_buff_select
041BF0             0149*   vdu_plot_bmp:
041BF0 ED 43 07 1C 0150*       ld (@x0),bc
       04          
041BF5 ED 53 09 1C 0151*       ld (@y0),de
       04          
041BFA 21 05 1C 04 0152*   	ld hl,@cmd
041BFE 01 06 00 00 0153*   	ld bc,@end-@cmd
041C02 5B DF       0154*   	rst.lil $18
041C04 C9          0155*   	ret
041C05 19          0156*   @cmd:   db 25
041C06 ED          0157*   @mode:  db plot_bmp+dr_abs_fg ; 0xED
041C07 00 00       0158*   @x0: 	dw 0x0000
041C09 00 00       0159*   @y0: 	dw 0x0000
041C0B 00          0160*   @end:   db 0x00 ; padding
041C0C             0161*   
041C0C             0162*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
041C0C             0163*   ; &E8-&EF 	232-239 	Bitmap plot Â§
041C0C             0164*   ; VDU 25, mode, x; y;: PLOT command
041C0C             0165*   ; inputs: bc=x0, de=y0
041C0C             0166*   ; USING 16.8 FIXED POINT COORDINATES
041C0C             0167*   ; inputs: ub.c is x coordinate, ud.e is y coordinate
041C0C             0168*   ;   the fractional portiion of the inputs are truncated
041C0C             0169*   ;   leaving only the 16-bit integer portion
041C0C             0170*   ; prerequisites: vdu_buff_select
041C0C             0171*   vdu_plot_bmp168:
041C0C             0172*   ; populate in the reverse of normal to keep the
041C0C             0173*   ; inputs from stomping on each other
041C0C ED 53 2A 1C 0174*       ld (@y0-1),de
       04          
041C11 ED 43 28 1C 0175*       ld (@x0-1),bc
       04          
041C16 3E ED       0176*       ld a,plot_bmp+dr_abs_fg ; 0xED
041C18 32 28 1C 04 0177*       ld (@mode),a ; restore the mode byte that got stomped on by bcu
041C1C 21 27 1C 04 0178*   	ld hl,@cmd
041C20 01 06 00 00 0179*   	ld bc,@end-@cmd
041C24 5B DF       0180*   	rst.lil $18
041C26 C9          0181*   	ret
041C27 19          0182*   @cmd:   db 25
041C28 ED          0183*   @mode:  db plot_bmp+dr_abs_fg ; 0xED
041C29 00 00       0184*   @x0: 	dw 0x0000
041C2B 00 00       0185*   @y0: 	dw 0x0000
041C2D             0186*   @end:  ; no padding required b/c we shifted de right
041C2D             0187*   
041C2D             0188*   ; draw a filled rectangle
041C2D             0189*   vdu_plot_rf:
041C2D ED 43 54 1C 0190*       ld (@x0),bc
       04          
041C32 ED 53 56 1C 0191*       ld (@y0),de
       04          
041C37 DD 22 5A 1C 0192*       ld (@x1),ix
       04          
041C3C FD 22 5C 1C 0193*       ld (@y1),iy
       04          
041C41 3E 19       0194*       ld a,25 ; we have to reload the 2nd plot command
041C43 32 58 1C 04 0195*       ld (@cmd1),a ; because the 24-bit y0 load stomped on it
041C47 21 52 1C 04 0196*   	ld hl,@cmd0
041C4B 01 0C 00 00 0197*   	ld bc,@end-@cmd0
041C4F 5B DF       0198*   	rst.lil $18
041C51 C9          0199*       ret
041C52 19          0200*   @cmd0:  db 25 ; plot
041C53 04          0201*   @arg0:  db plot_sl_both+mv_abs
041C54 00 00       0202*   @x0:    dw 0x0000
041C56 00 00       0203*   @y0:    dw 0x0000
041C58 19          0204*   @cmd1:  db 25 ; plot
041C59 65          0205*   @arg1:  db plot_rf+dr_abs_fg
041C5A 00 00       0206*   @x1:    dw 0x0000
041C5C 00 00       0207*   @y1:    dw 0x0000
041C5E 00          0208*   @end:   db 0x00 ; padding
041C5F             0209*   
041C5F             0210*   ; draw a filled circle
041C5F             0211*   vdu_plot_cf:
041C5F ED 43 86 1C 0212*       ld (@x0),bc
       04          
041C64 ED 53 88 1C 0213*       ld (@y0),de
       04          
041C69 DD 22 8C 1C 0214*       ld (@x1),ix
       04          
041C6E FD 22 8E 1C 0215*       ld (@y1),iy
       04          
041C73 3E 19       0216*       ld a,25 ; we have to reload the 2nd plot command
041C75 32 8A 1C 04 0217*       ld (@cmd1),a ; because the 24-bit y0 load stomped on it
041C79 21 84 1C 04 0218*   	ld hl,@cmd0
041C7D 01 0C 00 00 0219*   	ld bc,@end-@cmd0
041C81 5B DF       0220*   	rst.lil $18
041C83 C9          0221*       ret
041C84 19          0222*   @cmd0:  db 25 ; plot
041C85 04          0223*   @arg0:  db plot_sl_both+mv_abs
041C86 00 00       0224*   @x0:    dw 0x0000
041C88 00 00       0225*   @y0:    dw 0x0000
041C8A 19          0226*   @cmd1:  db 25 ; plot
041C8B 9D          0227*   @arg1:  db plot_cf+dr_abs_fg
041C8C 00 00       0228*   @x1:    dw 0x0000
041C8E 00 00       0229*   @y1:    dw 0x0000
041C90 00          0230*   @end:   db 0x00 ; padding
041C91             0043        include "vdu_sound.inc"
041C91             0001*   ; enable enough additional channels so that total enabled = max_channels
041C91             0002*   ; inputs: max_channels set
041C91             0003*   ; returns: nothing
041C91             0004*   ; destroys: af, bc, hl
041C91             0005*   vdu_enable_channels:
041C91 3E 01       0006*       ld a,max_channels
041C93 D6 03       0007*       sub 3 ; subtract number of default channels already enabled
041C95 F2 9C 1C 04 0008*       jp p,@loop
041C99 C9          0009*       ret
041C9A 3E 03       0010*       ld a,3 ; first non-default channel
041C9C             0011*   @loop:
041C9C 32 B7 1C 04 0012*       ld (@channel),a
041CA0 21 B4 1C 04 0013*       ld hl,@beg
041CA4 01 05 00 00 0014*       ld bc,@end-@beg
041CA8 F5          0015*       push af
041CA9 5B DF       0016*       rst.lil $18
041CAB F1          0017*       pop af
041CAC 3C          0018*       inc a
041CAD FE 01       0019*       cp max_channels
041CAF C2 9C 1C 04 0020*       jp nz,@loop
041CB3 C9          0021*       ret
041CB4             0022*   @beg:
041CB4 17 00 85    0023*               db 23, 0, $85
041CB7 00          0024*   @channel:   db 0
041CB8 08          0025*               db 8 ; command 8: enable channel
041CB9             0026*   @end:
041CB9             0027*   
041CB9             0028*   ; disable all but the three default sound channels
041CB9             0029*   ; inputs: max_channels set
041CB9             0030*   ; outputs: none
041CB9             0031*   ; destroys: ah,hl,bc
041CB9             0032*   vdu_disable_channels:
041CB9 3E 01       0033*       ld a,max_channels
041CBB D6 03       0034*       sub 3 ; subtract number of default channels already enabled
041CBD F2 C4 1C 04 0035*       jp p,@loop
041CC1 C9          0036*       ret
041CC2 3E 03       0037*       ld a,3 ; first non-default channel
041CC4             0038*   @loop:
041CC4 32 DF 1C 04 0039*       ld (@channel),a
041CC8 21 DC 1C 04 0040*       ld hl,@beg
041CCC 01 05 00 00 0041*       ld bc,@end-@beg
041CD0 F5          0042*       push af
041CD1 5B DF       0043*       rst.lil $18
041CD3 F1          0044*       pop af
041CD4 3C          0045*       inc a
041CD5 FE 01       0046*       cp max_channels
041CD7 C2 C4 1C 04 0047*       jp nz,@loop
041CDB C9          0048*       ret
041CDC             0049*   @beg:
041CDC 17 00 85    0050*       db 23, 0, $85
041CDF 00          0051*   @channel: db 0
041CE0 09          0052*       db 9 ; command 9: disable channel
041CE1             0053*   @end:
041CE1             0054*   
041CE1             0055*   
041CE1             0056*   ; ############################################################
041CE1             0057*   ; VDU SOUND API
041CE1             0058*   ; ############################################################
041CE1             0059*   ; Command 0: Play note
041CE1             0060*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
041CE1             0061*       MACRO PLAY_NOTE channel, volume, frequency, duration
041CE1             0062*       ld hl, @PLAY_NOTE_CMD        ; Start of command block
041CE1             0063*       ld bc, @PLAY_NOTE_END - @PLAY_NOTE_CMD  ; Command block size
041CE1             0064*       rst.lil $18
041CE1             0065*       jr @PLAY_NOTE_END
041CE1             0066*   @PLAY_NOTE_CMD:  db 23, 0, 0x85               ; Command header
041CE1             0067*                    db channel                  ; Channel, 0 (commented out)
041CE1             0068*                    db 0                        ; Play note command
041CE1             0069*                    db volume                   ; Volume
041CE1             0070*                    dw frequency                ; Frequency
041CE1             0071*                    dw duration                 ; Duration
041CE1             0072*   @PLAY_NOTE_END:
041CE1             0073*       ENDMACRO
041CE1             0074*   
041CE1             0075*       MACRO MUTE_CHANNEL channel
041CE1             0076*       ld hl, @MUTE_CHANNEL_CMD     ; Start of command block
041CE1             0077*       ld bc, @MUTE_CHANNEL_END - @MUTE_CHANNEL_CMD  ; Command block size
041CE1             0078*       rst.lil $18
041CE1             0079*       jr @MUTE_CHANNEL_END
041CE1             0080*   @MUTE_CHANNEL_CMD: db 23, 0, 0x85             ; Command header
041CE1             0081*                      db channel                ; Channel, 0 (commented out)
041CE1             0082*                      db 2                      ; Set volume command
041CE1             0083*                      db 0                      ; Volume (mute)
041CE1             0084*   @MUTE_CHANNEL_END:
041CE1             0085*       ENDMACRO
041CE1             0086*   
041CE1             0087*   ; inputs: c = channel, b = volume, hl = frequency; de = duration;
041CE1             0088*   vdu_play_note:
041CE1 79          0089*       ld a,c
041CE2 32 02 1D 04 0090*       ld (@channel),a
041CE6 78          0091*       ld a,b
041CE7 32 04 1D 04 0092*       ld (@volume),a
041CEB 22 05 1D 04 0093*       ld (@frequency),hl
041CEF ED 53 07 1D 0094*       ld (@duration),de
       04          
041CF4 21 FF 1C 04 0095*       ld hl,@cmd
041CF8 01 0A 00 00 0096*       ld bc,@end-@cmd
041CFC 5B DF       0097*       rst.lil $18
041CFE C9          0098*       ret
041CFF 17 00 85    0099*   @cmd:       db 23, 0, 0x85
041D02 00          0100*   @channel:   db 0x00
041D03 00          0101*               db 0x00 ; play note command
041D04 00          0102*   @volume:    db 0x00
041D05 00 00       0103*   @frequency: dw 0x0000
041D07 00 00       0104*   @duration:  dw 0x0000
041D09 00          0105*   @end:       db 0x00 ; padding
041D0A             0106*   
041D0A             0107*   ; Command 1: Status
041D0A             0108*   ; VDU 23, 0, &85, channel, 1
041D0A             0109*   ; inputs: a = channel
041D0A             0110*   ; Returns a bit mask indicating the status of the specified channel, or 255 if the channel is not valid, or has been disabled. The bit mask is as follows:
041D0A             0111*   ; Bit 	Name 	Meaning
041D0A             0112*   ; 0 	Active 	When set this indicates the channel is in use (has an active waveform)
041D0A             0113*   ; 1 	Playing 	Indicates the channel is actively playing a note, and thus will reject calls to play a new note
041D0A             0114*   ; 2 	Indefinite 	Set if the channel is playing an indefinite duration note
041D0A             0115*   ; 3 	Has Volume Envelope 	Set if the channel has a volume envelope
041D0A             0116*   ; 4 	Has Frequency Envelope 	Set if the channel has a frequency envelope
041D0A             0117*   
041D0A             0118*   ; Bits 5-7 are reserved for future use and, for enabled channels, will currently always be zero.
041D0A             0119*   vdu_channel_status:
041D0A 32 1C 1D 04 0120*       ld (@channel),a
041D0E 21 19 1D 04 0121*       ld hl,@cmd
041D12 01 05 00 00 0122*       ld bc,@end-@cmd
041D16 5B DF       0123*       rst.lil $18
041D18 C9          0124*       ret
041D19 17 00 85    0125*   @cmd:       db 23, 0, 0x85
041D1C 00          0126*   @channel:   db 0x00
041D1D 01          0127*               db 0x01 ; get channel status command
041D1E             0128*   @end:
041D1E             0129*   
041D1E             0130*   ; VDU 23, 0, &85, channel, 2, volume
041D1E             0131*   ; inputs: c = channel, b = volume
041D1E             0132*   ; Sets the volume of the specified channel. The volume is a value from 0 to 127, where 0 is silent and 127 is full volume. Values over 127 will be treated as 127 (with one exception described later).
041D1E             0133*   
041D1E             0134*   ; Specifying a channel of -1 (or 255) will set the global sound system volume level. (Requires Console8 VDP 2.5.0 or later.)
041D1E             0135*   
041D1E             0136*   ; Using this command provides more direct control over a channel than the play note command. It can be used to adjust the volume of a channel that is already playing a note.
041D1E             0137*   vdu_channel_volume:
041D1E 79          0138*       ld a,c
041D1F 32 36 1D 04 0139*       ld (@channel),a
041D23 78          0140*       ld a,b
041D24 32 38 1D 04 0141*       ld (@volume),a
041D28 21 33 1D 04 0142*       ld hl,@cmd
041D2C 01 06 00 00 0143*       ld bc,@end-@cmd
041D30 5B DF       0144*       rst.lil $18
041D32 C9          0145*       ret
041D33 17 00 85    0146*   @cmd:       db 23, 0, 0x85
041D36 00          0147*   @channel:   db 0x00
041D37 02          0148*               db 0x02 ; set volume command
041D38 00          0149*   @volume:    db 0x00
041D39             0150*   @end:
041D39             0151*   
041D39             0152*   ; VDU 23, 0, &85, channel, 3, frequency;
041D39             0153*   
041D39             0154*   ; Sets the frequency of the specified channel. The frequency is a 16-bit value specifying in Hz the frequency of the note to be played.
041D39             0155*   
041D39             0156*   ; Using this command provides more direct control over a channel than the play note command. It can be used to adjust the frequency of a channel that is already playing a note.
041D39             0157*   
041D39             0158*   ; Returns 1 on success, 0 for failure.
041D39             0159*   vdu_channel_frequency:
041D39 79          0160*       ld a,c
041D3A 32 51 1D 04 0161*       ld (@channel),a
041D3E ED 53 53 1D 0162*       ld (@frequency),de
       04          
041D43 21 4E 1D 04 0163*       ld hl,@cmd
041D47 01 07 00 00 0164*       ld bc,@end-@cmd
041D4B 5B DF       0165*       rst.lil $18
041D4D C9          0166*       ret
041D4E 17 00 85    0167*   @cmd:       db 23, 0, 0x85
041D51 00          0168*   @channel:   db 0x00
041D52 03          0169*               db 0x03 ; set frequency command
041D53 00 00       0170*   @frequency: dw 0x0000
041D55 00          0171*   @end:       db 0x00 ; padding
041D56             0172*   
041D56             0173*   
041D56             0174*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
041D56             0175*   ; inputs: c = channel, b = waveformOrSample, [hl = bufferId]
041D56             0176*   ; Sets the waveform type for a channel to use. The waveformOrSample value is a single byte treated as a signed value.
041D56             0177*   
041D56             0178*   ; Using a negative value for the waveform indicates that a sample should be used instead. For more information see the documentation for the sample command.
041D56             0179*   
041D56             0180*   ; By default a channel is set to use waveform 0 (square wave).
041D56             0181*   
041D56             0182*   ; Valid waveform values are as follows:
041D56             0183*   ; Value 	Waveform
041D56             0184*   ; 0 	Square wave
041D56             0185*   ; 1 	Triangle wave
041D56             0186*   ; 2 	Sawtooth wave
041D56             0187*   ; 3 	Sine wave
041D56             0188*   ; 4 	Noise (simple white noise with no frequency support)
041D56             0189*   ; 5 	VIC Noise (emulates a VIC6561; supports frequency)
041D56             0190*   ; 8 	Sample (specifying a 16-bit buffer ID for sample data)
041D56             0191*   
041D56             0192*   vdu_channel_waveform:
041D56 79          0193*       ld a,c
041D57 32 7C 1D 04 0194*       ld (@channel),a
041D5B 78          0195*       ld a,b
041D5C 32 7E 1D 04 0196*       ld (@waveform),a
041D60 FE 08       0197*       cp 8 ; check if the waveform is a sample
041D62 28 06       0198*       jr z, @sample
041D64 01 06 00 00 0199*       ld bc,@bufferId-@cmd
041D68 18 08       0200*       jr @sendToVdu
041D6A             0201*   @sample:
041D6A 22 7F 1D 04 0202*       ld (@bufferId),hl
041D6E 01 08 00 00 0203*       ld bc,@end-@cmd
041D72             0204*   @sendToVdu:
041D72 21 79 1D 04 0205*       ld hl,@cmd
041D76 5B DF       0206*       rst.lil $18
041D78 C9          0207*       ret
041D79 17 00 85    0208*   @cmd:       db 23, 0, 0x85
041D7C 00          0209*   @channel:   db 0x00
041D7D 04          0210*               db 0x04 ; set waveform command
041D7E 00          0211*   @waveform:  db 0x00
041D7F 00 00       0212*   @bufferId:  dw 0x0000
041D81 00          0213*   @end:       db 0x00 ; padding
041D82             0214*   
041D82             0215*   ; VDU 23, 0, &85, channel (ignored), 5, 2, bufferId; format, [sampleRate;]
041D82             0216*   ; inputs: hl = bufferId; a = format, de = sample rate in Hz
041D82             0217*   ; The format is a single byte giving the format of the sample data. The following formats are supported:
041D82             0218*   ; Value	Description
041D82             0219*   ; 0	8-bit signed
041D82             0220*   ; 1	8-bit unsigned
041D82             0221*   ; The format value can also have modifier bits set to modify the behaviour of the sample. The following modifier bits are supported:
041D82             0222*   ; Value	Description
041D82             0223*   ; 8	sample rate is sent in the next 16-bits
041D82             0224*   ; 16	sample is tuneable
041D82             0225*   ; The default sample rate for samples on the VDP is 16kHz (actually 16.384kHz to be precise).
041D82             0226*   vdu_buffer_to_sound:
041D82 22 A2 1D 04 0227*       ld (@bufferId),hl
041D86 C6 08       0228*       add a,8 ; modify format byte to indicate sample rate argument is given
041D88 32 A4 1D 04 0229*       ld (@format),a
041D8C ED 53 A5 1D 0230*       ld (@sampleRate),de
       04          
041D91 21 9C 1D 04 0231*       ld hl,@cmd
041D95 01 0B 00 00 0232*       ld bc,@end-@cmd
041D99 5B DF       0233*       rst.lil $18
041D9B C9          0234*       ret
041D9C 17 00 85    0235*   @cmd:       db 23, 0, 0x85
041D9F 00          0236*   @channel:   db 0x00 ; ignored
041DA0 05          0237*               db 0x05 ; buffer to sound command
041DA1 02          0238*               db 0x02 ; command 2 create sample
041DA2 00 00       0239*   @bufferId:  dw 0x0000
041DA4 00          0240*   @format:    db 0x00
041DA5 00 00       0241*   @sampleRate: dw 0x0000
041DA7 00          0242*   @end:       db 0x00 ; padding
041DA8             0243*   
041DA8             0244*   ; Command 13: Set sample rate
041DA8             0245*   ; VDU 23, 0, &85, channel, 13, sampleRate;
041DA8             0246*   ; inputs: c = channel, hl = sampleRate (Hz)
041DA8             0247*   vdu_set_sample_rate:
041DA8 79          0248*       ld a,c
041DA9 32 BF 1D 04 0249*       ld (@channel),a
041DAD 22 C1 1D 04 0250*       ld (@sampleRate),hl
041DB1 21 BC 1D 04 0251*       ld hl,@cmd
041DB5 01 07 00 00 0252*       ld bc,@end-@cmd
041DB9 5B DF       0253*       rst.lil $18
041DBB C9          0254*       ret
041DBC 17 00 85    0255*   @cmd:       db 23, 0, 0x85
041DBF 00          0256*   @channel:   db 0x00
041DC0 0D          0257*               db 13 ; set sample rate command
041DC1 00 00       0258*   @sampleRate: dw 0x0000
041DC3 00          0259*   @end:       db 0x00 ; padding
041DC4             0260*   
041DC4             0261*   ; load a sound file to a buffer
041DC4             0262*   ; inputs: hl = bufferId ; de = sampleRate in Hz ; iy = pointer to filename
041DC4             0263*   vdu_load_sfx:
041DC4             0264*   ; back up input parameters
041DC4 E5          0265*       push hl ; bufferId
041DC5 D5          0266*       push de ; sample rate
041DC6             0267*   ; load the sound
041DC6 CD 04 19 04 0268*       call vdu_load_buffer_from_file
041DCA             0269*   ; now make the buffer a sound sample
041DCA D1          0270*       pop de ; sample rate
041DCB E1          0271*       pop hl ; bufferId
041DCC AF          0272*       xor a ; zero is the magic number for mono 8-bit signed PCM
041DCD CD 82 1D 04 0273*       call vdu_buffer_to_sound
041DD1 C9          0274*       ret
041DD2             0275*   
041DD2             0276*   
041DD2 00          0277*   last_channel: db 0
041DD3             0278*   max_channels: equ 1
041DD3             0279*   
041DD3             0280*   ; play a sound effect from an already loaded buffer
041DD3             0281*   ; inputs: hl = bufferId ; bc = duration in milliseconds
041DD3             0282*   vdu_play_sfx:
041DD3 22 0B 1E 04 0283*       ld (@bufferId),hl
041DD7 ED 43 15 1E 0284*       ld (@duration),bc
       04          
041DDC 3E 17       0285*       ld a,23
041DDE 32 0D 1E 04 0286*       ld (@bufferId+2),a
041DE2 3A D2 1D 04 0287*       ld a,(last_channel)
041DE6 3C          0288*       inc a
041DE7             0289*       ; and 31 ; modulo 32
041DE7 FE 01       0290*       cp max_channels
041DE9 C2 EE 1D 04 0291*       jp nz,@load_channel
041DED AF          0292*       xor a
041DEE             0293*   @load_channel:
041DEE 32 D2 1D 04 0294*       ld (last_channel),a
041DF2 32 08 1E 04 0295*       ld (@channel0),a
041DF6 32 10 1E 04 0296*       ld (@channel1),a
041DFA 21 05 1E 04 0297*       ld hl, @sample
041DFE 01 12 00 00 0298*       ld bc, @sample_end - @sample
041E02 5B DF       0299*       rst.lil $18
041E04 C9          0300*       ret
041E05             0301*   @sample:
041E05             0302*   ; Command 4: Set waveform
041E05             0303*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
041E05 17 00 85    0304*       .db 23,0,$85                        ; do sound
041E08             0305*   @channel0:
041E08 00 04 08    0306*       .db 0,4,8 ; channel, command, waveform
041E0B             0307*   @bufferId:
041E0B 00 00       0308*       .dw 0x0000
041E0D             0309*   ; Command 0: Play note
041E0D             0310*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
041E0D 17 00 85    0311*       .db 23,0,$85                        ; do sound
041E10             0312*   @channel1:
041E10 00 00 7F    0313*       .db 0,0,127                ; channel, volume
041E13 00 00       0314*       .dw 0
041E15             0315*   @duration:                              ; freq (tuneable samples only)
041E15 00 00       0316*       .dw 0x0000                        ; duration
041E17             0317*   @sample_end:
041E17 00          0318*       .db 0x00 ; padding
041E18             0319*   
041E18             0320*   ; inputs: c = channel, b = volume, de = sample rate; hl = bufferId;
041E18             0321*   vdu_play_sample:
041E18             0322*       ; populate input parameters
041E18 79          0323*       ld a,c
041E19 32 4B 1E 04 0324*       ld (@channel0),a
041E1D 32 53 1E 04 0325*       ld (@channel1),a
041E21 32 5A 1E 04 0326*       ld (@channel2),a
041E25 78          0327*       ld a,b
041E26 32 5C 1E 04 0328*       ld (@volume),a
041E2A ED 53 55 1E 0329*       ld (@sampleRate),de
       04          
041E2F 22 4E 1E 04 0330*       ld (@bufferId),hl
041E33 3E 17       0331*       ld a,23
041E35 32 50 1E 04 0332*       ld (@cmd1),a
041E39 32 57 1E 04 0333*       ld (@cmd2),a
041E3D             0334*       ; prep the vdu command string
041E3D 21 48 1E 04 0335*       ld hl, @cmd0
041E41 01 19 00 00 0336*       ld bc, @end - @cmd0
041E45 5B DF       0337*       rst.lil $18
041E47 C9          0338*       ret
041E48             0339*   ; set waveform command
041E48 17 00 85    0340*   @cmd0:       db 23, 0, 0x85
041E4B 00          0341*   @channel0:   db 0x00
041E4C 04          0342*                db 0x04 ; set waveform command
041E4D 08          0343*   @waveform:   db 0x08 ; sample
041E4E 00 00       0344*   @bufferId:   dw 0x0000
041E50             0345*   ; set sample rate command
041E50 17 00 85    0346*   @cmd1:       db 23, 0, 0x85
041E53 00          0347*   @channel1:   db 0x00
041E54 0D          0348*               db 13 ; set sample rate command
041E55 00 00       0349*   @sampleRate: dw 0x0000
041E57             0350*   ; play note command
041E57 17 00 85    0351*   @cmd2:       db 23, 0, 0x85
041E5A 00          0352*   @channel2:   db 0x00
041E5B 00          0353*                db 0x00 ; play note command
041E5C 00          0354*   @volume:     db 0x00
041E5D 00 00       0355*   @frequency:  dw 0x00 ; no effect unless buffer has been set to tuneable sample
041E5F 00 00       0356*   @duration:   dw 0x0000 ; milliseconds: set to -1 to loop indefinitely, 0 to play full duration once
041E61 00          0357*   @end:        db 0x00 ; padding
041E62             0044    
041E62             0045    ; APPLICATION INCLUDES
041E62             0046        include "ascii.inc"
041E62             0001*   agon_jukebox_ascii:
041E62 20 20 20 5F 0002*       db 32,32,32,95,95,95,95,95,32,32,32,32,95,95,95,95,95,95,95,95,32,95,95,95,95,95,95,95,95,32,32,32,32,95,95,95,95,95,95,95,13,10
       5F 5F 5F 5F 
       20 20 20 20 
       5F 5F 5F 5F 
       5F 5F 5F 5F 
       20 5F 5F 5F 
       5F 5F 5F 5F 
       5F 20 20 20 
       20 5F 5F 5F 
       5F 5F 5F 5F 
       0D 0A       
041E8C 20 20 2F 20 0003*       db 32,32,47,32,32,95,32,32,92,32,32,47,32,32,95,95,95,95,95,47,32,92,95,95,95,95,95,32,32,92,32,32,32,92,32,32,32,32,32,32,92,13,10
       20 5F 20 20 
       5C 20 20 2F 
       20 20 5F 5F 
       5F 5F 5F 2F 
       20 5C 5F 5F 
       5F 5F 5F 20 
       20 5C 20 20 
       20 5C 20 20 
       20 20 20 20 
       5C 0D 0A    
041EB7 20 2F 20 20 0004*       db 32,47,32,32,47,95,92,32,32,92,47,32,32,32,92,32,32,95,95,95,32,32,47,32,32,32,124,32,32,32,92,32,32,47,32,32,32,124,32,32,32,92,13,10
       2F 5F 5C 20 
       20 5C 2F 20 
       20 20 5C 20 
       20 5F 5F 5F 
       20 20 2F 20 
       20 20 7C 20 
       20 20 5C 20 
       20 2F 20 20 
       20 7C 20 20 
       20 5C 0D 0A 
041EE3 2F 20 20 20 0005*       db 47,32,32,32,32,124,32,32,32,32,92,32,32,32,32,92,95,92,32,32,92,47,32,32,32,32,124,32,32,32,32,92,47,32,32,32,32,124,32,32,32,32,92,13,10
       20 7C 20 20 
       20 20 5C 20 
       20 20 20 5C 
       5F 5C 20 20 
       5C 2F 20 20 
       20 20 7C 20 
       20 20 20 5C 
       2F 20 20 20 
       20 7C 20 20 
       20 20 5C 0D 
       0A          
041F10 5C 5F 5F 5F 0006*       db 92,95,95,95,95,124,95,95,32,32,47,92,95,95,95,95,95,95,32,32,47,92,95,95,95,95,95,95,95,32,32,47,92,95,95,95,95,124,95,95,32,32,47,13,10
       5F 7C 5F 5F 
       20 20 2F 5C 
       5F 5F 5F 5F 
       5F 5F 20 20 
       2F 5C 5F 5F 
       5F 5F 5F 5F 
       5F 20 20 2F 
       5C 5F 5F 5F 
       5F 7C 5F 5F 
       20 20 2F 0D 
       0A          
041F3D 20 20 20 20 0007*       db 32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,32,92,47,13,10
       20 20 20 20 
       5C 2F 20 20 
       20 20 20 20 
       20 20 5C 2F 
       20 20 20 20 
       20 20 20 20 
       20 5C 2F 20 
       20 20 20 20 
       20 20 20 20 
       5C 2F 0D 0A 
041F69 20 20 20 20 0008*       db 32,32,32,32,32,95,95,95,95,32,95,95,95,95,32,95,95,95,32,95,95,95,95,32,32,95,95,32,95,95,95,95,95,95,95,95,95,95,95,13,10
       20 5F 5F 5F 
       5F 20 5F 5F 
       5F 5F 20 5F 
       5F 5F 20 5F 
       5F 5F 5F 20 
       20 5F 5F 20 
       5F 5F 5F 5F 
       5F 5F 5F 5F 
       5F 5F 5F 0D 
       0A          
041F92 20 20 20 20 0009*       db 32,32,32,32,124,32,32,32,32,124,32,32,32,32,124,32,32,32,92,32,32,32,32,124,47,32,95,124,92,95,32,32,32,95,95,95,95,95,47,13,10
       7C 20 20 20 
       20 7C 20 20 
       20 20 7C 20 
       20 20 5C 20 
       20 20 20 7C 
       2F 20 5F 7C 
       5C 5F 20 20 
       20 5F 5F 5F 
       5F 5F 2F 0D 
       0A          
041FBB 20 20 20 20 0010*       db 32,32,32,32,124,32,32,32,32,124,32,32,32,32,124,32,32,32,47,32,32,32,32,32,32,60,32,32,32,124,32,32,32,32,95,95,41,95,13,10
       7C 20 20 20 
       20 7C 20 20 
       20 20 7C 20 
       20 20 2F 20 
       20 20 20 20 
       20 3C 20 20 
       20 7C 20 20 
       20 20 5F 5F 
       29 5F 0D 0A 
041FE3 2F 5C 5F 5F 0011*       db 47,92,95,95,124,32,32,32,32,124,32,32,32,32,124,32,32,47,124,32,32,32,32,124,32,32,92,32,32,124,32,32,32,32,32,32,32,32,92,13,10
       7C 20 20 20 
       20 7C 20 20 
       20 20 7C 20 
       20 2F 7C 20 
       20 20 20 7C 
       20 20 5C 20 
       20 7C 20 20 
       20 20 20 20 
       20 20 5C 0D 
       0A          
04200C 5C 5F 5F 5F 0012*       db 92,95,95,95,95,95,95,95,95,124,95,95,95,95,95,95,47,32,124,95,95,95,95,124,95,95,32,92,47,95,95,95,95,95,95,95,32,32,47,13,10
       5F 5F 5F 5F 
       5F 7C 5F 5F 
       5F 5F 5F 5F 
       2F 20 7C 5F 
       5F 5F 5F 7C 
       5F 5F 20 5C 
       2F 5F 5F 5F 
       5F 5F 5F 5F 
       20 20 2F 0D 
       0A          
042035 20 20 20 20 0013*       db 32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,92,47,13,10
       20 20 20 20 
       20 20 20 20 
       20 20 20 20 
       20 20 20 20 
       20 20 20 20 
       20 20 5C 2F 
       20 20 20 20 
       20 20 20 20 
       5C 2F 0D 0A 
04205D 20 20 20 20 0014*       db 32,32,32,32,95,95,95,95,95,95,95,95,95,95,32,95,95,95,95,95,95,95,95,32,32,95,95,95,95,32,32,95,95,95,13,10
       5F 5F 5F 5F 
       5F 5F 5F 5F 
       5F 5F 20 5F 
       5F 5F 5F 5F 
       5F 5F 5F 20 
       20 5F 5F 5F 
       5F 20 20 5F 
       5F 5F 0D 0A 
042081 20 20 20 20 0015*       db 32,32,32,32,92,95,95,95,95,95,95,32,32,32,92,92,95,95,95,95,95,32,32,92,32,92,32,32,32,92,47,32,32,47,13,10
       5C 5F 5F 5F 
       5F 5F 5F 20 
       20 20 5C 5C 
       5F 5F 5F 5F 
       5F 20 20 5C 
       20 5C 20 20 
       20 5C 2F 20 
       20 2F 0D 0A 
0420A5 20 20 20 20 0016*       db 32,32,32,32,32,124,32,32,32,32,124,32,32,95,47,32,47,32,32,32,124,32,32,32,92,32,92,32,32,32,32,32,47,13,10
       20 7C 20 20 
       20 20 7C 20 
       20 5F 2F 20 
       2F 20 20 20 
       7C 20 20 20 
       5C 20 5C 20 
       20 20 20 20 
       2F 0D 0A    
0420C8 20 20 20 20 0017*       db 32,32,32,32,32,124,32,32,32,32,124,32,32,32,92,47,32,32,32,32,124,32,32,32,32,92,47,32,32,32,32,32,92,13,10
       20 7C 20 20 
       20 20 7C 20 
       20 20 5C 2F 
       20 20 20 20 
       7C 20 20 20 
       20 5C 2F 20 
       20 20 20 20 
       5C 0D 0A    
0420EB 20 20 20 20 0018*       db 32,32,32,32,32,124,95,95,95,95,95,95,32,32,47,92,95,95,95,95,95,95,95,32,32,47,95,95,95,47,92,32,32,92,13,10
       20 7C 5F 5F 
       5F 5F 5F 5F 
       20 20 2F 5C 
       5F 5F 5F 5F 
       5F 5F 5F 20 
       20 2F 5F 5F 
       5F 2F 5C 20 
       20 5C 0D 0A 
04210F 20 20 20 20 0019*       db 32,32,32,32,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,92,95,47,13,10
       20 20 20 20 
       20 20 20 20 
       5C 2F 20 20 
       20 20 20 20 
       20 20 20 5C 
       2F 20 20 20 
       20 20 20 5C 
       5F 2F 0D 0A 
042133             0047        include "input_dir.inc"
042133             0001*   get_input:
042133             0002*   @loop:
042133             0003*   ; wait for the user to push a button
042133             0004*       MOSCALL mos_getkey ; a = ascii code of key pressed
042133 3E 00       0001*M1 			LD	A, function
042135 5B CF       0002*M1 			RST.LIL	08h
042137 F3          0005*       di ; disable interrupts
042138             0006*       ; rst.lil 10h ; print the key pressed
042138             0007*   ; app control commands
042138 FE 1B       0008*       cp '\e' ; escape
04213A C8          0009*       ret z ; returns to main, which re-enables interrupts and exits app
04213B             0010*   ; song playing commands
04213B FE 72       0011*       cp 'r' ; random song
04213D CA 5A 27 04 0012*       jp z,ps_play_random
042141 FE 30       0013*       cp '0'
042143 DA 6F 21 04 0014*       jp c,@other ; not a song command
042147 FE 3A       0015*       cp '9'+1
042149 D2 6F 21 04 0016*       jp nc,@other ; not a song command
04214D             0017*   ; new song requested so stop playing current one
04214D F5          0018*       push af ; preserve keypress
04214E CD 18 26 04 0019*       call ps_close_file
042152 F1          0020*       pop af ; restore keypress
042153             0021*   ; get pointer to song filename and play it
042153 D6 30       0022*       sub '0' ; a = index into filename lut
042155 11 00 00 00 0023*       ld de,0
042159 5F          0024*       ld e,a
04215A 21 00 01 00 0025*       ld hl,256 ; 256 bytes per filename index
04215E CD 67 03 04 0026*       call umul24 ; hl index into the filename table
042162 11 00 00 06 0027*       ld de,ps_dir_fil_list
042166 19          0028*       add hl,de ; hl points to the filename
042167 22 8D 23 04 0029*       ld (ps_song_fn_cur),hl ; save song request
04216B C3 51 25 04 0030*       jp play_song ; re-enables interrupts and jp's to get_input when finished
04216F             0031*   @other: ; TODO: other commands
04216F FB          0032*       ei ; reenable interrupts
042170 C3 33 21 04 0033*       jp @loop ; no valid commmand so loop
042174             0034*   ; end get_input
042174             0048        include "play_dir.inc"
042174             0001*   ; stream a song from the SD card
042174             0002*   ; inputs: hl = pointer to filename
042174             0003*   ; requirements: the file must be 8-bit signed PCM mono
042174             0004*   ; uses: sound channels 0 and 1, buffers 0x3000 and 0x3001
042174             0005*   ; play_song constants
042174             0006*   ch0_buffer: equ 0x3000
042174             0007*   ch1_buffer: equ 0x3001
042174             0008*   cmd0_buffer: equ 0x3002
042174             0009*   cmd1_buffer: equ 0x3003
042174             0010*   
042174             0011*   ; play_song state variables
042174             0012*   ; current active channel and bufferId's
042174 00          0013*   ps_channel: db 0 ; channel number
042175 00 00 00    0014*   ps_cmdId: dl 0 ; command bufferId
042178 00 00 00    0015*   ps_sampleId: dl 0 ; sample bufferId
04217B 00 00 00 00 0016*   ps_dir_path:   blkw 256,0 ; path of the current directory
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04237B 00 00 00    0017*   ps_dir_num_files: dl 0 ; number of files/directories in the directory (virtually unlimited)
04237E 00 00 00    0018*   ps_dir_num_pages: dl 0 ; number of pages in the directory (virtually unlimited)
042381 00 00 00    0019*   ps_page_num_files: dl 0 ; number of files/directories in the current directory page (max 10)
042384 00 00 00    0020*   ps_pagelast_num_files: dl 0 ; mod(ps_dir_num_files,10)
042387 00 00 00    0021*   ps_page_cur: dl 0 ; current directory page number
04238A 00 00 00    0022*   ps_song_idx_cur: dl 0 ; current song index in the directory page
04238D 00 00 00    0023*   ps_song_fn_cur: dl 0 ; pointer to current song filename
042390 00 00 00 00 0024*   ps_page_fn_ptrs: blkw 10*3,0 ; list of filename pointers in the current directory page
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0423CC             0025*   
0423CC             0026*   ; play_song directory info
0423CC             0027*   ps_dir_struct:
0423CC 00 00 00 00 0028*   ps_dptr:       blkb  4,0   ; Current read/write offset
0423D0 00 00 00 00 0029*   ps_clust:      blkb  4,0   ; Current cluster
0423D4 00 00 00 00 0030*   ps_sect:       blkb  4,0   ; Current sector (0:Read operation has terminated)
0423D8 00 00 00    0031*   ps_dir:        blkb  3,0   ; Pointer to the directory item in the win[]
0423DB 00 00 00 00 0032*   ps_fn:         blkb  12,0  ; SFN (in/out) {body[8],ext[3],status[1]}
       00 00 00 00 
       00 00 00 00 
0423E7 00 00 00 00 0033*   ps_blk_ofs:    blkb  4,0   ; Offset of current entry block being processed (0xFFFFFFFF:Invalid)
0423EB             0034*   
0423EB             0035*   ; play_song file info
0423EB 00          0036*   ps_filehandle_cur: db 0 ; file handle
0423EC 00 00 00    0037*   ps_chunkpointer: dl 0 ; pointer to current chunk
0423EF             0038*   ; File information structure (FILINFO)
0423EF             0039*   ps_filinfo_struct:
0423EF 00 00 00 00 0040*   ps_filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
0423F3 00 00       0041*   ps_filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
0423F5 00 00       0042*   ps_filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
0423F7 00          0043*   ps_filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
0423F8 00 00 00 00 0044*   ps_filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
042405 00 00 00 00 0045*   ps_filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042505             0046*   
042505             0047*   ; buffer for play_song sound data
042505             0048*   ps_wav_header: ; marker for top of the wav file header and song data
042505             0049*   ; (must be last so buffer doesn't overwrite other program code or data)
042505             0050*   ; .wav header data
042505             0051*   ; WAV File Structure in Memory with LIST Chunk
042505 00 00 00 00 0052*   ps_wav_riff:          blkb 4,0   ; 4 bytes: "RIFF" identifier
042509 00 00 00 00 0053*   ps_wav_file_size:     blkb 4,0   ; 4 bytes: Total file size minus 8 bytes for RIFF header
04250D 00 00 00 00 0054*   ps_wav_wave:          blkb 4,0   ; 4 bytes: "WAVE" identifier
042511 00 00 00 00 0055*   ps_wav_fmt_marker:    blkb 4,0   ; 4 bytes: "fmt " subchunk marker
042515 00 00 00 00 0056*   ps_wav_fmt_size:      blkb 4,0   ; 4 bytes: Format chunk size (16 for PCM)
042519 00 00       0057*   ps_wav_audio_format:  blkb 2,0   ; 2 bytes: Audio format (1 = PCM)
04251B 00 00       0058*   ps_wav_num_channels:  blkb 2,0   ; 2 bytes: Number of channels (1 = mono, 2 = stereo)
04251D 00 00 00 00 0059*   ps_wav_sample_rate:   blkb 4,0   ; 4 bytes: Sample rate in Hz (e.g., 32768)
042521 00 00 00 00 0060*   ps_wav_byte_rate:     blkb 4,0   ; 4 bytes: Bytes per second (SampleRate * NumChannels * BitsPerSample / 8)
042525 00 00       0061*   ps_wav_block_align:   blkb 2,0   ; 2 bytes: Bytes per sample block (NumChannels * BitsPerSample / 8)
042527 00 00       0062*   ps_wav_bits_per_sample: blkb 2,0 ; 2 bytes: Bits per sample (e.g., 8 or 16)
042529             0063*   
042529             0064*   ; LIST Chunk (Extra Metadata)
042529 00 00 00 00 0065*   ps_wav_list_marker:   blkb 4,0   ; 4 bytes: "LIST" marker
04252D 00 00 00 00 0066*   ps_wav_list_size:     blkb 4,0   ; 4 bytes: Size of the LIST chunk (e.g., 26)
042531 00 00 00 00 0067*   ps_wav_info_marker:   blkb 4,0   ; 4 bytes: "INFO" marker
042535 00 00 00 00 0068*   ps_wav_isft_marker:   blkb 4,0   ; 4 bytes: "ISFT" marker (software identifier)
042539 00 00 00 00 0069*   ps_wav_isft_data:     blkb 14,0  ; 14 bytes: Software info string (e.g., "Lavf59.27.100")
       00 00 00 00 
       00 00 00 00 
       00 00       
042547 00 00       0070*   ps_wav_isft_padding:  blkb 2,0   ; 2 bytes: Padding/NULL terminator for alignment
042549             0071*   
042549             0072*   ; Data Chunk
042549 00 00 00 00 0073*   ps_wav_data_marker:   blkb 4,0   ; 4 bytes: "data" subchunk marker
04254D 00 00 00 00 0074*   ps_wav_data_size:     blkb 4,0   ; 4 bytes: Size of the audio data in bytes
042551             0075*   ; Total Header Size: 76 bytes
042551             0076*   play_song:
042551 22 8D 23 04 0077*       ld (ps_song_fn_cur),hl
042555             0078*   ; stop the PRT timer
042555 CD 36 28 04 0079*       call ps_prt_stop
042559             0080*   ; tell the user what they've won
042559 0E 00       0081*       ld c,0 ; left
04255B 16 00       0082*       ld d,0 ; top
04255D 1E 3E       0083*       ld e,62 ; right
04255F 06 01       0084*       ld b,1; bottom
042561 CD 4F 17 04 0085*       call vdu_set_txt_viewport
042565 CD F6 16 04 0086*       call vdu_cls
042569 2A 8D 23 04 0087*       ld hl,(ps_song_fn_cur)
04256D CD 60 00 04 0088*       call printInline
042571 50 6C 61 79 0089*       asciz "Playing song: "
       69 6E 67 20 
       73 6F 6E 67 
       3A 20 00    
042580 2A 8D 23 04 0090*       ld hl,(ps_song_fn_cur)
042584 CD 67 00 04 0091*       call printString ; print the song filename
042588             0092*   ; reset text viewport for playing breadcrumbs
042588 0E 00       0093*       ld c,0 ; left
04258A 16 01       0094*       ld d,1 ; top
04258C 1E 3E       0095*       ld e,62 ; right
04258E 06 01       0096*       ld b,1; bottom
042590 CD 4F 17 04 0097*       call vdu_set_txt_viewport
042594             0098*   ; open the file in read mode
042594             0099*   ; Open a file
042594             0100*   ; HLU: Filename
042594             0101*   ;   C: Mode
042594             0102*   ; Returns:
042594             0103*   ;   A: Filehandle, or 0 if couldn't open
042594 2A 8D 23 04 0104*       ld hl,(ps_song_fn_cur)
042598 0E 01       0105*   	ld c,fa_read
04259A             0106*       MOSCALL mos_fopen
04259A 3E 0A       0001*M1 			LD	A, function
04259C 5B CF       0002*M1 			RST.LIL	08h
04259E 32 EB 23 04 0107*       ld (ps_filehandle_cur),a
0425A2             0108*   ; read the .wav header data and copy it to the buffer
0425A2 CD 74 27 04 0109*       call ps_read_wav_header
0425A6             0110*   ; read the first block of data
0425A6 CD B3 25 04 0111*       call ps_read_file
0425AA             0112*   ; enable interrupts and start the PRT timer
0425AA FB          0113*       ei
0425AB CD 19 28 04 0114*       call ps_prt_start
0425AF             0115*   ; jump to user input loop:
0425AF             0116*   ; the play sample interrupt will return to there
0425AF             0117*   ; and exit app will return to main from there as well
0425AF C3 33 21 04 0118*       jp get_input
0425B3             0119*   ; end play_song
0425B3             0120*   
0425B3             0121*   ; read the next 1-second's worth of sound data from the file
0425B3             0122*   ; and upload it to the sample buffer
0425B3             0123*   ps_read_file:
0425B3             0124*   ; disable interrupts so load is guaranteed to complete
0425B3 F3          0125*       di
0425B4             0126*   ; print a playing breadcrumb
0425B4 3E 2E       0127*       ld a,'.'
0425B6 5B D7       0128*       rst.lil 10h
0425B8             0129*   ; Read a block of data from a file
0425B8             0130*   ;   C: Filehandle
0425B8             0131*   ; HLU: Pointer to where to write the data to
0425B8             0132*   ; DEU: Number of bytes to read
0425B8             0133*   ; Returns:
0425B8             0134*   ; DEU: Number of bytes read
0425B8 3A EB 23 04 0135*       ld a,(ps_filehandle_cur)
0425BC 4F          0136*       ld c,a
0425BD 21 00 00 05 0137*       ld hl,ps_wav_data_start
0425C1 ED 5B 1D 25 0138*       ld de,(ps_wav_sample_rate)
       04          
0425C6             0139*       MOSCALL mos_fread
0425C6 3E 1A       0001*M1 			LD	A, function
0425C8 5B CF       0002*M1 			RST.LIL	08h
0425CA             0140*   ; test de for zero bytes read
0425CA 21 00 00 00 0141*       ld hl,0
0425CE AF          0142*       xor a ; clear carry
0425CF ED 52       0143*       sbc hl,de ; hl = 0-chunksize
0425D1 C2 DD 25 04 0144*       jp nz,@load ; we read some data
0425D5             0145*   ; no data read so close file and play a random song
0425D5 CD 18 26 04 0146*       call ps_close_file
0425D9 C3 5A 27 04 0147*       jp ps_play_random
0425DD             0148*   ; load a vdu buffer from local memory
0425DD             0149*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0425DD             0150*   @load:
0425DD 3A 74 21 04 0151*       ld a,(ps_channel)
0425E1 3C          0152*       inc a
0425E2 E6 01       0153*       and 1
0425E4 32 74 21 04 0154*       ld (ps_channel),a
0425E8 21 00 30 00 0155*       ld hl,ch0_buffer
0425EC 6F          0156*       ld l,a
0425ED 22 78 21 04 0157*       ld (ps_sampleId),hl
0425F1 CD B0 1A 04 0158*       call vdu_clear_buffer
0425F5 2A 78 21 04 0159*       ld hl,(ps_sampleId)
0425F9 D5          0160*       push de ; chunksize
0425FA C1          0161*       pop bc ; how much data to load
0425FB 11 00 00 05 0162*       ld de,ps_wav_data_start ; pointer to data
0425FF CD 9B 18 04 0163*       call vdu_load_buffer
042603 C9          0164*       ret
042604             0165*   ; end ps_read_file
042604             0166*   
042604             0167*   ; this is called by the PRT timer interrupt
042604             0168*   ps_play_sample:
042604             0169*   ; call the command buffer to play the sound
042604 2A 78 21 04 0170*       ld hl,(ps_sampleId)
042608 2C          0171*       inc l
042609 2C          0172*       inc l
04260A 22 75 21 04 0173*       ld (ps_cmdId),hl ; TODO: perhaps not needed
04260E CD 95 1A 04 0174*       call vdu_call_buffer
042612             0175*   ; load the next chunk of data
042612 CD B3 25 04 0176*       call ps_read_file
042616             0177*   ; reenable interrupts and return to the user input loop
042616 FB          0178*       ei
042617 C9          0179*       ret
042618             0180*   ; end ps_play_sample
042618             0181*   
042618             0182*   ; close the file
042618             0183*   ps_close_file:
042618 CD 36 28 04 0184*       call ps_prt_stop ; stop the PRT timer
04261C 3A EB 23 04 0185*       ld a,(ps_filehandle_cur)
042620             0186*       MOSCALL mos_fclose
042620 3E 0B       0001*M1 			LD	A, function
042622 5B CF       0002*M1 			RST.LIL	08h
042624 C9          0187*       ret
042625             0188*   ; end ps_close_file
042625             0189*   
042625             0190*   ps_get_dir:
042625             0191*   ; reset filecounter
042625 21 00 00 00 0192*       ld hl,0
042629 22 7B 23 04 0193*       ld (ps_dir_num_files),hl
04262D             0194*   ; initialize pointers to store directory info
04262D 21 7B 21 04 0195*       ld hl,ps_dir_path  ; where to store result
042631 01 FF 00 00 0196*       ld bc,255          ; max length
042635             0197*       MOSCALL ffs_getcwd ; MOS api get current working directory
042635 3E 9E       0001*M1 			LD	A, function
042637 5B CF       0002*M1 			RST.LIL	08h
042639             0198*   ; now get dir info
042639 21 CC 23 04 0199*       ld hl,ps_dir_struct ; define where to store directory info
04263D 11 7B 21 04 0200*       ld de,ps_dir_path   ; this is pointer to the path to the directory
042641             0201*       MOSCALL ffs_dopen   ; open dir
042641 3E 91       0001*M1 			LD	A, function
042643 5B CF       0002*M1 			RST.LIL	08h
042645             0202*   @readFileInfo:               ; we will loop here until all files have been processed
042645 21 CC 23 04 0203*       ld hl,ps_dir_struct      ; HL is where to get directory info
042649 11 EF 23 04 0204*       ld de,ps_filinfo_struct  ; define where to store current file info
04264D             0205*       MOSCALL ffs_dread        ; read next item from dir
04264D 3E 93       0001*M1 			LD	A, function
04264F 5B CF       0002*M1 			RST.LIL	08h
042651 3A 05 24 04 0206*       ld a,(ps_filinfo_fname)  ; get first char of file name
042655 FE 00       0207*       cp 0                     ; if 0 then we are at the end of the listing
042657 28 27       0208*       jr z,@allDone
042659 ED 5B 7B 23 0209*       ld de,(ps_dir_num_files) ; get the current file counter
       04          
04265E 21 00 01 00 0210*       ld hl,256 ; bytes per filename
042662 CD 67 03 04 0211*       call umul24 ; hl = offset into the filename table
042666 13          0212*       inc de                  ; increment the counter
042667 ED 53 7B 23 0213*       ld (ps_dir_num_files),de
       04          
04266C 11 00 00 06 0214*       ld de,ps_dir_fil_list ; get the address of the filename table
042670 19          0215*       add hl,de ; add the offset to the base address
042671 EB          0216*       ex de,hl ; de is the destination address to copy the filename
042672 21 05 24 04 0217*       ld hl,ps_filinfo_fname   ; this is pointer to the name of current file
042676 01 00 01 00 0218*       ld bc,256 ; bytes per filename
04267A ED B0       0219*       ldir ; copy the filename to the filename table
04267C C3 45 26 04 0220*       jp @readFileInfo         ; loop around to check next entry
042680             0221*   @allDone:
042680             0222*   ; compute page statistics
042680 2A 7B 23 04 0223*       ld hl,(ps_dir_num_files) ; get the number of files
042684 11 0A 00 00 0224*       ld de,10 ; max files per page
042688 CD 80 03 04 0225*       call udiv24 ; de = hl/10, hl = mod(hl,10)
04268C             0226*       SIGN_HLU ; check remainder for zero
04268C 19          0001*M1     add hl,de ; 1 cycle
04268D B7          0002*M1     or a ; clear flags ; 1 cycle
04268E ED 52       0003*M1     sbc hl,de ; 2 cycles
042690             0004*M1     ; 4 cycles total
042690 CA 95 26 04 0227*       jp z,@F ; if zero then we have exactly 10 files
042694 13          0228*       inc de ; bump the page count
042695             0229*   @@:
042695 ED 53 7E 23 0230*       ld (ps_dir_num_pages),de ; save the number of pages
       04          
04269A 22 84 23 04 0231*       ld (ps_pagelast_num_files),hl ; save the number of files on the last page
04269E             0232*   ; reset the song index and page to zero and populate the page filename pointers
04269E 21 00 00 00 0233*       ld hl,0
0426A2 22 8A 23 04 0234*       ld (ps_song_idx_cur),hl
0426A6 22 87 23 04 0235*       ld (ps_page_cur),hl
0426AA CD B7 26 04 0236*       call ps_fill_page_fn_ptrs
0426AE             0237*   ; close the directory
0426AE 21 CC 23 04 0238*       ld hl,ps_dir_struct      ; load H: with address of the DIR struct
0426B2             0239*       MOSCALL ffs_dclose       ; close dir
0426B2 3E 92       0001*M1 			LD	A, function
0426B4 5B CF       0002*M1 			RST.LIL	08h
0426B6 C9          0240*       ret
0426B7             0241*   ; end ps_get_dir
0426B7             0242*   
0426B7             0243*   ; populate the page filename pointers for the current directory page
0426B7             0244*   ; inputs: ps_page_cur
0426B7             0245*   ; prerequisites: ps_get_dir called on a valid directory
0426B7             0246*   ; outputs: a populated filename pointer list for the current page
0426B7             0247*   ; destroys: a, hl, bc, de, ix
0426B7             0248*   ps_fill_page_fn_ptrs:
0426B7 2A 87 23 04 0249*       ld hl,(ps_page_cur) ; get the current page number
0426BB 11 00 0A 00 0250*       ld de,10*256 ; records/page * 256 bytes/record
0426BF CD 67 03 04 0251*       call umul24 ; hl = offset into the filename table
0426C3 11 00 00 06 0252*       ld de,ps_dir_fil_list ; base address of filename table
0426C7 19          0253*       add hl,de ; add the offset to the base address
0426C8 DD 21 90 23 0254*       ld ix,ps_page_fn_ptrs ; get the address of the page filename pointer table
       04          
0426CD 11 00 01 00 0255*       ld de,256 ; bytes per filename record
0426D1 06 0A       0256*       ld b,10 ; number of files per page
0426D3             0257*   @loop:
0426D3 DD 2F 00    0258*       ld (ix),hl ; store the filename pointer
0426D6 ED 32 03    0259*       lea ix,ix+3 ; bump the index pointer
0426D9 19          0260*       add hl,de ; add the record size to the filename pointer
0426DA 10 F7       0261*       djnz @loop
0426DC C9          0262*       ret
0426DD             0263*   ; end ps_fill_page_fn_ptrs
0426DD             0264*   
0426DD             0265*   ps_print_dir_page:
0426DD             0266*   ; check whether we're at last page
0426DD 2A 87 23 04 0267*       ld hl,(ps_page_cur)
0426E1 ED 5B 7E 23 0268*       ld de,(ps_dir_num_pages)
       04          
0426E6 1B          0269*       dec de ; zero-based
0426E7 B7          0270*       or a ; clear carry
0426E8 ED 52       0271*       sbc hl,de
0426EA 06 0A       0272*       ld b,10 ; default number of files per page
0426EC C2 F5 26 04 0273*       jp nz,@F ; not last page so skip ahead
0426F0 3A 84 23 04 0274*       ld a,(ps_pagelast_num_files) ; get the number of files on the last page
0426F4 47          0275*       ld b,a ; loop counter
0426F5             0276*   @@: ; print the current directory page
0426F5 AF          0277*       xor a ; song index
0426F6 DD 21 90 23 0278*       ld ix,ps_page_fn_ptrs
       04          
0426FB             0279*   @loop:
0426FB C5          0280*       push bc ; save loop counter
0426FC F5          0281*       push af ; save song index
0426FD CD 7C 28 04 0282*       call printHexA ; print the song index
042701 DD 27 00    0283*       ld hl,(ix) ; get the filename pointer
042704 CD 67 00 04 0284*       call printString ; print the filename
042708 CD 7C 00 04 0285*       call printNewLine
04270C ED 32 03    0286*       lea ix,ix+3 ; bump the filename pointer
04270F F1          0287*       pop af ; restore song index
042710 3C          0288*       inc a ; increment the song index
042711 C1          0289*       pop bc ; restore loop counter
042712 10 E7       0290*       djnz @loop
042714 C9          0291*       ret
042715             0292*   ; end ps_print_dir_page
042715             0293*   
042715             0294*   ps_print_dir:
042715             0295*   ; loop through the filename table and print out the filenames
042715 DD 21 00 00 0296*       ld ix,ps_dir_fil_list      ; get the address of the filename table
       06          
04271A 2A 7B 23 04 0297*       ld hl,(ps_dir_num_files)   ; get the number of files
04271E E5          0298*       push hl ; save loop counter
04271F             0299*   @print_loop:
04271F DD E5       0300*       push ix
042721 E1          0301*       pop hl ; get the address of the filename
042722 CD 67 00 04 0302*       call printString
042726 CD 7C 00 04 0303*       call printNewLine
04272A ED 32 7F    0304*       lea ix,ix+127 ; bump the pointer
04272D ED 32 7F    0305*       lea ix,ix+127 ; to the next file
042730 ED 32 02    0306*       lea ix,ix+2   ; 256 bytes
042733 E1          0307*       pop hl ; get the loop counter
042734 2B          0308*       dec hl ; decrement the loop counter
042735 E5          0309*       push hl ; save loop counter
042736             0310*       SIGN_HLU ; check for zero
042736 19          0001*M1     add hl,de ; 1 cycle
042737 B7          0002*M1     or a ; clear flags ; 1 cycle
042738 ED 52       0003*M1     sbc hl,de ; 2 cycles
04273A             0004*M1     ; 4 cycles total
04273A 20 E3       0311*       jr nz,@print_loop
04273C E1          0312*       pop hl ; dummy pop to balance stack
04273D C9          0313*       ret
04273E             0314*   ; end ps_print_dir
04273E             0315*   
04273E             0316*   ps_get_song_fn_from_pg_idx:
04273E 21 00 00 00 0317*       ld hl,0 ; clear hlu and h
042742 6F          0318*       ld l,a
042743 ED 5B 81 23 0319*       ld de,(ps_page_num_files)
       04          
042748 CD 80 03 04 0320*       call udiv24 ; hl = mod(hl,num_files)
04274C 11 00 01 00 0321*       ld de,256 ; 256 bytes per filename record
042750 CD 67 03 04 0322*       call umul24 ; hl = index into the filename table
042754 11 00 00 06 0323*       ld de,ps_dir_fil_list
042758 19          0324*       add hl,de ; hl points to the filename
042759 C9          0325*       ret
04275A             0326*   ; end ps_get_song_fn_from_pg_idx
04275A             0327*   
04275A             0328*   ; queue a random song to play next
04275A             0329*   ps_play_random:
04275A CD 38 05 04 0330*       call rand_8 ; a = 0-255
04275E CD 3E 27 04 0331*       call ps_get_song_fn_from_pg_idx
042762 EB          0332*       ex de,hl ; setting up cp hl,de
042763 2A 8D 23 04 0333*       ld hl,(ps_song_fn_cur) ; don't play the same song twice in a row
042767 B7          0334*       or a ; clear carry
042768 ED 52       0335*       sbc hl,de
04276A CA 5A 27 04 0336*       jp z,ps_play_random ; same song, try again
04276E EB          0337*       ex de,hl ; pointer back to hl
04276F CD 51 25 04 0338*       call play_song ; hit it
042773 C9          0339*       ret
042774             0340*   ; end ps_play_random
042774             0341*   
042774             0342*   ps_read_wav_header:
042774             0343*   ; Read a block of data from a file
042774             0344*   ;   C: Filehandle
042774             0345*   ; HLU: Pointer to where to write the data to
042774             0346*   ; DEU: Number of bytes to read
042774             0347*   ; Returns:
042774             0348*   ; DEU: Number of bytes read
042774 3A EB 23 04 0349*       ld a,(ps_filehandle_cur)
042778 4F          0350*       ld c,a
042779 21 05 25 04 0351*       ld hl,ps_wav_header
04277D 11 4C 00 00 0352*       ld de,wav_header_size
042781             0353*       MOSCALL mos_fread
042781 3E 1A       0001*M1 			LD	A, function
042783 5B CF       0002*M1 			RST.LIL	08h
042785             0354*   ; test de for zero bytes read
042785 21 00 00 00 0355*       ld hl,0
042789 AF          0356*       xor a ; clear carry
04278A ED 52       0357*       sbc hl,de ; hl = 0-chunksize
04278C C8          0358*       ret z ; no data read so return zero to caller
04278D             0359*   ; data read so initialize song variables
04278D             0360*   ; load play sample command buffers (namely the sample rate for now)
04278D CD 92 27 04 0361*       call ps_load_command_buffers
042791 C9          0362*       ret
042792             0363*   ; end ps_read_wav_header
042792             0364*   
042792             0365*   ps_load_command_buffers:
042792 21 02 30 00 0366*       ld hl,cmd0_buffer
042796 CD B0 1A 04 0367*       call vdu_clear_buffer
04279A 2A 1D 25 04 0368*       ld hl,(ps_wav_sample_rate)
04279E 22 E8 27 04 0369*       ld (ps_sr0),hl
0427A2 3E 17       0370*       ld a,23
0427A4 32 EA 27 04 0371*       ld (ps_sr0+2),a
0427A8 21 02 30 00 0372*       ld hl,cmd0_buffer
0427AC 01 1D 00 00 0373*       ld bc,ps_cmd0_end-ps_cmd0
0427B0 11 DF 27 04 0374*       ld de,ps_cmd0
0427B4 CD 6D 1A 04 0375*       call vdu_write_block_to_buffer
0427B8             0376*   
0427B8 21 03 30 00 0377*       ld hl,cmd1_buffer
0427BC CD B0 1A 04 0378*       call vdu_clear_buffer
0427C0 2A 1D 25 04 0379*       ld hl,(ps_wav_sample_rate)
0427C4 22 05 28 04 0380*       ld (ps_sr1),hl
0427C8 3E 17       0381*       ld a,23
0427CA 32 07 28 04 0382*       ld (ps_sr1+2),a
0427CE 21 03 30 00 0383*       ld hl,cmd1_buffer
0427D2 01 1D 00 00 0384*       ld bc,ps_cmd1_end-ps_cmd1
0427D6 11 FC 27 04 0385*       ld de,ps_cmd1
0427DA CD 6D 1A 04 0386*       call vdu_write_block_to_buffer
0427DE C9          0387*       ret
0427DF             0388*   ps_cmd0:
0427DF             0389*   ; vdu_buffer_to_sound command string
0427DF             0390*   ; Command 5: Buffer to sound
0427DF             0391*   ; VDU 23, 0, &85, channel (ignored), 5, 2, bufferId; format, [sampleRate;]
0427DF 17 00 85    0392*       db 23,0,0x85 ; vdu sound command header
0427E2 00          0393*       db 0x00 ; channel (ignored)
0427E3 05          0394*       db 0x05 ; buffer to sound command
0427E4 02          0395*       db 0x02 ; command 2 create sample
0427E5 00 30       0396*       dw ch0_buffer
0427E7 09          0397*       db 1+8 ; 8-bit unsigned PCM mono, 8 = sample rate argument follows
0427E8             0398*   ps_sr0:
0427E8 00 00       0399*       dw 0x0000 ; sample rate Hz
0427EA             0400*   ; vdu_play_sfx command string
0427EA             0401*   ; Command 4: Set waveform
0427EA             0402*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
0427EA 17 00 85    0403*       db 23,0,$85 ; vdu sound command header
0427ED 00          0404*       db 0 ; channel
0427EE 04          0405*       db 4 ; set waveform command
0427EF 08          0406*       db 8 ; waveform 8 = sample
0427F0 00 30       0407*       dw ch0_buffer ; sample bufferId
0427F2             0408*   ; Command 0: Play note
0427F2             0409*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
0427F2 17 00 85    0410*       db 23,0,$85 ; vdu sound command header
0427F5 00          0411*       db 0 ; channel
0427F6 00          0412*       db 0 ; play note command
0427F7 7F          0413*       db 127  ; volume 127 = max
0427F8 00 00       0414*       dw 0 ; frequency (relevant only for tuneable samples)
0427FA 00 00       0415*       dw 0 ; duration (ms), zero means play one time in full
0427FC             0416*   ps_cmd0_end:
0427FC             0417*   
0427FC             0418*   ps_cmd1:
0427FC             0419*   ; vdu_buffer_to_sound command string
0427FC             0420*   ; Command 5: Buffer to sound
0427FC             0421*   ; VDU 23, 0, &85, channel (ignored), 5, 2, bufferId; format, [sampleRate;]
0427FC 17 00 85    0422*       db 23,0,0x85 ; vdu sound command header
0427FF 00          0423*       db 0x00 ; channel (ignored)
042800 05          0424*       db 0x05 ; buffer to sound command
042801 02          0425*       db 0x02 ; command 2 create sample
042802 01 30       0426*       dw ch1_buffer
042804 09          0427*       db 1+8 ; 8-bit unsigned PCM mono, 8 = sample rate argument follows
042805             0428*   ps_sr1:
042805 00 00       0429*       dw 0x0000 ; sample rate Hz
042807             0430*   ; vdu_play_sfx command string
042807             0431*   ; Command 4: Set waveform
042807             0432*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
042807 17 00 85    0433*       db 23,0,$85 ; vdu sound command header
04280A 01          0434*       db 1 ; channel
04280B 04          0435*       db 4 ; set waveform command
04280C 08          0436*       db 8 ; waveform 8 = sample
04280D 01 30       0437*       dw ch1_buffer ; sample bufferId
04280F             0438*   ; Command 0: Play note
04280F             0439*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
04280F 17 00 85    0440*       db 23,0,$85 ; vdu sound command header
042812 01          0441*       db 1 ; channel
042813 00          0442*       db 0 ; play note command
042814 7F          0443*       db 127  ; volume 127 = max
042815 00 00       0444*       dw 0 ; frequency (relevant only for tuneable samples)
042817 00 00       0445*       dw 0 ; duration (ms), zero means play one time in full
042819             0446*   ps_cmd1_end:
042819             0447*   ; end ps_load_command_buffers
042819             0049        include "timer_jukebox.inc"
042819             0001*   ps_prt_reload: equ [72000/2]+1 ; 2 ticks per second at 18.432 MHz with a 256 clock divider
042819             0002*   
042819             0003*   ; start PRT timer
042819             0004*   ps_prt_start:
042819 21 00 00 00 0005*       ld hl,0
04281D 22 58 28 04 0006*       ld (ps_prt_irq_counter),hl
042821 21 A1 8C 00 0007*       ld hl,ps_prt_reload
042825 ED 29 84    0008*       out0 (TMR1_CTL+TMR_RES_LOW),l
042828 ED 21 85    0009*   	out0 (TMR1_CTL+TMR_RES_HIGH),h
04282B             0010*   ; disable timer (in effect, reset it)
04282B 3E 0E       0011*       ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_256 | RST_EN_1 | PRT_EN_0
04282D ED 39 83    0012*   	out0 (TMR1_CTL+TMR_REG_CTL),a
042830             0013*   ; enable timer,with interrupt and CONTINUOUS mode,clock divider 256
042830 3E 5F       0014*       ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_256 | RST_EN_1 | PRT_EN_1
042832 ED 39 83    0015*   	out0 (TMR1_CTL+TMR_REG_CTL),a
042835 C9          0016*       ret
042836             0017*   
042836             0018*   ; stop PRT timer
042836             0019*   ps_prt_stop:
042836 3E 0E       0020*       ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_256 | RST_EN_1 | PRT_EN_0
042838 ED 39 83    0021*   	out0 (TMR1_CTL+TMR_REG_CTL),a
04283B C9          0022*       ret
04283C             0023*   
04283C             0024*   ; ===============================================
04283C             0025*   ; PRT Timer Interrupt Handling
04283C             0026*   ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.asm
04283C             0027*   ; -----------------------------------------------
04283C             0028*   ps_prt_irq_init:
04283C             0029*       ; set up interrupt vector table 2
04283C 21 00 00 00 0030*   	ld hl,0
042840 3A 0C 01 00 0031*   	ld a,($10c)
042844 6F          0032*   	ld l,a
042845 3A 0D 01 00 0033*   	ld a,($10d)
042849 67          0034*   	ld h,a
04284A             0035*   
04284A             0036*   	; skip over CALL ($c3)
04284A 23          0037*   	inc hl
04284B             0038*   	; load address of jump into vector table 2 (in ram)
04284B ED 27       0039*   	ld hl,(hl)
04284D             0040*   
04284D             0041*   	; write CALL ps_prt_irq_handler to vector table 2
04284D 3E C3       0042*   	ld a,$c3
04284F 77          0043*   	ld (hl),a
042850 23          0044*   	inc hl
042851 11 59 28 04 0045*   	ld de,ps_prt_irq_handler
042855 ED 1F       0046*   	ld (hl),de
042857             0047*   
042857 C9          0048*       ret
042858             0049*   ; end ps_prt_irq_init
042858             0050*   
042858             0051*   ; interrupt routine for playing the next sample
042858             0052*   ps_prt_irq_counter:
042858 00          0053*   	db 0
042859             0054*   ps_prt_irq_handler:
042859 F3          0055*       di
04285A 08          0056*       ex af,af'
04285B D9          0057*       exx
04285C             0058*   ; clear sysvar_keyascii
04285C             0059*   	MOSCALL mos_sysvars
04285C 3E 08       0001*M1 			LD	A, function
04285E 5B CF       0002*M1 			RST.LIL	08h
042860 AF          0060*   	xor a
042861 DD 77 05    0061*   	ld (IX+sysvar_keyascii),a
042864             0062*   ; read the timer interrupt and bump the counter
042864 ED 38 83    0063*       in0 a,(TMR1_CTL+TMR_REG_CTL)
042867 3A 58 28 04 0064*       ld a,(ps_prt_irq_counter)
04286B 3C          0065*       inc a
04286C E6 01       0066*       and 1 ; modulo 2
04286E 32 58 28 04 0067*       ld (ps_prt_irq_counter),a
042872             0068*   ; if counter zero, play the next sample
042872 CC 04 26 04 0069*       call z,ps_play_sample
042876 D9          0070*       exx
042877 08          0071*       ex af,af'
042878 FB          0072*       ei
042879 5B ED 4D    0073*       reti.l
04287C             0074*   ; end ps_prt_irq_handler
04287C             0050        include "wav.inc"
04287C             0001*   ; WAV File Structure Offsets and Descriptions
04287C             0002*   wav_riff:          EQU 0    ; 4 bytes: "RIFF" identifier
04287C             0003*   wav_file_size:     EQU 4    ; 4 bytes: Total file size minus 8 bytes for RIFF header
04287C             0004*   wav_wave:          EQU 8    ; 4 bytes: "WAVE" identifier
04287C             0005*   wav_fmt_marker:    EQU 12   ; 4 bytes: "fmt " subchunk marker
04287C             0006*   wav_fmt_size:      EQU 16   ; 4 bytes: Format chunk size (16 for PCM)
04287C             0007*   wav_audio_format:  EQU 20   ; 2 bytes: Audio format (1 = PCM)
04287C             0008*   wav_num_channels:  EQU 22   ; 2 bytes: Number of channels (1 = mono, 2 = stereo)
04287C             0009*   wav_sample_rate:   EQU 24   ; 4 bytes: Sample rate in Hz (e.g., 32768)
04287C             0010*   wav_byte_rate:     EQU 28   ; 4 bytes: Bytes per second (SampleRate * NumChannels * BitsPerSample / 8)
04287C             0011*   wav_block_align:   EQU 32   ; 2 bytes: Bytes per sample block (NumChannels * BitsPerSample / 8)
04287C             0012*   wav_bits_per_sample: EQU 34 ; 2 bytes: Bits per sample (e.g., 8 or 16)
04287C             0013*   
04287C             0014*   ; LIST Chunk (Extra Metadata)
04287C             0015*   wav_list_marker:   EQU 36   ; 4 bytes: "LIST" marker
04287C             0016*   wav_list_size:     EQU 40   ; 4 bytes: Size of the LIST chunk (e.g., 26)
04287C             0017*   wav_info_marker:   EQU 44   ; 4 bytes: "INFO" marker
04287C             0018*   wav_isft_marker:   EQU 48   ; 4 bytes: "ISFT" marker (software identifier)
04287C             0019*   wav_isft_data:     EQU 52   ; 14 bytes: Software info string (e.g., "Lavf59.27.100")
04287C             0020*   wav_isft_padding:  EQU 66   ; 2 bytes: Padding/NULL terminator for alignment
04287C             0021*   
04287C             0022*   ; Data Chunk
04287C             0023*   wav_data_marker:   EQU 68   ; 4 bytes: "data" subchunk marker
04287C             0024*   wav_data_size:     EQU 72   ; 4 bytes: Size of the audio data in bytes
04287C             0025*   wav_data_start:    EQU 76   ; Start of audio data
04287C             0026*   wav_header_size:   EQU wav_data_start ; Total Header Size: 76 bytes
04287C             0051        include "debug.inc"
04287C             0001*   printHexA:
04287C F5          0002*       push af
04287D C5          0003*       push bc
04287E CD AE 00 04 0004*       call printHex8
042882 3E 20       0005*       ld a,' '
042884 5B D7       0006*       rst.lil 10h
042886 C1          0007*       pop bc
042887 F1          0008*       pop af
042888 C9          0009*       ret
042889             0010*   
042889             0011*   printHexHL:
042889 F5          0012*       push af
04288A C5          0013*       push bc
04288B CD A8 00 04 0014*       call printHex16
04288F 3E 20       0015*       ld a,' '
042891 5B D7       0016*       rst.lil 10h
042893 C1          0017*       pop bc
042894 F1          0018*       pop af
042895 C9          0019*       ret
042896             0020*   
042896             0021*   printHexUHL:
042896 F5          0022*       push af
042897 C5          0023*       push bc
042898 CD A0 00 04 0024*       call printHex24
04289C 3E 20       0025*       ld a,' '
04289E 5B D7       0026*       rst.lil 10h
0428A0 C1          0027*       pop bc
0428A1 F1          0028*       pop af
0428A2 C9          0029*       ret
0428A3             0030*   
0428A3             0031*   printHexAUHL:
0428A3 F5          0032*       push af
0428A4 C5          0033*       push bc
0428A5 CD AE 00 04 0034*       call printHex8
0428A9 3E 2E       0035*       ld a,'.'
0428AB 5B D7       0036*       rst.lil 10h
0428AD CD A0 00 04 0037*       call printHex24
0428B1 3E 20       0038*       ld a,' '
0428B3 5B D7       0039*       rst.lil 10h
0428B5 C1          0040*       pop bc
0428B6 F1          0041*       pop af
0428B7 C9          0042*       ret
0428B8             0043*   
0428B8             0044*   printHexABHL:
0428B8             0045*   ; preserve registers
0428B8 C5          0046*       push bc ; b will be ok c will not
0428B9 F5          0047*       push af ; will get totally destroyed
0428BA             0048*   ; print a
0428BA CD AE 00 04 0049*       call printHex8
0428BE             0050*   ; print b
0428BE 78          0051*       ld a,b
0428BF CD AE 00 04 0052*       call printHex8
0428C3             0053*   ; print hl
0428C3 CD A8 00 04 0054*       call printHex16
0428C7             0055*   ; restore registers
0428C7 F1          0056*       pop af
0428C8 C1          0057*       pop bc
0428C9 C9          0058*       ret
0428CA             0059*   
0428CA             0060*   printHexBHL:
0428CA             0061*   ; preserve registers
0428CA C5          0062*       push bc ; b will be ok c will not
0428CB F5          0063*       push af ; will get totally destroyed
0428CC             0064*   ; print b
0428CC 78          0065*       ld a,b
0428CD CD AE 00 04 0066*       call printHex8
0428D1             0067*   ; print hl
0428D1 CD A8 00 04 0068*       call printHex16
0428D5             0069*   ; restore registers
0428D5 F1          0070*       pop af
0428D6 C1          0071*       pop bc
0428D7 C9          0072*       ret
0428D8             0073*   
0428D8             0074*   printHexCDE:
0428D8             0075*   ; preserve registers
0428D8 C5          0076*       push bc ; b will be ok c will not
0428D9 F5          0077*       push af ; will get totally destroyed
0428DA             0078*   ; print c
0428DA 79          0079*       ld a,c
0428DB CD AE 00 04 0080*       call printHex8
0428DF             0081*   ; print de
0428DF EB          0082*       ex de,hl
0428E0 CD A8 00 04 0083*       call printHex16
0428E4 EB          0084*       ex de,hl
0428E5             0085*   ; restore registers
0428E5 F1          0086*       pop af
0428E6 C1          0087*       pop bc
0428E7 C9          0088*       ret
0428E8             0089*   
0428E8             0090*   printHexUIX:
0428E8             0091*   ; store everything in scratch
0428E8 22 35 03 04 0092*       ld (uhl),hl
0428EC ED 43 38 03 0093*       ld (ubc),bc
       04          
0428F1 ED 53 3B 03 0094*       ld (ude),de
       04          
0428F6 DD 22 3E 03 0095*       ld (uix),ix
       04          
0428FB FD 22 41 03 0096*       ld (uiy),iy
       04          
042900 F5          0097*       push af ; fml
042901             0098*   
042901 21 CC 02 04 0099*       ld hl,str_ixu
042905 CD 67 00 04 0100*       call printString
042909 2A 3E 03 04 0101*       ld hl,(uix)
04290D CD A0 00 04 0102*       call printHex24
042911 CD 7C 00 04 0103*       call printNewLine
042915             0104*   
042915             0105*   ; restore everything
042915 2A 35 03 04 0106*       ld hl, (uhl)
042919 ED 4B 38 03 0107*       ld bc, (ubc)
       04          
04291E ED 5B 3B 03 0108*       ld de, (ude)
       04          
042923 DD 2A 3E 03 0109*       ld ix, (uix)
       04          
042928 FD 2A 41 03 0110*       ld iy, (uiy)
       04          
04292D F1          0111*       pop af
04292E             0112*   ; all done
04292E C9          0113*       ret
04292F             0114*   
04292F             0115*   
04292F             0116*   ; print registers to screen in hexidecimal format
04292F             0117*   ; inputs: none
04292F             0118*   ; outputs: values of every register printed to screen
04292F             0119*   ;    values of each register in global scratch memory
04292F             0120*   ; destroys: nothing
04292F             0121*   stepRegistersHex:
04292F             0122*   ; store everything in scratch
04292F 22 35 03 04 0123*       ld (uhl),hl
042933 ED 43 38 03 0124*       ld (ubc),bc
       04          
042938 ED 53 3B 03 0125*       ld (ude),de
       04          
04293D DD 22 3E 03 0126*       ld (uix),ix
       04          
042942 FD 22 41 03 0127*       ld (uiy),iy
       04          
042947 F5          0128*       push af ; fml
042948 E1          0129*       pop hl ; thanks, zilog
042949 22 32 03 04 0130*       ld (uaf),hl
04294D F5          0131*       push af ; dammit
04294E             0132*   
04294E             0133*   ; home the cursor
04294E             0134*       ; call vdu_home_cursor
04294E             0135*   
04294E             0136*   ; print each register
04294E 21 B8 02 04 0137*       ld hl,str_afu
042952 CD 67 00 04 0138*       call printString
042956 2A 32 03 04 0139*       ld hl,(uaf)
04295A CD A0 00 04 0140*       call printHex24
04295E CD 7C 00 04 0141*       call printNewLine
042962             0142*   
042962 21 BD 02 04 0143*       ld hl,str_hlu
042966 CD 67 00 04 0144*       call printString
04296A 2A 35 03 04 0145*       ld hl,(uhl)
04296E CD A0 00 04 0146*       call printHex24
042972 CD 7C 00 04 0147*       call printNewLine
042976             0148*   
042976 21 C2 02 04 0149*       ld hl,str_bcu
04297A CD 67 00 04 0150*       call printString
04297E 2A 38 03 04 0151*       ld hl,(ubc)
042982 CD A0 00 04 0152*       call printHex24
042986 CD 7C 00 04 0153*       call printNewLine
04298A             0154*   
04298A 21 C7 02 04 0155*       ld hl,str_deu
04298E CD 67 00 04 0156*       call printString
042992 2A 3B 03 04 0157*       ld hl,(ude)
042996 CD A0 00 04 0158*       call printHex24
04299A CD 7C 00 04 0159*       call printNewLine
04299E             0160*   
04299E 21 CC 02 04 0161*       ld hl,str_ixu
0429A2 CD 67 00 04 0162*       call printString
0429A6 2A 3E 03 04 0163*       ld hl,(uix)
0429AA CD A0 00 04 0164*       call printHex24
0429AE CD 7C 00 04 0165*       call printNewLine
0429B2             0166*   
0429B2 21 D1 02 04 0167*       ld hl,str_iyu
0429B6 CD 67 00 04 0168*       call printString
0429BA 2A 41 03 04 0169*       ld hl,(uiy)
0429BE CD A0 00 04 0170*       call printHex24
0429C2 CD 7C 00 04 0171*       call printNewLine
0429C6             0172*   
0429C6             0173*       ; call vsync
0429C6             0174*   
0429C6 CD 7C 00 04 0175*       call printNewLine
0429CA             0176*   
0429CA             0177*   ; check for right shift key and quit if pressed
0429CA             0178*       MOSCALL mos_getkbmap
0429CA 3E 1E       0001*M1 			LD	A, function
0429CC 5B CF       0002*M1 			RST.LIL	08h
0429CE             0179*   @stayhere:
0429CE             0180*   ; 7 RightShift
0429CE DD CB 00 76 0181*       bit 6,(ix+0)
0429D2 20 02       0182*       jr nz,@RightShift
0429D4 18 F8       0183*       jr @stayhere
0429D6             0184*   @RightShift:
0429D6 DD CB 0E 86 0185*       res 0,(ix+14) ; debounce the key (hopefully)
0429DA 3E 80       0186*       ld a,%10000000
0429DC             0187*       ; call multiPurposeDelay
0429DC             0188*   
0429DC             0189*   ; restore everything
0429DC 2A 35 03 04 0190*       ld hl, (uhl)
0429E0 ED 4B 38 03 0191*       ld bc, (ubc)
       04          
0429E5 ED 5B 3B 03 0192*       ld de, (ude)
       04          
0429EA DD 2A 3E 03 0193*       ld ix, (uix)
       04          
0429EF FD 2A 41 03 0194*       ld iy, (uiy)
       04          
0429F4 F1          0195*       pop af
0429F5             0196*   ; all done
0429F5 C9          0197*       ret
0429F6             0198*   
0429F6             0199*   ; print registers to screen in hexidecimal format
0429F6             0200*   ; inputs: none
0429F6             0201*   ; outputs: values of every register printed to screen
0429F6             0202*   ;    values of each register in global scratch memory
0429F6             0203*   ; destroys: nothing
0429F6             0204*   dumpRegistersHex:
0429F6             0205*   ; store everything in scratch
0429F6 22 35 03 04 0206*       ld (uhl),hl
0429FA ED 43 38 03 0207*       ld (ubc),bc
       04          
0429FF ED 53 3B 03 0208*       ld (ude),de
       04          
042A04 DD 22 3E 03 0209*       ld (uix),ix
       04          
042A09 FD 22 41 03 0210*       ld (uiy),iy
       04          
042A0E F5          0211*       push af ; fml
042A0F E1          0212*       pop hl ; thanks, zilog
042A10 22 32 03 04 0213*       ld (uaf),hl
042A14 F5          0214*       push af ; dammit
042A15             0215*   
042A15             0216*   ; home the cursor
042A15             0217*       ; call vdu_home_cursor
042A15             0218*       ; call printNewLine
042A15             0219*   
042A15             0220*   ; print each register
042A15 21 B8 02 04 0221*       ld hl,str_afu
042A19 CD 67 00 04 0222*       call printString
042A1D 2A 32 03 04 0223*       ld hl,(uaf)
042A21 CD A0 00 04 0224*       call printHex24
042A25 CD 7C 00 04 0225*       call printNewLine
042A29             0226*   
042A29 21 BD 02 04 0227*       ld hl,str_hlu
042A2D CD 67 00 04 0228*       call printString
042A31 2A 35 03 04 0229*       ld hl,(uhl)
042A35 CD A0 00 04 0230*       call printHex24
042A39 CD 7C 00 04 0231*       call printNewLine
042A3D             0232*   
042A3D 21 C2 02 04 0233*       ld hl,str_bcu
042A41 CD 67 00 04 0234*       call printString
042A45 2A 38 03 04 0235*       ld hl,(ubc)
042A49 CD A0 00 04 0236*       call printHex24
042A4D CD 7C 00 04 0237*       call printNewLine
042A51             0238*   
042A51 21 C7 02 04 0239*       ld hl,str_deu
042A55 CD 67 00 04 0240*       call printString
042A59 2A 3B 03 04 0241*       ld hl,(ude)
042A5D CD A0 00 04 0242*       call printHex24
042A61 CD 7C 00 04 0243*       call printNewLine
042A65             0244*   
042A65 21 CC 02 04 0245*       ld hl,str_ixu
042A69 CD 67 00 04 0246*       call printString
042A6D 2A 3E 03 04 0247*       ld hl,(uix)
042A71 CD A0 00 04 0248*       call printHex24
042A75 CD 7C 00 04 0249*       call printNewLine
042A79             0250*   
042A79 21 D1 02 04 0251*       ld hl,str_iyu
042A7D CD 67 00 04 0252*       call printString
042A81 2A 41 03 04 0253*       ld hl,(uiy)
042A85 CD A0 00 04 0254*       call printHex24
042A89             0255*   
042A89 CD 7C 00 04 0256*       call printNewLine
042A8D CD 7C 00 04 0257*       call printNewLine
042A91             0258*   ; restore everything
042A91 2A 35 03 04 0259*       ld hl, (uhl)
042A95 ED 4B 38 03 0260*       ld bc, (ubc)
       04          
042A9A ED 5B 3B 03 0261*       ld de, (ude)
       04          
042A9F DD 2A 3E 03 0262*       ld ix, (uix)
       04          
042AA4 FD 2A 41 03 0263*       ld iy, (uiy)
       04          
042AA9 F1          0264*       pop af
042AAA             0265*   ; all done
042AAA C9          0266*       ret
042AAB             0267*   
042AAB             0268*   dumpRegistersHexPrime:
042AAB D9          0269*       exx
042AAC 08          0270*       ex af,af'
042AAD CD F6 29 04 0271*       call dumpRegistersHex
042AB1 08          0272*       ex af,af'
042AB2 D9          0273*       exx
042AB3 C9          0274*       ret
042AB4             0275*   
042AB4             0276*   ; additionally dump prime registers
042AB4             0277*   ; inputs: none
042AB4             0278*   ; outputs: values of every register printed to screen
042AB4             0279*   ; destroys: nothing
042AB4             0280*   dumpRegistersHexAll:
042AB4 CD F6 29 04 0281*       call dumpRegistersHex
042AB8 08          0282*       ex af,af'
042AB9 D9          0283*       exx
042ABA CD F6 29 04 0284*       call dumpRegistersHex
042ABE 08          0285*       ex af,af'
042ABF D9          0286*       exx
042AC0 C9          0287*       ret
042AC1             0288*   
042AC1             0289*   ; print hlu to screen in hexidecimal format
042AC1             0290*   ; inputs: none
042AC1             0291*   ; destroys: nothing
042AC1             0292*   print_hex_hl:
042AC1 F5          0293*       push af
042AC2 E5          0294*       push hl
042AC3 21 BD 02 04 0295*       ld hl,str_hlu
042AC7 CD 67 00 04 0296*       call printString
042ACB E1          0297*       pop hl
042ACC E5          0298*       push hl
042ACD CD A0 00 04 0299*       call printHex24
042AD1 3E 20       0300*       ld a,' '
042AD3 5B D7       0301*       rst.lil 10h
042AD5 E1          0302*       pop hl
042AD6 F1          0303*       pop af
042AD7 C9          0304*       ret
042AD8             0305*   
042AD8             0306*   ; print bcu to screen in hexidecimal format
042AD8             0307*   ; inputs: none
042AD8             0308*   ; destroys: nothing
042AD8             0309*   print_hex_bc:
042AD8 F5          0310*       push af
042AD9 E5          0311*       push hl
042ADA C5          0312*       push bc
042ADB 21 C2 02 04 0313*       ld hl,str_bcu
042ADF CD 67 00 04 0314*       call printString
042AE3 E1          0315*       pop hl
042AE4 E5          0316*       push hl
042AE5 CD A0 00 04 0317*       call printHex24
042AE9 3E 20       0318*       ld a,' '
042AEB 5B D7       0319*       rst.lil 10h
042AED C1          0320*       pop bc
042AEE E1          0321*       pop hl
042AEF F1          0322*       pop af
042AF0 C9          0323*       ret
042AF1             0324*   
042AF1             0325*   ; print deu to screen in hexidecimal format
042AF1             0326*   ; inputs: none
042AF1             0327*   ; destroys: nothing
042AF1             0328*   print_hex_de:
042AF1 F5          0329*       push af
042AF2 E5          0330*       push hl
042AF3 D5          0331*       push de
042AF4 21 C7 02 04 0332*       ld hl,str_deu
042AF8 CD 67 00 04 0333*       call printString
042AFC E1          0334*       pop hl
042AFD E5          0335*       push hl
042AFE CD A0 00 04 0336*       call printHex24
042B02 3E 20       0337*       ld a,' '
042B04 5B D7       0338*       rst.lil 10h
042B06 D1          0339*       pop de
042B07 E1          0340*       pop hl
042B08 F1          0341*       pop af
042B09 C9          0342*       ret
042B0A             0343*   
042B0A             0344*   
042B0A             0345*   ; inputs: whatever is in the flags register
042B0A             0346*   ; outputs: binary representation of flags
042B0A             0347*   ;          with a header so we know which is what
042B0A             0348*   ; destroys: nothing
042B0A             0349*   ; preserves: everything
042B0A             0350*   dumpFlags:
042B0A             0351*   ; first we curse zilog for not giving direct access to flags
042B0A F5          0352*       push af ; this is so we can send it back unharmed
042B0B F5          0353*       push af ; this is so we can pop it to hl
042B0C             0354*   ; store everything in scratch
042B0C 22 35 03 04 0355*       ld (uhl),hl
042B10 ED 43 38 03 0356*       ld (ubc),bc
       04          
042B15 ED 53 3B 03 0357*       ld (ude),de
       04          
042B1A DD 22 3E 03 0358*       ld (uix),ix
       04          
042B1F FD 22 41 03 0359*       ld (uiy),iy
       04          
042B24             0360*   ; next we print the header
042B24 21 50 2B 04 0361*       ld hl,@header
042B28 CD 67 00 04 0362*       call printString
042B2C E1          0363*       pop hl ; flags are now in l
042B2D 7D          0364*       ld a,l ; flags are now in a
042B2E CD 6E 02 04 0365*       call printBin8
042B32 CD 7C 00 04 0366*       call printNewLine
042B36             0367*   ; restore everything
042B36 2A 35 03 04 0368*       ld hl, (uhl)
042B3A ED 4B 38 03 0369*       ld bc, (ubc)
       04          
042B3F ED 5B 3B 03 0370*       ld de, (ude)
       04          
042B44 DD 2A 3E 03 0371*       ld ix, (uix)
       04          
042B49 FD 2A 41 03 0372*       ld iy, (uiy)
       04          
042B4E F1          0373*       pop af ; send her home the way she came
042B4F C9          0374*       ret
042B50             0375*   ; Bit 7 (S): Sign flag
042B50             0376*   ; Bit 6 (Z): Zero flag
042B50             0377*   ; Bit 5 (5): Reserved (copy of bit 5 of the result)
042B50             0378*   ; Bit 4 (H): Half Carry flag
042B50             0379*   ; Bit 3 (3): Reserved (copy of bit 3 of the result)
042B50             0380*   ; Bit 2 (PV): Parity/Overflow flag
042B50             0381*   ; Bit 1 (N): Subtract flag
042B50             0382*   ; Bit 0 (C): Carry flag
042B50 53 5A 78 48 0383*   @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
042B5B             0384*   
042B5B             0385*   
042B5B             0386*   ; print bytes from an address to the screen in hexidecimal format
042B5B             0387*   ; inputs: hl = address of first byte to print, a = number of bytes to print
042B5B             0388*   ; outputs: values of each byte printed to screen separated by spaces
042B5B             0389*   ; destroys: nothing
042B5B             0390*   dumpMemoryHex:
042B5B             0391*   ; save registers to the stack
042B5B C5          0392*       push bc
042B5C E5          0393*       push hl
042B5D F5          0394*       push af
042B5E             0395*   
042B5E             0396*   ; print the address and separator
042B5E CD A0 00 04 0397*       call printHex24
042B62 3E 3A       0398*       ld a,':'
042B64 5B D7       0399*       rst.lil 10h
042B66 3E 20       0400*       ld a,' '
042B68 5B D7       0401*       rst.lil 10h
042B6A             0402*   
042B6A             0403*   ; set b to be our loop counter
042B6A F1          0404*       pop af
042B6B 47          0405*       ld b,a
042B6C E1          0406*       pop hl
042B6D E5          0407*       push hl
042B6E F5          0408*       push af
042B6F             0409*   @loop:
042B6F             0410*   ; print the byte
042B6F 7E          0411*       ld a,(hl)
042B70 CD AE 00 04 0412*       call printHex8
042B74             0413*   ; print a space
042B74 3E 20       0414*       ld a,' '
042B76 5B D7       0415*       rst.lil 10h
042B78 23          0416*       inc hl
042B79 10 F4       0417*       djnz @loop
042B7B CD 7C 00 04 0418*       call printNewLine
042B7F             0419*   
042B7F             0420*   ; restore everything
042B7F F1          0421*       pop af
042B80 E1          0422*       pop hl
042B81 C1          0423*       pop bc
042B82             0424*   
042B82             0425*   ; all done
042B82 C9          0426*       ret
042B83             0427*   
042B83             0428*   
042B83             0429*   ; print bytes from an address to the screen in binary format
042B83             0430*   ; inputs: hl = address of first byte to print, a = number of bytes to print
042B83             0431*   ; outputs: values of each byte printed to screen separated by spaces
042B83             0432*   ; destroys: nothing
042B83             0433*   dumpMemoryBin:
042B83             0434*   ; save all registers to the stack
042B83 F5          0435*       push af
042B84 C5          0436*       push bc
042B85 D5          0437*       push de
042B86 E5          0438*       push hl
042B87 DD E5       0439*       push ix
042B89 FD E5       0440*       push iy
042B8B             0441*   
042B8B             0442*   ; set b to be our loop counter
042B8B 47          0443*       ld b,a
042B8C             0444*   @loop:
042B8C             0445*   ; print the byte
042B8C 7E          0446*       ld a,(hl)
042B8D E5          0447*       push hl
042B8E C5          0448*       push bc
042B8F CD 6E 02 04 0449*       call printBin8
042B93 C1          0450*       pop bc
042B94             0451*   ; print a space
042B94 3E 20       0452*       ld a,' '
042B96 5B D7       0453*       rst.lil 10h
042B98 E1          0454*       pop hl
042B99 23          0455*       inc hl
042B9A 10 F0       0456*       djnz @loop
042B9C CD 7C 00 04 0457*       call printNewLine
042BA0             0458*   
042BA0             0459*   ; restore everything
042BA0 FD E1       0460*       pop iy
042BA2 DD E1       0461*       pop ix
042BA4 E1          0462*       pop hl
042BA5 D1          0463*       pop de
042BA6 C1          0464*       pop bc
042BA7 F1          0465*       pop af
042BA8             0466*   ; all done
042BA8 C9          0467*       ret
042BA9             0468*   
042BA9             0469*   ; print bytes from an address to the screen in binary format
042BA9             0470*   ; with the bits of each byte in reverse order (lsb first)
042BA9             0471*   ; inputs: hl = address of first byte to print, a = number of bytes to print
042BA9             0472*   ; outputs: values of each byte printed to screen separated by spaces
042BA9             0473*   ; destroys: nothing
042BA9             0474*   dumpMemoryBinRev:
042BA9             0475*   ; save all registers to the stack
042BA9 F5          0476*       push af
042BAA C5          0477*       push bc
042BAB D5          0478*       push de
042BAC E5          0479*       push hl
042BAD DD E5       0480*       push ix
042BAF FD E5       0481*       push iy
042BB1             0482*   
042BB1             0483*   ; set b to be our loop counter
042BB1 47          0484*       ld b,a
042BB2             0485*   @loop:
042BB2             0486*   ; print the byte
042BB2 7E          0487*       ld a,(hl)
042BB3 E5          0488*       push hl
042BB4 C5          0489*       push bc
042BB5 CD 93 02 04 0490*       call printBin8Rev
042BB9 C1          0491*       pop bc
042BBA             0492*   ; print a space
042BBA 3E 20       0493*       ld a,' '
042BBC 5B D7       0494*       rst.lil 10h
042BBE E1          0495*       pop hl
042BBF 23          0496*       inc hl
042BC0 10 F0       0497*       djnz @loop
042BC2 CD 7C 00 04 0498*       call printNewLine
042BC6             0499*   
042BC6             0500*   ; restore everything
042BC6 FD E1       0501*       pop iy
042BC8 DD E1       0502*       pop ix
042BCA E1          0503*       pop hl
042BCB D1          0504*       pop de
042BCC C1          0505*       pop bc
042BCD F1          0506*       pop af
042BCE             0507*   ; all done
042BCE C9          0508*       ret
042BCF             0509*   
042BCF             0510*   DEBUG_PRINT:
042BCF             0511*       PUSH_ALL
042BCF 08          0001*M1     ex af,af'
042BD0 D9          0002*M1     exx
042BD1 F5          0003*M1     push af
042BD2 E5          0004*M1     push hl
042BD3 C5          0005*M1     push bc
042BD4 D5          0006*M1     push de
042BD5             0007*M1 
042BD5 08          0008*M1     ex af,af'
042BD6 D9          0009*M1     exx
042BD7 F5          0010*M1     push af
042BD8 E5          0011*M1     push hl
042BD9 C5          0012*M1     push bc
042BDA D5          0013*M1     push de
042BDB DD E5       0014*M1     push ix
042BDD FD E5       0015*M1     push iy
042BDF             0512*       ; ld c,0 ; X
042BDF             0513*       ; ld b,0 ; Y
042BDF             0514*       ; call vdu_move_cursor
042BDF CD 7C 00 04 0515*       call printNewLine
042BE3             0516*       POP_ALL
042BE3 FD E1       0001*M1     pop iy
042BE5 DD E1       0002*M1     pop ix
042BE7 D1          0003*M1     pop de
042BE8 C1          0004*M1     pop bc
042BE9 E1          0005*M1     pop hl
042BEA F1          0006*M1     pop af
042BEB 08          0007*M1     ex af,af'
042BEC D9          0008*M1     exx
042BED             0009*M1 
042BED D1          0010*M1     pop de
042BEE C1          0011*M1     pop bc
042BEF E1          0012*M1     pop hl
042BF0 F1          0013*M1     pop af
042BF1 08          0014*M1     ex af,af'
042BF2 D9          0015*M1     exx
042BF3             0517*       PUSH_ALL
042BF3 08          0001*M1     ex af,af'
042BF4 D9          0002*M1     exx
042BF5 F5          0003*M1     push af
042BF6 E5          0004*M1     push hl
042BF7 C5          0005*M1     push bc
042BF8 D5          0006*M1     push de
042BF9             0007*M1 
042BF9 08          0008*M1     ex af,af'
042BFA D9          0009*M1     exx
042BFB F5          0010*M1     push af
042BFC E5          0011*M1     push hl
042BFD C5          0012*M1     push bc
042BFE D5          0013*M1     push de
042BFF DD E5       0014*M1     push ix
042C01 FD E5       0015*M1     push iy
042C03 CD 0A 2B 04 0518*       call dumpFlags
042C07             0519*       POP_ALL
042C07 FD E1       0001*M1     pop iy
042C09 DD E1       0002*M1     pop ix
042C0B D1          0003*M1     pop de
042C0C C1          0004*M1     pop bc
042C0D E1          0005*M1     pop hl
042C0E F1          0006*M1     pop af
042C0F 08          0007*M1     ex af,af'
042C10 D9          0008*M1     exx
042C11             0009*M1 
042C11 D1          0010*M1     pop de
042C12 C1          0011*M1     pop bc
042C13 E1          0012*M1     pop hl
042C14 F1          0013*M1     pop af
042C15 08          0014*M1     ex af,af'
042C16 D9          0015*M1     exx
042C17             0520*       PUSH_ALL
042C17 08          0001*M1     ex af,af'
042C18 D9          0002*M1     exx
042C19 F5          0003*M1     push af
042C1A E5          0004*M1     push hl
042C1B C5          0005*M1     push bc
042C1C D5          0006*M1     push de
042C1D             0007*M1 
042C1D 08          0008*M1     ex af,af'
042C1E D9          0009*M1     exx
042C1F F5          0010*M1     push af
042C20 E5          0011*M1     push hl
042C21 C5          0012*M1     push bc
042C22 D5          0013*M1     push de
042C23 DD E5       0014*M1     push ix
042C25 FD E5       0015*M1     push iy
042C27 CD F6 29 04 0521*       call dumpRegistersHex
042C2B             0522*       ; call waitKeypress
042C2B CD 7C 00 04 0523*       call printNewLine
042C2F             0524*       POP_ALL
042C2F FD E1       0001*M1     pop iy
042C31 DD E1       0002*M1     pop ix
042C33 D1          0003*M1     pop de
042C34 C1          0004*M1     pop bc
042C35 E1          0005*M1     pop hl
042C36 F1          0006*M1     pop af
042C37 08          0007*M1     ex af,af'
042C38 D9          0008*M1     exx
042C39             0009*M1 
042C39 D1          0010*M1     pop de
042C3A C1          0011*M1     pop bc
042C3B E1          0012*M1     pop hl
042C3C F1          0013*M1     pop af
042C3D 08          0014*M1     ex af,af'
042C3E D9          0015*M1     exx
042C3F C9          0525*       ret
042C40             0526*   DEBUG_WAITKEYPRESS:
042C40             0527*       PUSH_ALL
042C40 08          0001*M1     ex af,af'
042C41 D9          0002*M1     exx
042C42 F5          0003*M1     push af
042C43 E5          0004*M1     push hl
042C44 C5          0005*M1     push bc
042C45 D5          0006*M1     push de
042C46             0007*M1 
042C46 08          0008*M1     ex af,af'
042C47 D9          0009*M1     exx
042C48 F5          0010*M1     push af
042C49 E5          0011*M1     push hl
042C4A C5          0012*M1     push bc
042C4B D5          0013*M1     push de
042C4C DD E5       0014*M1     push ix
042C4E FD E5       0015*M1     push iy
042C50 CD 5A 03 04 0528*       call waitKeypress
042C54             0529*       POP_ALL
042C54 FD E1       0001*M1     pop iy
042C56 DD E1       0002*M1     pop ix
042C58 D1          0003*M1     pop de
042C59 C1          0004*M1     pop bc
042C5A E1          0005*M1     pop hl
042C5B F1          0006*M1     pop af
042C5C 08          0007*M1     ex af,af'
042C5D D9          0008*M1     exx
042C5E             0009*M1 
042C5E D1          0010*M1     pop de
042C5F C1          0011*M1     pop bc
042C60 E1          0012*M1     pop hl
042C61 F1          0013*M1     pop af
042C62 08          0014*M1     ex af,af'
042C63 D9          0015*M1     exx
042C64 C9          0530*       RET
042C65             0531*   
042C65             0532*   dumpVduCmdStr:
042C65             0533*       PUSH_ALL
042C65 08          0001*M1     ex af,af'
042C66 D9          0002*M1     exx
042C67 F5          0003*M1     push af
042C68 E5          0004*M1     push hl
042C69 C5          0005*M1     push bc
042C6A D5          0006*M1     push de
042C6B             0007*M1 
042C6B 08          0008*M1     ex af,af'
042C6C D9          0009*M1     exx
042C6D F5          0010*M1     push af
042C6E E5          0011*M1     push hl
042C6F C5          0012*M1     push bc
042C70 D5          0013*M1     push de
042C71 DD E5       0014*M1     push ix
042C73 FD E5       0015*M1     push iy
042C75 79          0534*       ld a,c
042C76 CD 5B 2B 04 0535*       call dumpMemoryHex
042C7A CD 5A 03 04 0536*       call waitKeypress
042C7E             0537*       POP_ALL
042C7E FD E1       0001*M1     pop iy
042C80 DD E1       0002*M1     pop ix
042C82 D1          0003*M1     pop de
042C83 C1          0004*M1     pop bc
042C84 E1          0005*M1     pop hl
042C85 F1          0006*M1     pop af
042C86 08          0007*M1     ex af,af'
042C87 D9          0008*M1     exx
042C88             0009*M1 
042C88 D1          0010*M1     pop de
042C89 C1          0011*M1     pop bc
042C8A E1          0012*M1     pop hl
042C8B F1          0013*M1     pop af
042C8C 08          0014*M1     ex af,af'
042C8D D9          0015*M1     exx
042C8E C9          0538*       ret
042C8F             0539*   ; end dumpVduCmdStr
042C8F             0052    
042C8F             0053    ; --- MAIN PROGRAM FILE ---
042C8F 00          0054    original_screen_mode: db 0
042C90             0055    
042C90             0056    init:
042C90 C9          0057        ret
042C91             0058    ; end init
042C91             0059    
042C91 63 64 20 6D 0060    cmd_cd_music: asciz "cd music"
       75 73 69 63 
       00          
042C9A 63 64 20 2E 0061    cmd_cd_up: asciz "cd .."
       2E 00       
042CA0 2D 2D 2D 2D 0062    str_dashes: asciz "------------------------------"
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 00    
042CBF 3D 3D 3D 3D 0063    str_thick_dashes: asciz "=============================="
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 00    
042CDE             0064    
042CDE             0065    main:
042CDE             0066    ; change directory to music
042CDE 21 91 2C 04 0067        ld hl,cmd_cd_music
042CE2             0068        MOSCALL mos_oscli
042CE2 3E 10       0001M1  			LD	A, function
042CE4 5B CF       0002M1  			RST.LIL	08h
042CE6             0069    
042CE6             0070    ; initialize the current directory
042CE6 CD 25 26 04 0071        call ps_get_dir
042CEA             0072    
042CEA             0073    ; list the first page of the directory
042CEA CD 60 00 04 0074        call printInline
042CEE 0D 0A 50 61 0075        asciz "\r\nPage 0\r\n"
       67 65 20 30 
       0D 0A 00    
042CF9 21 00 00 00 0076        ld hl,0
042CFD 22 87 23 04 0077        ld (ps_page_cur),hl
042D01 CD B7 26 04 0078        call ps_fill_page_fn_ptrs
042D05 CD DD 26 04 0079        call ps_print_dir_page
042D09             0080    
042D09             0081    ; list the second page of the directory
042D09 CD 60 00 04 0082        call printInline
042D0D 0D 0A 50 61 0083        asciz "\r\nPage 1\r\n"
       67 65 20 31 
       0D 0A 00    
042D18 21 01 00 00 0084        ld hl,1
042D1C 22 87 23 04 0085        ld (ps_page_cur),hl
042D20 CD B7 26 04 0086        call ps_fill_page_fn_ptrs
042D24 CD DD 26 04 0087        call ps_print_dir_page
042D28             0088    
042D28             0089    ; list the third page of the directory
042D28 CD 60 00 04 0090        call printInline
042D2C 0D 0A 50 61 0091        asciz "\r\nPage 2\r\n"
       67 65 20 32 
       0D 0A 00    
042D37 21 02 00 00 0092        ld hl,2
042D3B 22 87 23 04 0093        ld (ps_page_cur),hl
042D3F CD B7 26 04 0094        call ps_fill_page_fn_ptrs
042D43 CD DD 26 04 0095        call ps_print_dir_page
042D47             0096    
042D47             0097    ; change back to directory containing the program
042D47 21 9A 2C 04 0098        ld hl,cmd_cd_up
042D4B             0099        MOSCALL mos_oscli
042D4B 3E 10       0001M1  			LD	A, function
042D4D 5B CF       0002M1  			RST.LIL	08h
042D4F C9          0100        ret ; back to MOS
042D50             0101    ; end main
042D50             0102    
042D50             0103    ; must be final include in program so file data does not stomp on program code or other data
042D50             0104        include "files.inc"
042D50             0001*   ; THIS MUST BE LAST INCLUDE SO FILE DATA DOES NOT OVERWRITE OTHER CODE OR DATA
042D50             0002*   
042D50             0003*   ; buffer for loading files unrelated to audio
042D50             0004*   ; e.g.: fonts, sprites, etc. (limited to 8k)
042D50             0005*   filedata: equ 0xB7E000 ; address of onboard 8k sram
042D50             0006*   
042D50             0007*   ;     align 256 ; make things nice for indexing into especially ps_dir_fil_list
042D50             0008*   ; ; buffer for sound data
042D50             0009*   ps_wav_data_start: equ 0x050000 ;    equ $   ; (042E00) Start of audio data
042D50             0010*   
042D50             0011*   ; this list can grow as large as necessary to hold all the files in the directory
042D50             0012*   ; each entry will be 256 bytes long, the max filename size MOS/FFS supports
042D50             0013*   ps_dir_fil_list: equ 0x060000 ; equ ps_wav_data_start+65536 ; (052E00) max file data we can load in one chunk is 64k
