PC     Output      Line
040000             0001        assume adl=1
040000             0002        org 0x040000
040000 C3 45 00 04 0003        jp start
040004 FF FF FF FF 0004        align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0005        db "MOS"
040043 00          0006        db 00h
040044 01          0007        db 01h
040045             0008    
040045             0009    start:
040045             0010        ; push af
040045             0011        ; push bc
040045             0012        ; push de
040045             0013        ; push ix
040045             0014        ; push iy
040045             0015    
040045             0016        ; call init
040045             0017        ; call main
040045             0018    
040045 C3 6C 2E 04 0019        jp main
040049             0020    
040049             0021    exit:
040049             0022        ; pop iy
040049             0023        ; pop ix
040049             0024        ; pop de
040049             0025        ; pop bc
040049             0026        ; pop af
040049 21 00 00 00 0027        ld hl,0
04004D             0028    
04004D C9          0029        ret
04004E             0030    
04004E             0031    ; API INCLUDES
04004E             0032        include "mos_api.inc"
04004E             0001*   ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.inc
04004E             0002*   ; Title:	AGON MOS - API for user projects
04004E             0003*   ; Author:	Dean Belfield
04004E             0004*   ;			Adapted for agon-ez80asm by Jeroen Venema
04004E             0005*   ;			Added MOS error codes for return in HL
04004E             0006*   ; Created:	03/08/2022
04004E             0007*   ; Last Updated:	10/08/2023
04004E             0008*   ;
04004E             0009*   ; Modinfo:
04004E             0010*   ; 05/08/2022:	Added mos_feof
04004E             0011*   ; 09/08/2022:	Added system variables: cursorX, cursorY
04004E             0012*   ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
04004E             0013*   ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
04004E             0014*   ; 24/09/2022:	Added mos_getError, mos_mkdir
04004E             0015*   ; 13/10/2022:	Added mos_oscli
04004E             0016*   ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
04004E             0017*   ; 04/03/2023:	Added sysvar_scrpixelIndex
04004E             0018*   ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
04004E             0019*   ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
04004E             0020*   ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
04004E             0021*   ; 22/03/2023:	The VDP commands are now indexed from 0x80
04004E             0022*   ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
04004E             0023*   ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
04004E             0024*   ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
04004E             0025*   ; 19/05/2023:	Added sysvar_scrMode
04004E             0026*   ; 05/06/2023:	Added sysvar_rtcEnable
04004E             0027*   ; 03/08/2023:	Added mos_setkbvector
04004E             0028*   ; 10/08/2023:	Added mos_getkbmap
04004E             0029*   
04004E             0030*   ; VDP control (VDU 23, 0, n)
04004E             0031*   ;
04004E             0032*   vdp_gp:				EQU 80h
04004E             0033*   vdp_keycode:		EQU 81h
04004E             0034*   vdp_cursor:			EQU	82h
04004E             0035*   vdp_scrchar:		EQU	83h
04004E             0036*   vdp_scrpixel:		EQU	84h
04004E             0037*   vdp_audio:			EQU	85h
04004E             0038*   vdp_mode:			EQU	86h
04004E             0039*   vdp_rtc:			EQU	87h
04004E             0040*   vdp_keystate:		EQU	88h
04004E             0041*   vdp_logicalcoords:	EQU	C0h
04004E             0042*   vdp_terminalmode:	EQU	FFh
04004E             0043*   
04004E             0044*   ; MOS high level functions
04004E             0045*   ;
04004E             0046*   mos_getkey:			EQU	00h
04004E             0047*   mos_load:			EQU	01h
04004E             0048*   mos_save:			EQU	02h
04004E             0049*   mos_cd:				EQU	03h
04004E             0050*   mos_dir:			EQU	04h
04004E             0051*   mos_del:			EQU	05h
04004E             0052*   mos_ren:			EQU	06h
04004E             0053*   mos_mkdir:			EQU	07h
04004E             0054*   mos_sysvars:		EQU	08h
04004E             0055*   mos_editline:		EQU	09h
04004E             0056*   mos_fopen:			EQU	0Ah
04004E             0057*   mos_fclose:			EQU	0Bh
04004E             0058*   mos_fgetc:			EQU	0Ch
04004E             0059*   mos_fputc:			EQU	0Dh
04004E             0060*   mos_feof:			EQU	0Eh
04004E             0061*   mos_getError:		EQU	0Fh
04004E             0062*   mos_oscli:			EQU	10h
04004E             0063*   mos_copy:			EQU	11h
04004E             0064*   mos_getrtc:			EQU	12h
04004E             0065*   mos_setrtc:			EQU	13h
04004E             0066*   mos_setintvector:	EQU	14h
04004E             0067*   mos_uopen:			EQU	15h
04004E             0068*   mos_uclose:			EQU	16h
04004E             0069*   mos_ugetc:			EQU	17h
04004E             0070*   mos_uputc:			EQU	18h
04004E             0071*   mos_getfil:			EQU	19h
04004E             0072*   mos_fread:			EQU	1Ah
04004E             0073*   mos_fwrite:			EQU	1Bh
04004E             0074*   mos_flseek:			EQU	1Ch
04004E             0075*   mos_setkbvector:	EQU	1Dh
04004E             0076*   mos_getkbmap:		EQU	1Eh
04004E             0077*   
04004E             0078*   ; MOS program exit codes
04004E             0079*   ;
04004E             0080*   EXIT_OK:				EQU  0;	"OK",
04004E             0081*   EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
04004E             0082*   EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
04004E             0083*   EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
04004E             0084*   EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
04004E             0085*   EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
04004E             0086*   EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
04004E             0087*   EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
04004E             0088*   EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
04004E             0089*   EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
04004E             0090*   EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
04004E             0091*   EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
04004E             0092*   EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
04004E             0093*   EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
04004E             0094*   EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
04004E             0095*   EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
04004E             0096*   EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
04004E             0097*   EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
04004E             0098*   EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
04004E             0099*   EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
04004E             0100*   EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
04004E             0101*   EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
04004E             0102*   ; FatFS file access functions
04004E             0103*   ;
04004E             0104*   ffs_fopen:			EQU	80h
04004E             0105*   ffs_fclose:			EQU	81h
04004E             0106*   ffs_fread:			EQU	82h
04004E             0107*   ffs_fwrite:			EQU	83h
04004E             0108*   ffs_flseek:			EQU	84h
04004E             0109*   ffs_ftruncate:		EQU	85h
04004E             0110*   ffs_fsync:			EQU	86h
04004E             0111*   ffs_fforward:		EQU	87h
04004E             0112*   ffs_fexpand:		EQU	88h
04004E             0113*   ffs_fgets:			EQU	89h
04004E             0114*   ffs_fputc:			EQU	8Ah
04004E             0115*   ffs_fputs:			EQU	8Bh
04004E             0116*   ffs_fprintf:		EQU	8Ch
04004E             0117*   ffs_ftell:			EQU	8Dh
04004E             0118*   ffs_feof:			EQU	8Eh
04004E             0119*   ffs_fsize:			EQU	8Fh
04004E             0120*   ffs_ferror:			EQU	90h
04004E             0121*   
04004E             0122*   ; FatFS directory access functions
04004E             0123*   ;
04004E             0124*   ffs_dopen:			EQU	91h
04004E             0125*   ffs_dclose:			EQU	92h
04004E             0126*   ffs_dread:			EQU	93h
04004E             0127*   ffs_dfindfirst:		EQU	94h
04004E             0128*   ffs_dfindnext:		EQU	95h
04004E             0129*   
04004E             0130*   ; FatFS file and directory management functions
04004E             0131*   ;
04004E             0132*   ffs_stat:			EQU	96h
04004E             0133*   ffs_unlink:			EQU	97h
04004E             0134*   ffs_rename:			EQU	98h
04004E             0135*   ffs_chmod:			EQU	99h
04004E             0136*   ffs_utime:			EQU	9Ah
04004E             0137*   ffs_mkdir:			EQU	9Bh
04004E             0138*   ffs_chdir:			EQU	9Ch
04004E             0139*   ffs_chdrive:		EQU	9Dh
04004E             0140*   ffs_getcwd:			EQU	9Eh
04004E             0141*   
04004E             0142*   ; FatFS volume management and system configuration functions
04004E             0143*   ;
04004E             0144*   ffs_mount:			EQU	9Fh
04004E             0145*   ffs_mkfs:			EQU	A0h
04004E             0146*   ffs_fdisk:			EQU	A1h
04004E             0147*   ffs_getfree:		EQU	A2h
04004E             0148*   ffs_getlabel:		EQU	A3h
04004E             0149*   ffs_setlabel:		EQU	A4h
04004E             0150*   ffs_setcp:			EQU	A5h
04004E             0151*   
04004E             0152*   ; File access modes
04004E             0153*   ;
04004E             0154*   fa_read:			EQU	01h
04004E             0155*   fa_write:			EQU	02h
04004E             0156*   fa_open_existing:	EQU	00h
04004E             0157*   fa_create_new:		EQU	04h
04004E             0158*   fa_create_always:	EQU	08h
04004E             0159*   fa_open_always:		EQU	10h
04004E             0160*   fa_open_append:		EQU	30h
04004E             0161*   
04004E             0162*   ; System variable indexes for api_sysvars
04004E             0163*   ; Index into _sysvars in globals.inc
04004E             0164*   ;
04004E             0165*   sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
04004E             0166*   sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
04004E             0167*   sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
04004E             0168*   sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
04004E             0169*   sysvar_cursorX:			EQU	07h	; 1: Cursor X position
04004E             0170*   sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
04004E             0171*   sysvar_scrchar:			EQU	09h	; 1: Character read from screen
04004E             0172*   sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
04004E             0173*   sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
04004E             0174*   sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
04004E             0175*   sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
04004E             0176*   sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
04004E             0177*   sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
04004E             0178*   sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
04004E             0179*   sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
04004E             0180*   sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
04004E             0181*   sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
04004E             0182*   sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
04004E             0183*   sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
04004E             0184*   sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
04004E             0185*   sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
04004E             0186*   sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
04004E             0187*   sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
04004E             0188*   sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
04004E             0189*   sysvar_scrMode:			EQU	27h	; 1: Screen mode
04004E             0190*   sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
04004E             0191*   
04004E             0192*   ; Flags for the VPD protocol
04004E             0193*   ;
04004E             0194*   vdp_pflag_cursor:		EQU	00000001b
04004E             0195*   vdp_pflag_scrchar:		EQU	00000010b
04004E             0196*   vdp_pflag_point:		EQU	00000100b
04004E             0197*   vdp_pflag_audio:		EQU	00001000b
04004E             0198*   vdp_pflag_mode:			EQU	00010000b
04004E             0199*   vdp_pflag_rtc:			EQU	00100000b
04004E             0200*   
04004E             0201*   ;
04004E             0202*   ; FatFS structures
04004E             0203*   ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
04004E             0204*   ;
04004E             0205*   ; Object ID and allocation information (FFOBJID)
04004E             0206*   ;
04004E             0207*   ; Indexes into FFOBJID structure
04004E             0208*   ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
04004E             0209*   ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
04004E             0210*   ffobjid_attr:		EQU	5	; 1: Object attribute
04004E             0211*   ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
04004E             0212*   ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
04004E             0213*   ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
04004E             0214*   ;
04004E             0215*   ; File object structure (FIL)
04004E             0216*   ;
04004E             0217*   ; Indexes into FIL structure
04004E             0218*   fil_obj:		EQU 0	; 15: Object identifier
04004E             0219*   fil_flag:		EQU	15 	;  1: File status flags
04004E             0220*   fil_err:		EQU	16	;  1: Abort flag (error code)
04004E             0221*   fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
04004E             0222*   fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
04004E             0223*   fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
04004E             0224*   fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
04004E             0225*   fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
04004E             0226*   ;
04004E             0227*   ; Directory object structure (DIR)
04004E             0228*   ; Indexes into DIR structure
04004E             0229*   dir_obj:		EQU  0	; 15: Object identifier
04004E             0230*   dir_dptr:		EQU	15	;  4: Current read/write offset
04004E             0231*   dir_clust:		EQU	19	;  4: Current cluster
04004E             0232*   dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
04004E             0233*   dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
04004E             0234*   dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
04004E             0235*   dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
04004E             0236*   ;
04004E             0237*   ; File information structure (FILINFO)
04004E             0238*   ;
04004E             0239*   ; Indexes into FILINFO structure
04004E             0240*   filinfo_fsize:		EQU 0	;   4: File size
04004E             0241*   filinfo_fdate:		EQU	4	;   2: Modified date
04004E             0242*   filinfo_ftime:		EQU	6	;   2: Modified time
04004E             0243*   filinfo_fattrib:	EQU	8	;   1: File attribute
04004E             0244*   filinfo_altname:	EQU	9	;  13: Alternative file name
04004E             0245*   filinfo_fname:		EQU	22	; 256: Primary file name
04004E             0246*   ;
04004E             0247*   ; Macro for calling the API
04004E             0248*   ; Parameters:
04004E             0249*   ; - function: One of the function numbers listed above
04004E             0250*   ;
04004E             0251*   	MACRO	MOSCALL	function
04004E             0252*   			LD	A, function
04004E             0253*   			RST.LIL	08h
04004E             0254*   	ENDMACRO
04004E             0033        include "macros.inc"
04004E             0001*   
04004E             0002*   ; test the sign of HL
04004E             0003*   ; inputs: HL obviously
04004E             0004*   ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
04004E             0005*   ; destroys: flags
04004E             0006*       MACRO SIGN_HLU
04004E             0007*       add hl,de ; 1 cycle
04004E             0008*       or a ; clear flags ; 1 cycle
04004E             0009*       sbc hl,de ; 2 cycles
04004E             0010*       ; 4 cycles total
04004E             0011*       ENDMACRO
04004E             0012*   
04004E             0013*   ; put the value in A into HLU
04004E             0014*   ; affects: HLU
04004E             0015*   ; destroys: nothing
04004E             0016*   ; note: $ instead of @@ b/c anon labels deprecated in ez80asm
04004E             0017*       MACRO A_TO_HLU
04004E             0018*       xor a ; 1 cycle
04004E             0019*       ld ($+8+1),hl ; 7 cycles
04004E             0020*       ld ($+4+3),a ; 5 cycles
04004E             0021*       ld hl,0x000000 ; 4 cycles
04004E             0022*       ; 17 cycles total
04004E             0023*       ENDMACRO
04004E             0024*   
04004E             0025*   ; alternative: https://discord.com/channels/1158535358624039014/1282290921815408681/1318315567102300220
04004E             0026*   ; one cycle less but burns flags
04004E             0027*       MACRO A_TO_HLU_ALT
04004E             0028*       push hl ; 4 cycles
04004E             0029*       ld hl,2 ; 4 cycles
04004E             0030*       add hl,sp ; 1 cycle
04004E             0031*       ld (hl),a ; 2 cycles
04004E             0032*       pop hl ; 4 cycles
04004E             0033*       ; 15 cycles total
04004E             0034*       ENDMACRO
04004E             0035*   
04004E             0036*       MACRO hlu_mul256
04004E             0037*       add hl,hl ; * 2
04004E             0038*       add hl,hl ; * 4
04004E             0039*       add hl,hl ; * 8
04004E             0040*       add hl,hl ; * 16
04004E             0041*       add hl,hl ; * 32
04004E             0042*       add hl,hl ; * 64
04004E             0043*       add hl,hl ; * 128
04004E             0044*       add hl,hl ; * 256
04004E             0045*       ENDMACRO
04004E             0046*   
04004E             0047*   ; https://discord.com/channels/1158535358624039014/1282290921815408681/1317793870070812715
04004E             0048*       MACRO SRL_UHL
04004E             0049*       dec sp ; 1 cycle
04004E             0050*       push hl ; 4 cycles
04004E             0051*       inc sp ; 1 cycle
04004E             0052*       pop hl ; 4 cycles
04004E             0053*       inc hl ; 1 cycle
04004E             0054*       dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
04004E             0055*       ; 13 cycles total
04004E             0056*       ENDMACRO
04004E             0057*   
04004E             0058*       MACRO printChar char
04004E             0059*       LD A, char
04004E             0060*       RST.LIL 10h
04004E             0061*       ENDMACRO
04004E             0062*   
04004E             0063*   ; Simulated call to subroutine at HL
04004E             0064*   ; inputs: HL pointing to the subroutine address plus whatever the called function expects
04004E             0065*   ; outputs: whatever the subroutine does, including HL and BC
04004E             0066*   ; destroys: only what the subroutine does, but always BC
04004E             0067*       MACRO CALL_HL
04004E             0068*       ld bc,$+6 ; Address of first instruction after the jump
04004E             0069*       push bc ; which constitutes the return address
04004E             0070*       jp (hl) ; Jump to the address in HL
04004E             0071*       ENDMACRO
04004E             0072*   
04004E             0073*   ; Simulated call to subroutine at IX
04004E             0074*   ; inputs: IX pointing to the subroutine address plus whatever the called function expects
04004E             0075*   ; outputs: whatever the subroutine does, including IX and BC
04004E             0076*   ; destroys: only what the subroutine does, but always BC
04004E             0077*       MACRO CALL_IX
04004E             0078*       ld bc,$+6 ; Address of first instruction after the jump
04004E             0079*       push bc ; which constitutes the return address
04004E             0080*       jp (ix) ; Jump to the address in IX
04004E             0081*       ENDMACRO
04004E             0082*   
04004E             0083*   ; Simulated call to soubroutinte at IY
04004E             0084*   ; inputs: IY pointing to the subroutine address plus whatever the called function expects
04004E             0085*   ; outputs: whatever the subroutine does, including IY and BC
04004E             0086*   ; destroys: only what the subroutine does, but always BC
04004E             0087*       MACRO CALL_IY
04004E             0088*       ld bc,$+6 ; Address of first instruction after the jump
04004E             0089*       push bc ; which constitutes the return address
04004E             0090*       jp (iy) ; Jump to the address in IY
04004E             0091*       ENDMACRO
04004E             0092*   
04004E             0093*   ; put the value in HLU into A
04004E             0094*   ; destroys: af
04004E             0095*       MACRO HLU_TO_A
04004E             0096*       dec sp ; 1 cycle
04004E             0097*       push hl ; 4 cycles
04004E             0098*       inc sp ; 1 cycle
04004E             0099*       pop af ; 4 cycles
04004E             0100*       ; 10 cycles total
04004E             0101*       ENDMACRO
04004E             0102*   
04004E             0103*       MACRO PUSH_ALL
04004E             0104*       ex af,af'
04004E             0105*       exx
04004E             0106*       push af
04004E             0107*       push hl
04004E             0108*       push bc
04004E             0109*       push de
04004E             0110*   
04004E             0111*       ex af,af'
04004E             0112*       exx
04004E             0113*       push af
04004E             0114*       push hl
04004E             0115*       push bc
04004E             0116*       push de
04004E             0117*       push ix
04004E             0118*       push iy
04004E             0119*       ENDMACRO
04004E             0120*   
04004E             0121*       MACRO POP_ALL
04004E             0122*       pop iy
04004E             0123*       pop ix
04004E             0124*       pop de
04004E             0125*       pop bc
04004E             0126*       pop hl
04004E             0127*       pop af
04004E             0128*       ex af,af'
04004E             0129*       exx
04004E             0130*   
04004E             0131*       pop de
04004E             0132*       pop bc
04004E             0133*       pop hl
04004E             0134*       pop af
04004E             0135*       ex af,af'
04004E             0136*       exx
04004E             0137*       ENDMACRO
04004E             0034        include "functions.inc"
04004E             0001*   ; Print a zero-terminated string inline with code, e.g.:
04004E             0002*   ;
04004E             0003*   ;    call printInline
04004E             0004*   ;    ASCIZ "Hello, world!\r\n"
04004E             0005*   ;
04004E             0006*   ; Destroys: HL,AF
04004E             0007*   printInline:
04004E E1          0008*       pop hl ; get the return address = pointer to start of string
04004F CD 55 00 04 0009*       call printString ; HL advances to end of string
040053 E5          0010*       push hl ; restore the return address = pointer to end of string
040054 C9          0011*       ret
040055             0012*   
040055             0013*   ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
040055             0014*   ; Print a zero-terminated string
040055             0015*   ; HL: Pointer to string
040055             0016*   ; returns: hl pointed to character after string terminator
040055             0017*   ; destroys: af, hl
040055             0018*   printString:
040055 C5          0019*       PUSH BC
040056 01 00 00 00 0020*       LD BC,0
04005A 3E 00       0021*       LD A,0
04005C 5B DF       0022*       RST.LIL 18h
04005E C1          0023*       POP BC
04005F C9          0024*       RET
040060             0025*   ; print a VDU sequence
040060             0026*   ; HL: Pointer to VDU sequence - <1 byte length> <data>
040060             0027*   sendVDUsequence:
040060 C5          0028*       PUSH BC
040061 01 00 00 00 0029*       LD BC, 0
040065 4E          0030*       LD C, (HL)
040066 5B DF       0031*       RST.LIL 18h
040068 C1          0032*       POP BC
040069 C9          0033*       RET
04006A             0034*   ; Print Newline sequence to VDP
04006A             0035*   ; destroys: nothing
04006A             0036*   printNewLine:
04006A F5          0037*       push af ; for some reason rst.lil 10h sets carry flag
04006B 3E 0D       0038*       LD A, '\r'
04006D 5B D7       0039*       RST.LIL 10h
04006F 3E 0A       0040*       LD A, '\n'
040071 5B D7       0041*       RST.LIL 10h
040073 F1          0042*       pop af
040074 C9          0043*       RET
040075             0044*   
040075             0045*   ; print a zero-terminated string at a graphics coordinate
040075             0046*   ; Inputs: HL Pointer to string, BC,DE x,y position (in pixels)
040075             0047*   printStringGfx:
040075 E5          0048*       push hl ; preserve string pointer
040076             0049*   ; move graphics cursor to x,y location
040076 3E 44       0050*       ld a,plot_pt+mv_abs
040078 CD CC 1B 04 0051*       call vdu_plot
04007C             0052*   ; print string
04007C E1          0053*       pop hl ; restore string pointer
04007D             0054*   @print_loop:
04007D 7E          0055*       ld a,(hl)
04007E B7          0056*       or a ; check for end of string
04007F C8          0057*       ret z ; if zero, we're done
040080 08          0058*       ex af,af' ; preserve character
040081 3E 05       0059*       ld a,5 ; VDU 5 char to gfx cursor
040083 5B D7       0060*       rst.lil 10h ; send it
040085 08          0061*       ex af,af' ; restore character
040086 5B D7       0062*       rst.lil 10h ; print character
040088 23          0063*       inc hl
040089 C3 7D 00 04 0064*       jp @print_loop
04008D C9          0065*       ret
04008E             0066*   ; end printStringGfx
04008E             0067*   
04008E             0068*   ; Print a 24-bit HEX number
04008E             0069*   ; HLU: Number to print
04008E             0070*   printHex24:
04008E             0071*       HLU_TO_A
04008E 3B          0001*M1     dec sp ; 1 cycle
04008F E5          0002*M1     push hl ; 4 cycles
040090 33          0003*M1     inc sp ; 1 cycle
040091 F1          0004*M1     pop af ; 4 cycles
040092             0005*M1     ; 10 cycles total
040092 CD 9C 00 04 0072*       CALL printHex8
040096             0073*   ; Print a 16-bit HEX number
040096             0074*   ; HL: Number to print
040096             0075*   printHex16:
040096 7C          0076*       LD A,H
040097 CD 9C 00 04 0077*       CALL printHex8
04009B 7D          0078*       LD A,L
04009C             0079*   ; Print an 8-bit HEX number
04009C             0080*   ; A: Number to print
04009C             0081*   printHex8:
04009C 4F          0082*       LD C,A
04009D 1F          0083*       RRA
04009E 1F          0084*       RRA
04009F 1F          0085*       RRA
0400A0 1F          0086*       RRA
0400A1 CD A6 00 04 0087*       CALL @F
0400A5 79          0088*       LD A,C
0400A6             0089*   @@:
0400A6 E6 0F       0090*       AND 0Fh
0400A8 C6 90       0091*       ADD A,90h
0400AA 27          0092*       DAA
0400AB CE 40       0093*       ADC A,40h
0400AD 27          0094*       DAA
0400AE 5B D7       0095*       RST.LIL 10h
0400B0 C9          0096*       RET
0400B1             0097*   
0400B1             0098*   ; Print a 0x HEX prefix
0400B1             0099*   DisplayHexPrefix:
0400B1 3E 30       0100*       LD A, '0'
0400B3 5B D7       0101*       RST.LIL 10h
0400B5 3E 78       0102*       LD A, 'x'
0400B7 5B D7       0103*       RST.LIL 10h
0400B9 C9          0104*       RET
0400BA             0105*   
0400BA             0106*       MACRO printDecBC
0400BA             0107*       push hl
0400BA             0108*       push bc
0400BA             0109*       pop hl
0400BA             0110*       call printDec
0400BA             0111*       pop hl
0400BA             0112*       ENDMACRO
0400BA             0113*   
0400BA             0114*       MACRO printDecDE
0400BA             0115*       push hl
0400BA             0116*       push de
0400BA             0117*       pop hl
0400BA             0118*       call printDec
0400BA             0119*       pop hl
0400BA             0120*       ENDMACRO
0400BA             0121*   
0400BA             0122*       MACRO printDecHL
0400BA             0123*       call printDec
0400BA             0124*       ENDMACRO
0400BA             0125*   
0400BA             0126*       MACRO printDecIX
0400BA             0127*       push hl
0400BA             0128*       push ix
0400BA             0129*       pop hl
0400BA             0130*       call printDec
0400BA             0131*       pop hl
0400BA             0132*       ENDMACRO
0400BA             0133*   
0400BA             0134*       MACRO printDecIY
0400BA             0135*       push hl
0400BA             0136*       push iy
0400BA             0137*       pop hl
0400BA             0138*       call printDec
0400BA             0139*       pop hl
0400BA             0140*       ENDMACRO
0400BA             0141*   
0400BA             0142*   
0400BA             0143*   ; Prints the right justified decimal value in HL without leading zeroes
0400BA             0144*   ; HL : Value to print
0400BA             0145*   ; preserves all registers and flags
0400BA             0146*   printDec:
0400BA             0147*   ; BEGIN MY CODE
0400BA             0148*   ; back up all the things
0400BA F5          0149*       push af
0400BB C5          0150*       push bc
0400BC D5          0151*       push de
0400BD E5          0152*       push hl
0400BE             0153*   ; END MY CODE
0400BE 11 E6 00 04 0154*       LD DE, _printDecBuffer
0400C2 CD F6 00 04 0155*       CALL u24_to_ascii
0400C6             0156*   ; BEGIN MY CODE
0400C6             0157*   ; replace leading zeroes with spaces
0400C6 21 E6 00 04 0158*       LD HL, _printDecBuffer
0400CA 06 07       0159*       ld B, 7 ; if HL was 0, we want to keep the final zero
0400CC             0160*   @loop:
0400CC 7E          0161*       LD A, (HL)
0400CD FE 30       0162*       CP '0'
0400CF C2 D9 00 04 0163*       JP NZ, @done
0400D3 3E 20       0164*       LD A, ' '
0400D5 77          0165*       LD (HL), A
0400D6 23          0166*       INC HL
0400D7             0167*       ; CALL vdu_cursor_forward
0400D7 10 F3       0168*       DJNZ @loop
0400D9             0169*   @done:
0400D9             0170*   ; END MY CODE
0400D9 21 E6 00 04 0171*       LD HL, _printDecBuffer
0400DD CD 55 00 04 0172*       CALL printString
0400E1             0173*   ; BEGIN MY CODE
0400E1             0174*   ; restore all the things
0400E1 E1          0175*       pop hl
0400E2 D1          0176*       pop de
0400E3 C1          0177*       pop bc
0400E4 F1          0178*       pop af
0400E5             0179*   ; END MY CODE
0400E5 C9          0180*       RET
0400E6 00 00 00 00 0181*   _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0400F6             0182*   
0400F6             0183*   ; This routine converts the unsigned 24-bit value in HLU into its ASCII representation,
0400F6             0184*   ; starting to memory location pointing by DE, in decimal form and with leading zeroes
0400F6             0185*   ; so it will allways be 8 characters length
0400F6             0186*   ; HL : Value to convert to string
0400F6             0187*   ; DE : pointer to buffer, at least 8 byte + 0
0400F6             0188*   u24_to_ascii:
0400F6 01 80 69 67 0189*       LD BC,-10000000
0400FA CD 2D 01 04 0190*       CALL @one_digit
0400FE 01 C0 BD F0 0191*       LD BC,-1000000
040102 CD 2D 01 04 0192*       CALL @one_digit
040106 01 60 79 FE 0193*       LD BC,-100000
04010A CD 2D 01 04 0194*       CALL @one_digit
04010E 01 F0 D8 FF 0195*       LD BC,-10000
040112 CD 2D 01 04 0196*       CALL @one_digit
040116 01 18 FC FF 0197*       LD BC,-1000
04011A CD 2D 01 04 0198*       CALL @one_digit
04011E 01 9C FF FF 0199*       LD BC,-100
040122 CD 2D 01 04 0200*       CALL @one_digit
040126 0E F6       0201*       LD C,-10
040128 CD 2D 01 04 0202*       CALL @one_digit
04012C 48          0203*       LD C,B
04012D             0204*   @one_digit:
04012D 3E 2F       0205*       LD A,'0'-1
04012F             0206*   @divide_me:
04012F 3C          0207*       INC A
040130 09          0208*       ADD HL,BC
040131 38 FC       0209*       JR C,@divide_me
040133 ED 42       0210*       SBC HL,BC
040135 12          0211*       LD (DE),A
040136 13          0212*       INC DE
040137 C9          0213*       RET
040138             0214*   
040138             0215*   print_u24:
040138 D5          0216*       push de
040139 E5          0217*       push hl
04013A 11 E6 00 04 0218*       ld de,_printDecBuffer
04013E CD F6 00 04 0219*       call u24_to_ascii
040142 21 E6 00 04 0220*       ld hl,_printDecBuffer
040146 CD 55 00 04 0221*       call printString
04014A 3E 20       0222*       ld a,' '
04014C 5B D7       0223*       rst.lil 10h
04014E E1          0224*       pop hl
04014F D1          0225*       pop de
040150 C9          0226*       ret
040151             0227*   
040151             0228*   ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
040151             0229*   ; HL : Value to convert to string (integer part in H, fractional part in L)
040151             0230*   ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
040151             0231*   u168_to_ascii:
040151             0232*   ; add a leading space to make room for sign flag if needed
040151 3E 20       0233*       ld a,' '
040153 12          0234*       ld (de),a
040154 13          0235*       inc de
040155             0236*   ; Convert integer part
040155 E5          0237*       push hl ; Save HL (we’ll need the fractional part later)
040156             0238*       ; call hlu_udiv256 ; Shift to get integer portion in HL
040156             0239*       SRL_UHL ; Shift to get integer portion in HL
040156 3B          0001*M1     dec sp ; 1 cycle
040157 E5          0002*M1     push hl ; 4 cycles
040158 33          0003*M1     inc sp ; 1 cycle
040159 E1          0004*M1     pop hl ; 4 cycles
04015A 23          0005*M1     inc hl ; 1 cycle
04015B 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
04015D             0007*M1     ; 13 cycles total
04015D 01 F0 D8 FF 0240*       ld bc, -10000
040161 CD 84 01 04 0241*       call @one_int
040165 01 18 FC FF 0242*       ld bc, -1000
040169 CD 84 01 04 0243*       call @one_int
04016D 01 9C FF FF 0244*       ld bc, -100
040171 CD 84 01 04 0245*       call @one_int
040175 0E F6       0246*       ld c, -10
040177 CD 84 01 04 0247*       call @one_int
04017B 48          0248*       ld c, b
04017C CD 84 01 04 0249*       call @one_int
040180 C3 8F 01 04 0250*       jp @frac ; Jump to fractional part conversion
040184             0251*   @one_int:
040184 3E 2F       0252*       ld a, '0' - 1 ; Start ASCII character at '0'
040186             0253*   @divide_me:
040186 3C          0254*       inc a
040187 09          0255*       add hl, bc ; Accumulate until overflow
040188 38 FC       0256*       jr c, @divide_me
04018A ED 42       0257*       sbc hl, bc ; Remove excess after overflow
04018C 12          0258*       ld (de), a ; Store ASCII digit
04018D 13          0259*       inc de
04018E C9          0260*       ret
04018F             0261*   ; Convert fractional part
04018F             0262*   @frac:
04018F 3E 2E       0263*       ld a, '.' ; Decimal point
040191 12          0264*       ld (de), a
040192 13          0265*       inc de
040193 E1          0266*       pop hl ; Restore HL with original fraction
040194 06 03       0267*       ld b, 3 ; Loop counter for 3 fractional digits
040196             0268*   @frac_loop:
040196 26 0A       0269*       ld h, 10 ; Load multiplier for fractional part
040198 ED 6C       0270*       mlt hl ; Multiply by 10, result in HL (H holds the integer part)
04019A 3E 30       0271*       ld a, '0'
04019C 84          0272*       add a, h ; Convert integer part to ASCII
04019D 12          0273*       ld (de), a
04019E 13          0274*       inc de
04019F 10 F5       0275*       djnz @frac_loop ; Repeat for each fractional digit
0401A1             0276*   ; Add null terminator
0401A1 AF          0277*       xor a ; Null terminator
0401A2 12          0278*       ld (de), a
0401A3 C9          0279*       ret
0401A4             0280*   
0401A4             0281*   print_u168:
0401A4 D5          0282*       push de
0401A5 E5          0283*       push hl
0401A6 11 E6 00 04 0284*       ld de,_printDecBuffer
0401AA CD 51 01 04 0285*       call u168_to_ascii
0401AE 21 E6 00 04 0286*       ld hl,_printDecBuffer
0401B2 CD 55 00 04 0287*       call printString
0401B6 E1          0288*       pop hl
0401B7 D1          0289*       pop de
0401B8 C9          0290*       ret
0401B9             0291*   
0401B9             0292*   ; signed version of u168_to_ascii
0401B9             0293*   s168_to_ascii:
0401B9 D5          0294*       push de ; save starting address of buffer
0401BA CD 5E 04 04 0295*       call hlu_abs
0401BE F5          0296*       push af ; save sign flag
0401BF CD 51 01 04 0297*       call u168_to_ascii
0401C3 F1          0298*       pop af ; restore sign flag
0401C4 D1          0299*       pop de ; restore starting address of buffer
0401C5 F0          0300*       ret p ; hlu was positive so nothing to do
0401C6 3E 2D       0301*       ld a,'-'
0401C8 12          0302*       ld (de),a
0401C9 C9          0303*       ret
0401CA             0304*   
0401CA             0305*   print_s168:
0401CA D5          0306*       push de
0401CB E5          0307*       push hl
0401CC 11 E6 00 04 0308*       ld de,_printDecBuffer
0401D0 CD B9 01 04 0309*       call s168_to_ascii
0401D4 21 E6 00 04 0310*       ld hl,_printDecBuffer
0401D8 CD 55 00 04 0311*       call printString
0401DC E1          0312*       pop hl
0401DD D1          0313*       pop de
0401DE C9          0314*       ret
0401DF             0315*   
0401DF             0316*   print_s168_hl:
0401DF F5          0317*       push af
0401E0 E5          0318*       push hl
0401E1 CD CA 01 04 0319*       call print_s168
0401E5 3E 20       0320*       ld a,' '
0401E7 5B D7       0321*       rst.lil 10h
0401E9 E1          0322*       pop hl
0401EA F1          0323*       pop af
0401EB C9          0324*       ret
0401EC             0325*   
0401EC             0326*   print_s168_bc:
0401EC F5          0327*       push af
0401ED C5          0328*       push bc
0401EE E5          0329*       push hl
0401EF C5          0330*       push bc
0401F0 E1          0331*       pop hl
0401F1 CD CA 01 04 0332*       call print_s168
0401F5 3E 20       0333*       ld a,' '
0401F7 5B D7       0334*       rst.lil 10h
0401F9 E1          0335*       pop hl
0401FA C1          0336*       pop bc
0401FB F1          0337*       pop af
0401FC C9          0338*       ret
0401FD             0339*   
0401FD             0340*   print_s168_de:
0401FD F5          0341*       push af
0401FE D5          0342*       push de
0401FF E5          0343*       push hl
040200 EB          0344*       ex de,hl
040201 CD CA 01 04 0345*       call print_s168
040205 3E 20       0346*       ld a,' '
040207 5B D7       0347*       rst.lil 10h
040209 E1          0348*       pop hl
04020A D1          0349*       pop de
04020B F1          0350*       pop af
04020C C9          0351*       ret
04020D             0352*   
04020D             0353*   print_s168_hl_bc_de:
04020D F5          0354*       push af
04020E C5          0355*       push bc
04020F D5          0356*       push de
040210 E5          0357*       push hl
040211 CD CA 01 04 0358*       call print_s168
040215 3E 20       0359*       ld a,' '
040217 5B D7       0360*       rst.lil 10h
040219 C5          0361*       push bc
04021A E1          0362*       pop hl
04021B CD CA 01 04 0363*       call print_s168
04021F 3E 20       0364*       ld a,' '
040221 5B D7       0365*       rst.lil 10h
040223 EB          0366*       ex de,hl
040224 CD CA 01 04 0367*       call print_s168
040228 3E 20       0368*       ld a,' '
04022A 5B D7       0369*       rst.lil 10h
04022C E1          0370*       pop hl
04022D D1          0371*       pop de
04022E C1          0372*       pop bc
04022F F1          0373*       pop af
040230 C9          0374*       ret
040231             0375*   
040231             0376*   print_s168_bc_de:
040231 F5          0377*       push af
040232 C5          0378*       push bc
040233 D5          0379*       push de
040234 C5          0380*       push bc
040235 E1          0381*       pop hl
040236 CD CA 01 04 0382*       call print_s168
04023A 3E 20       0383*       ld a,' '
04023C 5B D7       0384*       rst.lil 10h
04023E EB          0385*       ex de,hl
04023F CD CA 01 04 0386*       call print_s168
040243 3E 20       0387*       ld a,' '
040245 5B D7       0388*       rst.lil 10h
040247 E1          0389*       pop hl
040248 D1          0390*       pop de
040249 C1          0391*       pop bc
04024A F1          0392*       pop af
04024B C9          0393*       ret
04024C             0394*   
04024C             0395*   print_s168_a:
04024C F5          0396*       push af
04024D C5          0397*       push bc
04024E E5          0398*       push hl
04024F 21 00 00 00 0399*       ld hl,0
040253 6F          0400*       ld l,a
040254 CD DF 01 04 0401*       call print_s168_hl
040258 E1          0402*       pop hl
040259 C1          0403*       pop bc
04025A F1          0404*       pop af
04025B C9          0405*       ret
04025C             0406*   
04025C             0407*   ; #### new functions added by Brandon R. Gates ####
04025C             0408*   
04025C             0409*   ; print the binary representation of the 8-bit value in a
04025C             0410*   ; destroys a, hl, bc
04025C             0411*   printBin8:
04025C 06 08       0412*       ld b,8 ; loop counter for 8 bits
04025E 21 79 02 04 0413*       ld hl,@cmd ; set hl to the low byte of the output string
040262             0414*       ; (which will be the high bit of the value in a)
040262             0415*   @loop:
040262 07          0416*       rlca ; put the next highest bit into carry
040263 38 04       0417*       jr c,@one
040265 36 30       0418*       ld (hl),'0'
040267 18 02       0419*       jr @next_bit
040269             0420*   @one:
040269 36 31       0421*       ld (hl),'1'
04026B             0422*   @next_bit:
04026B 23          0423*       inc hl
04026C 10 F4       0424*       djnz @loop
04026E             0425*   ; print it
04026E 21 79 02 04 0426*       ld hl,@cmd
040272 01 08 00 00 0427*       ld bc,@end-@cmd
040276 5B DF       0428*       rst.lil $18
040278 C9          0429*       ret
040279             0430*   @cmd: ds 8 ; eight bytes for eight bits
040281             0431*   @end:
040281             0432*   
040281             0433*   ; print the binary representation of the 8-bit value in a
040281             0434*   ; in reverse order (lsb first)
040281             0435*   ; destroys a, hl, bc
040281             0436*   printBin8Rev:
       FF FF FF FF 
       FF FF FF FF 
040281 06 08       0437*       ld b,8 ; loop counter for 8 bits
040283 21 9E 02 04 0438*       ld hl,@cmd ; set hl to the low byte of the output string
040287             0439*       ; (which will be the high bit of the value in a)
040287             0440*   @loop:
040287 0F          0441*       rrca ; put the next lowest bit into carry
040288 38 04       0442*       jr c,@one
04028A 36 30       0443*       ld (hl),'0'
04028C 18 02       0444*       jr @next_bit
04028E             0445*   @one:
04028E 36 31       0446*       ld (hl),'1'
040290             0447*   @next_bit:
040290 23          0448*       inc hl
040291 10 F4       0449*       djnz @loop
040293             0450*   ; print it
040293 21 9E 02 04 0451*       ld hl,@cmd
040297 01 08 00 00 0452*       ld bc,@end-@cmd
04029B 5B DF       0453*       rst.lil $18
04029D C9          0454*       ret
04029E             0455*   @cmd: ds 8 ; eight bytes for eight bits
0402A6             0456*   @end:
0402A6             0457*   
       FF FF FF FF 
       FF FF FF FF 
0402A6 20 61 66 3D 0458*   str_afu: db " af=",0
       00          
0402AB 20 68 6C 3D 0459*   str_hlu: db " hl=",0
       00          
0402B0 20 62 63 3D 0460*   str_bcu: db " bc=",0
       00          
0402B5 20 64 65 3D 0461*   str_deu: db " de=",0
       00          
0402BA 20 69 78 3D 0462*   str_ixu: db " ix=",0
       00          
0402BF 20 69 79 3D 0463*   str_iyu: db " iy=",0
       00          
0402C4             0464*   
0402C4             0465*   ; print udeuhl to screen in hexidecimal format
0402C4             0466*   ; inputs: none
0402C4             0467*   ; outputs: concatenated hexidecimal udeuhl
0402C4             0468*   ; destroys: nothing
0402C4             0469*   dumpUDEUHLHex:
0402C4             0470*   ; store everything in scratch
0402C4 22 23 03 04 0471*       ld (uhl),hl
0402C8 ED 43 26 03 0472*       ld (ubc),bc
       04          
0402CD ED 53 29 03 0473*       ld (ude),de
       04          
0402D2 DD 22 2C 03 0474*       ld (uix),ix
       04          
0402D7 FD 22 2F 03 0475*       ld (uiy),iy
       04          
0402DC F5          0476*       push af
0402DD             0477*   
0402DD             0478*   ; print each register
0402DD             0479*   
0402DD 21 17 03 04 0480*       ld hl,str_udeuhl
0402E1 CD 55 00 04 0481*       call printString
0402E5 2A 29 03 04 0482*       ld hl,(ude)
0402E9 CD 8E 00 04 0483*       call printHex24
0402ED 3E 2E       0484*       ld a,'.' ; print a dot to separate the values
0402EF 5B D7       0485*       rst.lil 10h
0402F1 2A 23 03 04 0486*       ld hl,(uhl)
0402F5 CD 8E 00 04 0487*       call printHex24
0402F9 CD 6A 00 04 0488*       call printNewLine
0402FD             0489*   
0402FD             0490*   ; restore everything
0402FD 2A 23 03 04 0491*       ld hl, (uhl)
040301 ED 4B 26 03 0492*       ld bc, (ubc)
       04          
040306 ED 5B 29 03 0493*       ld de, (ude)
       04          
04030B DD 2A 2C 03 0494*       ld ix, (uix)
       04          
040310 FD 2A 2F 03 0495*       ld iy, (uiy)
       04          
040315 F1          0496*       pop af
040316             0497*   ; all done
040316 C9          0498*       ret
040317             0499*   
040317 75 64 65 2E 0500*   str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
040320             0501*   
040320             0502*   ; global scratch memory for registers
040320 00 00 00    0503*   uaf: dl 0
040323 00 00 00    0504*   uhl: dl 0
040326 00 00 00    0505*   ubc: dl 0
040329 00 00 00    0506*   ude: dl 0
04032C 00 00 00    0507*   uix: dl 0
04032F 00 00 00    0508*   uiy: dl 0
040332 00 00 00    0509*   usp: dl 0
040335 00 00 00    0510*   upc: dl 0
040338             0511*   
040338             0512*   
040338             0513*   ; set all the bits in the flag register
040338             0514*   ; more of an academic exercise than anything useful
040338             0515*   ; inputs; none
040338             0516*   ; outputs; a=0,f=255
040338             0517*   ; destroys: flags, hl
040338             0518*   ; preserves: a, because why not
040338             0519*   setAllFlags:
040338 21 FF 00 00 0520*       ld hl,255
04033C 67          0521*       ld h,a ; four cycles to preserve a is cheap
04033D E5          0522*       push hl
04033E F1          0523*       pop af
04033F C9          0524*       ret
040340             0525*   
040340             0526*   ; reset all the bits in the flag register
040340             0527*   ; unlike its inverse counterpart, this may actually be useful
040340             0528*   ; inputs; none
040340             0529*   ; outputs; a=0,f=0
040340             0530*   ; destroys: flags, hl
040340             0531*   ; preserves: a, because why not
040340             0532*   resetAllFlags:
040340 21 00 00 00 0533*       ld hl,0
040344 67          0534*       ld h,a ; four cycles to preserve a is cheap
040345 E5          0535*       push hl
040346 F1          0536*       pop af
040347 C9          0537*       ret
040348             0538*   
040348             0539*   ; wait until user presses a key
040348             0540*   ; inputs: none
040348             0541*   ; outputs: ascii code of key pressed in a
040348             0542*   ; destroys: af,ix
040348             0543*   waitKeypress:
040348             0544*       MOSCALL mos_getkey
040348 3E 00       0001*M1 			LD	A, function
04034A 5B CF       0002*M1 			RST.LIL	08h
04034C C9          0545*       ret
04034D             0546*   
04034D             0547*   ; clear a block of memory by writing a prescribed value to each byte in the range
04034D             0548*   ; inputs: a = value to write, hl = address of first byte, bc = number of bytes
04034D             0549*   ; outputs: memory block is cleared
04034D             0550*   ; destroys: hl, de
04034D             0551*   clear_mem:
04034D 0B          0552*       dec bc ; we do this because we will increment de before writing the first byte
04034E 77          0553*       ld (hl),a
04034F E5          0554*       push hl
040350 D1          0555*       pop de
040351 13          0556*       inc de ; target address
040352 ED B0       0557*       ldir
040354 C9          0558*       ret
040355             0035        include "arith24.inc"
040355             0001*   ;------------------------------------------------------------------------
040355             0002*   ;  arith24.asm
040355             0003*   ;  24-bit ez80 arithmetic routines
040355             0004*   ;  Copyright (c) Shawn Sijnstra 2024
040355             0005*   ;  MIT license
040355             0006*   ;
040355             0007*   ;  This library was created as a tool to help make ez80
040355             0008*   ;  24-bit native assembly routines for simple mathematical problems
040355             0009*   ;  more widely available.
040355             0010*   ;
040355             0011*   ;------------------------------------------------------------------------
040355             0012*   
040355             0013*   ;------------------------------------------------------------------------
040355             0014*   ; umul24:	HL = HL*DE (unsigned)
040355             0015*   ; Preserves AF, BC, DE
040355             0016*   ; Uses a fast multiply routine.
040355             0017*   ;------------------------------------------------------------------------
040355             0018*   umul24:
040355 D5          0019*   	push	DE
040356 C5          0020*   	push	BC
040357 F5          0021*   	push	AF
040358 E5          0022*   	push	HL
040359 C1          0023*   	pop		BC
04035A 3E 18       0024*       ld	 	a, 24 ; No. of bits to process
04035C 21 00 00 00 0025*       ld	 	hl, 0 ; Result
040360             0026*   umul24_lp:
040360 29          0027*   	add	hl,hl
040361 EB          0028*   	ex	de,hl
040362 29          0029*   	add	hl,hl
040363 EB          0030*   	ex	de,hl
040364 30 01       0031*   	jr	nc,umul24_nc
040366 09          0032*   	add	hl,bc
040367             0033*   umul24_nc:
040367 3D          0034*   	dec	a
040368 20 F6       0035*   	jr	nz,umul24_lp
04036A F1          0036*   	pop	af
04036B C1          0037*   	pop	bc
04036C D1          0038*   	pop	de
04036D C9          0039*   	ret
04036E             0040*   
04036E             0041*   
04036E             0042*   ;------------------------------------------------------------------------
04036E             0043*   ; udiv24
04036E             0044*   ; Unsigned 24-bit division
04036E             0045*   ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
04036E             0046*   ;
04036E             0047*   ; Uses AF BC DE HL
04036E             0048*   ; Uses Restoring Division algorithm
04036E             0049*   ;------------------------------------------------------------------------
04036E             0050*   
04036E             0051*   udiv24:
04036E E5          0052*   	push	hl
04036F C1          0053*   	pop		bc	;move dividend to BCU
040370 21 00 00 00 0054*   	ld		hl,0	;result
040374 A7          0055*   	and		a
040375 ED 52       0056*   	sbc		hl,de	;test for div by 0
040377 C8          0057*   	ret		z		;it's zero, carry flag is clear
040378 19          0058*   	add		hl,de	;HL is 0 again
040379 3E 18       0059*   	ld		a,24	;number of loops through.
04037B             0060*   udiv1:
04037B C5          0061*   	push	bc	;complicated way of doing this because of lack of access to top bits
04037C E3          0062*   	ex		(sp),hl
04037D 37          0063*   	scf
04037E ED 6A       0064*   	adc	hl,hl
040380 E3          0065*   	ex	(sp),hl
040381 C1          0066*   	pop	bc		;we now have bc = (bc * 2) + 1
040382             0067*   
040382 ED 6A       0068*   	adc	hl,hl
040384 A7          0069*   	and	a		;is this the bug
040385 ED 52       0070*   	sbc	hl,de
040387 30 02       0071*   	jr	nc,udiv2
040389 19          0072*   	add	hl,de
04038A             0073*   ;	dec	c
04038A 0B          0074*   	dec	bc
04038B             0075*   udiv2:
04038B 3D          0076*   	dec	a
04038C 20 ED       0077*   	jr	nz,udiv1
04038E 37          0078*   	scf		;flag used for div0 error
04038F C5          0079*   	push	bc
040390 D1          0080*   	pop		de	;remainder
040391 C9          0081*   	ret
040392             0082*   
040392             0083*   
040392             0084*   
040392             0085*   ;------------------------------------------------------------------------
040392             0086*   ; neg24
040392             0087*   ; Returns: HLU = 0-HLU
040392             0088*   ; preserves all other registers
040392             0089*   ;------------------------------------------------------------------------
040392             0090*   neg24:
040392 D5          0091*   	push	de
040393 EB          0092*   	ex		de,hl
040394 21 00 00 00 0093*   	ld		hl,0
040398 B7          0094*   	or		a
040399 ED 52       0095*   	sbc		hl,de
04039B D1          0096*   	pop		de
04039C C9          0097*   	ret
04039D             0098*   
04039D             0099*   ;------------------------------------------------------------------------
04039D             0100*   ; or_hlu_deu: 24 bit bitwise OR
04039D             0101*   ; Returns: hlu = hlu OR deu
04039D             0102*   ; preserves all other registers
04039D             0103*   ;------------------------------------------------------------------------
04039D             0104*   or_hlu_deu:
04039D 22 26 04 04 0105*   	ld	(bitbuf1),hl
0403A1 ED 53 29 04 0106*   	ld	(bitbuf2),de
       04          
0403A6 D5          0107*   	push	de	;preserve DEU
0403A7 C5          0108*   	push	bc	;preserve BCU
0403A8 06 03       0109*   	ld		b,3
0403AA 21 26 04 04 0110*   	ld	hl,bitbuf1
0403AE 11 26 04 04 0111*   	ld	de,bitbuf1
0403B2             0112*   orloop_24:
0403B2 1A          0113*   	ld	a,(de)
0403B3 B6          0114*   	or	(hl)
0403B4 12          0115*   	ld	(de),a
0403B5 13          0116*   	inc	de
0403B6 23          0117*   	inc	hl
0403B7 10 F9       0118*   	djnz	orloop_24
0403B9 2A 29 04 04 0119*   	ld	hl,(bitbuf2)
0403BD C1          0120*   	pop		bc	;restore BC
0403BE D1          0121*   	pop		de	;restore DE
0403BF             0122*   
0403BF             0123*   ;------------------------------------------------------------------------
0403BF             0124*   ; and_hlu_deu: 24 bit bitwise AND
0403BF             0125*   ; Returns: hlu = hlu AND deu
0403BF             0126*   ; preserves all other registers
0403BF             0127*   ;------------------------------------------------------------------------
0403BF             0128*   and_hlu_deu:
0403BF 22 26 04 04 0129*   	ld	(bitbuf1),hl
0403C3 ED 53 29 04 0130*   	ld	(bitbuf2),de
       04          
0403C8 D5          0131*   	push	de	;preserve DEU
0403C9 C5          0132*   	push	bc	;preserve BCU
0403CA 06 03       0133*   	ld		b,3
0403CC 21 26 04 04 0134*   	ld	hl,bitbuf1
0403D0 11 26 04 04 0135*   	ld	de,bitbuf1
0403D4             0136*   andloop_24:
0403D4 1A          0137*   	ld	a,(de)
0403D5 A6          0138*   	and	(hl)
0403D6 12          0139*   	ld	(de),a
0403D7 13          0140*   	inc	de
0403D8 23          0141*   	inc	hl
0403D9 10 F9       0142*   	djnz	andloop_24
0403DB 2A 29 04 04 0143*   	ld	hl,(bitbuf2)
0403DF C1          0144*   	pop		bc	;restore BC
0403E0 D1          0145*   	pop		de	;restore DE
0403E1             0146*   
0403E1             0147*   ;------------------------------------------------------------------------
0403E1             0148*   ; xor_hlu_deu: 24 bit bitwise XOR
0403E1             0149*   ; Returns: hlu = hlu XOR deu
0403E1             0150*   ; preserves all other registers
0403E1             0151*   ;------------------------------------------------------------------------
0403E1             0152*   xor_hlu_deu:
0403E1 22 26 04 04 0153*   	ld	(bitbuf1),hl
0403E5 ED 53 29 04 0154*   	ld	(bitbuf2),de
       04          
0403EA D5          0155*   	push	de	;preserve DEU
0403EB C5          0156*   	push	bc	;preserve BCU
0403EC 06 03       0157*   	ld		b,3
0403EE 21 26 04 04 0158*   	ld	hl,bitbuf1
0403F2 11 26 04 04 0159*   	ld	de,bitbuf1
0403F6             0160*   xorloop_24:
0403F6 1A          0161*   	ld	a,(de)
0403F7 AE          0162*   	xor	(hl)
0403F8 12          0163*   	ld	(de),a
0403F9 13          0164*   	inc	de
0403FA 23          0165*   	inc	hl
0403FB 10 F9       0166*   	djnz	xorloop_24
0403FD 2A 29 04 04 0167*   	ld	hl,(bitbuf2)
040401 C1          0168*   	pop		bc	;restore BC
040402 D1          0169*   	pop		de	;restore DE
040403             0170*   
040403             0171*   ;------------------------------------------------------------------------
040403             0172*   ; shl_hlu: 24 bit shift left hlu by a positions
040403             0173*   ; Returns: hlu = hlu << a
040403             0174*   ;		   a = 0
040403             0175*   ; NOTE: only considers a up to 16 bits.
040403             0176*   ; preserves all other registers
040403             0177*   ; modified by Brandon R. Gates to use a instead of de
040403             0178*   ;------------------------------------------------------------------------
040403             0179*   shl_hlu:
040403 B7          0180*   	or a
040404 C8          0181*   	ret		z		;we're done
040405 29          0182*   	add		hl,hl	;shift HLU left
040406 3D          0183*   	dec a
040407 18 FA       0184*   	jr		shl_hlu
040409             0185*   
040409             0186*   ;------------------------------------------------------------------------
040409             0187*   ; shr_hlu: 24 bit shift right hlu by a positions
040409             0188*   ; Returns: hlu = hlu >> a
040409             0189*   ;		   a = 0
040409             0190*   ; NOTE: only considers a up to 16 bits.
040409             0191*   ; preserves all other registers
040409             0192*   ; modified by Brandon R. Gates to use a instead of de
040409             0193*   ;------------------------------------------------------------------------
040409             0194*   shr_hlu:
040409 22 26 04 04 0195*   	ld		(bitbuf1),hl
04040D 21 28 04 04 0196*   	ld		hl,bitbuf1+2
040411             0197*   @shr_loop:
040411 B7          0198*   	or a
040412 28 0D       0199*   	jr		z,@shr_done		;we're done
040414             0200*   ;carry is clear from or instruction
040414 CB 1E       0201*   	rr		(hl)
040416 2B          0202*   	dec		hl
040417 CB 1E       0203*   	rr		(hl)
040419 2B          0204*   	dec		hl
04041A CB 1E       0205*   	rr		(hl)
04041C 23          0206*   	inc		hl
04041D 23          0207*   	inc		hl
04041E 3D          0208*   	dec a
04041F 18 F0       0209*   	jr		@shr_loop
040421             0210*   @shr_done:
040421 2A 26 04 04 0211*   	ld		hl,(bitbuf1)	;collect result
040425 C9          0212*   	ret
040426             0213*   
040426             0214*   ;------------------------------------------------------------------------
040426             0215*   ; Scratch area for calculations
040426             0216*   ;------------------------------------------------------------------------
040426 00 00 00    0217*   bitbuf1:	dw24	0	;bit manipulation buffer 1
040429 00 00 00    0218*   bitbuf2:	dw24	0	;bit manipulation buffer 2
04042C             0219*   
04042C             0220*   ; -----------------------------------------------------------------------
04042C             0221*   ; Functions added by Brandon R. Gates
04042C             0222*   ; -----------------------------------------------------------------------
04042C             0223*   
04042C             0224*   ;------------------------------------------------------------------------
04042C             0225*   ; shr_hlu_div: Quick division by powers of two based on log2 of A
04042C             0226*   ;              Determines the LSB of A and shifts HLU accordingly.
04042C             0227*   ;              HLU = HLU >> LSB(A)
04042C             0228*   ; Returns: HLU = HLU >> LSB(A)
04042C             0229*   ; Destroys: af
04042C             0230*   ;------------------------------------------------------------------------
04042C             0231*   shr_hlu_log2a:
04042C B7          0232*   	or a    ; check for zero
04042D C8          0233*   	ret z   ; nothing to shift so we're done
04042E C5          0234*   	push 	bc ; preserve
04042F 06 00       0235*   	ld		b,0 ; clear b
040431             0236*   @find_bit:
040431 0F          0237*   	rrca ; bit 0 to carry
040432 DA 3B 04 04 0238*   	jp c,@found_bit
040436 04          0239*   	inc b ; next bit
040437 C3 31 04 04 0240*   	jp @find_bit
04043B             0241*   @found_bit:
04043B 78          0242*   	ld a,b
04043C CD 09 04 04 0243*   	call shr_hlu
040440 C1          0244*   	pop 	bc ; restore
040441 C9          0245*   	ret
040442             0246*   ; end shr_hlu_log2a
040442             0247*   
040442             0248*   ;------------------------------------------------------------------------
040442             0249*   ; shl_hlu_log2a: Quick multiplication by powers of two based on log2 of A
040442             0250*   ;                Determines the LSB of A and shifts HLU accordingly.
040442             0251*   ;                HLU = HLU << LSB(A)
040442             0252*   ; Returns: HLU = HLU << LSB(A)
040442             0253*   ; Destroys: af
040442             0254*   ;------------------------------------------------------------------------
040442             0255*   shl_hlu_log2a:
040442 B7          0256*   	or a    ; check for zero
040443 C8          0257*   	ret z   ; nothing to shift so we're done
040444 C5          0258*   	push 	bc ; preserve
040445 06 00       0259*   	ld		b,0 ; clear b
040447             0260*   @find_bit:
040447 0F          0261*   	rrca ; bit 0 to carry
040448 DA 51 04 04 0262*   	jp c,@found_bit
04044C 04          0263*   	inc b ; next bit
04044D C3 47 04 04 0264*   	jp @find_bit
040451             0265*   @found_bit:
040451 78          0266*   	ld a,b
040452 CD 03 04 04 0267*   	call shl_hlu
040456 C1          0268*   	pop 	bc ; restore
040457 C9          0269*   	ret
040458             0270*   ; end shl_hlu_log2a
040458             0036        include "maths.inc"
040458             0001*   ;------------------------------------------------------------------------
040458             0002*   ; Scratch area for calculations
040458             0003*   ;------------------------------------------------------------------------
040458 00 00 00    0004*   scratch1: dw24 0 ;bit manipulation buffer 1
04045B 00 00 00    0005*   scratch2: dw24 0 ;bit manipulation buffer 2
04045E             0006*   
04045E             0007*   ; absolute value of hlu
04045E             0008*   ; returns: abs(hlu), flags set according to the incoming sign of hlu:
04045E             0009*   ;         s1,z0,pv0,n1,c0 if hlu was negative
04045E             0010*   ;         s0,z1,pv0,n1,c0 if hlu was zero
04045E             0011*   ;         s0,z0,pv0,n1,c0 if hlu was positive
04045E             0012*   ; destroys: a
04045E             0013*   hlu_abs:
04045E 19          0014*       add hl,de
04045F B7          0015*       or a
040460 ED 52       0016*       sbc hl,de
040462 FA 67 04 04 0017*       jp m,@is_neg
040466 C9          0018*       ret ; hlu is positive or zero so we're done
040467             0019*   @is_neg:
040467 F5          0020*       push af ; otherwise, save current flags for return
040468 CD 6E 04 04 0021*       call neg_hlu ; negate hlu
04046C F1          0022*       pop af ; get back flags
04046D C9          0023*       ret
04046E             0024*   
04046E             0025*   ; flip the sign of hlu
04046E             0026*   ; inputs: hlu
04046E             0027*   ; returns: 0-hlu, flags set appropriately for the result:
04046E             0028*   ;         s1,z0,pv0,n1,c1 if result is negative
04046E             0029*   ;         s0,z1,pv0,n1,c0 if result is zero
04046E             0030*   ;         s0,z0,pv0,n1,c1 if result is positive
04046E             0031*   ; destroys a
04046E             0032*   neg_hlu:
04046E D5          0033*       push de ; save de
04046F EB          0034*       ex de,hl ; put hl into de
040470 21 00 00 00 0035*       ld hl,0 ; clear hl
040474 AF          0036*       xor a ; clear carry
040475 ED 52       0037*       sbc hl,de ; 0-hlu = -hlu
040477 D1          0038*       pop de ; get de back
040478 C9          0039*       ret ; easy peasy
040479             0040*   
040479             0041*   ;------------------------------------------------------------------------
040479             0042*   ; divide hlu by 2, inspired by above
040479             0043*   ;------------------------------------------------------------------------
040479             0044*   hlu_div2:
040479 22 58 04 04 0045*       ld (scratch1),hl
04047D 21 5A 04 04 0046*       ld hl,scratch1+2
040481 CB 1E       0047*       rr (hl)
040483 2B          0048*       dec hl
040484 CB 1E       0049*       rr (hl)
040486 2B          0050*       dec hl
040487 CB 1E       0051*       rr (hl)
040489 23          0052*       inc hl
04048A 23          0053*       inc hl
04048B 2A 58 04 04 0054*       ld hl,(scratch1)
04048F C9          0055*       ret
040490             0056*   
040490             0057*   ; this is my little hack to divide by 16
040490             0058*   hlu_div16:
040490 AF          0059*       xor a
040491 29          0060*       add hl,hl
040492 17          0061*       rla
040493 29          0062*       add hl,hl
040494 17          0063*       rla
040495 29          0064*       add hl,hl
040496 17          0065*       rla
040497 29          0066*       add hl,hl
040498 17          0067*       rla
040499 22 A6 04 04 0068*       ld (@scratch),hl
04049D 32 A9 04 04 0069*       ld (@scratch+3),a
0404A1 2A A7 04 04 0070*       ld hl,(@scratch+1)
0404A5 C9          0071*       ret
0404A6             0072*   @scratch: ds 4
0404AA             0073*   
0404AA             0074*   ; hlu signed division by 256
0404AA             0075*   ; returns: hlu / 256
0404AA             0076*   ; destroys: af
0404AA             0077*   hlu_sdiv256:
       FF FF FF FF 
0404AA AF          0078*       xor a ; assume hl is positive
0404AB 22 C1 04 04 0079*       ld (@buffer),hl
0404AF             0080*       SIGN_HLU
0404AF 19          0001*M1     add hl,de ; 1 cycle
0404B0 B7          0002*M1     or a ; clear flags ; 1 cycle
0404B1 ED 52       0003*M1     sbc hl,de ; 2 cycles
0404B3             0004*M1     ; 4 cycles total
0404B3 F2 B8 04 04 0081*       jp p,@hl_pos
0404B7 3D          0082*       dec a
0404B8             0083*   @hl_pos:
0404B8 32 C4 04 04 0084*       ld (@buffer+3),a
0404BC 2A C2 04 04 0085*       ld hl,(@buffer+1)
0404C0 C9          0086*       ret
0404C1             0087*   @buffer: ds 4
0404C5             0088*   
0404C5             0089*   ; hlu 1 byte right shift, unsigned
0404C5             0090*   ; returns: hlu / 256, fractional portion in a
0404C5             0091*   ; destroys: af
0404C5             0092*   hlu_udiv256:
       FF FF FF FF 
0404C5 AF          0093*       xor a
0404C6 32 D7 04 04 0094*       ld (@buffer+3),a
0404CA 7D          0095*       ld a,l ; save the fractional portion
0404CB 22 D4 04 04 0096*       ld (@buffer),hl
0404CF 2A D5 04 04 0097*       ld hl,(@buffer+1)
0404D3 C9          0098*       ret
0404D4             0099*   @buffer: ds 4
0404D8             0100*   
0404D8             0101*   ; floor(value,n)
0404D8             0102*   ; inputs: hl = value to floor, de = n
0404D8             0103*   ; outputs: hl = value floored to n
0404D8             0104*   ; destroys: af, hl, bc, de
0404D8             0105*   hlu_floor:
       FF FF FF FF 
0404D8 D5          0106*       push de ; save n
0404D9 CD 6E 03 04 0107*       call udiv24 ; de = quotient, hl = remainder
0404DD E1          0108*       pop hl ; get n back (was de)
0404DE CD 55 03 04 0109*       call umul24 ; hl = n * quotient
0404E2 C9          0110*       ret
0404E3             0111*   ; end hlu_floor
0404E3             0112*   
0404E3             0113*   ; ceil(value,n)
0404E3             0114*   ; inputs: hl = value to ceil, de = n
0404E3             0115*   ; outputs: hl = value ceiled to n
0404E3             0116*   ; destroys: af, hl, bc, de
0404E3             0117*   hlu_ceiling:
0404E3 D5          0118*       push de ; save n
0404E4 CD 6E 03 04 0119*       call udiv24 ; de = quotient, hl = remainder
0404E8             0120*       SIGN_HLU ; test remaider for zero
0404E8 19          0001*M1     add hl,de ; 1 cycle
0404E9 B7          0002*M1     or a ; clear flags ; 1 cycle
0404EA ED 52       0003*M1     sbc hl,de ; 2 cycles
0404EC             0004*M1     ; 4 cycles total
0404EC CA F1 04 04 0121*       jp z,@F ; if zero, nothing to add
0404F0 13          0122*       inc de ; add 1 to quotient for the ceiling
0404F1             0123*   @@:
0404F1 E1          0124*       pop hl ; get n back (was de)
0404F2 CD 55 03 04 0125*       call umul24 ; hl = n * quotient
0404F6 C9          0126*       ret
0404F7             0127*   ; end hlu_ceiling
0404F7             0128*   
0404F7 C9          0129*       ret
0404F8             0130*   
0404F8 00 00 00 00 0131*   add_bcd_arg1: db #00,#00,#00,#00
0404FC 00 00 00 00 0132*   add_bcd_arg2: db #00,#00,#00,#00
040500             0133*   
040500             0134*   ; set bcd values in a scratch memory address from registers bcde
040500             0135*   ; input: hl; scratch address,bcde; 8-place bcd number
040500             0136*   ; destroys ; hl
040500             0137*   set_bcd:
040500 73          0138*       ld (hl),e
040501 23          0139*       inc hl
040502 72          0140*       ld (hl),d
040503 23          0141*       inc hl
040504 71          0142*       ld (hl),c
040505 23          0143*       inc hl
040506 70          0144*       ld (hl),b
040507 C9          0145*       ret
040508             0146*   
040508             0147*   ; load bcd values from a scratch memory address to bcde
040508             0148*   ; input: hl; scratch address
040508             0149*   ; output: bcde; 8-place bcd number
040508             0150*   ; destroys: hl
040508             0151*   get_bcd:
040508 5E          0152*       ld e,(hl)
040509 23          0153*       inc hl
04050A 56          0154*       ld d,(hl)
04050B 23          0155*       inc hl
04050C 4E          0156*       ld c,(hl)
04050D 23          0157*       inc hl
04050E 46          0158*       ld b,(hl)
04050F C9          0159*       ret
040510             0160*   
040510             0161*   ; BCD addition
040510             0162*   ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
040510             0163*   ;       a is the number of bytes holding each number (number of places/2)
040510             0164*   ; outputs: (hl) + (de) --> (hl)
040510             0165*   ; destroys: a,b,de,hl
040510             0166*   add_bcd:
040510 47          0167*       ld b,a ; loop counter
040511 AF          0168*       xor a ; reset a, clear carry flag
040512             0169*   adcec:
040512 1A          0170*       ld a,(de) ; addend to acc
040513 8E          0171*       adc a,(hl) ; add (hl) to acc
040514 27          0172*       daa ; adjust result to bcd
040515 77          0173*       ld (hl),a ; store result
040516 23          0174*       inc hl ; advance memory pointers
040517 13          0175*       inc de
040518 10 F8       0176*       djnz adcec ; loop until b == 0
04051A C9          0177*       ret
04051B             0178*   
04051B             0179*   ; BCD subtraction
04051B             0180*   ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
04051B             0181*   ;       a is the number of bytes holding each number (number of places/2)
04051B             0182*   ; outputs: (hl) - (de) --> (hl)
04051B             0183*   ; destroys: a,b,de,hl
04051B             0184*   sub_bcd:
04051B 47          0185*       ld b,a ; loop counter
04051C AF          0186*       xor a ; reset a,clear carry flag
04051D             0187*   subdec:
04051D 1A          0188*       ld a,(de) ; subtrahend to acc
04051E 9E          0189*       sbc a,(hl) ; subtract (hl) from acc
04051F 27          0190*       daa ; adjust result to bcd
040520 77          0191*       ld (hl),a ; store result
040521 23          0192*       inc hl ; advance memory pointers
040522 13          0193*       inc de
040523 10 F8       0194*       djnz subdec ; loop until b == 0
040525 C9          0195*       ret
040526             0196*   
040526             0197*   ; http://www.z80.info/pseudo-random.txt
040526             0198*   rand_8:
040526 C5          0199*       push bc
040527 3A 3A 05 04 0200*       ld a,(r_seed)
04052B 4F          0201*       ld c,a
04052C             0202*   
04052C 0F          0203*       rrca ; multiply by 32
04052D 0F          0204*       rrca
04052E 0F          0205*       rrca
04052F EE 1F       0206*       xor 0x1f
040531             0207*   
040531 81          0208*       add a,c
040532 DE FF       0209*       sbc a,255 ; carry
040534             0210*   
040534 32 3A 05 04 0211*       ld (r_seed),a
040538 C1          0212*       pop bc
040539 C9          0213*       ret
04053A 50          0214*   r_seed: defb $50
04053B             0215*   
04053B             0216*   ; https://www.omnimaga.org/asm-language/ez80-optimized-routines/msg399325/#msg399325
04053B             0217*   prng24:
04053B             0218*   ;;Expects ADL mode.
04053B             0219*   ;;Output: HL
04053B             0220*   ;;50cc
04053B             0221*   ;;33 bytes
04053B             0222*   ;;cycle length: 281,474,959,933,440 (about 2.8 trillion)
04053B ED 5B 5C 05 0223*       ld de,(seed1)
       04          
040540 B7          0224*       or a
040541 ED 62       0225*       sbc hl,hl
040543 19          0226*       add hl,de
040544 29          0227*       add hl,hl
040545 29          0228*       add hl,hl
040546 2C          0229*       inc l
040547 19          0230*       add hl,de
040548 22 5C 05 04 0231*       ld (seed1),hl
04054C 2A 5F 05 04 0232*       ld hl,(seed2)
040550 29          0233*       add hl,hl
040551 9F          0234*       sbc a,a
040552 E6 1B       0235*       and %00011011
040554 AD          0236*       xor l
040555 6F          0237*       ld l,a
040556 22 5F 05 04 0238*       ld (seed2),hl
04055A 19          0239*       add hl,de
04055B C9          0240*       ret
04055C 00 00 00    0241*   seed1: dl 0
04055F 00 00 00    0242*   seed2: dl 0
040562             0243*   
040562             0244*   
040562             0245*   ; https://map.grauw.nl/sources/external/z80bits.html#2.1
040562             0246*   ; 2.1 Restoring 8-bit / 8-bit Unsigned
040562             0247*   ; Input: H = Dividend, L = Divisor, A = 0
040562             0248*   ; Output: H = Quotient, A = Remainder, L = Divisor (unchanged)
040562             0249*   udiv8:
040562 AF          0250*       xor a
040563 06 08       0251*       ld b,8
040565             0252*   @loop:
040565 CB 24       0253*       sla h
040567 17          0254*       rla
040568 BD          0255*       cp l
040569 38 02       0256*       jr c,$+4
04056B 95          0257*       sub l
04056C 24          0258*       inc h
04056D 10 F6       0259*       djnz @loop
04056F C9          0260*       ret
040570             0037        include "fonts.inc"
040570             0001*   fonts_load:
040570 DD 21 A1 05 0002*       ld ix,font_list ; pointer to font list lookup
       04          
040575 06 1D       0003*       ld b,num_fonts ; loop counter
040577             0004*   
040577             0005*   @load_loop:
040577 C5          0006*       push bc ; save loop counter
040578             0007*   
040578             0008*   ; load font into a buffer
040578 DD 27 06    0009*       ld hl,(ix+font_list_bufferId)
04057B DD 31 09    0010*       ld iy,(ix+font_list_filename)
04057E CD 00 19 04 0011*       call vdu_load_buffer_from_file
040582             0012*   
040582             0013*   ; create font from buffer
040582 DD 27 06    0014*       ld hl,(ix+font_list_bufferId)
040585 DD 5E 00    0015*       ld e,(ix+font_list_width)
040588 DD 56 03    0016*       ld d,(ix+font_list_height)
04058B 3E 00       0017*       ld a,0 ; flags
04058D CD 53 1B 04 0018*       call vdu_font_create
040591             0019*   
040591             0020*   ; select font
040591 DD 27 06    0021*       ld hl,(ix+font_list_bufferId)
040594 3E 01       0022*       ld a,1 ; flags
040596 CD 39 1B 04 0023*       call vdu_font_select
04059A             0024*   
04059A             0025*   ; ; debug print filename
04059A             0026*   ;     call printNewLine
04059A             0027*   ;     ld hl,(ix+font_list_filename)
04059A             0028*   ;     call printString
04059A             0029*   
04059A             0030*   ; advance font_list pointer to next record
04059A ED 32 0C    0031*       lea ix,ix+font_list_record_size
04059D             0032*   
04059D             0033*   ; restore loop counter
04059D C1          0034*       pop bc
04059E 10 D7       0035*       djnz @load_loop
0405A0             0036*   
0405A0             0037*   ; all done
0405A0 C9          0038*       ret
0405A1             0038        include "fonts_list.inc"
0405A1             0001*   ; Generated by asm_config_editor.py
0405A1             0002*   font_list_record_size: equ 12
0405A1             0003*   font_list_width: equ 0
0405A1             0004*   font_list_height: equ 3
0405A1             0005*   font_list_bufferId: equ 6
0405A1             0006*   font_list_filename: equ 9
0405A1             0007*   
0405A1             0008*   num_fonts: equ 29
0405A1             0009*   
0405A1             0010*   ; Index list:
0405A1             0011*   amiga_forever_16x16: equ 64000
0405A1             0012*   amiga_forever_16x24: equ 64001
0405A1             0013*   amiga_forever_8x16: equ 64002
0405A1             0014*   amiga_forever_8x8: equ 64003
0405A1             0015*   computer_pixel_7_10x15: equ 64004
0405A1             0016*   computer_pixel_7_10x24: equ 64005
0405A1             0017*   computer_pixel_7_8x12: equ 64006
0405A1             0018*   computer_pixel_7_8x14: equ 64007
0405A1             0019*   computer_pixel_7_8x16: equ 64008
0405A1             0020*   dopecre_8x8: equ 64009
0405A1             0021*   gamer_2_8x8: equ 64010
0405A1             0022*   Lat15_VGA8_8x8: equ 64011
0405A1             0023*   Lat2_Terminus12x6_6x12: equ 64012
0405A1             0024*   Lat2_TerminusBold14_8x14: equ 64013
0405A1             0025*   Lat2_VGA14_8x14: equ 64014
0405A1             0026*   Lat2_VGA16_8x16: equ 64015
0405A1             0027*   Lat2_VGA8_8x8: equ 64016
0405A1             0028*   Lat38_VGA8_8x8: equ 64017
0405A1             0029*   Lat7_Fixed13_8x13: equ 64018
0405A1             0030*   Lat7_Terminus12x6_6x12: equ 64019
0405A1             0031*   Lat7_TerminusBold16_8x16: equ 64020
0405A1             0032*   Lat7_VGA14_8x14: equ 64021
0405A1             0033*   Lat7_VGA16_8x16: equ 64022
0405A1             0034*   Lat7_VGA8_8x8: equ 64023
0405A1             0035*   planetary_contact_8x8: equ 64024
0405A1             0036*   scriptorium_12x14: equ 64025
0405A1             0037*   Squarewave_Bold_8x12: equ 64026
0405A1             0038*   super_mario_bros_2_8x8: equ 64027
0405A1             0039*   wendy_neue_6x6: equ 64028
0405A1             0040*   
0405A1             0041*   font_list: ; width; height; bufferId; filename;:
0405A1 10 00 00 10 0042*   	dl 16, 16, 64000, fn_amiga_forever_16x16
       00 00 00 FA 
       00 FD 06 04 
0405AD 10 00 00 18 0043*   	dl 16, 24, 64001, fn_amiga_forever_16x24
       00 00 01 FA 
       00 1B 07 04 
0405B9 08 00 00 10 0044*   	dl 8, 16, 64002, fn_amiga_forever_8x16
       00 00 02 FA 
       00 39 07 04 
0405C5 08 00 00 08 0045*   	dl 8, 8, 64003, fn_amiga_forever_8x8
       00 00 03 FA 
       00 56 07 04 
0405D1 0A 00 00 0F 0046*   	dl 10, 15, 64004, fn_computer_pixel_7_10x15
       00 00 04 FA 
       00 72 07 04 
0405DD 0A 00 00 18 0047*   	dl 10, 24, 64005, fn_computer_pixel_7_10x24
       00 00 05 FA 
       00 93 07 04 
0405E9 08 00 00 0C 0048*   	dl 8, 12, 64006, fn_computer_pixel_7_8x12
       00 00 06 FA 
       00 B4 07 04 
0405F5 08 00 00 0E 0049*   	dl 8, 14, 64007, fn_computer_pixel_7_8x14
       00 00 07 FA 
       00 D4 07 04 
040601 08 00 00 10 0050*   	dl 8, 16, 64008, fn_computer_pixel_7_8x16
       00 00 08 FA 
       00 F4 07 04 
04060D 08 00 00 08 0051*   	dl 8, 8, 64009, fn_dopecre_8x8
       00 00 09 FA 
       00 14 08 04 
040619 08 00 00 08 0052*   	dl 8, 8, 64010, fn_gamer_2_8x8
       00 00 0A FA 
       00 2A 08 04 
040625 08 00 00 08 0053*   	dl 8, 8, 64011, fn_Lat15_VGA8_8x8
       00 00 0B FA 
       00 40 08 04 
040631 06 00 00 0C 0054*   	dl 6, 12, 64012, fn_Lat2_Terminus12x6_6x12
       00 00 0C FA 
       00 59 08 04 
04063D 08 00 00 0E 0055*   	dl 8, 14, 64013, fn_Lat2_TerminusBold14_8x14
       00 00 0D FA 
       00 7A 08 04 
040649 08 00 00 0E 0056*   	dl 8, 14, 64014, fn_Lat2_VGA14_8x14
       00 00 0E FA 
       00 9D 08 04 
040655 08 00 00 10 0057*   	dl 8, 16, 64015, fn_Lat2_VGA16_8x16
       00 00 0F FA 
       00 B7 08 04 
040661 08 00 00 08 0058*   	dl 8, 8, 64016, fn_Lat2_VGA8_8x8
       00 00 10 FA 
       00 D1 08 04 
04066D 08 00 00 08 0059*   	dl 8, 8, 64017, fn_Lat38_VGA8_8x8
       00 00 11 FA 
       00 E9 08 04 
040679 08 00 00 0D 0060*   	dl 8, 13, 64018, fn_Lat7_Fixed13_8x13
       00 00 12 FA 
       00 02 09 04 
040685 06 00 00 0C 0061*   	dl 6, 12, 64019, fn_Lat7_Terminus12x6_6x12
       00 00 13 FA 
       00 1E 09 04 
040691 08 00 00 10 0062*   	dl 8, 16, 64020, fn_Lat7_TerminusBold16_8x16
       00 00 14 FA 
       00 3F 09 04 
04069D 08 00 00 0E 0063*   	dl 8, 14, 64021, fn_Lat7_VGA14_8x14
       00 00 15 FA 
       00 62 09 04 
0406A9 08 00 00 10 0064*   	dl 8, 16, 64022, fn_Lat7_VGA16_8x16
       00 00 16 FA 
       00 7C 09 04 
0406B5 08 00 00 08 0065*   	dl 8, 8, 64023, fn_Lat7_VGA8_8x8
       00 00 17 FA 
       00 96 09 04 
0406C1 08 00 00 08 0066*   	dl 8, 8, 64024, fn_planetary_contact_8x8
       00 00 18 FA 
       00 AE 09 04 
0406CD 0C 00 00 0E 0067*   	dl 12, 14, 64025, fn_scriptorium_12x14
       00 00 19 FA 
       00 CE 09 04 
0406D9 08 00 00 0C 0068*   	dl 8, 12, 64026, fn_Squarewave_Bold_8x12
       00 00 1A FA 
       00 EA 09 04 
0406E5 08 00 00 08 0069*   	dl 8, 8, 64027, fn_super_mario_bros_2_8x8
       00 00 1B FA 
       00 09 0A 04 
0406F1 06 00 00 06 0070*   	dl 6, 6, 64028, fn_wendy_neue_6x6
       00 00 1C FA 
       00 2A 0A 04 
0406FD             0071*   
0406FD             0072*   ; files_list: ; filename:
0406FD 66 6F 6E 74 0073*   fn_amiga_forever_16x16: db "fontsamiga_forever_16x16.font",0
       73 61 6D 69 
       67 61 5F 66 
       6F 72 65 76 
       65 72 5F 31 
       36 78 31 36 
       2E 66 6F 6E 
       74 00       
04071B 66 6F 6E 74 0074*   fn_amiga_forever_16x24: db "fontsamiga_forever_16x24.font",0
       73 61 6D 69 
       67 61 5F 66 
       6F 72 65 76 
       65 72 5F 31 
       36 78 32 34 
       2E 66 6F 6E 
       74 00       
040739 66 6F 6E 74 0075*   fn_amiga_forever_8x16: db "fontsamiga_forever_8x16.font",0
       73 61 6D 69 
       67 61 5F 66 
       6F 72 65 76 
       65 72 5F 38 
       78 31 36 2E 
       66 6F 6E 74 
       00          
040756 66 6F 6E 74 0076*   fn_amiga_forever_8x8: db "fontsamiga_forever_8x8.font",0
       73 61 6D 69 
       67 61 5F 66 
       6F 72 65 76 
       65 72 5F 38 
       78 38 2E 66 
       6F 6E 74 00 
040772 66 6F 6E 74 0077*   fn_computer_pixel_7_10x15: db "fontscomputer_pixel_7_10x15.font",0
       73 63 6F 6D 
       70 75 74 65 
       72 5F 70 69 
       78 65 6C 5F 
       37 5F 31 30 
       78 31 35 2E 
       66 6F 6E 74 
       00          
040793 66 6F 6E 74 0078*   fn_computer_pixel_7_10x24: db "fontscomputer_pixel_7_10x24.font",0
       73 63 6F 6D 
       70 75 74 65 
       72 5F 70 69 
       78 65 6C 5F 
       37 5F 31 30 
       78 32 34 2E 
       66 6F 6E 74 
       00          
0407B4 66 6F 6E 74 0079*   fn_computer_pixel_7_8x12: db "fontscomputer_pixel_7_8x12.font",0
       73 63 6F 6D 
       70 75 74 65 
       72 5F 70 69 
       78 65 6C 5F 
       37 5F 38 78 
       31 32 2E 66 
       6F 6E 74 00 
0407D4 66 6F 6E 74 0080*   fn_computer_pixel_7_8x14: db "fontscomputer_pixel_7_8x14.font",0
       73 63 6F 6D 
       70 75 74 65 
       72 5F 70 69 
       78 65 6C 5F 
       37 5F 38 78 
       31 34 2E 66 
       6F 6E 74 00 
0407F4 66 6F 6E 74 0081*   fn_computer_pixel_7_8x16: db "fontscomputer_pixel_7_8x16.font",0
       73 63 6F 6D 
       70 75 74 65 
       72 5F 70 69 
       78 65 6C 5F 
       37 5F 38 78 
       31 36 2E 66 
       6F 6E 74 00 
040814 66 6F 6E 74 0082*   fn_dopecre_8x8: db "fontsdopecre_8x8.font",0
       73 64 6F 70 
       65 63 72 65 
       5F 38 78 38 
       2E 66 6F 6E 
       74 00       
04082A 66 6F 6E 74 0083*   fn_gamer_2_8x8: db "fontsgamer_2_8x8.font",0
       73 67 61 6D 
       65 72 5F 32 
       5F 38 78 38 
       2E 66 6F 6E 
       74 00       
040840 66 6F 6E 74 0084*   fn_Lat15_VGA8_8x8: db "fontsLat15-VGA8_8x8.font",0
       73 4C 61 74 
       31 35 2D 56 
       47 41 38 5F 
       38 78 38 2E 
       66 6F 6E 74 
       00          
040859 66 6F 6E 74 0085*   fn_Lat2_Terminus12x6_6x12: db "fontsLat2-Terminus12x6_6x12.font",0
       73 4C 61 74 
       32 2D 54 65 
       72 6D 69 6E 
       75 73 31 32 
       78 36 5F 36 
       78 31 32 2E 
       66 6F 6E 74 
       00          
04087A 66 6F 6E 74 0086*   fn_Lat2_TerminusBold14_8x14: db "fontsLat2-TerminusBold14_8x14.font",0
       73 4C 61 74 
       32 2D 54 65 
       72 6D 69 6E 
       75 73 42 6F 
       6C 64 31 34 
       5F 38 78 31 
       34 2E 66 6F 
       6E 74 00    
04089D 66 6F 6E 74 0087*   fn_Lat2_VGA14_8x14: db "fontsLat2-VGA14_8x14.font",0
       73 4C 61 74 
       32 2D 56 47 
       41 31 34 5F 
       38 78 31 34 
       2E 66 6F 6E 
       74 00       
0408B7 66 6F 6E 74 0088*   fn_Lat2_VGA16_8x16: db "fontsLat2-VGA16_8x16.font",0
       73 4C 61 74 
       32 2D 56 47 
       41 31 36 5F 
       38 78 31 36 
       2E 66 6F 6E 
       74 00       
0408D1 66 6F 6E 74 0089*   fn_Lat2_VGA8_8x8: db "fontsLat2-VGA8_8x8.font",0
       73 4C 61 74 
       32 2D 56 47 
       41 38 5F 38 
       78 38 2E 66 
       6F 6E 74 00 
0408E9 66 6F 6E 74 0090*   fn_Lat38_VGA8_8x8: db "fontsLat38-VGA8_8x8.font",0
       73 4C 61 74 
       33 38 2D 56 
       47 41 38 5F 
       38 78 38 2E 
       66 6F 6E 74 
       00          
040902 66 6F 6E 74 0091*   fn_Lat7_Fixed13_8x13: db "fontsLat7-Fixed13_8x13.font",0
       73 4C 61 74 
       37 2D 46 69 
       78 65 64 31 
       33 5F 38 78 
       31 33 2E 66 
       6F 6E 74 00 
04091E 66 6F 6E 74 0092*   fn_Lat7_Terminus12x6_6x12: db "fontsLat7-Terminus12x6_6x12.font",0
       73 4C 61 74 
       37 2D 54 65 
       72 6D 69 6E 
       75 73 31 32 
       78 36 5F 36 
       78 31 32 2E 
       66 6F 6E 74 
       00          
04093F 66 6F 6E 74 0093*   fn_Lat7_TerminusBold16_8x16: db "fontsLat7-TerminusBold16_8x16.font",0
       73 4C 61 74 
       37 2D 54 65 
       72 6D 69 6E 
       75 73 42 6F 
       6C 64 31 36 
       5F 38 78 31 
       36 2E 66 6F 
       6E 74 00    
040962 66 6F 6E 74 0094*   fn_Lat7_VGA14_8x14: db "fontsLat7-VGA14_8x14.font",0
       73 4C 61 74 
       37 2D 56 47 
       41 31 34 5F 
       38 78 31 34 
       2E 66 6F 6E 
       74 00       
04097C 66 6F 6E 74 0095*   fn_Lat7_VGA16_8x16: db "fontsLat7-VGA16_8x16.font",0
       73 4C 61 74 
       37 2D 56 47 
       41 31 36 5F 
       38 78 31 36 
       2E 66 6F 6E 
       74 00       
040996 66 6F 6E 74 0096*   fn_Lat7_VGA8_8x8: db "fontsLat7-VGA8_8x8.font",0
       73 4C 61 74 
       37 2D 56 47 
       41 38 5F 38 
       78 38 2E 66 
       6F 6E 74 00 
0409AE 66 6F 6E 74 0097*   fn_planetary_contact_8x8: db "fontsplanetary_contact_8x8.font",0
       73 70 6C 61 
       6E 65 74 61 
       72 79 5F 63 
       6F 6E 74 61 
       63 74 5F 38 
       78 38 2E 66 
       6F 6E 74 00 
0409CE 66 6F 6E 74 0098*   fn_scriptorium_12x14: db "fontsscriptorium_12x14.font",0
       73 73 63 72 
       69 70 74 6F 
       72 69 75 6D 
       5F 31 32 78 
       31 34 2E 66 
       6F 6E 74 00 
0409EA 66 6F 6E 74 0099*   fn_Squarewave_Bold_8x12: db "fontsSquarewave_Bold_8x12.font",0
       73 53 71 75 
       61 72 65 77 
       61 76 65 5F 
       42 6F 6C 64 
       5F 38 78 31 
       32 2E 66 6F 
       6E 74 00    
040A09 66 6F 6E 74 0100*   fn_super_mario_bros_2_8x8: db "fontssuper_mario_bros_2_8x8.font",0
       73 73 75 70 
       65 72 5F 6D 
       61 72 69 6F 
       5F 62 72 6F 
       73 5F 32 5F 
       38 78 38 2E 
       66 6F 6E 74 
       00          
040A2A 66 6F 6E 74 0101*   fn_wendy_neue_6x6: db "fontswendy_neue_6x6.font",0
       73 77 65 6E 
       64 79 5F 6E 
       65 75 65 5F 
       36 78 36 2E 
       66 6F 6E 74 
       00          
040A43             0039        include "fixed168.inc"
040A43             0001*   ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
040A43             0002*   ; uses EZ80 MLT instruction for speed
040A43             0003*   ; operation: UHL * A --> UHL
040A43             0004*   ; destroys: AF, HL
040A43             0005*   smul24x8:
040A43             0006*   ; make hl positive and store sign flag
040A43 CD 5E 04 04 0007*       call hlu_abs
040A47 F5          0008*       push af
040A48             0009*   ; do the division
040A48 CD 53 0A 04 0010*       call mul24x8 ; hl = product
040A4C             0011*   ; adjust sign of result
040A4C F1          0012*       pop af ; sign de
040A4D F0          0013*       ret p ; hl was positive, nothing to do
040A4E CD 6E 04 04 0014*       call neg_hlu ; result is negative
040A52 C9          0015*       ret
040A53             0016*   
040A53             0017*   ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
040A53             0018*   ; uses EZ80 MLT instruction for speed
040A53             0019*   ; operation: UHL * A --> AUHL
040A53             0020*   ; destroys: AF, HL
040A53             0021*   mul24x8:
040A53 D5          0022*       push de ; preserve de
040A54             0023*   ; low byte
040A54 5D          0024*       ld e,l
040A55 57          0025*       ld d,a
040A56 ED 5C       0026*       mlt de
040A58 6B          0027*       ld l,e ; product low byte
040A59 08          0028*       ex af,af' ; save multiplier
040A5A 7A          0029*       ld a,d ; carry
040A5B 08          0030*       ex af,af' ; save carry, restore multiplier
040A5C             0031*   ; high byte
040A5C 5C          0032*       ld e,h
040A5D 57          0033*       ld d,a
040A5E ED 5C       0034*       mlt de
040A60 08          0035*       ex af,af' ; save multiplier, restore carry
040A61 83          0036*       add a,e ; add carry
040A62 67          0037*       ld h,a ; product middle byte
040A63 7A          0038*       ld a,d ; carry
040A64 08          0039*       ex af,af' ; save carry, restore multiplier
040A65             0040*   ; upper byte
040A65 22 80 0A 04 0041*       ld (@scratch),hl ; 7 cycles
040A69 5F          0042*       ld e,a
040A6A 3A 82 0A 04 0043*       ld a,(@scratch+2)
040A6E 57          0044*       ld d,a
040A6F ED 5C       0045*       mlt de
040A71 08          0046*       ex af,af' ; restore carry
040A72 8B          0047*       adc a,e ; add carry
040A73 32 82 0A 04 0048*       ld (@scratch+2),a ; 5 cycles
040A77 2A 80 0A 04 0049*       ld hl,(@scratch) ; 7 cycles
040A7B             0050*   ; highest byte
040A7B 3E 00       0051*       ld a,0 ; preserve carry flag
040A7D 8A          0052*       adc a,d ; product highest byte
040A7E D1          0053*       pop de ; restore de
040A7F C9          0054*       ret
040A80             0055*   @scratch: ds 3
040A83             0056*   
       FF FF FF 
040A83 00 00 00 00 0057*   mul24out: blkb 6,0
       00 00       
040A89             0058*   
040A89             0059*   ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
040A89             0060*   ; operation: UHL * UDE --> mul24out
040A89             0061*   mul24:
040A89 DD E5       0062*       push ix ; preserve
040A8B             0063*   ; point to output buffer and clear it
040A8B DD 21 83 0A 0064*       ld ix,mul24out
       04          
040A90 C5          0065*       push bc
040A91 01 00 00 00 0066*       ld bc,0
040A95 DD 0F 00    0067*       ld (ix),bc
040A98 DD 0F 03    0068*       ld (ix+3),bc
040A9B C1          0069*       pop bc
040A9C             0070*   ; STEP 1: UHL * E
040A9C 7B          0071*       ld a,e
040A9D E5          0072*       push hl
040A9E CD 53 0A 04 0073*       call mul24x8
040AA2 DD 2F 00    0074*       ld (ix+0),hl
040AA5 DD 77 03    0075*       ld (ix+3),a
040AA8             0076*   ; STEP 2: UHL * D
040AA8 E1          0077*       pop hl
040AA9 E5          0078*       push hl
040AAA 7A          0079*       ld a,d
040AAB CD 53 0A 04 0080*       call mul24x8
040AAF CD C8 0A 04 0081*       call @accumulate
040AB3             0082*   ; STEP 3: UHL * DEU
040AB3 E1          0083*       pop hl
040AB4 ED 53 F8 0A 0084*       ld (@de),de
       04          
040AB9 3A FA 0A 04 0085*       ld a,(@de+2)
040ABD CD 53 0A 04 0086*       call mul24x8
040AC1 CD C8 0A 04 0087*       call @accumulate
040AC5             0088*   ; all done
040AC5 DD E1       0089*       pop ix ; restore
040AC7 C9          0090*       ret
040AC8             0091*   @accumulate:
040AC8 DD 23       0092*       inc ix
040ACA             0093*   ; highest byte of product to carry
040ACA DD 77 03    0094*       ld (ix+3),a
040ACD             0095*   ; low byte of product
040ACD 7D          0096*       ld a,l
040ACE DD 86 00    0097*       add a,(ix+0)
040AD1 DD 77 00    0098*       ld (ix+0),a
040AD4             0099*   ; high byte of product
040AD4 7C          0100*       ld a,h
040AD5 DD 8E 01    0101*       adc a,(ix+1)
040AD8 DD 77 01    0102*       ld (ix+1),a
040ADB             0103*   ; uppper byte of product
040ADB 22 F5 0A 04 0104*       ld (@hl),hl
040ADF 3A F7 0A 04 0105*       ld a,(@hl+2)
040AE3 DD 8E 02    0106*       adc a,(ix+2)
040AE6 DD 77 02    0107*       ld (ix+2),a
040AE9             0108*   ; carry
040AE9 3E 00       0109*       ld a,0 ; preserve flags
040AEB DD 8E 03    0110*       adc a,(ix+3)
040AEE DD 77 03    0111*       ld (ix+3),a
040AF1 C9          0112*       ret
040AF2             0113*   
040AF2 00 00 00    0114*   @ix: dl 0
040AF5 00 00 00    0115*   @hl: dl 0
040AF8 00 00 00    0116*   @de: dl 0
040AFB             0117*   
040AFB             0118*   ; ; UHL * UDE --> UHL (unsigned)
040AFB             0119*   ; umul24:
040AFB             0120*   ;     call mul24
040AFB             0121*   ;     ld hl,(mul24out)
040AFB             0122*   ;     ret
040AFB             0123*   
040AFB             0124*   ; UH.L = UH.L*UD.E (unsigned)
040AFB             0125*   umul168:
040AFB CD 89 0A 04 0126*       call mul24
040AFF 2A 84 0A 04 0127*       ld hl,(mul24out+1)
040B03 C9          0128*       ret
040B04             0129*   
040B04             0130*   ; UH.L * UD.E --> UH.L (signed)
040B04             0131*   smul168:
040B04             0132*   ; make everything positive and store sign flags
040B04 CD 5E 04 04 0133*       call hlu_abs
040B08 F5          0134*       push af
040B09 EB          0135*       ex de,hl
040B0A CD 5E 04 04 0136*       call hlu_abs
040B0E EB          0137*       ex de,hl
040B0F F5          0138*       push af
040B10             0139*   ; do the division
040B10 CD FB 0A 04 0140*       call umul168 ; hl = product
040B14             0141*   ; adjust sign of result
040B14 F1          0142*       pop af ; sign de
040B15 FA 20 0B 04 0143*       jp m,@de_neg
040B19 F1          0144*       pop af ; sign hl
040B1A F0          0145*       ret p ; both positive, nothing to do
040B1B             0146*   @hl_neg:
040B1B CD 6E 04 04 0147*       call neg_hlu ; de pos, hl neg, result is negative
040B1F C9          0148*       ret
040B20             0149*   @de_neg:
040B20 F1          0150*       pop af
040B21 F8          0151*       ret m ; both negative, nothing to do
040B22 CD 6E 04 04 0152*       call neg_hlu ; result is negative
040B26 C9          0153*       ret
040B27             0154*   
040B27             0155*   ; UH.L / UD.E --> UD.E rem UHL (unsigned)
040B27             0156*   ; perform unsigned division of 16.8 fixed place values
040B27             0157*   ; with an unsigned 16.8 fixed place result and 24-bit remainder
040B27             0158*   udiv168:
040B27             0159*   ; back up divisor
040B27 ED 53 5E 0B 0160*       ld (@ude),de
       04          
040B2C             0161*   ; get the 16-bit integer part of the quotient
040B2C CD 6E 03 04 0162*       call udiv24 ; de = quotient, hl = remainder
040B30             0163*   ; load quotient to upper three bytes of output
040B30 ED 53 65 0B 0164*       ld (div168_out+1),de
       04          
040B35             0165*   @div256:
040B35             0166*   ; multiply remainder by 256
040B35             0167*       hlu_mul256
040B35 29          0001*M1     add hl,hl ; * 2
040B36 29          0002*M1     add hl,hl ; * 4
040B37 29          0003*M1     add hl,hl ; * 8
040B38 29          0004*M1     add hl,hl ; * 16
040B39 29          0005*M1     add hl,hl ; * 32
040B3A 29          0006*M1     add hl,hl ; * 64
040B3B 29          0007*M1     add hl,hl ; * 128
040B3C 29          0008*M1     add hl,hl ; * 256
040B3D             0168*   ; skip fractional computation if remainder is zero
040B3D             0169*       SIGN_HLU
040B3D 19          0001*M1     add hl,de ; 1 cycle
040B3E B7          0002*M1     or a ; clear flags ; 1 cycle
040B3F ED 52       0003*M1     sbc hl,de ; 2 cycles
040B41             0004*M1     ; 4 cycles total
040B41 20 03       0170*       jr nz,@div_frac
040B43 AF          0171*       xor a
040B44 18 0A       0172*       jr @write_frac
040B46             0173*   ; now divide the shifted remainder by the divisor
040B46             0174*   @div_frac:
040B46 ED 5B 5E 0B 0175*       ld de,(@ude) ; get back divisor
       04          
040B4B CD 6E 03 04 0176*       call udiv24 ; de = quotient, hl = remainder
040B4F             0177*   ; load low byte of quotient to low byte of output
040B4F 7B          0178*       ld a,e
040B50             0179*   @write_frac:
040B50 32 64 0B 04 0180*       ld (div168_out),a
040B54             0181*   ; load de with return value
040B54 ED 5B 64 0B 0182*       ld de,(div168_out)
       04          
040B59             0183*   ; load a with any overflow
040B59 3A 67 0B 04 0184*       ld a,(div168_out+3)
040B5D C9          0185*       ret ; ud.e is the 16.8 result
040B5E             0186*   @ude: ds 6
040B64             0187*   div168_out: ds 4 ; the extra byte is for overflow
040B68             0188*   
040B68             0189*   ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
040B68             0190*   ; perform signed division of 16.8 fixed place values
040B68             0191*   ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
040B68             0192*   sdiv168:
040B68             0193*   ; make everything positive and store sign flags
       FF FF FF FF 
       FF FF FF FF 
       FF FF 
040B68 CD 5E 04 04 0194*       call hlu_abs
040B6C F5          0195*       push af
040B6D EB          0196*       ex de,hl
040B6E CD 5E 04 04 0197*       call hlu_abs
040B72 EB          0198*       ex de,hl
040B73 F5          0199*       push af
040B74             0200*   ; do the division
040B74 CD 27 0B 04 0201*       call udiv168 ; de = quotient, hl = remainder
040B78             0202*   ; adjust sign of result
040B78 F1          0203*       pop af ; sign de
040B79 FA 86 0B 04 0204*       jp m,@de_neg
040B7D F1          0205*       pop af ; sign hl
040B7E F0          0206*       ret p ; both positive, nothing to do
040B7F             0207*   @hl_neg:
040B7F EB          0208*       ex de,hl ; hl = quotient, de = remainder
040B80 CD 6E 04 04 0209*       call neg_hlu ; de pos, hl neg, result is negative
040B84 EB          0210*       ex de,hl ; de = negated quotient, hl = remainder
040B85 C9          0211*       ret
040B86             0212*   @de_neg:
040B86 F1          0213*       pop af
040B87 F8          0214*       ret m ; both negative, nothing to do
040B88 EB          0215*       ex de,hl ; hl = quotient, de = remainder
040B89 CD 6E 04 04 0216*       call neg_hlu ; result is negative
040B8D EB          0217*       ex de,hl ; de = negated quotient, hl = remainder
040B8E C9          0218*       ret
040B8F             0219*   
040B8F             0220*   ; convert signed angles from a 360 to 256 degree circle
040B8F             0221*   ; inputs: uh.l is the angle360 in 16.8 fixed format
040B8F             0222*   ; outputs: uh.l is the angle256 in 16.8 fixed format
040B8F             0223*   ; destroys: TODO
040B8F             0224*   deg_360_to_256:
040B8F D5          0225*       push de ; preserve de
040B90             0226*   ; make angle positive and store sign flag
040B90 CD 5E 04 04 0227*       call hlu_abs
040B94 F5          0228*       push af
040B95             0229*   ; multiply by coversion factor of 256/360
040B95 11 B6 00 00 0230*       ld de,0x0000B6 ; 0.711
040B99 CD FB 0A 04 0231*       call umul168 ; uh.l = uh.l * 0.711
040B9D             0232*   ; restore sign flag and adjust output accordingly
040B9D F1          0233*       pop af
040B9E F2 A6 0B 04 0234*       jp p,@pos ; positive number
040BA2 CD 6E 04 04 0235*       call neg_hlu
040BA6             0236*   @pos:
040BA6             0237*   ; restore de and return uh.l as the result
040BA6 D1          0238*       pop de
040BA7 C9          0239*       ret
040BA8             0240*   
040BA8             0241*   ; convert signed angles from a 256 to 360 degree circle
040BA8             0242*   ; inputs: uh.l is the angle256 in 16.8 fixed format
040BA8             0243*   ; outputs: uh.l is the angle360 in 16.8 fixed format
040BA8             0244*   ; destroys: TODO
040BA8             0245*   deg_256_to_360:
040BA8 D5          0246*       push de ; preserve de
040BA9             0247*   ; make angle positive and store sign flag
040BA9 CD 5E 04 04 0248*       call hlu_abs
040BAD F5          0249*       push af
040BAE             0250*   ; multiply by coversion factor of 360/256
040BAE 11 68 01 00 0251*       ld de,0x000168 ; 1.406
040BB2 CD FB 0A 04 0252*       call umul168 ; uh.l = uh.l * 1.406
040BB6             0253*   ; restore sign flag and adjust output accordingly
040BB6 F1          0254*       pop af
040BB7 F2 BF 0B 04 0255*       jp p,@pos ; positive number
040BBB CD 6E 04 04 0256*       call neg_hlu
040BBF             0257*   @pos:
040BBF             0258*   ; restore de and return uh.l as the result
040BBF D1          0259*       pop de
040BC0 C9          0260*       ret
040BC1             0261*   
040BC1             0262*   ; fixed 16.8 routine
040BC1             0263*   ; cos(uh.l) --> uh.l
040BC1             0264*   ; destroys: f, hl
040BC1             0265*   cos168:
040BC1 D5          0266*       push de ; preserve de
040BC2             0267*   ; for cos we simply increment the angle by 90 degrees
040BC2             0268*   ; or 0x004000 in 16.8 degrees256
040BC2             0269*   ; which makes it a sin problem
040BC2 11 00 40 00 0270*       ld de,0x004000
040BC6 19          0271*       add hl,de ; modulo 256 happens below
040BC7 D1          0272*       pop de ; restore de
040BC8             0273*   ; fall through to sin168
040BC8             0274*   
040BC8             0275*   ; ---------------------
040BC8             0276*   ; fixed 16.8 routine
040BC8             0277*   ; sin(uh.l) --> uh.l
040BC8             0278*   ; destroys: f, hl
040BC8             0279*   sin168:
040BC8 D5          0280*       push de
040BC9             0281*   ; handle negative angles appropriately
040BC9 CD 5E 04 04 0282*       call hlu_abs
040BCD F2 D6 0B 04 0283*       jp p,@F
040BD1 11 00 00 FF 0284*       ld de,-256*256
040BD5 19          0285*       add hl,de
040BD6             0286*   @@:
040BD6 2E 03       0287*       ld l,3 ; multiply by 3 to get our lookup index
040BD8 ED 6C       0288*       mlt hl
040BDA 11 8E 0E 04 0289*       ld de,sin_lut_168 ; grab the lut address
040BDE 19          0290*       add hl,de ; bump hl by the index
040BDF ED 27       0291*       ld hl,(hl) ; don't try this on a z80!
040BE1 D1          0292*       pop de
040BE2 C9          0293*       ret
040BE3             0294*   
040BE3             0295*   ; 16.8 fixed inputs / outputs
040BE3             0296*   ; takes: uh.l as angle in degrees 256
040BE3             0297*   ;        ud.e as radius
040BE3             0298*   ; returns ub.c as dx, ud.e as dy, uh.l as radius
040BE3             0299*   ;        displacements from origin (0,0)
040BE3             0300*   ; destroys: everything except indexes
040BE3             0301*   polar_to_cartesian:
040BE3             0302*   ; back up input parameters
040BE3 22 12 0C 04 0303*       ld (@angle), hl
040BE7 ED 53 15 0C 0304*       ld (@radius), de
       04          
040BEC             0305*   ; compute dx = sin(uh.l) * ud.e
040BEC CD C8 0B 04 0306*       call sin168 ; uh.l = sin(uh.l)
040BF0 ED 5B 15 0C 0307*       ld de,(@radius)
       04          
040BF5 CD 04 0B 04 0308*       call smul168 ; uh.l = dx
040BF9 E5          0309*       push hl
040BFA             0310*   ; compute dy = -cos(uh.l) * ud.e
040BFA 2A 12 0C 04 0311*       ld hl,(@angle)
040BFE CD C1 0B 04 0312*       call cos168 ; uh.l = cos(uh.l)
040C02 ED 5B 15 0C 0313*       ld de,(@radius)
       04          
040C07 CD 04 0B 04 0314*       call smul168 ; uh.l = dy
040C0B CD 6E 04 04 0315*       call neg_hlu ; invert dy for screen coords convention
040C0F EB          0316*       ex de,hl ; de = dy for output
040C10 C1          0317*       pop bc ; bc = dx for output
040C11             0318*   ; and out
040C11 C9          0319*       ret
040C12             0320*   @angle: ds 3
040C15             0321*   @radius: ds 3
040C18             0322*   
040C18             0323*   ; 16.8 fixed inputs / outputs
040C18             0324*   ; inputs: ub.c as dx, ud.e as dy
040C18             0325*   ;        displacements from origin (0,0)
040C18             0326*   ; returns: uh.l as angle in degrees 256
040C18             0327*   ;        ud.e as radius
040C18             0328*   ; destroys: everything except indexes
040C18             0329*   cartesian_to_polar:
       FF FF FF FF 
       FF FF 
040C18 ED 43 71 0C 0330*       ld (dx168),bc ; dx argument for distance168
       04          
040C1D ED 53 77 0C 0331*       ld (dy168),de ; dy argument for distance168
       04          
040C22             0332*   ; compute radius
040C22 CD 7D 0C 04 0333*       call distance168 ; uh.l = radius
040C26 E5          0334*       push hl ; save radius
040C27             0335*   ; compute angle
040C27 ED 4B 71 0C 0336*       ld bc,(dx168) ; dx argument for atan2_168fast
       04          
040C2C ED 5B 77 0C 0337*       ld de,(dy168) ; dy argument for atan2_168fast
       04          
040C31 CD DD 0C 04 0338*       call atan2_168fast ; uh.l = angle
040C35             0339*   ; return result
040C35 D1          0340*       pop de ; de = radius (was hl)
040C36 C9          0341*       ret
040C37             0342*   ; end cartesian_to_polar
040C37             0343*   
040C37             0344*   ; 16.8 fixed inputs / outputs
040C37             0345*   ; inputs: ub.c as dx, ud.e as dy
040C37             0346*   ;        displacements from origin (0,0)
040C37             0347*   ; returns: uh.l as angle in degrees 256
040C37             0348*   ;        ud.e as radius
040C37             0349*   ; destroys: everything except indexes
040C37             0350*   ; note: uses distance168sm which is more accurate for small deltas
040C37             0351*   cartesian_to_polar_sm:
040C37 ED 43 71 0C 0352*       ld (dx168),bc ; dx argument for distance168
       04          
040C3C ED 53 77 0C 0353*       ld (dy168),de ; dy argument for distance168
       04          
040C41             0354*   ; compute radius
040C41 CD B8 0C 04 0355*       call distance168sm ; uh.l = radius
040C45 E5          0356*       push hl ; save radius
040C46             0357*   ; compute angle
040C46 ED 4B 71 0C 0358*       ld bc,(dx168) ; dx argument for atan2_168fast
       04          
040C4B ED 5B 77 0C 0359*       ld de,(dy168) ; dy argument for atan2_168fast
       04          
040C50 CD DD 0C 04 0360*       call atan2_168fast ; uh.l = angle
040C54             0361*   ; return result
040C54 D1          0362*       pop de ; de = radius (was hl)
040C55 C9          0363*       ret
040C56             0364*   ; end cartesian_to_polar
040C56             0365*   
040C56             0366*   ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
040C56             0367*   ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
040C56             0368*   ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
040C56             0369*   ;         also populates scratch locations dx168 and dy168
040C56             0370*   ; destroys: a,hl,bc,de
040C56             0371*   dxy168:
040C56             0372*   ; compute dx = x1-x0
040C56 AF          0373*       xor a ; clear carry
040C57 DD E5       0374*       push ix ; move ix to hl via the stack
040C59 E1          0375*       pop hl ; hl = x1
040C5A ED 42       0376*       sbc hl,bc ; hl = dx
040C5C 22 71 0C 04 0377*       ld (dx168),hl ; dx to scratch
040C60             0378*   ; compute dy = y1-y0
040C60 AF          0379*       xor a ; clear carry
040C61 FD E5       0380*       push iy ; move iy to hl via the stack
040C63 E1          0381*       pop hl ; hl = y1
040C64 ED 52       0382*       sbc hl,de ; hl = dy
040C66 22 77 0C 04 0383*       ld (dy168),hl ; dy to scratch
040C6A             0384*   ; populate output registers and return
040C6A EB          0385*       ex de,hl ; ud.e = dy
040C6B ED 4B 71 0C 0386*       ld bc,(dx168) ; ub.c = dx
       04          
040C70 C9          0387*       ret
040C71 00 00 00 00 0388*   dx168: blkb 6,0
       00 00       
040C77 00 00 00 00 0389*   dy168: blkb 6,0
       00 00       
040C7D             0390*   
040C7D             0391*   ; compute the euclidian distance between two cartesian coordinates
040C7D             0392*   ; using the formula d = sqrt(dx^2+dy^2)
040C7D             0393*   ; inputs: dx168 and dy168 are dx and dy in 16.8 fixed format
040C7D             0394*   ; output; uh.l is the 16.8 fixed format distance
040C7D             0395*   ;         also populates scratch locations dx168 and dy168
040C7D             0396*   ; destroys: a,hl,bc,de
040C7D             0397*   ; NOTE: rounds both deltas down to the nearest integer to avoid overflow when squaring,
040C7D             0398*   ;       thus the result will always be an integer, albeit in 16.8 format
040C7D             0399*   distance168:
040C7D             0400*   ; compute dy^2
040C7D 2A 77 0C 04 0401*       ld hl,(dy168)
040C81 CD 5E 04 04 0402*       call hlu_abs
040C85             0403*       ; call hlu_udiv256 ; make integer to avoid overflow
040C85             0404*       SRL_UHL ; make integer to avoid overflow
040C85 3B          0001*M1     dec sp ; 1 cycle
040C86 E5          0002*M1     push hl ; 4 cycles
040C87 33          0003*M1     inc sp ; 1 cycle
040C88 E1          0004*M1     pop hl ; 4 cycles
040C89 23          0005*M1     inc hl ; 1 cycle
040C8A 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
040C8C             0007*M1     ; 13 cycles total
040C8C E5          0405*       push hl
040C8D D1          0406*       pop de
040C8E CD 55 03 04 0407*       call umul24 ; hl = dy^2
040C92 E5          0408*       push hl ; save dy^2
040C93             0409*   ; compute dx^2
040C93 2A 71 0C 04 0410*       ld hl,(dx168)
040C97 CD 5E 04 04 0411*       call hlu_abs
040C9B             0412*       ; call hlu_udiv256 ; make integer to avoid overflow
040C9B             0413*       SRL_UHL ; make integer to avoid overflow
040C9B 3B          0001*M1     dec sp ; 1 cycle
040C9C E5          0002*M1     push hl ; 4 cycles
040C9D 33          0003*M1     inc sp ; 1 cycle
040C9E E1          0004*M1     pop hl ; 4 cycles
040C9F 23          0005*M1     inc hl ; 1 cycle
040CA0 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
040CA2             0007*M1     ; 13 cycles total
040CA2 E5          0414*       push hl
040CA3 D1          0415*       pop de
040CA4 CD 55 03 04 0416*       call umul24 ; hl = dx^2
040CA8             0417*   ; add dx^2 and dy^2
040CA8 D1          0418*       pop de ; de = dy^2 (was hl)
040CA9 19          0419*       add hl,de ; hl = dx^2 + dy^2
040CAA             0420*   ; compute the square root
040CAA CD A8 0D 04 0421*       call sqrt24 ; de = sqrt(dx^2 + dy^2)
040CAE EB          0422*       ex de,hl ; hl = distance
040CAF             0423*       hlu_mul256 ; convert back to 16.8 fixed
040CAF 29          0001*M1     add hl,hl ; * 2
040CB0 29          0002*M1     add hl,hl ; * 4
040CB1 29          0003*M1     add hl,hl ; * 8
040CB2 29          0004*M1     add hl,hl ; * 16
040CB3 29          0005*M1     add hl,hl ; * 32
040CB4 29          0006*M1     add hl,hl ; * 64
040CB5 29          0007*M1     add hl,hl ; * 128
040CB6 29          0008*M1     add hl,hl ; * 256
040CB7 C9          0424*       ret
040CB8             0425*   
040CB8             0426*   ; compute the euclidian distance between two cartesian coordinates
040CB8             0427*   ; using the formula d = sqrt(dx^2+dy^2)
040CB8             0428*   ; inputs: dx168 and dy168 are dx and dy in 16.8 fixed format
040CB8             0429*   ; output; uh.l is the 16.8 fixed format distance
040CB8             0430*   ;         also populates scratch locations dx168 and dy168
040CB8             0431*   ; destroys: a,hl,bc,de
040CB8             0432*   ; NOTE: sm means 'small' because it doesn't round down the deltas
040CB8             0433*   ;       making it more accurate for small deltas,
040CB8             0434*   ;       but will overflow if used for screen-sized deltas
040CB8             0435*   distance168sm:
040CB8             0436*   ; compute dy^2
040CB8 2A 77 0C 04 0437*       ld hl,(dy168)
040CBC CD 5E 04 04 0438*       call hlu_abs
040CC0 E5          0439*       push hl
040CC1 D1          0440*       pop de
040CC2 CD 55 03 04 0441*       call umul24 ; hl = dy^2
040CC6 E5          0442*       push hl ; save dy^2
040CC7             0443*   ; compute dx^2
040CC7 2A 71 0C 04 0444*       ld hl,(dx168)
040CCB CD 5E 04 04 0445*       call hlu_abs
040CCF E5          0446*       push hl
040CD0 D1          0447*       pop de
040CD1 CD 55 03 04 0448*       call umul24 ; hl = dx^2
040CD5             0449*   ; add dx^2 and dy^2
040CD5 D1          0450*       pop de ; de = dy^2 (was hl)
040CD6 19          0451*       add hl,de ; hl = dx^2 + dy^2
040CD7             0452*   ; compute the square root
040CD7 CD A8 0D 04 0453*       call sqrt24 ; de = sqrt(dx^2 + dy^2)
040CDB EB          0454*       ex de,hl ; hl = distance
040CDC C9          0455*       ret
040CDD             0456*   
040CDD             0457*   ; atan2_(ub.c,ud.e) --> uh.l
040CDD             0458*   ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040CDD             0459*   ;   whether inputs are integers or fractional doesn't matter
040CDD             0460*   ;   so long as the sign bit of the upper byte is correct
040CDD             0461*   ; output: uh.l is the 16.8 fixed angle in degrees 256
040CDD             0462*   ; angles are COMPASS HEADINGS based on
040CDD             0463*   ; screen coordinate conventions,where the y axis is flipped
040CDD             0464*   ; #E0 224      0       32 #20
040CDD             0465*   ;        -x,-y | +x,-y
040CDD             0466*   ; #C0 192------+------ 64 #40
040CDD             0467*   ;        -x,+y | +x,+y
040CDD             0468*   ; #A0 160   128 #80   96 #60
040CDD             0469*   atan2_168fast:
040CDD             0470*   ; get signs and make everything positive
040CDD             0471*   ; get abs(x) and store its original sign
040CDD C5          0472*       push bc
040CDE E1          0473*       pop hl
040CDF CD 5E 04 04 0474*       call hlu_abs ; if x was negative this also sets the sign flag
040CE3 E5          0475*       push hl ; store abs(x)
040CE4 C1          0476*       pop bc ; bc = abs(x)
040CE5 F5          0477*       push af ; store sign of x
040CE6             0478*   ; get abs(y) and store its original sign
040CE6 EB          0479*       ex de,hl ; hl = y
040CE7 CD 5E 04 04 0480*       call hlu_abs ; if y was negative this also sets the sign flag
040CEB EB          0481*       ex de,hl ; de = abs(y)
040CEC F5          0482*       push af ; store sign of y
040CED             0483*   ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
040CED             0484*   ; this ensures that our lookup value is between 0 and 1 inclusive
040CED AF          0485*       xor a ; clear the carry flag
040CEE D5          0486*       push de
040CEF E1          0487*       pop hl
040CF0 ED 42       0488*       sbc hl,bc
040CF2 F5          0489*       push af ; save sign of de - bc
040CF3 F2 FC 0C 04 0490*       jp p,@1 ; bc <= de, so we skip ahead
040CF7             0491*   ; otherwise we swap bc and de
040CF7 C5          0492*       push bc
040CF8 E1          0493*       pop hl
040CF9 EB          0494*       ex de,hl
040CFA E5          0495*       push hl
040CFB C1          0496*       pop bc
040CFC             0497*   @1:
040CFC             0498*   ; now we're ready to snag our preliminary result
040CFC C5          0499*       push bc
040CFD E1          0500*       pop hl
040CFE CD 6C 0D 04 0501*       call atan_168fast ; uh.l comes back with prelim result
040D02             0502*   ; now we adjust uh.l based on sign of de - bc
040D02 F1          0503*       pop af
040D03 F2 0F 0D 04 0504*       jp p,@2 ; bc <= de,so we skip ahead
040D07 EB          0505*       ex de,hl
040D08 21 00 40 00 0506*       ld hl,64*256 ; subtract from 64 (90) degrees
040D0C AF          0507*       xor a ; clear the carry flag
040D0D ED 52       0508*       sbc hl,de
040D0F             0509*   @2:
040D0F             0510*   ; adjust the result based on quadrant
040D0F             0511*   ; #E0 224      0       32 #20
040D0F             0512*   ;        -x,-y | +x,-y
040D0F             0513*   ; #C0 192------+------ 64 #40
040D0F             0514*   ;        -x,+y | +x,+y
040D0F             0515*   ; #A0 160   128 #80   96 #60
040D0F F1          0516*       pop af ; sign of y
040D10 CA 4D 0D 04 0517*       jp z,@y_zero
040D14 F2 2D 0D 04 0518*       jp p,@y_pos
040D18             0519*   ; y neg,check x
040D18 F1          0520*       pop af ; sign of x
040D19 CA 27 0D 04 0521*       jp z,@y_neg_x_zero
040D1D F2 2C 0D 04 0522*       jp p,@y_neg_x_pos
040D21             0523*   ; y neg,x neg
040D21             0524*   ; angle is 128 to 256 (270 to 360)
040D21             0525*   ; negating the intermediate does the trick
040D21 CD 6E 04 04 0526*       call neg_hlu
040D25 18 31       0527*       jr @zero_hlu
040D27             0528*   
040D27             0529*   @y_neg_x_zero:
040D27             0530*   ; y neg,x zero
040D27             0531*   ; angle is 0
040D27 21 00 00 00 0532*       ld hl,0
040D2B C9          0533*       ret
040D2C             0534*   @y_neg_x_pos:
040D2C             0535*   ; y neg,x pos
040D2C             0536*   ; angle is 0 to 64 (0 to 90)
040D2C             0537*   ; so we're good
040D2C C9          0538*       ret
040D2D             0539*   
040D2D             0540*   @y_pos:
040D2D F1          0541*       pop af ; sign of x
040D2E CA 3D 0D 04 0542*       jp z,@y_pos_x_zero
040D32 F2 42 0D 04 0543*       jp p,@y_pos_x_pos
040D36             0544*   ; y pos,x neg
040D36             0545*   ; angle is 128 to 192 (180-270)
040D36             0546*   ; so we add 128 to intermediate
040D36 11 00 80 00 0547*       ld de,128*256
040D3A 19          0548*       add hl,de
040D3B 18 1B       0549*       jr @zero_hlu
040D3D             0550*   @y_pos_x_zero:
040D3D             0551*   ; y pos,x zero
040D3D             0552*   ; angle is 128 (180)
040D3D 21 00 80 00 0553*       ld hl,128*256
040D41 C9          0554*       ret
040D42             0555*   @y_pos_x_pos:
040D42             0556*   ; y pos,x pos
040D42             0557*   ; angle is 64 to 128 (90 to 180)
040D42             0558*   ; neg the intermediate and add 180 degrees
040D42 CD 6E 04 04 0559*       call neg_hlu
040D46 11 00 80 00 0560*       ld de,128*256
040D4A 19          0561*       add hl,de
040D4B 18 0B       0562*       jr @zero_hlu
040D4D             0563*   
040D4D             0564*   @y_zero:
040D4D F1          0565*       pop af ; sign of x
040D4E FA 53 0D 04 0566*       jp m,@y_zero_x_neg
040D52             0567*   ; y zero,x pos
040D52             0568*   ; angle is 64 (90),nothing to do
040D52 C9          0569*       ret
040D53             0570*   @y_zero_x_neg:
040D53             0571*   ; y zero ,x neg
040D53             0572*   ; angle is 192 (270)
040D53 21 00 C0 00 0573*       ld hl,192*256
040D57 C9          0574*       ret
040D58             0575*   @zero_hlu:
040D58 AF          0576*       xor a
040D59 22 66 0D 04 0577*       ld (@scratch),hl
040D5D 32 68 0D 04 0578*       ld (@scratch+2),a
040D61 2A 66 0D 04 0579*       ld hl,(@scratch)
040D65 C9          0580*       ret
040D66             0581*   @scratch: ds 6
040D6C             0582*   
040D6C             0583*   ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040D6C             0584*   ; output: uh.l is the 16.8 fixed format angle in degrees 256
040D6C             0585*   ; destroys: a,hl,bc,de
040D6C             0586*   ; note: only works for angles from 0 to 32 (45) degrees
040D6C             0587*   ;   use atan2_168fast (which calls this proc) to handle the full 256 (360) degrees
040D6C             0588*   atan_168fast:
040D6C             0589*   ; because we use compass headings instead of geometric angles
040D6C             0590*   ; we compute dx/dy which is 1/tan(theta) in the maths world
040D6C             0591*   ; we can do faster unsigned division here because we know dx and dy are positive
       FF FF FF FF 
       FF FF 
040D6C CD 27 0B 04 0592*       call udiv168 ; ud.e = dx/dy
040D70 EB          0593*       ex de,hl ; uh.l = dx/dy
040D71             0594*   ; test uh.l for 0
040D71 19          0595*       add hl,de
040D72 B7          0596*       or a
040D73 ED 52       0597*       sbc hl,de
040D75 28 22       0598*       jr z,@is_zero
040D77             0599*   ; test uh.l for 1
040D77 AF          0600*       xor a ; clear carry
040D78 EB          0601*       ex de,hl
040D79 21 00 01 00 0602*       ld hl,1*256 ; 1 in 16.8 fixed format
040D7D ED 52       0603*       sbc hl,de
040D7F 28 13       0604*       jr z,@is_45
040D81 EB          0605*       ex de,hl
040D82             0606*   ; no special cases so we move on
040D82             0607*   ; l contains the fractional portion of tan(uh.l)
040D82             0608*   ; we multiply it by three to get our lookup table index
040D82 26 03       0609*       ld h,3
040D84 ED 6C       0610*       mlt hl ; index into lut
040D86 11 00 00 00 0611*       ld de,0 ; clear deu
040D8A 54          0612*       ld d,h ; copy hl to de
040D8B 5D          0613*       ld e,l ; de contains our index
040D8C 21 91 11 04 0614*       ld hl,atan_lut_168 ; grab the lut address
040D90 19          0615*       add hl,de ; bump hl by the index
040D91 ED 27       0616*       ld hl,(hl) ; don't try this on a z80!
040D93 C9          0617*       ret ; and out
040D94             0618*   @is_45:
040D94 21 00 20 00 0619*       ld hl,32*256
040D98 C9          0620*       ret
040D99             0621*   ; for the case tan(0)
040D99             0622*   @is_zero:
040D99 21 00 00 00 0623*       ld hl,0*256
040D9D C9          0624*       ret
040D9E             0625*   
040D9E             0626*   ; Expects  ADL mode
040D9E             0627*   ; Inputs:  UH.L
040D9E             0628*   ; Outputs: UH.L is the 16.8 square root
040D9E             0629*   ;          UDE is the integer difference inputHL-DE^2
040D9E             0630*   sqrt168:
040D9E CD A8 0D 04 0631*       call sqrt24
040DA2 EB          0632*       ex de,hl
040DA3 29          0633*       add hl,hl
040DA4 29          0634*       add hl,hl
040DA5 29          0635*       add hl,hl
040DA6 29          0636*       add hl,hl
040DA7 C9          0637*       ret
040DA8             0638*   
040DA8             0639*   ; credit: xeda112358
040DA8             0640*   ; https://www.cemetech.net/forum/viewtopic.php?t=11178&postdays=0&postorder=asc&start=0
040DA8             0641*   sqrt24:
040DA8             0642*   ; Expects ADL mode
040DA8             0643*   ; Inputs: HL
040DA8             0644*   ; Outputs: DE is the integer square root
040DA8             0645*   ;  HL is the difference inputHL-DE^2
040DA8             0646*   ;  c flag reset
040DA8 01 00 00 00 0647*       ld bc,0 ; clear bcu
040DAC 11 00 00 00 0648*       ld de,0 ; clear deu
040DB0 AF          0649*       xor a
040DB1 45          0650*       ld b,l
040DB2 C5          0651*       push bc
040DB3 47          0652*       ld b,a
040DB4 6F          0653*       ld l,a
040DB5             0654*   ; Iteration 1
040DB5 29          0655*       add hl,hl
040DB6 CB 11       0656*       rl c
040DB8 29          0657*       add hl,hl
040DB9 CB 11       0658*       rl c
040DBB 91          0659*       sub c
040DBC 30 04       0660*       jr nc,$+6
040DBE 1C          0661*       inc e
040DBF 1C          0662*       inc e
040DC0 2F          0663*       cpl
040DC1 4F          0664*       ld c,a
040DC2             0665*   ; Iteration 2
040DC2 29          0666*       add hl,hl
040DC3 CB 11       0667*       rl c
040DC5 29          0668*       add hl,hl
040DC6 CB 11       0669*       rl c
040DC8 CB 13       0670*       rl e
040DCA 7B          0671*       ld a,e
040DCB 91          0672*       sub c
040DCC 30 04       0673*       jr nc,$+6
040DCE 1C          0674*       inc e
040DCF 1C          0675*       inc e
040DD0 2F          0676*       cpl
040DD1 4F          0677*       ld c,a
040DD2             0678*   ; Iteration 3
040DD2 29          0679*       add hl,hl
040DD3 CB 11       0680*       rl c
040DD5 29          0681*       add hl,hl
040DD6 CB 11       0682*       rl c
040DD8 CB 13       0683*       rl e
040DDA 7B          0684*       ld a,e
040DDB 91          0685*       sub c
040DDC 30 04       0686*       jr nc,$+6
040DDE 1C          0687*       inc e
040DDF 1C          0688*       inc e
040DE0 2F          0689*       cpl
040DE1 4F          0690*       ld c,a
040DE2             0691*   ; Iteration 4
040DE2 29          0692*       add hl,hl
040DE3 CB 11       0693*       rl c
040DE5 29          0694*       add hl,hl
040DE6 CB 11       0695*       rl c
040DE8 CB 13       0696*       rl e
040DEA 7B          0697*       ld a,e
040DEB 91          0698*       sub c
040DEC 30 04       0699*       jr nc,$+6
040DEE 1C          0700*       inc e
040DEF 1C          0701*       inc e
040DF0 2F          0702*       cpl
040DF1 4F          0703*       ld c,a
040DF2             0704*   ; Iteration 5
040DF2 29          0705*       add hl,hl
040DF3 CB 11       0706*       rl c
040DF5 29          0707*       add hl,hl
040DF6 CB 11       0708*       rl c
040DF8 CB 13       0709*       rl e
040DFA 7B          0710*       ld a,e
040DFB 91          0711*       sub c
040DFC 30 04       0712*       jr nc,$+6
040DFE 1C          0713*       inc e
040DFF 1C          0714*       inc e
040E00 2F          0715*       cpl
040E01 4F          0716*       ld c,a
040E02             0717*   ; Iteration 6
040E02 29          0718*       add hl,hl
040E03 CB 11       0719*       rl c
040E05 29          0720*       add hl,hl
040E06 CB 11       0721*       rl c
040E08 CB 13       0722*       rl e
040E0A 7B          0723*       ld a,e
040E0B 91          0724*       sub c
040E0C 30 04       0725*       jr nc,$+6
040E0E 1C          0726*       inc e
040E0F 1C          0727*       inc e
040E10 2F          0728*       cpl
040E11 4F          0729*       ld c,a
040E12             0730*   ; Iteration 7
040E12 29          0731*       add hl,hl
040E13 CB 11       0732*       rl c
040E15 29          0733*       add hl,hl
040E16 CB 11       0734*       rl c
040E18 CB 10       0735*       rl b
040E1A EB          0736*       ex de,hl
040E1B 29          0737*       add hl,hl
040E1C E5          0738*       push hl
040E1D ED 42       0739*       sbc hl,bc
040E1F 30 06       0740*       jr nc,$+8
040E21 7C          0741*       ld a,h
040E22 2F          0742*       cpl
040E23 47          0743*       ld b,a
040E24 7D          0744*       ld a,l
040E25 2F          0745*       cpl
040E26 4F          0746*       ld c,a
040E27 E1          0747*       pop hl
040E28 30 02       0748*       jr nc,$+4
040E2A 23          0749*       inc hl
040E2B 23          0750*       inc hl
040E2C EB          0751*       ex de,hl
040E2D             0752*   ; Iteration 8
040E2D 29          0753*       add hl,hl
040E2E 69          0754*       ld l,c
040E2F 60          0755*       ld h,b
040E30 ED 6A       0756*       adc hl,hl
040E32 ED 6A       0757*       adc hl,hl
040E34 EB          0758*       ex de,hl
040E35 29          0759*       add hl,hl
040E36 ED 52       0760*       sbc hl,de
040E38 19          0761*       add hl,de
040E39 EB          0762*       ex de,hl
040E3A 30 04       0763*       jr nc,$+6
040E3C ED 52       0764*       sbc hl,de
040E3E 13          0765*       inc de
040E3F 13          0766*       inc de
040E40             0767*   ; Iteration 9
040E40 F1          0768*       pop af
040E41 17          0769*       rla
040E42 ED 6A       0770*       adc hl,hl
040E44 17          0771*       rla
040E45 ED 6A       0772*       adc hl,hl
040E47 EB          0773*       ex de,hl
040E48 29          0774*       add hl,hl
040E49 ED 52       0775*       sbc hl,de
040E4B 19          0776*       add hl,de
040E4C EB          0777*       ex de,hl
040E4D 30 04       0778*       jr nc,$+6
040E4F ED 52       0779*       sbc hl,de
040E51 13          0780*       inc de
040E52 13          0781*       inc de
040E53             0782*   ; Iteration 10
040E53 17          0783*       rla
040E54 ED 6A       0784*       adc hl,hl
040E56 17          0785*       rla
040E57 ED 6A       0786*       adc hl,hl
040E59 EB          0787*       ex de,hl
040E5A 29          0788*       add hl,hl
040E5B ED 52       0789*       sbc hl,de
040E5D 19          0790*       add hl,de
040E5E EB          0791*       ex de,hl
040E5F 30 04       0792*       jr nc,$+6
040E61 ED 52       0793*       sbc hl,de
040E63 13          0794*       inc de
040E64 13          0795*       inc de
040E65             0796*   ; Iteration 11
040E65 17          0797*       rla
040E66 ED 6A       0798*       adc hl,hl
040E68 17          0799*       rla
040E69 ED 6A       0800*       adc hl,hl
040E6B EB          0801*       ex de,hl
040E6C 29          0802*       add hl,hl
040E6D ED 52       0803*       sbc hl,de
040E6F 19          0804*       add hl,de
040E70 EB          0805*       ex de,hl
040E71 30 04       0806*       jr nc,$+6
040E73 ED 52       0807*       sbc hl,de
040E75 13          0808*       inc de
040E76 13          0809*       inc de
040E77             0810*   ; Iteration 12
040E77 17          0811*       rla
040E78 ED 6A       0812*       adc hl,hl
040E7A 17          0813*       rla
040E7B ED 6A       0814*       adc hl,hl
040E7D EB          0815*       ex de,hl
040E7E 29          0816*       add hl,hl
040E7F ED 52       0817*       sbc hl,de
040E81 19          0818*       add hl,de
040E82 EB          0819*       ex de,hl
040E83 30 04       0820*       jr nc,$+6
040E85 ED 52       0821*       sbc hl,de
040E87 13          0822*       inc de
040E88 13          0823*       inc de
040E89 CB 1A       0824*       rr d
040E8B CB 1B       0825*       rr e
040E8D C9          0826*       ret
040E8E             0827*   
040E8E             0828*   sin_lut_168:
040E8E 00 00 00    0829*       dl 0x000000 ; 0.000 00, 0.000
040E91 06 00 00    0830*       dl 0x000006 ; 1.406 01, 0.025
040E94 0C 00 00    0831*       dl 0x00000C ; 2.813 02, 0.049
040E97 12 00 00    0832*       dl 0x000012 ; 4.219 03, 0.074
040E9A 19 00 00    0833*       dl 0x000019 ; 5.625 04, 0.098
040E9D 1F 00 00    0834*       dl 0x00001F ; 7.031 05, 0.122
040EA0 25 00 00    0835*       dl 0x000025 ; 8.438 06, 0.147
040EA3 2B 00 00    0836*       dl 0x00002B ; 9.844 07, 0.171
040EA6 31 00 00    0837*       dl 0x000031 ; 11.250 08, 0.195
040EA9 38 00 00    0838*       dl 0x000038 ; 12.656 09, 0.219
040EAC 3E 00 00    0839*       dl 0x00003E ; 14.063 0A, 0.243
040EAF 44 00 00    0840*       dl 0x000044 ; 15.469 0B, 0.267
040EB2 4A 00 00    0841*       dl 0x00004A ; 16.875 0C, 0.290
040EB5 50 00 00    0842*       dl 0x000050 ; 18.281 0D, 0.314
040EB8 56 00 00    0843*       dl 0x000056 ; 19.688 0E, 0.337
040EBB 5C 00 00    0844*       dl 0x00005C ; 21.094 0F, 0.360
040EBE 61 00 00    0845*       dl 0x000061 ; 22.500 10, 0.383
040EC1 67 00 00    0846*       dl 0x000067 ; 23.906 11, 0.405
040EC4 6D 00 00    0847*       dl 0x00006D ; 25.313 12, 0.428
040EC7 73 00 00    0848*       dl 0x000073 ; 26.719 13, 0.450
040ECA 78 00 00    0849*       dl 0x000078 ; 28.125 14, 0.471
040ECD 7E 00 00    0850*       dl 0x00007E ; 29.531 15, 0.493
040ED0 83 00 00    0851*       dl 0x000083 ; 30.938 16, 0.514
040ED3 88 00 00    0852*       dl 0x000088 ; 32.344 17, 0.535
040ED6 8E 00 00    0853*       dl 0x00008E ; 33.750 18, 0.556
040ED9 93 00 00    0854*       dl 0x000093 ; 35.156 19, 0.576
040EDC 98 00 00    0855*       dl 0x000098 ; 36.563 1A, 0.596
040EDF 9D 00 00    0856*       dl 0x00009D ; 37.969 1B, 0.615
040EE2 A2 00 00    0857*       dl 0x0000A2 ; 39.375 1C, 0.634
040EE5 A7 00 00    0858*       dl 0x0000A7 ; 40.781 1D, 0.653
040EE8 AB 00 00    0859*       dl 0x0000AB ; 42.188 1E, 0.672
040EEB B0 00 00    0860*       dl 0x0000B0 ; 43.594 1F, 0.690
040EEE B5 00 00    0861*       dl 0x0000B5 ; 45.000 20, 0.707
040EF1 B9 00 00    0862*       dl 0x0000B9 ; 46.406 21, 0.724
040EF4 BD 00 00    0863*       dl 0x0000BD ; 47.813 22, 0.741
040EF7 C1 00 00    0864*       dl 0x0000C1 ; 49.219 23, 0.757
040EFA C5 00 00    0865*       dl 0x0000C5 ; 50.625 24, 0.773
040EFD C9 00 00    0866*       dl 0x0000C9 ; 52.031 25, 0.788
040F00 CD 00 00    0867*       dl 0x0000CD ; 53.438 26, 0.803
040F03 D1 00 00    0868*       dl 0x0000D1 ; 54.844 27, 0.818
040F06 D4 00 00    0869*       dl 0x0000D4 ; 56.250 28, 0.831
040F09 D8 00 00    0870*       dl 0x0000D8 ; 57.656 29, 0.845
040F0C DB 00 00    0871*       dl 0x0000DB ; 59.063 2A, 0.858
040F0F DE 00 00    0872*       dl 0x0000DE ; 60.469 2B, 0.870
040F12 E1 00 00    0873*       dl 0x0000E1 ; 61.875 2C, 0.882
040F15 E4 00 00    0874*       dl 0x0000E4 ; 63.281 2D, 0.893
040F18 E7 00 00    0875*       dl 0x0000E7 ; 64.688 2E, 0.904
040F1B EA 00 00    0876*       dl 0x0000EA ; 66.094 2F, 0.914
040F1E EC 00 00    0877*       dl 0x0000EC ; 67.500 30, 0.924
040F21 EE 00 00    0878*       dl 0x0000EE ; 68.906 31, 0.933
040F24 F1 00 00    0879*       dl 0x0000F1 ; 70.313 32, 0.942
040F27 F3 00 00    0880*       dl 0x0000F3 ; 71.719 33, 0.950
040F2A F4 00 00    0881*       dl 0x0000F4 ; 73.125 34, 0.957
040F2D F6 00 00    0882*       dl 0x0000F6 ; 74.531 35, 0.964
040F30 F8 00 00    0883*       dl 0x0000F8 ; 75.938 36, 0.970
040F33 F9 00 00    0884*       dl 0x0000F9 ; 77.344 37, 0.976
040F36 FB 00 00    0885*       dl 0x0000FB ; 78.750 38, 0.981
040F39 FC 00 00    0886*       dl 0x0000FC ; 80.156 39, 0.985
040F3C FD 00 00    0887*       dl 0x0000FD ; 81.563 3A, 0.989
040F3F FE 00 00    0888*       dl 0x0000FE ; 82.969 3B, 0.992
040F42 FE 00 00    0889*       dl 0x0000FE ; 84.375 3C, 0.995
040F45 FF 00 00    0890*       dl 0x0000FF ; 85.781 3D, 0.997
040F48 FF 00 00    0891*       dl 0x0000FF ; 87.188 3E, 0.999
040F4B FF 00 00    0892*       dl 0x0000FF ; 88.594 3F, 1.000
040F4E 00 01 00    0893*       dl 0x000100 ; 90.000 40, 1.000
040F51 FF 00 00    0894*       dl 0x0000FF ; 91.406 41, 1.000
040F54 FF 00 00    0895*       dl 0x0000FF ; 92.813 42, 0.999
040F57 FF 00 00    0896*       dl 0x0000FF ; 94.219 43, 0.997
040F5A FE 00 00    0897*       dl 0x0000FE ; 95.625 44, 0.995
040F5D FE 00 00    0898*       dl 0x0000FE ; 97.031 45, 0.992
040F60 FD 00 00    0899*       dl 0x0000FD ; 98.438 46, 0.989
040F63 FC 00 00    0900*       dl 0x0000FC ; 99.844 47, 0.985
040F66 FB 00 00    0901*       dl 0x0000FB ; 101.250 48, 0.981
040F69 F9 00 00    0902*       dl 0x0000F9 ; 102.656 49, 0.976
040F6C F8 00 00    0903*       dl 0x0000F8 ; 104.063 4A, 0.970
040F6F F6 00 00    0904*       dl 0x0000F6 ; 105.469 4B, 0.964
040F72 F4 00 00    0905*       dl 0x0000F4 ; 106.875 4C, 0.957
040F75 F3 00 00    0906*       dl 0x0000F3 ; 108.281 4D, 0.950
040F78 F1 00 00    0907*       dl 0x0000F1 ; 109.688 4E, 0.942
040F7B EE 00 00    0908*       dl 0x0000EE ; 111.094 4F, 0.933
040F7E EC 00 00    0909*       dl 0x0000EC ; 112.500 50, 0.924
040F81 EA 00 00    0910*       dl 0x0000EA ; 113.906 51, 0.914
040F84 E7 00 00    0911*       dl 0x0000E7 ; 115.313 52, 0.904
040F87 E4 00 00    0912*       dl 0x0000E4 ; 116.719 53, 0.893
040F8A E1 00 00    0913*       dl 0x0000E1 ; 118.125 54, 0.882
040F8D DE 00 00    0914*       dl 0x0000DE ; 119.531 55, 0.870
040F90 DB 00 00    0915*       dl 0x0000DB ; 120.938 56, 0.858
040F93 D8 00 00    0916*       dl 0x0000D8 ; 122.344 57, 0.845
040F96 D4 00 00    0917*       dl 0x0000D4 ; 123.750 58, 0.831
040F99 D1 00 00    0918*       dl 0x0000D1 ; 125.156 59, 0.818
040F9C CD 00 00    0919*       dl 0x0000CD ; 126.563 5A, 0.803
040F9F C9 00 00    0920*       dl 0x0000C9 ; 127.969 5B, 0.788
040FA2 C5 00 00    0921*       dl 0x0000C5 ; 129.375 5C, 0.773
040FA5 C1 00 00    0922*       dl 0x0000C1 ; 130.781 5D, 0.757
040FA8 BD 00 00    0923*       dl 0x0000BD ; 132.188 5E, 0.741
040FAB B9 00 00    0924*       dl 0x0000B9 ; 133.594 5F, 0.724
040FAE B5 00 00    0925*       dl 0x0000B5 ; 135.000 60, 0.707
040FB1 B0 00 00    0926*       dl 0x0000B0 ; 136.406 61, 0.690
040FB4 AB 00 00    0927*       dl 0x0000AB ; 137.813 62, 0.672
040FB7 A7 00 00    0928*       dl 0x0000A7 ; 139.219 63, 0.653
040FBA A2 00 00    0929*       dl 0x0000A2 ; 140.625 64, 0.634
040FBD 9D 00 00    0930*       dl 0x00009D ; 142.031 65, 0.615
040FC0 98 00 00    0931*       dl 0x000098 ; 143.438 66, 0.596
040FC3 93 00 00    0932*       dl 0x000093 ; 144.844 67, 0.576
040FC6 8E 00 00    0933*       dl 0x00008E ; 146.250 68, 0.556
040FC9 88 00 00    0934*       dl 0x000088 ; 147.656 69, 0.535
040FCC 83 00 00    0935*       dl 0x000083 ; 149.063 6A, 0.514
040FCF 7E 00 00    0936*       dl 0x00007E ; 150.469 6B, 0.493
040FD2 78 00 00    0937*       dl 0x000078 ; 151.875 6C, 0.471
040FD5 73 00 00    0938*       dl 0x000073 ; 153.281 6D, 0.450
040FD8 6D 00 00    0939*       dl 0x00006D ; 154.688 6E, 0.428
040FDB 67 00 00    0940*       dl 0x000067 ; 156.094 6F, 0.405
040FDE 61 00 00    0941*       dl 0x000061 ; 157.500 70, 0.383
040FE1 5C 00 00    0942*       dl 0x00005C ; 158.906 71, 0.360
040FE4 56 00 00    0943*       dl 0x000056 ; 160.313 72, 0.337
040FE7 50 00 00    0944*       dl 0x000050 ; 161.719 73, 0.314
040FEA 4A 00 00    0945*       dl 0x00004A ; 163.125 74, 0.290
040FED 44 00 00    0946*       dl 0x000044 ; 164.531 75, 0.267
040FF0 3E 00 00    0947*       dl 0x00003E ; 165.938 76, 0.243
040FF3 38 00 00    0948*       dl 0x000038 ; 167.344 77, 0.219
040FF6 31 00 00    0949*       dl 0x000031 ; 168.750 78, 0.195
040FF9 2B 00 00    0950*       dl 0x00002B ; 170.156 79, 0.171
040FFC 25 00 00    0951*       dl 0x000025 ; 171.563 7A, 0.147
040FFF 1F 00 00    0952*       dl 0x00001F ; 172.969 7B, 0.122
041002 19 00 00    0953*       dl 0x000019 ; 174.375 7C, 0.098
041005 12 00 00    0954*       dl 0x000012 ; 175.781 7D, 0.074
041008 0C 00 00    0955*       dl 0x00000C ; 177.188 7E, 0.049
04100B 06 00 00    0956*       dl 0x000006 ; 178.594 7F, 0.025
04100E 00 00 00    0957*       dl 0x000000 ; 180.000 80, 0.000
041011 FA FF FF    0958*       dl 0xFFFFFA ; 181.406 81, -0.025
041014 F4 FF FF    0959*       dl 0xFFFFF4 ; 182.813 82, -0.049
041017 EE FF FF    0960*       dl 0xFFFFEE ; 184.219 83, -0.074
04101A E7 FF FF    0961*       dl 0xFFFFE7 ; 185.625 84, -0.098
04101D E1 FF FF    0962*       dl 0xFFFFE1 ; 187.031 85, -0.122
041020 DB FF FF    0963*       dl 0xFFFFDB ; 188.438 86, -0.147
041023 D5 FF FF    0964*       dl 0xFFFFD5 ; 189.844 87, -0.171
041026 CF FF FF    0965*       dl 0xFFFFCF ; 191.250 88, -0.195
041029 C8 FF FF    0966*       dl 0xFFFFC8 ; 192.656 89, -0.219
04102C C2 FF FF    0967*       dl 0xFFFFC2 ; 194.063 8A, -0.243
04102F BC FF FF    0968*       dl 0xFFFFBC ; 195.469 8B, -0.267
041032 B6 FF FF    0969*       dl 0xFFFFB6 ; 196.875 8C, -0.290
041035 B0 FF FF    0970*       dl 0xFFFFB0 ; 198.281 8D, -0.314
041038 AA FF FF    0971*       dl 0xFFFFAA ; 199.688 8E, -0.337
04103B A4 FF FF    0972*       dl 0xFFFFA4 ; 201.094 8F, -0.360
04103E 9F FF FF    0973*       dl 0xFFFF9F ; 202.500 90, -0.383
041041 99 FF FF    0974*       dl 0xFFFF99 ; 203.906 91, -0.405
041044 93 FF FF    0975*       dl 0xFFFF93 ; 205.313 92, -0.428
041047 8D FF FF    0976*       dl 0xFFFF8D ; 206.719 93, -0.450
04104A 88 FF FF    0977*       dl 0xFFFF88 ; 208.125 94, -0.471
04104D 82 FF FF    0978*       dl 0xFFFF82 ; 209.531 95, -0.493
041050 7D FF FF    0979*       dl 0xFFFF7D ; 210.938 96, -0.514
041053 78 FF FF    0980*       dl 0xFFFF78 ; 212.344 97, -0.535
041056 72 FF FF    0981*       dl 0xFFFF72 ; 213.750 98, -0.556
041059 6D FF FF    0982*       dl 0xFFFF6D ; 215.156 99, -0.576
04105C 68 FF FF    0983*       dl 0xFFFF68 ; 216.563 9A, -0.596
04105F 63 FF FF    0984*       dl 0xFFFF63 ; 217.969 9B, -0.615
041062 5E FF FF    0985*       dl 0xFFFF5E ; 219.375 9C, -0.634
041065 59 FF FF    0986*       dl 0xFFFF59 ; 220.781 9D, -0.653
041068 55 FF FF    0987*       dl 0xFFFF55 ; 222.188 9E, -0.672
04106B 50 FF FF    0988*       dl 0xFFFF50 ; 223.594 9F, -0.690
04106E 4B FF FF    0989*       dl 0xFFFF4B ; 225.000 A0, -0.707
041071 47 FF FF    0990*       dl 0xFFFF47 ; 226.406 A1, -0.724
041074 43 FF FF    0991*       dl 0xFFFF43 ; 227.813 A2, -0.741
041077 3F FF FF    0992*       dl 0xFFFF3F ; 229.219 A3, -0.757
04107A 3B FF FF    0993*       dl 0xFFFF3B ; 230.625 A4, -0.773
04107D 37 FF FF    0994*       dl 0xFFFF37 ; 232.031 A5, -0.788
041080 33 FF FF    0995*       dl 0xFFFF33 ; 233.438 A6, -0.803
041083 2F FF FF    0996*       dl 0xFFFF2F ; 234.844 A7, -0.818
041086 2C FF FF    0997*       dl 0xFFFF2C ; 236.250 A8, -0.831
041089 28 FF FF    0998*       dl 0xFFFF28 ; 237.656 A9, -0.845
04108C 25 FF FF    0999*       dl 0xFFFF25 ; 239.063 AA, -0.858
04108F 22 FF FF    1000*       dl 0xFFFF22 ; 240.469 AB, -0.870
041092 1F FF FF    1001*       dl 0xFFFF1F ; 241.875 AC, -0.882
041095 1C FF FF    1002*       dl 0xFFFF1C ; 243.281 AD, -0.893
041098 19 FF FF    1003*       dl 0xFFFF19 ; 244.688 AE, -0.904
04109B 16 FF FF    1004*       dl 0xFFFF16 ; 246.094 AF, -0.914
04109E 14 FF FF    1005*       dl 0xFFFF14 ; 247.500 B0, -0.924
0410A1 12 FF FF    1006*       dl 0xFFFF12 ; 248.906 B1, -0.933
0410A4 0F FF FF    1007*       dl 0xFFFF0F ; 250.313 B2, -0.942
0410A7 0D FF FF    1008*       dl 0xFFFF0D ; 251.719 B3, -0.950
0410AA 0C FF FF    1009*       dl 0xFFFF0C ; 253.125 B4, -0.957
0410AD 0A FF FF    1010*       dl 0xFFFF0A ; 254.531 B5, -0.964
0410B0 08 FF FF    1011*       dl 0xFFFF08 ; 255.938 B6, -0.970
0410B3 07 FF FF    1012*       dl 0xFFFF07 ; 257.344 B7, -0.976
0410B6 05 FF FF    1013*       dl 0xFFFF05 ; 258.750 B8, -0.981
0410B9 04 FF FF    1014*       dl 0xFFFF04 ; 260.156 B9, -0.985
0410BC 03 FF FF    1015*       dl 0xFFFF03 ; 261.563 BA, -0.989
0410BF 02 FF FF    1016*       dl 0xFFFF02 ; 262.969 BB, -0.992
0410C2 02 FF FF    1017*       dl 0xFFFF02 ; 264.375 BC, -0.995
0410C5 01 FF FF    1018*       dl 0xFFFF01 ; 265.781 BD, -0.997
0410C8 01 FF FF    1019*       dl 0xFFFF01 ; 267.188 BE, -0.999
0410CB 01 FF FF    1020*       dl 0xFFFF01 ; 268.594 BF, -1.000
0410CE 00 FF FF    1021*       dl 0xFFFF00 ; 270.000 C0, -1.000
0410D1 01 FF FF    1022*       dl 0xFFFF01 ; 271.406 C1, -1.000
0410D4 01 FF FF    1023*       dl 0xFFFF01 ; 272.813 C2, -0.999
0410D7 01 FF FF    1024*       dl 0xFFFF01 ; 274.219 C3, -0.997
0410DA 02 FF FF    1025*       dl 0xFFFF02 ; 275.625 C4, -0.995
0410DD 02 FF FF    1026*       dl 0xFFFF02 ; 277.031 C5, -0.992
0410E0 03 FF FF    1027*       dl 0xFFFF03 ; 278.438 C6, -0.989
0410E3 04 FF FF    1028*       dl 0xFFFF04 ; 279.844 C7, -0.985
0410E6 05 FF FF    1029*       dl 0xFFFF05 ; 281.250 C8, -0.981
0410E9 07 FF FF    1030*       dl 0xFFFF07 ; 282.656 C9, -0.976
0410EC 08 FF FF    1031*       dl 0xFFFF08 ; 284.063 CA, -0.970
0410EF 0A FF FF    1032*       dl 0xFFFF0A ; 285.469 CB, -0.964
0410F2 0C FF FF    1033*       dl 0xFFFF0C ; 286.875 CC, -0.957
0410F5 0D FF FF    1034*       dl 0xFFFF0D ; 288.281 CD, -0.950
0410F8 0F FF FF    1035*       dl 0xFFFF0F ; 289.688 CE, -0.942
0410FB 12 FF FF    1036*       dl 0xFFFF12 ; 291.094 CF, -0.933
0410FE 14 FF FF    1037*       dl 0xFFFF14 ; 292.500 D0, -0.924
041101 16 FF FF    1038*       dl 0xFFFF16 ; 293.906 D1, -0.914
041104 19 FF FF    1039*       dl 0xFFFF19 ; 295.313 D2, -0.904
041107 1C FF FF    1040*       dl 0xFFFF1C ; 296.719 D3, -0.893
04110A 1F FF FF    1041*       dl 0xFFFF1F ; 298.125 D4, -0.882
04110D 22 FF FF    1042*       dl 0xFFFF22 ; 299.531 D5, -0.870
041110 25 FF FF    1043*       dl 0xFFFF25 ; 300.938 D6, -0.858
041113 28 FF FF    1044*       dl 0xFFFF28 ; 302.344 D7, -0.845
041116 2C FF FF    1045*       dl 0xFFFF2C ; 303.750 D8, -0.831
041119 2F FF FF    1046*       dl 0xFFFF2F ; 305.156 D9, -0.818
04111C 33 FF FF    1047*       dl 0xFFFF33 ; 306.563 DA, -0.803
04111F 37 FF FF    1048*       dl 0xFFFF37 ; 307.969 DB, -0.788
041122 3B FF FF    1049*       dl 0xFFFF3B ; 309.375 DC, -0.773
041125 3F FF FF    1050*       dl 0xFFFF3F ; 310.781 DD, -0.757
041128 43 FF FF    1051*       dl 0xFFFF43 ; 312.188 DE, -0.741
04112B 47 FF FF    1052*       dl 0xFFFF47 ; 313.594 DF, -0.724
04112E 4B FF FF    1053*       dl 0xFFFF4B ; 315.000 E0, -0.707
041131 50 FF FF    1054*       dl 0xFFFF50 ; 316.406 E1, -0.690
041134 55 FF FF    1055*       dl 0xFFFF55 ; 317.813 E2, -0.672
041137 59 FF FF    1056*       dl 0xFFFF59 ; 319.219 E3, -0.653
04113A 5E FF FF    1057*       dl 0xFFFF5E ; 320.625 E4, -0.634
04113D 63 FF FF    1058*       dl 0xFFFF63 ; 322.031 E5, -0.615
041140 68 FF FF    1059*       dl 0xFFFF68 ; 323.438 E6, -0.596
041143 6D FF FF    1060*       dl 0xFFFF6D ; 324.844 E7, -0.576
041146 72 FF FF    1061*       dl 0xFFFF72 ; 326.250 E8, -0.556
041149 78 FF FF    1062*       dl 0xFFFF78 ; 327.656 E9, -0.535
04114C 7D FF FF    1063*       dl 0xFFFF7D ; 329.063 EA, -0.514
04114F 82 FF FF    1064*       dl 0xFFFF82 ; 330.469 EB, -0.493
041152 88 FF FF    1065*       dl 0xFFFF88 ; 331.875 EC, -0.471
041155 8D FF FF    1066*       dl 0xFFFF8D ; 333.281 ED, -0.450
041158 93 FF FF    1067*       dl 0xFFFF93 ; 334.688 EE, -0.428
04115B 99 FF FF    1068*       dl 0xFFFF99 ; 336.094 EF, -0.405
04115E 9F FF FF    1069*       dl 0xFFFF9F ; 337.500 F0, -0.383
041161 A4 FF FF    1070*       dl 0xFFFFA4 ; 338.906 F1, -0.360
041164 AA FF FF    1071*       dl 0xFFFFAA ; 340.313 F2, -0.337
041167 B0 FF FF    1072*       dl 0xFFFFB0 ; 341.719 F3, -0.314
04116A B6 FF FF    1073*       dl 0xFFFFB6 ; 343.125 F4, -0.290
04116D BC FF FF    1074*       dl 0xFFFFBC ; 344.531 F5, -0.267
041170 C2 FF FF    1075*       dl 0xFFFFC2 ; 345.938 F6, -0.243
041173 C8 FF FF    1076*       dl 0xFFFFC8 ; 347.344 F7, -0.219
041176 CF FF FF    1077*       dl 0xFFFFCF ; 348.750 F8, -0.195
041179 D5 FF FF    1078*       dl 0xFFFFD5 ; 350.156 F9, -0.171
04117C DB FF FF    1079*       dl 0xFFFFDB ; 351.563 FA, -0.147
04117F E1 FF FF    1080*       dl 0xFFFFE1 ; 352.969 FB, -0.122
041182 E7 FF FF    1081*       dl 0xFFFFE7 ; 354.375 FC, -0.098
041185 EE FF FF    1082*       dl 0xFFFFEE ; 355.781 FD, -0.074
041188 F4 FF FF    1083*       dl 0xFFFFF4 ; 357.188 FE, -0.049
04118B FA FF FF    1084*       dl 0xFFFFFA ; 358.594 FF, -0.025
04118E 00 00 00    1085*       dl 0x000000 ; 0.000 00, 0.000 for interpolation
041191             1086*   
041191             1087*   atan_lut_168:
041191 00 00 00    1088*       dl 0x000000 ; 000000, 0.000
041194 28 00 00    1089*       dl 0x000028 ; 000001, 0.224
041197 51 00 00    1090*       dl 0x000051 ; 000002, 0.448
04119A 7A 00 00    1091*       dl 0x00007A ; 000003, 0.671
04119D A2 00 00    1092*       dl 0x0000A2 ; 000004, 0.895
0411A0 CB 00 00    1093*       dl 0x0000CB ; 000005, 1.119
0411A3 F4 00 00    1094*       dl 0x0000F4 ; 000006, 1.343
0411A6 1D 01 00    1095*       dl 0x00011D ; 000007, 1.566
0411A9 45 01 00    1096*       dl 0x000145 ; 000008, 1.790
0411AC 6E 01 00    1097*       dl 0x00016E ; 000009, 2.013
0411AF 97 01 00    1098*       dl 0x000197 ; 00000A, 2.237
0411B2 BF 01 00    1099*       dl 0x0001BF ; 00000B, 2.460
0411B5 E8 01 00    1100*       dl 0x0001E8 ; 00000C, 2.684
0411B8 11 02 00    1101*       dl 0x000211 ; 00000D, 2.907
0411BB 39 02 00    1102*       dl 0x000239 ; 00000E, 3.130
0411BE 62 02 00    1103*       dl 0x000262 ; 00000F, 3.353
0411C1 8B 02 00    1104*       dl 0x00028B ; 000010, 3.576
0411C4 B3 02 00    1105*       dl 0x0002B3 ; 000011, 3.799
0411C7 DC 02 00    1106*       dl 0x0002DC ; 000012, 4.022
0411CA 04 03 00    1107*       dl 0x000304 ; 000013, 4.245
0411CD 2D 03 00    1108*       dl 0x00032D ; 000014, 4.467
0411D0 55 03 00    1109*       dl 0x000355 ; 000015, 4.690
0411D3 7E 03 00    1110*       dl 0x00037E ; 000016, 4.912
0411D6 A6 03 00    1111*       dl 0x0003A6 ; 000017, 5.134
0411D9 CE 03 00    1112*       dl 0x0003CE ; 000018, 5.356
0411DC F7 03 00    1113*       dl 0x0003F7 ; 000019, 5.578
0411DF 1F 04 00    1114*       dl 0x00041F ; 00001A, 5.799
0411E2 48 04 00    1115*       dl 0x000448 ; 00001B, 6.021
0411E5 70 04 00    1116*       dl 0x000470 ; 00001C, 6.242
0411E8 98 04 00    1117*       dl 0x000498 ; 00001D, 6.463
0411EB C0 04 00    1118*       dl 0x0004C0 ; 00001E, 6.684
0411EE E8 04 00    1119*       dl 0x0004E8 ; 00001F, 6.905
0411F1 11 05 00    1120*       dl 0x000511 ; 000020, 7.125
0411F4 39 05 00    1121*       dl 0x000539 ; 000021, 7.345
0411F7 61 05 00    1122*       dl 0x000561 ; 000022, 7.565
0411FA 89 05 00    1123*       dl 0x000589 ; 000023, 7.785
0411FD B1 05 00    1124*       dl 0x0005B1 ; 000024, 8.005
041200 D9 05 00    1125*       dl 0x0005D9 ; 000025, 8.224
041203 01 06 00    1126*       dl 0x000601 ; 000026, 8.443
041206 28 06 00    1127*       dl 0x000628 ; 000027, 8.662
041209 50 06 00    1128*       dl 0x000650 ; 000028, 8.881
04120C 78 06 00    1129*       dl 0x000678 ; 000029, 9.099
04120F A0 06 00    1130*       dl 0x0006A0 ; 00002A, 9.317
041212 C7 06 00    1131*       dl 0x0006C7 ; 00002B, 9.535
041215 EF 06 00    1132*       dl 0x0006EF ; 00002C, 9.752
041218 16 07 00    1133*       dl 0x000716 ; 00002D, 9.970
04121B 3E 07 00    1134*       dl 0x00073E ; 00002E, 10.187
04121E 65 07 00    1135*       dl 0x000765 ; 00002F, 10.403
041221 8D 07 00    1136*       dl 0x00078D ; 000030, 10.620
041224 B4 07 00    1137*       dl 0x0007B4 ; 000031, 10.836
041227 DB 07 00    1138*       dl 0x0007DB ; 000032, 11.051
04122A 03 08 00    1139*       dl 0x000803 ; 000033, 11.267
04122D 2A 08 00    1140*       dl 0x00082A ; 000034, 11.482
041230 51 08 00    1141*       dl 0x000851 ; 000035, 11.697
041233 78 08 00    1142*       dl 0x000878 ; 000036, 11.911
041236 9F 08 00    1143*       dl 0x00089F ; 000037, 12.125
041239 C6 08 00    1144*       dl 0x0008C6 ; 000038, 12.339
04123C ED 08 00    1145*       dl 0x0008ED ; 000039, 12.553
04123F 13 09 00    1146*       dl 0x000913 ; 00003A, 12.766
041242 3A 09 00    1147*       dl 0x00093A ; 00003B, 12.978
041245 61 09 00    1148*       dl 0x000961 ; 00003C, 13.191
041248 87 09 00    1149*       dl 0x000987 ; 00003D, 13.403
04124B AE 09 00    1150*       dl 0x0009AE ; 00003E, 13.614
04124E D4 09 00    1151*       dl 0x0009D4 ; 00003F, 13.825
041251 FB 09 00    1152*       dl 0x0009FB ; 000040, 14.036
041254 21 0A 00    1153*       dl 0x000A21 ; 000041, 14.247
041257 47 0A 00    1154*       dl 0x000A47 ; 000042, 14.457
04125A 6D 0A 00    1155*       dl 0x000A6D ; 000043, 14.666
04125D 94 0A 00    1156*       dl 0x000A94 ; 000044, 14.876
041260 BA 0A 00    1157*       dl 0x000ABA ; 000045, 15.085
041263 E0 0A 00    1158*       dl 0x000AE0 ; 000046, 15.293
041266 05 0B 00    1159*       dl 0x000B05 ; 000047, 15.501
041269 2B 0B 00    1160*       dl 0x000B2B ; 000048, 15.709
04126C 51 0B 00    1161*       dl 0x000B51 ; 000049, 15.916
04126F 77 0B 00    1162*       dl 0x000B77 ; 00004A, 16.123
041272 9C 0B 00    1163*       dl 0x000B9C ; 00004B, 16.329
041275 C2 0B 00    1164*       dl 0x000BC2 ; 00004C, 16.535
041278 E7 0B 00    1165*       dl 0x000BE7 ; 00004D, 16.740
04127B 0C 0C 00    1166*       dl 0x000C0C ; 00004E, 16.945
04127E 32 0C 00    1167*       dl 0x000C32 ; 00004F, 17.150
041281 57 0C 00    1168*       dl 0x000C57 ; 000050, 17.354
041284 7C 0C 00    1169*       dl 0x000C7C ; 000051, 17.558
041287 A1 0C 00    1170*       dl 0x000CA1 ; 000052, 17.761
04128A C6 0C 00    1171*       dl 0x000CC6 ; 000053, 17.964
04128D EB 0C 00    1172*       dl 0x000CEB ; 000054, 18.166
041290 0F 0D 00    1173*       dl 0x000D0F ; 000055, 18.368
041293 34 0D 00    1174*       dl 0x000D34 ; 000056, 18.569
041296 58 0D 00    1175*       dl 0x000D58 ; 000057, 18.770
041299 7D 0D 00    1176*       dl 0x000D7D ; 000058, 18.970
04129C A1 0D 00    1177*       dl 0x000DA1 ; 000059, 19.170
04129F C6 0D 00    1178*       dl 0x000DC6 ; 00005A, 19.370
0412A2 EA 0D 00    1179*       dl 0x000DEA ; 00005B, 19.569
0412A5 0E 0E 00    1180*       dl 0x000E0E ; 00005C, 19.767
0412A8 32 0E 00    1181*       dl 0x000E32 ; 00005D, 19.965
0412AB 56 0E 00    1182*       dl 0x000E56 ; 00005E, 20.163
0412AE 7A 0E 00    1183*       dl 0x000E7A ; 00005F, 20.360
0412B1 9E 0E 00    1184*       dl 0x000E9E ; 000060, 20.556
0412B4 C1 0E 00    1185*       dl 0x000EC1 ; 000061, 20.752
0412B7 E5 0E 00    1186*       dl 0x000EE5 ; 000062, 20.947
0412BA 08 0F 00    1187*       dl 0x000F08 ; 000063, 21.142
0412BD 2C 0F 00    1188*       dl 0x000F2C ; 000064, 21.337
0412C0 4F 0F 00    1189*       dl 0x000F4F ; 000065, 21.531
0412C3 72 0F 00    1190*       dl 0x000F72 ; 000066, 21.724
0412C6 95 0F 00    1191*       dl 0x000F95 ; 000067, 21.917
0412C9 B8 0F 00    1192*       dl 0x000FB8 ; 000068, 22.109
0412CC DB 0F 00    1193*       dl 0x000FDB ; 000069, 22.301
0412CF FE 0F 00    1194*       dl 0x000FFE ; 00006A, 22.493
0412D2 21 10 00    1195*       dl 0x001021 ; 00006B, 22.683
0412D5 44 10 00    1196*       dl 0x001044 ; 00006C, 22.874
0412D8 66 10 00    1197*       dl 0x001066 ; 00006D, 23.063
0412DB 89 10 00    1198*       dl 0x001089 ; 00006E, 23.253
0412DE AB 10 00    1199*       dl 0x0010AB ; 00006F, 23.441
0412E1 CD 10 00    1200*       dl 0x0010CD ; 000070, 23.629
0412E4 EF 10 00    1201*       dl 0x0010EF ; 000071, 23.817
0412E7 11 11 00    1202*       dl 0x001111 ; 000072, 24.004
0412EA 33 11 00    1203*       dl 0x001133 ; 000073, 24.191
0412ED 55 11 00    1204*       dl 0x001155 ; 000074, 24.376
0412F0 77 11 00    1205*       dl 0x001177 ; 000075, 24.562
0412F3 99 11 00    1206*       dl 0x001199 ; 000076, 24.747
0412F6 BA 11 00    1207*       dl 0x0011BA ; 000077, 24.931
0412F9 DC 11 00    1208*       dl 0x0011DC ; 000078, 25.115
0412FC FD 11 00    1209*       dl 0x0011FD ; 000079, 25.298
0412FF 1E 12 00    1210*       dl 0x00121E ; 00007A, 25.481
041302 3F 12 00    1211*       dl 0x00123F ; 00007B, 25.663
041305 60 12 00    1212*       dl 0x001260 ; 00007C, 25.844
041308 81 12 00    1213*       dl 0x001281 ; 00007D, 26.025
04130B A2 12 00    1214*       dl 0x0012A2 ; 00007E, 26.206
04130E C3 12 00    1215*       dl 0x0012C3 ; 00007F, 26.386
041311 E4 12 00    1216*       dl 0x0012E4 ; 000080, 26.565
041314 04 13 00    1217*       dl 0x001304 ; 000081, 26.744
041317 25 13 00    1218*       dl 0x001325 ; 000082, 26.922
04131A 45 13 00    1219*       dl 0x001345 ; 000083, 27.100
04131D 65 13 00    1220*       dl 0x001365 ; 000084, 27.277
041320 85 13 00    1221*       dl 0x001385 ; 000085, 27.453
041323 A5 13 00    1222*       dl 0x0013A5 ; 000086, 27.629
041326 C5 13 00    1223*       dl 0x0013C5 ; 000087, 27.805
041329 E5 13 00    1224*       dl 0x0013E5 ; 000088, 27.979
04132C 05 14 00    1225*       dl 0x001405 ; 000089, 28.154
04132F 24 14 00    1226*       dl 0x001424 ; 00008A, 28.327
041332 44 14 00    1227*       dl 0x001444 ; 00008B, 28.501
041335 63 14 00    1228*       dl 0x001463 ; 00008C, 28.673
041338 83 14 00    1229*       dl 0x001483 ; 00008D, 28.845
04133B A2 14 00    1230*       dl 0x0014A2 ; 00008E, 29.017
04133E C1 14 00    1231*       dl 0x0014C1 ; 00008F, 29.187
041341 E0 14 00    1232*       dl 0x0014E0 ; 000090, 29.358
041344 FF 14 00    1233*       dl 0x0014FF ; 000091, 29.527
041347 1E 15 00    1234*       dl 0x00151E ; 000092, 29.697
04134A 3C 15 00    1235*       dl 0x00153C ; 000093, 29.865
04134D 5B 15 00    1236*       dl 0x00155B ; 000094, 30.033
041350 79 15 00    1237*       dl 0x001579 ; 000095, 30.201
041353 98 15 00    1238*       dl 0x001598 ; 000096, 30.368
041356 B6 15 00    1239*       dl 0x0015B6 ; 000097, 30.534
041359 D4 15 00    1240*       dl 0x0015D4 ; 000098, 30.700
04135C F2 15 00    1241*       dl 0x0015F2 ; 000099, 30.865
04135F 10 16 00    1242*       dl 0x001610 ; 00009A, 31.030
041362 2E 16 00    1243*       dl 0x00162E ; 00009B, 31.194
041365 4C 16 00    1244*       dl 0x00164C ; 00009C, 31.357
041368 6A 16 00    1245*       dl 0x00166A ; 00009D, 31.520
04136B 87 16 00    1246*       dl 0x001687 ; 00009E, 31.682
04136E A5 16 00    1247*       dl 0x0016A5 ; 00009F, 31.844
041371 C2 16 00    1248*       dl 0x0016C2 ; 0000A0, 32.005
041374 DF 16 00    1249*       dl 0x0016DF ; 0000A1, 32.166
041377 FC 16 00    1250*       dl 0x0016FC ; 0000A2, 32.326
04137A 19 17 00    1251*       dl 0x001719 ; 0000A3, 32.486
04137D 36 17 00    1252*       dl 0x001736 ; 0000A4, 32.645
041380 53 17 00    1253*       dl 0x001753 ; 0000A5, 32.803
041383 70 17 00    1254*       dl 0x001770 ; 0000A6, 32.961
041386 8C 17 00    1255*       dl 0x00178C ; 0000A7, 33.118
041389 A9 17 00    1256*       dl 0x0017A9 ; 0000A8, 33.275
04138C C5 17 00    1257*       dl 0x0017C5 ; 0000A9, 33.431
04138F E2 17 00    1258*       dl 0x0017E2 ; 0000AA, 33.587
041392 FE 17 00    1259*       dl 0x0017FE ; 0000AB, 33.742
041395 1A 18 00    1260*       dl 0x00181A ; 0000AC, 33.896
041398 36 18 00    1261*       dl 0x001836 ; 0000AD, 34.050
04139B 52 18 00    1262*       dl 0x001852 ; 0000AE, 34.203
04139E 6E 18 00    1263*       dl 0x00186E ; 0000AF, 34.356
0413A1 8A 18 00    1264*       dl 0x00188A ; 0000B0, 34.509
0413A4 A5 18 00    1265*       dl 0x0018A5 ; 0000B1, 34.660
0413A7 C1 18 00    1266*       dl 0x0018C1 ; 0000B2, 34.811
0413AA DC 18 00    1267*       dl 0x0018DC ; 0000B3, 34.962
0413AD F7 18 00    1268*       dl 0x0018F7 ; 0000B4, 35.112
0413B0 13 19 00    1269*       dl 0x001913 ; 0000B5, 35.262
0413B3 2E 19 00    1270*       dl 0x00192E ; 0000B6, 35.410
0413B6 49 19 00    1271*       dl 0x001949 ; 0000B7, 35.559
0413B9 64 19 00    1272*       dl 0x001964 ; 0000B8, 35.707
0413BC 7F 19 00    1273*       dl 0x00197F ; 0000B9, 35.854
0413BF 99 19 00    1274*       dl 0x001999 ; 0000BA, 36.001
0413C2 B4 19 00    1275*       dl 0x0019B4 ; 0000BB, 36.147
0413C5 CE 19 00    1276*       dl 0x0019CE ; 0000BC, 36.293
0413C8 E9 19 00    1277*       dl 0x0019E9 ; 0000BD, 36.438
0413CB 03 1A 00    1278*       dl 0x001A03 ; 0000BE, 36.582
0413CE 1D 1A 00    1279*       dl 0x001A1D ; 0000BF, 36.726
0413D1 37 1A 00    1280*       dl 0x001A37 ; 0000C0, 36.870
0413D4 51 1A 00    1281*       dl 0x001A51 ; 0000C1, 37.013
0413D7 6B 1A 00    1282*       dl 0x001A6B ; 0000C2, 37.155
0413DA 85 1A 00    1283*       dl 0x001A85 ; 0000C3, 37.297
0413DD 9F 1A 00    1284*       dl 0x001A9F ; 0000C4, 37.439
0413E0 B9 1A 00    1285*       dl 0x001AB9 ; 0000C5, 37.579
0413E3 D2 1A 00    1286*       dl 0x001AD2 ; 0000C6, 37.720
0413E6 EC 1A 00    1287*       dl 0x001AEC ; 0000C7, 37.859
0413E9 05 1B 00    1288*       dl 0x001B05 ; 0000C8, 37.999
0413EC 1E 1B 00    1289*       dl 0x001B1E ; 0000C9, 38.137
0413EF 37 1B 00    1290*       dl 0x001B37 ; 0000CA, 38.276
0413F2 50 1B 00    1291*       dl 0x001B50 ; 0000CB, 38.413
0413F5 69 1B 00    1292*       dl 0x001B69 ; 0000CC, 38.550
0413F8 82 1B 00    1293*       dl 0x001B82 ; 0000CD, 38.687
0413FB 9B 1B 00    1294*       dl 0x001B9B ; 0000CE, 38.823
0413FE B4 1B 00    1295*       dl 0x001BB4 ; 0000CF, 38.959
041401 CC 1B 00    1296*       dl 0x001BCC ; 0000D0, 39.094
041404 E5 1B 00    1297*       dl 0x001BE5 ; 0000D1, 39.228
041407 FD 1B 00    1298*       dl 0x001BFD ; 0000D2, 39.362
04140A 16 1C 00    1299*       dl 0x001C16 ; 0000D3, 39.496
04140D 2E 1C 00    1300*       dl 0x001C2E ; 0000D4, 39.629
041410 46 1C 00    1301*       dl 0x001C46 ; 0000D5, 39.762
041413 5E 1C 00    1302*       dl 0x001C5E ; 0000D6, 39.894
041416 76 1C 00    1303*       dl 0x001C76 ; 0000D7, 40.025
041419 8E 1C 00    1304*       dl 0x001C8E ; 0000D8, 40.156
04141C A5 1C 00    1305*       dl 0x001CA5 ; 0000D9, 40.286
04141F BD 1C 00    1306*       dl 0x001CBD ; 0000DA, 40.416
041422 D5 1C 00    1307*       dl 0x001CD5 ; 0000DB, 40.546
041425 EC 1C 00    1308*       dl 0x001CEC ; 0000DC, 40.675
041428 04 1D 00    1309*       dl 0x001D04 ; 0000DD, 40.803
04142B 1B 1D 00    1310*       dl 0x001D1B ; 0000DE, 40.931
04142E 32 1D 00    1311*       dl 0x001D32 ; 0000DF, 41.059
041431 49 1D 00    1312*       dl 0x001D49 ; 0000E0, 41.186
041434 60 1D 00    1313*       dl 0x001D60 ; 0000E1, 41.312
041437 77 1D 00    1314*       dl 0x001D77 ; 0000E2, 41.438
04143A 8E 1D 00    1315*       dl 0x001D8E ; 0000E3, 41.564
04143D A5 1D 00    1316*       dl 0x001DA5 ; 0000E4, 41.689
041440 BB 1D 00    1317*       dl 0x001DBB ; 0000E5, 41.814
041443 D2 1D 00    1318*       dl 0x001DD2 ; 0000E6, 41.938
041446 E9 1D 00    1319*       dl 0x001DE9 ; 0000E7, 42.061
041449 FF 1D 00    1320*       dl 0x001DFF ; 0000E8, 42.184
04144C 15 1E 00    1321*       dl 0x001E15 ; 0000E9, 42.307
04144F 2C 1E 00    1322*       dl 0x001E2C ; 0000EA, 42.429
041452 42 1E 00    1323*       dl 0x001E42 ; 0000EB, 42.551
041455 58 1E 00    1324*       dl 0x001E58 ; 0000EC, 42.672
041458 6E 1E 00    1325*       dl 0x001E6E ; 0000ED, 42.793
04145B 84 1E 00    1326*       dl 0x001E84 ; 0000EE, 42.913
04145E 99 1E 00    1327*       dl 0x001E99 ; 0000EF, 43.033
041461 AF 1E 00    1328*       dl 0x001EAF ; 0000F0, 43.152
041464 C5 1E 00    1329*       dl 0x001EC5 ; 0000F1, 43.271
041467 DA 1E 00    1330*       dl 0x001EDA ; 0000F2, 43.390
04146A F0 1E 00    1331*       dl 0x001EF0 ; 0000F3, 43.508
04146D 05 1F 00    1332*       dl 0x001F05 ; 0000F4, 43.625
041470 1B 1F 00    1333*       dl 0x001F1B ; 0000F5, 43.742
041473 30 1F 00    1334*       dl 0x001F30 ; 0000F6, 43.859
041476 45 1F 00    1335*       dl 0x001F45 ; 0000F7, 43.975
041479 5A 1F 00    1336*       dl 0x001F5A ; 0000F8, 44.091
04147C 6F 1F 00    1337*       dl 0x001F6F ; 0000F9, 44.206
04147F 84 1F 00    1338*       dl 0x001F84 ; 0000FA, 44.321
041482 99 1F 00    1339*       dl 0x001F99 ; 0000FB, 44.435
041485 AD 1F 00    1340*       dl 0x001FAD ; 0000FC, 44.549
041488 C2 1F 00    1341*       dl 0x001FC2 ; 0000FD, 44.662
04148B D7 1F 00    1342*       dl 0x001FD7 ; 0000FE, 44.775
04148E EB 1F 00    1343*       dl 0x001FEB ; 0000FF, 44.888
041491 00 20 00    1344*       dl 0x002000 ; 000100, 45.000 only needed for interpolation
041494             0040        include "timer.inc"
041494             0001*   ; Table 32. Timer Control Registers
041494             0002*   TMR0_CTL: equ 80h
041494             0003*   TMR1_CTL: equ 83h
041494             0004*   TMR2_CTL: equ 86h
041494             0005*   TMR3_CTL: equ 89h
041494             0006*   TMR4_CTL: equ 8Ch
041494             0007*   TMR5_CTL: equ 8Fh
041494             0008*   
041494             0009*   ; each timer register takes three bytes:
041494             0010*   ;   0: control register
041494             0011*   ;   1: low byte of timer reset value
041494             0012*   ;   2: high byte of timer reset value
041494             0013*   ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
041494             0014*   ; which correctly force the high and upper bytes of the address bus to zero
041494             0015*   
041494             0016*   TMR_REG_CTL: equ 0
041494             0017*   TMR_RES_LOW: equ 1
041494             0018*   TMR_RES_HIGH: equ 2
041494             0019*   
041494             0020*   ; Timer Control Register Bit Definitions
041494             0021*   PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
041494             0022*                               ; This bit is reset to 0 every time the TMRx_CTL register is read.
041494             0023*   PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
041494             0024*                               ; an interrupt signal is sent to the CPU. This bit remains 1 until
041494             0025*                               ; the TMRx_CTL register is read.
041494             0026*   
041494             0027*   IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
041494             0028*   IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
041494             0029*   
041494             0030*   PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
041494             0031*                               ;  0,and counting stops when the end-of-count value is reached.
041494             0032*   PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
041494             0033*                               ; written to the counter when the end-of-count value is reached.
041494             0034*   
041494             0035*   ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
041494             0036*   CLK_DIV_256:  equ %00001100 ;
041494             0037*   CLK_DIV_64:   equ %00001000 ;
041494             0038*   CLK_DIV_16:   equ %00000100 ;
041494             0039*   CLK_DIV_4:    equ %00000000 ;
041494             0040*   
041494             0041*   RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
041494             0042*   RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
041494             0043*                               ; When a 1 is written to this bit,the values in the reload registers
041494             0044*                               ;  are loaded into the downcounter when the timer restarts. The
041494             0045*                               ; programmer must ensure that this bit is set to 1 each time
041494             0046*                               ; SINGLE-PASS mode is used.
041494             0047*   
041494             0048*   ; disable/enable the programmable reload timer
041494             0049*   PRT_EN_0:     equ %00000000 ;
041494             0050*   PRT_EN_1:     equ %00000001 ;
041494             0051*   
041494             0052*   ; Table 37. Timer Input Source Select Register
041494             0053*   ; Each of the 4 timers are allocated two bits of the 8-bit register
041494             0054*   ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
041494             0055*   ;   00: System clock / CLK_DIV
041494             0056*   ;   01: RTC / CLK_DIV
041494             0057*   ;   NOTE: these are the values given in the manual,but it may be a typo
041494             0058*   ;   10: GPIO port B pin 1.
041494             0059*   ;   11: GPIO port B pin 1.
041494             0060*   TMR_ISS:   equ 92h ; register address
041494             0061*   
041494             0062*   ; Table 51. Real-Time Clock Control Register
041494             0063*   RTC_CTRL: equ EDh ; register address
041494             0064*   
041494             0065*   ; alarm interrupt disable/enable
041494             0066*   RTC_ALARM_0:    equ %00000000
041494             0067*   RTC_ALARM_1:    equ %10000000
041494             0068*   
041494             0069*   ; interrupt on alarm disable/enable
041494             0070*   RTC_INT_ENT_0:  equ %00000000
041494             0071*   RTC_INT_ENT_1:  equ %01000000
041494             0072*   
041494             0073*   RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
041494             0074*   RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
041494             0075*   
041494             0076*   RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
041494             0077*                                   ; On-chip 32768 Hz oscillator is enabled.
041494             0078*   RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
041494             0079*                                   ; On-chip 32768 Hz oscillator is disabled.
041494             0080*   
041494             0081*   RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
041494             0082*   RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
041494             0083*   
041494             0084*   RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
041494             0085*   RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
041494             0086*   
041494             0087*   RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
041494             0088*                                   ; RTC counter is enabled.
041494             0089*   RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
041494             0090*                                   ; RTC counter is disabled.
041494             0091*   
041494             0092*   ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
041494             0093*   
041494             0094*   prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
041494             0095*   prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
041494 00 00 00    0096*   prt_reload: dl 0x000000
041497             0097*   
041497             0098*   ; returns: a = 0 if running on hardware,1 if running on emulator
041497             0099*   ;          de = number PRT interrupts during test interval
041497             0100*   prt_calibrate:
041497 CD 66 17 04 0101*       call vdu_vblank
04149B             0102*   ; set a MOS timer
04149B 21 78 00 00 0103*       ld hl,120*1 ; 1 second
04149F FD 21 1F 16 0104*       ld iy,tmr_test
       04          
0414A4 CD FD 15 04 0105*       call tmr_set
0414A8             0106*   ; set a PRT timer
0414A8             0107*       ; ld hl,prt_reload_hardware
0414A8             0108*       ; ld hl,prt_reload_emulator
0414A8 21 05 2D 00 0109*       ld hl,prt_reload_emulator + prt_reload_hardware / 2
0414AC 22 94 14 04 0110*       ld (prt_reload),hl
0414B0 CD 38 15 04 0111*       call prt_set
0414B4             0112*   @loop:
0414B4             0113*   ; check time remaining on MOS timer
0414B4 CD 0B 16 04 0114*       call tmr_get
0414B8 CA C2 14 04 0115*       jp z,@done ; time expired,so quit
0414BC FA C2 14 04 0116*       jp m,@done ; time past expiration (negative),so quit
0414C0 18 F2       0117*       jr @loop
0414C2             0118*   @done:
0414C2 ED 5B 86 15 0119*       ld de,(prt_irq_counter)
       04          
0414C7 01 0C 2D 00 0120*       ld bc,prt_reload_hardware ; default value for running on hardware
0414CB ED 43 94 14 0121*       ld (prt_reload),bc
       04          
0414D0 21 64 00 00 0122*       ld hl,100 ; halfway between 101 for real hardware and 99 for emulator
0414D4 AF          0123*       xor a ; clear carry,zero is default value for running on hardware
0414D5 32 F7 14 04 0124*       ld (is_emulator),a
0414D9 ED 52       0125*       sbc hl,de
0414DB 21 F8 14 04 0126*       ld hl,on_hardware ; default message for running on hardware
0414DF CA 97 14 04 0127*       jp z,prt_calibrate ; zero result is indeterminate so we try again
0414E3 F8          0128*       ret m ; negative result means we're on hardware
0414E4 3C          0129*       inc a ; we're on emulator
0414E5 32 F7 14 04 0130*       ld (is_emulator),a
0414E9 01 FF 2C 00 0131*       ld bc,prt_reload_emulator
0414ED ED 43 94 14 0132*       ld (prt_reload),bc
       04          
0414F2 21 0E 15 04 0133*       ld hl,on_emulator
0414F6 C9          0134*       ret
0414F7 00          0135*   is_emulator: db 0
0414F8 52 75 6E 6E 0136*   on_hardware: defb "Running on hardware\r\n",0
       69 6E 67 20 
       6F 6E 20 68 
       61 72 64 77 
       61 72 65 0D 
       0A 00       
04150E 52 75 6E 6E 0137*   on_emulator: defb "Running on emulator\r\n",0
       69 6E 67 20 
       6F 6E 20 65 
       6D 75 6C 61 
       74 6F 72 0D 
       0A 00       
041524             0138*   
041524 43 61 6C 69 0139*   calibrating_timer: defb "Calibrating timer\r\n",0
       62 72 61 74 
       69 6E 67 20 
       74 69 6D 65 
       72 0D 0A 00 
041538             0140*   
041538             0141*   ; set PRT timer
041538             0142*   prt_set:
041538 21 00 00 00 0143*       ld hl,0
04153C 22 86 15 04 0144*       ld (prt_irq_counter),hl
041540 2A 94 14 04 0145*       ld hl,(prt_reload)
041544 ED 29 84    0146*       out0 (TMR1_CTL+TMR_RES_LOW),l
041547 ED 21 85    0147*   	out0 (TMR1_CTL+TMR_RES_HIGH),h
04154A             0148*   ; disable timer
04154A 3E 06       0149*       ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
04154C ED 39 83    0150*   	out0 (TMR1_CTL+TMR_REG_CTL),a
04154F             0151*   ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
04154F 3E 57       0152*       ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
041551 ED 39 83    0153*   	out0 (TMR1_CTL+TMR_REG_CTL),a
041554 C9          0154*       ret
041555             0155*   
041555             0156*   ; ===============================================
041555             0157*   ; PRT Timer Interrupt Handling
041555             0158*   ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.asm
041555             0159*   ; -----------------------------------------------
041555             0160*   prt_irq_init:
041555             0161*       ; set up interrupt vector table 2
041555 21 00 00 00 0162*   	ld hl,0
041559 3A 0C 01 00 0163*   	ld a,($10c)
04155D 6F          0164*   	ld l,a
04155E 3A 0D 01 00 0165*   	ld a,($10d)
041562 67          0166*   	ld h,a
041563             0167*   
041563             0168*   	; skip over CALL ($c3)
041563 23          0169*   	inc hl
041564             0170*   	; load address of jump into vector table 2 (in ram)
041564 ED 27       0171*   	ld hl,(hl)
041566             0172*   
041566             0173*   	; write CALL prt_irq_handler to vector table 2
041566 3E C3       0174*   	ld a,$c3
041568 77          0175*   	ld (hl),a
041569 23          0176*   	inc hl
04156A 11 71 15 04 0177*   	ld de,prt_irq_handler
04156E ED 1F       0178*   	ld (hl),de
041570             0179*   
041570 C9          0180*       ret
041571             0181*   
041571             0182*   prt_irq_handler:
041571 F3          0183*   	di
041572 F5          0184*   	push af
041573 E5          0185*       push hl
041574 ED 38 83    0186*   	in0 a,(TMR1_CTL+TMR_REG_CTL)
041577 2A 86 15 04 0187*   	ld hl,(prt_irq_counter)
04157B 23          0188*   	inc hl
04157C 22 86 15 04 0189*   	ld (prt_irq_counter),hl
041580 E1          0190*       pop hl
041581 F1          0191*   	pop af
041582 FB          0192*   	ei
041583 5B ED 4D    0193*   	reti.l
041586             0194*   
041586             0195*   prt_irq_counter:
041586 00 00 00    0196*   	.dl 0
041589             0197*   prt_irq_counter_saved:
041589 00 00 00    0198*       .dl 0
04158C             0199*   
04158C             0200*   prt_loop_reset:
04158C E5          0201*       push hl
04158D 21 00 00 00 0202*   	ld hl,0
041591 22 86 15 04 0203*   	ld (prt_irq_counter),hl
041595 22 F7 15 04 0204*       ld (prt_loop_counter),hl
041599 22 FA 15 04 0205*       ld (prt_loops),hl
04159D CD 38 15 04 0206*       call prt_set
0415A1 E1          0207*       pop hl
0415A2 C9          0208*       ret
0415A3             0209*   
0415A3             0210*   prt_loop_start:
0415A3 E5          0211*       push hl
0415A4 21 00 00 00 0212*   	ld hl,0
0415A8 22 86 15 04 0213*   	ld (prt_irq_counter),hl
0415AC E1          0214*       pop hl
0415AD C9          0215*       ret
0415AE             0216*   
0415AE             0217*   prt_loop_stop:
0415AE E5          0218*       push hl
0415AF D5          0219*       push de
0415B0 2A 86 15 04 0220*       ld hl,(prt_irq_counter)
0415B4 ED 5B F7 15 0221*       ld de,(prt_loop_counter)
       04          
0415B9 19          0222*       add hl,de
0415BA 22 F7 15 04 0223*       ld (prt_loop_counter),hl
0415BE 21 00 00 00 0224*       ld hl,0
0415C2 22 86 15 04 0225*       ld (prt_irq_counter),hl
0415C6 2A FA 15 04 0226*       ld hl,(prt_loops)
0415CA 23          0227*       inc hl
0415CB 22 FA 15 04 0228*       ld (prt_loops),hl
0415CF D1          0229*       pop de
0415D0 E1          0230*       pop hl
0415D1 C9          0231*       ret
0415D2             0232*   
0415D2             0233*   ; inputs: bc = y,x text coordinates to print
0415D2             0234*   prt_loop_print:
0415D2 F5          0235*       push af
0415D3 E5          0236*       push hl
0415D4 C5          0237*       push bc
0415D5 D5          0238*       push de
0415D6 DD E5       0239*       push ix
0415D8 FD E5       0240*       push iy
0415DA CD DE 16 04 0241*       call vdu_move_cursor
0415DE             0242*   
0415DE 2A F7 15 04 0243*       ld hl,(prt_loop_counter)
0415E2 CD BA 00 04 0244*       call printDec
0415E6             0245*   
0415E6 2A FA 15 04 0246*       ld hl,(prt_loops)
0415EA CD BA 00 04 0247*       call printDec
0415EE             0248*   
0415EE FD E1       0249*       pop iy
0415F0 DD E1       0250*       pop ix
0415F2 D1          0251*       pop de
0415F3 C1          0252*       pop bc
0415F4 E1          0253*       pop hl
0415F5 F1          0254*       pop af
0415F6 C9          0255*       ret
0415F7             0256*   
0415F7             0257*   prt_loop_counter:
0415F7 00 00 00    0258*       .dl 0
0415FA             0259*   prt_loops:
0415FA 00 00 00    0260*       .dl 0
0415FD             0261*   
0415FD             0262*   ; ===============================================
0415FD             0263*   ; Timer functions
0415FD             0264*   ; -----------------------------------------------
0415FD             0265*   ; set a countdown timer
0415FD             0266*   ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0415FD             0267*   ; returns: hl = current time
0415FD             0268*   tmr_set:
0415FD FD 2F 03    0269*       ld (iy+3),hl            ; set time remaining
041600             0270*       MOSCALL mos_sysvars     ; ix points to syvars table
041600 3E 08       0001*M1 			LD	A, function
041602 5B CF       0002*M1 			RST.LIL	08h
041604 DD 27 00    0271*       ld hl,(ix+sysvar_time)  ; get current time
041607 FD 2F 00    0272*       ld (iy+0),hl            ; set start time
04160A C9          0273*       ret
04160B             0274*   
04160B             0275*   ; gets time remaining on a countdown timer
04160B             0276*   ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
04160B             0277*   ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
04160B             0278*   ;          sign flags: pos = time not expired,zero or neg = time expired
04160B             0279*   tmr_get:
04160B             0280*       MOSCALL mos_sysvars     ; ix points to syvars table
04160B 3E 08       0001*M1 			LD	A, function
04160D 5B CF       0002*M1 			RST.LIL	08h
04160F DD 17 00    0281*       ld de,(ix+sysvar_time)  ; get current time
041612 FD 27 00    0282*       ld hl,(iy+0)            ; get start time
041615 AF          0283*       xor a                   ; clear carry
041616 ED 52       0284*       sbc hl,de               ; hl = time elapsed (will always be zero or negative)
041618 FD 17 03    0285*       ld de,(iy+3)            ; get timer set value
04161B AF          0286*       xor a                   ; clear carry
04161C ED 5A       0287*       adc hl,de               ; hl = time remaining
04161E             0288*                               ; (we do adc because add hl,rr doesn't set sign or zero flags)
04161E C9          0289*       ret
04161F             0290*   
04161F             0291*   tmr_test: ds 6 ; example of a buffer to hold timer data
041625             0292*   
       FF FF FF FF 
       FF FF 
041625 00 00 00    0293*   timestamp_now: dl 0
041628 00 00 00    0294*   timestamp_old: dl 0
04162B 00 00 00    0295*   timestamp_chg: dl 0
04162E             0296*   
04162E             0297*   ; update the global timestamp from the system clock
04162E             0298*   ; inputs: none
04162E             0299*   ; returns: hl = time elapsed in 1/120ths of a second
04162E             0300*   ;          de = current time
04162E             0301*   ;          ix = pointer to syvars table
04162E             0302*   ; destroys: af,hl,de,ix
04162E             0303*   timestamp_tick:
04162E ED 5B 25 16 0304*       ld de,(timestamp_now)   ; get previous time
       04          
041633 ED 53 28 16 0305*       ld (timestamp_old),de   ; save previous time
       04          
041638             0306*       MOSCALL mos_sysvars     ; ix points to syvars table
041638 3E 08       0001*M1 			LD	A, function
04163A 5B CF       0002*M1 			RST.LIL	08h
04163C DD 27 00    0307*       ld hl,(ix+sysvar_time)  ; get current time
04163F 22 25 16 04 0308*       ld (timestamp_now),hl   ; save current time
041643 AF          0309*       xor a                   ; clear carry
041644 ED 52       0310*       sbc hl,de               ; hl = time elapsed
041646 22 2B 16 04 0311*       ld (timestamp_chg),hl   ; save elapsed time
04164A C9          0312*       ret
04164B             0313*   
04164B             0314*   ; set a countdown timer
04164B             0315*   ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
04164B             0316*   ; requires: timestamp_tick to be called at least once before this function
04164B             0317*   ; returns: hl = current time
04164B             0318*   ; destroys: hl
04164B             0319*   timestamp_tmr_set:
04164B FD 2F 03    0320*       ld (iy+3),hl            ; set time remaining
04164E 2A 25 16 04 0321*       ld hl,(timestamp_now)   ; get current timestamp
041652 FD 2F 00    0322*       ld (iy+0),hl            ; set start time
041655 C9          0323*       ret
041656             0324*   
041656             0325*   ; gets time remaining on a countdown timer following the global timestamp
041656             0326*   ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
041656             0327*   ; requires: timestamp_tick to be called at least once before this function
041656             0328*   ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
041656             0329*   ;          sign flags: pos = time not expired,zero or neg = time expired
041656             0330*   ; destroys: af,hl,de
041656             0331*   timestamp_tmr_get:
041656 ED 5B 25 16 0332*       ld de,(timestamp_now)   ; get current timestamp
       04          
04165B FD 27 00    0333*       ld hl,(iy+0)            ; get start time
04165E AF          0334*       xor a                   ; clear carry
04165F ED 52       0335*       sbc hl,de               ; hl = time elapsed (will always be zero or negative)
041661 FD 17 03    0336*       ld de,(iy+3)            ; get timer set value
041664 AF          0337*       xor a                   ; clear carry
041665 ED 5A       0338*       adc hl,de               ; hl = time remaining
041667             0339*                               ; (we do adc because add hl,rr doesn't set sign or zero flags)
041667 C9          0340*       ret
041668             0341*   
041668             0342*   ; set a stopwatch
041668             0343*   ; returns: hl = start time
041668             0344*   ; destroys: hl,ix
041668             0345*   stopwatch_set:
041668             0346*       MOSCALL mos_sysvars     ; ix points to syvars table
041668 3E 08       0001*M1 			LD	A, function
04166A 5B CF       0002*M1 			RST.LIL	08h
04166C DD 27 00    0347*       ld hl,(ix+sysvar_time)  ; get current time
04166F 22 84 16 04 0348*       ld (stopwatch_started),hl            ; set start time
041673 C9          0349*       ret
041674             0350*   
041674             0351*   ; gets time elapsed on a stopwatch
041674             0352*   ; returns: hl = time elapsed in 1/120ths of a second
041674             0353*   ; destroys: af,hl,de,ix
041674             0354*   stopwatch_get:
041674             0355*       MOSCALL mos_sysvars     ; ix points to syvars table
041674 3E 08       0001*M1 			LD	A, function
041676 5B CF       0002*M1 			RST.LIL	08h
041678 DD 27 00    0356*       ld hl,(ix+sysvar_time)  ; get current time
04167B ED 5B 84 16 0357*       ld de,(stopwatch_started)            ; get start time
       04          
041680 AF          0358*       xor a                   ; clear carry
041681 ED 52       0359*       sbc hl,de               ; hl = time elapsed (will always be zero or positive)
041683 C9          0360*       ret
041684             0361*   
041684             0362*   stopwatch_started: ds 3 ; buffer to hold stopwatch start time
041687             0363*   
041687             0364*   ; ------------------
041687             0365*   ; delay routine
041687             0366*   ; Author: Richard Turrnidge
041687             0367*   ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.asm
041687             0368*   ; routine waits a fixed time,then returns
041687             0369*   ; arrive with A =  the delay byte. One bit to be set only.
041687             0370*   ; eg. ld A,00000100b
041687             0371*   
041687             0372*   multiPurposeDelay:
       FF FF FF 
041687 F5          0373*       push af
041688 C5          0374*       push bc
041689 DD E5       0375*       push ix
04168B 47          0376*       ld b,a
04168C 3E 08       0377*       ld a,$08
04168E 5B CF       0378*       RST.LIL	08h                 ; get IX pointer to sysvars
041690             0379*   
041690             0380*   waitLoop:
041690             0381*   
041690 DD 7E 00    0382*       ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
041693             0383*   
041693             0384*                                   ;   we check if bit set is same as last time we checked.
041693             0385*                                   ;   bit 0 - don't use
041693             0386*                                   ;   bit 1 - changes 64 times per second
041693             0387*                                   ;   bit 2 - changes 32 times per second
041693             0388*                                   ;   bit 3 - changes 16 times per second
041693             0389*   
041693             0390*                                   ;   bit 4 - changes 8 times per second
041693             0391*                                   ;   bit 5 - changes 4 times per second
041693             0392*                                   ;   bit 6 - changes 2 times per second
041693             0393*                                   ;   bit 7 - changes 1 times per second
041693 A0          0394*       and b
041694 4F          0395*       ld c,a
041695 3A A6 16 04 0396*       ld a,(oldTimeStamp)
041699 B9          0397*       cp c                        ; is A same as last value?
04169A 28 F4       0398*       jr z,waitLoop              ; loop here if it is
04169C 79          0399*       ld a,c
04169D 32 A6 16 04 0400*       ld (oldTimeStamp),a        ; set new value
0416A1             0401*   
0416A1 DD E1       0402*       pop ix
0416A3 C1          0403*       pop bc
0416A4 F1          0404*       pop af
0416A5 C9          0405*       ret
0416A6             0406*   
0416A6 00          0407*   oldTimeStamp:   .db 00h
0416A7             0041        include "vdu.inc"
0416A7             0001*   ; VDU 30: Home cursor
0416A7             0002*   vdu_home_cursor:
0416A7 3E 1E       0003*       ld a,30
0416A9 5B D7       0004*   	rst.lil $10
0416AB C9          0005*   	ret
0416AC             0006*   
0416AC             0007*   vdu_cursor_on:
0416AC 21 B7 16 04 0008*   	ld hl,@cmd
0416B0 01 03 00 00 0009*   	ld bc,@end-@cmd
0416B4 5B DF       0010*   	rst.lil $18
0416B6 C9          0011*   	ret
0416B7             0012*   @cmd:
0416B7 17 01 01    0013*   	db 23,1,1
0416BA             0014*   @end:
0416BA             0015*   
0416BA             0016*   vdu_cursor_off:
0416BA 21 C5 16 04 0017*   	ld hl,@cmd
0416BE 01 03 00 00 0018*   	ld bc,@end-@cmd
0416C2 5B DF       0019*   	rst.lil $18
0416C4 C9          0020*   	ret
0416C5             0021*   @cmd:
0416C5 17 01 00    0022*   	db 23,1,0
0416C8             0023*   @end:
0416C8             0024*   
0416C8             0025*   ; VDU 5: Write text at graphics cursor
0416C8             0026*   ; inputs: a is the character to write to the screen
0416C8             0027*   ; prerequisites: the graphics cursor at the intended position on screen
0416C8             0028*   ; outputs: see the name of the function
0416C8             0029*   ; destroys: a, hl, bc
0416C8             0030*   vdu_char_to_gfx_cursor:
0416C8 32 D8 16 04 0031*   	ld (@arg),a
0416CC 21 D7 16 04 0032*   	ld hl,@cmd
0416D0 01 02 00 00 0033*   	ld bc,@end-@cmd
0416D4 5B DF       0034*   	rst.lil $18
0416D6 C9          0035*   	ret
0416D7 05          0036*   @cmd: db 5
0416D8 00          0037*   @arg: db 0
0416D9             0038*   @end:
0416D9             0039*   ; VDU 9: Move cursor forward one character
0416D9             0040*   vdu_cursor_forward:
0416D9 3E 09       0041*       ld a,9
0416DB 5B D7       0042*   	rst.lil $10
0416DD C9          0043*   	ret
0416DE             0044*   
0416DE             0045*   ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
0416DE             0046*   ; inputs: c=x, b=y 8-bit unsigned integers
0416DE             0047*   vdu_move_cursor:
0416DE ED 43 EF 16 0048*       ld (@x0),bc
       04          
0416E3 21 EE 16 04 0049*   	ld hl,@cmd
0416E7 01 03 00 00 0050*   	ld bc,@end-@cmd
0416EB 5B DF       0051*   	rst.lil $18
0416ED C9          0052*   	ret
0416EE 1F          0053*   @cmd: 	db 31
0416EF 00          0054*   @x0:	db 0
0416F0 00          0055*   @y0: 	db 0
0416F1 00          0056*   @end: 	db 0 ; padding
0416F2             0057*   
0416F2             0058*   ; VDU 12: Clear text area (CLS)
0416F2             0059*   vdu_cls:
0416F2 3E 0C       0060*       ld a,12
0416F4 5B D7       0061*   	rst.lil $10
0416F6 C9          0062*   	ret
0416F7             0063*   
0416F7             0064*   vdu_flip:
0416F7 21 02 17 04 0065*   	ld hl,@cmd
0416FB 01 03 00 00 0066*   	ld bc,@end-@cmd
0416FF 5B DF       0067*   	rst.lil $18
041701 C9          0068*   	ret
041702 17 00 C3    0069*   @cmd: db 23,0,0xC3
041705             0070*   @end:
041705             0071*   
041705             0072*   ; VDU 16: Clear graphics area (CLG)
041705             0073*   vdu_clg:
041705 3E 10       0074*       ld a,16
041707 5B D7       0075*   	rst.lil $10
041709 C9          0076*   	ret
04170A             0077*   
04170A             0078*   ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
04170A             0079*   ; VDU 23, 7: Scrolling
04170A             0080*   ;     VDU 23, 7, extent, direction, speed: Scroll the screen
04170A             0081*   ; inputs: a, extent; l, direction; h; speed
04170A             0082*   vdu_scroll_down:
04170A 32 1F 17 04 0083*   	ld (@extent),a
04170E 22 20 17 04 0084*   	ld (@dir),hl ; implicitly populates @speed
041712 21 1D 17 04 0085*   	ld hl,@cmd
041716 01 05 00 00 0086*   	ld bc,@end-@cmd
04171A 5B DF       0087*   	rst.lil $18     ;; Sending command to VDP
04171C C9          0088*   	ret
04171D 17 07       0089*   @cmd:       db 23,7
04171F 00          0090*   @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
041720 00          0091*   @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
041721 00          0092*   @speed:     db 0x00 ; pixels
041722 00          0093*   @end:		db 0x00 ; padding
041723             0094*   
041723             0095*   ; COLOUR MODES
041723             0096*   ; Mode	Effect
041723             0097*   ; 0	Set on-screen pixel to target colour value
041723             0098*   ; 1	OR value with the on-screen pixel
041723             0099*   ; 2	AND value with the on-screen pixel
041723             0100*   ; 3	XOR value with the on-screen pixel
041723             0101*   ; 4	Invert the on-screen pixel
041723             0102*   ; 5	No operation
041723             0103*   ; 6	AND the inverse of the specified colour with the on-screen pixel
041723             0104*   ; 7	OR the inverse of the specified colour with the on-screen pixel
041723             0105*   
041723             0106*   ; VDU 17, colour: Define text colour (COLOUR)
041723             0107*   vdu_colour_text:
041723 32 33 17 04 0108*   	ld (@arg),a
041727 21 32 17 04 0109*   	ld hl,@cmd
04172B 01 02 00 00 0110*   	ld bc,@end-@cmd
04172F 5B DF       0111*   	rst.lil $18
041731 C9          0112*   	ret
041732 11          0113*   @cmd: db 17
041733 00          0114*   @arg: db 0
041734             0115*   @end:
041734             0116*   
041734             0117*   ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
041734             0118*   ; inputs: a=mode, c=colour (add 128 to set background colour)
041734             0119*   vdu_gcol:
041734 32 49 17 04 0120*   	ld (@mode),a
041738 79          0121*       ld a,c
041739 32 4A 17 04 0122*       ld (@col),a
04173D 21 48 17 04 0123*   	ld hl,@cmd
041741 01 03 00 00 0124*   	ld bc,@end-@cmd
041745 5B DF       0125*   	rst.lil $18
041747 C9          0126*   	ret
041748 12          0127*   @cmd:  db 18
041749 00          0128*   @mode: db 0
04174A 00          0129*   @col:  db 0
04174B             0130*   @end:
04174B             0131*   
04174B             0132*   
04174B             0133*   ; VDU 28, left, bottom, right, top: Set text viewport **
04174B             0134*   ; MIND THE LITTLE-ENDIANESS
04174B             0135*   ; inputs: c=left,b=bottom,e=right,d=top
04174B             0136*   ; outputs; nothing
04174B             0137*   ; destroys: a might make it out alive
04174B             0138*   vdu_set_txt_viewport:
04174B ED 43 61 17 0139*       ld (@lb),bc
       04          
041750 ED 53 63 17 0140*   	ld (@rt),de
       04          
041755 21 60 17 04 0141*   	ld hl,@cmd
041759 01 05 00 00 0142*   	ld bc,@end-@cmd
04175D 5B DF       0143*   	rst.lil $18
04175F C9          0144*   	ret
041760 1C          0145*   @cmd:   db 28 ; set text viewport command
041761 00 00       0146*   @lb: 	dw 0x0000 ; set by bc
041763 00 00       0147*   @rt: 	dw 0x0000 ; set by de
041765 00          0148*   @end:   db 0x00	  ; padding
041766             0149*   
041766             0150*   ; Wait for VBLANK interrupt
041766             0151*   vdu_vblank:
041766 DD E5       0152*       PUSH 	IX
041768             0153*   	MOSCALL	mos_sysvars
041768 3E 08       0001*M1 			LD	A, function
04176A 5B CF       0002*M1 			RST.LIL	08h
04176C DD 7E 00    0154*   	LD	A, (IX + sysvar_time + 0)
04176F             0155*   @wait:
04176F DD BE 00    0156*       CP 	A, (IX + sysvar_time + 0)
041772 28 FB       0157*       JR	Z, @wait
041774 DD E1       0158*       POP	IX
041776 C9          0159*       RET
041777             0160*   
041777             0161*   ; VDU 29, x; y;: Set graphics origin
041777             0162*   ; This command sets the graphics origin.
041777             0163*   ; The origin is the point on the screen where the coordinates (0,0) are located.
041777             0164*   ; inputs: bc=x0,de=y0
041777             0165*   ; outputs; nothing
041777             0166*   ; destroys: a might make it out alive
041777             0167*   vdu_set_gfx_origin:
041777 ED 43 8D 17 0168*       ld (@x0),bc
       04          
04177C ED 53 8F 17 0169*       ld (@y0),de
       04          
041781 21 8C 17 04 0170*       ld hl,@cmd
041785 01 05 00 00 0171*       ld bc,@end-@cmd
041789 5B DF       0172*       rst.lil $18
04178B C9          0173*       ret
04178C 1D          0174*   @cmd:   db 29 ; set graphics origin command
04178D 00 00       0175*   @x0: 	dw 0x0000 ; set by bc
04178F 00 00       0176*   @y0: 	dw 0x0000 ; set by de
041791 00          0177*   @end:   db 0x00	  ; padding
041792             0178*   
041792             0179*   ; VDU 24, left; bottom; right; top;: Set graphics viewport
041792             0180*   ; NOTE: the order of the y-coordinate parameters are inverted
041792             0181*   ; 	because we have turned off logical screen scaling
041792             0182*   ; NOTE: coordinates are relative to current gfx origin
041792             0183*   ; inputs: bc=x0,de=y0,ix=x1,iy=y1
041792             0184*   ; outputs; nothing
041792             0185*   ; destroys: a might make it out alive
041792             0186*   vdu_set_gfx_viewport:
041792 ED 43 B2 17 0187*       ld (@x0),bc
       04          
041797 FD 22 B4 17 0188*       ld (@y1),iy
       04          
04179C DD 22 B6 17 0189*   	ld (@x1),ix
       04          
0417A1 ED 53 B8 17 0190*   	ld (@y0),de
       04          
0417A6 21 B1 17 04 0191*   	ld hl,@cmd
0417AA 01 09 00 00 0192*   	ld bc,@end-@cmd
0417AE 5B DF       0193*   	rst.lil $18
0417B0 C9          0194*   	ret
0417B1 18          0195*   @cmd:   db 24 ; set graphics viewport command
0417B2 00 00       0196*   @x0: 	dw 0x0000 ; set by bc
0417B4 00 00       0197*   @y1: 	dw 0x0000 ; set by iy
0417B6 00 00       0198*   @x1: 	dw 0x0000 ; set by ix
0417B8 00 00       0199*   @y0: 	dw 0x0000 ; set by de
0417BA 00          0200*   @end:   db 0x00	  ; padding
0417BB             0201*   
0417BB             0202*   ; VDU 26: Reset graphics and text viewports
0417BB             0203*   vdu_reset_viewports:
0417BB 3E 1A       0204*       ld a,26
0417BD 5B D7       0205*       rst.lil $10
0417BF C9          0206*       ret
0417C0             0207*   
0417C0             0208*   ; SCREEN MODES
0417C0             0209*   ; ===============================
0417C0             0210*   ; Mode  Horz  Vert  Cols  Refresh
0417C0             0211*   ; ---   ----  ----  ----  -------
0417C0             0212*   ; 11    320   240   2     60hz
0417C0             0213*   ; 139   320   240   2     60hz
0417C0             0214*   ; 23    512   384   2     60hz
0417C0             0215*   ; 151   512   384   2     60hz
0417C0             0216*   ; 6     640   240   2     60hz
0417C0             0217*   ; 134   640   240   2     60hz
0417C0             0218*   ; 2     640   480   2     60hz
0417C0             0219*   ; 130   640   480   2     60hz
0417C0             0220*   ; 17    800   600   2     60hz
0417C0             0221*   ; 145   800   600   2     60hz
0417C0             0222*   ; 18    1024  768   2     60hz
0417C0             0223*   ; 146   1024  768   2     60hz
0417C0             0224*   ; ---   ----  ----  ----  -------
0417C0             0225*   ; 10    320   240   4     60hz
0417C0             0226*   ; 138   320   240   4     60hz
0417C0             0227*   ; 22    512   384   4     60hz
0417C0             0228*   ; 150   512   384   4     60hz
0417C0             0229*   ; 5     640   240   4     60hz
0417C0             0230*   ; 133   640   240   4     60hz
0417C0             0231*   ; 1     640   480   4     60hz
0417C0             0232*   ; 129   640   480   4     60hz
0417C0             0233*   ; 16    800   600   4     60hz
0417C0             0234*   ; 19    1024  768   4     60hz
0417C0             0235*   ; ---   ----  ----  ----  -------
0417C0             0236*   ; 9     320   240   16    60hz
0417C0             0237*   ; 137   320   240   16    60hz
0417C0             0238*   ; 21    512   384   16    60hz
0417C0             0239*   ; 149   512   384   16    60hz
0417C0             0240*   ; 4     640   240   16    60hz
0417C0             0241*   ; 132   640   240   16    60hz
0417C0             0242*   ; 0     640   480   16    60hz
0417C0             0243*   ; 7     n/a   n/a   16    60hz
0417C0             0244*   ; ---   ----  ----  ----  -------
0417C0             0245*   ; 8     320   240   64    60hz
0417C0             0246*   ; 136   320   240   64    60hz
0417C0             0247*   ; 20    512   384   64    60hz
0417C0             0248*   ; 3     640   240   64    60hz
0417C0             0249*   ; ---   ----  ----  ----  -------
0417C0             0250*   vdu_set_screen_mode:
0417C0 32 D0 17 04 0251*   	ld (@arg),a
0417C4 21 CF 17 04 0252*   	ld hl,@cmd
0417C8 01 02 00 00 0253*   	ld bc,@end-@cmd
0417CC 5B DF       0254*   	rst.lil $18
0417CE C9          0255*   	ret
0417CF 16          0256*   @cmd: db 22 ; set screen mode
0417D0 00          0257*   @arg: db 0  ; screen mode parameter
0417D1             0258*   @end:
0417D1             0259*   
0417D1             0260*   ; get the current screen mode
0417D1             0261*   ; inputs: none
0417D1             0262*   ; outputs: a=screen mode
0417D1             0263*   ; destroys: af, ix
0417D1             0264*   vdu_get_screen_mode:
0417D1             0265*       MOSCALL mos_sysvars
0417D1 3E 08       0001*M1 			LD	A, function
0417D3 5B CF       0002*M1 			RST.LIL	08h
0417D5 DD 7E 27    0266*       ld a,(IX+sysvar_scrMode)
0417D8 C9          0267*       ret
0417D9             0268*   ; end vdu_get_screen_mode
0417D9             0269*   
0417D9             0270*   ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
0417D9             0271*   ; inputs: a is scaling mode, 1=on, 0=off
0417D9             0272*   ; note: default setting on boot is scaling ON
0417D9             0273*   vdu_set_scaling:
0417D9 32 EB 17 04 0274*   	ld (@arg),a
0417DD 21 E8 17 04 0275*   	ld hl,@cmd
0417E1 01 04 00 00 0276*   	ld bc,@end-@cmd
0417E5 5B DF       0277*   	rst.lil $18
0417E7 C9          0278*   	ret
0417E8 17 00 C0    0279*   @cmd: db 23,0,0xC0
0417EB 00          0280*   @arg: db 0  ; scaling on/off
0417EC             0281*   @end:
0417EC             0282*   
0417EC             0283*   ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
0417EC             0284*   ; inputs: hl=bufferId
0417EC             0285*   vdu_buff_select:
0417EC 22 FE 17 04 0286*   	ld (@bufferId),hl
0417F0 21 FB 17 04 0287*   	ld hl,@cmd
0417F4 01 05 00 00 0288*   	ld bc,@end-@cmd
0417F8 5B DF       0289*   	rst.lil $18
0417FA C9          0290*   	ret
0417FB 17 1B 20    0291*   @cmd: db 23,27,0x20
0417FE 00 00       0292*   @bufferId: dw 0x0000
041800 00          0293*   @end: db 0x00 ; padding
041801             0294*   
041801             0295*   ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
041801             0296*   ; inputs: a=format; bc=width; de=height
041801             0297*   ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
041801             0298*   ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
041801             0299*   ; 0 	RGBA8888 (4-bytes per pixel)
041801             0300*   ; 1 	RGBA2222 (1-bytes per pixel)
041801             0301*   ; 2 	Mono/Mask (1-bit per pixel)
041801             0302*   ; 3 	Reserved for internal use by VDP (“native” format)
041801             0303*   vdu_bmp_create:
041801 ED 43 1D 18 0304*       ld (@width),bc
       04          
041806 ED 53 1F 18 0305*       ld (@height),de
       04          
04180B 32 21 18 04 0306*       ld (@fmt),a
04180F 21 1A 18 04 0307*   	ld hl,@cmd
041813 01 08 00 00 0308*   	ld bc,@end-@cmd
041817 5B DF       0309*   	rst.lil $18
041819 C9          0310*   	ret
04181A 17 1B 21    0311*   @cmd:       db 23,27,0x21
04181D 00 00       0312*   @width:     dw 0x0000
04181F 00 00       0313*   @height:    dw 0x0000
041821 00          0314*   @fmt:       db 0x00
041822             0315*   @end:
041822             0316*   
041822             0317*   ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
041822             0318*   ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
041822             0319*   vdu_load_img_rgba2_to_8:
041822             0320*   ; backup the target buffer id and image dimensions
041822 E5          0321*       push hl
041823 D5          0322*       push de
041824 C5          0323*       push bc
041825             0324*   ; load the rgba2 image to working buffer 65534
041825 21 FE FF 00 0325*       ld hl,65534 ; temporary working buffer id
041829 CD 00 19 04 0326*   	call vdu_load_buffer_from_file
04182D             0327*   ; restore the image dimensions and target buffer id
04182D C1          0328*       pop bc
04182E D1          0329*       pop de
04182F E1          0330*       pop hl
041830             0331*   ; fall through to vdu_rgba2_to_8
041830             0332*   
041830             0333*   ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
041830             0334*   ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
041830             0335*   ; the "expand bitmap" command is:
041830             0336*   ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
041830             0337*   ; and then to reverse the byte order to fix endian-ness:
041830             0338*   ; VDU 23,0,&A0,targetBufferID%;24,4,4;
041830             0339*   ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
041830             0340*   ; VDU 23,27,&20,targetBufferID%;
041830             0341*   ; VDU 23,27,&21,width%;height%;0
041830             0342*   ; -------------------------------------------------------------------
041830             0343*   ; inputs: bc,de image width,height ; hl = targetBufferId
041830             0344*   ; prerequisites: rgba2 image data loaded into workingBufferId 65534
041830             0345*   vdu_rgba2_to_8:
041830             0346*   ; load the image dimensions and buffer id parameters
041830 ED 43 8C 18 0347*       ld (@width),bc
       04          
041835 ED 53 8E 18 0348*       ld (@height),de
       04          
04183A 22 71 18 04 0349*       ld (@bufferId0),hl
04183E 22 7E 18 04 0350*       ld (@bufferId2),hl
041842 22 87 18 04 0351*       ld (@bufferId1),hl
041846             0352*   ; clean up bytes that got stomped on by the ID loads
041846 3E 48       0353*       ld a,0x48
041848 32 73 18 04 0354*       ld (@bufferId0+2),a
04184C 3E 17       0355*       ld a,23
04184E 32 89 18 04 0356*       ld (@bufferId1+2),a
041852 3E 18       0357*       ld a,24
041854 32 80 18 04 0358*       ld (@bufferId2+2),a
041858 AF          0359*       xor a
041859 32 90 18 04 0360*       ld (@height+2),a
04185D             0361*   ; send the vdu command strings
04185D 21 68 18 04 0362*       ld hl,@beg
041861 01 29 00 00 0363*       ld bc,@end-@beg
041865 5B DF       0364*       rst.lil $18
041867 C9          0365*       ret
041868             0366*   @beg:
041868             0367*   ; Command 14: Consolidate blocks in a buffer
041868             0368*   ; VDU 23, 0, &A0, bufferId; 14
041868 17 00 A0    0369*       db 23,0,0xA0
04186B FE FF       0370*       dw 65534 ; workingBufferId
04186D 0E          0371*       db 14 ; consolidate blocks
04186E             0372*   ; the "expand bitmap" command is:
04186E             0373*   ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
04186E 17 00 A0    0374*       db 23,0,0xA0
041871 00 00       0375*   @bufferId0: dw 0x0000 ; targetBufferId
041873 48          0376*       db 0x48 ; given as decimal command 72 in the docs
041874 02          0377*       db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
041875 FE FF       0378*       dw 65534 ; sourceBufferId
041877 00 7F BF FF 0379*       db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
04187B             0380*   ; reverse the byte order to fix endian-ness:
04187B             0381*   ; Command 24: Reverse the order of data of blocks within a buffer
04187B             0382*   ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
04187B             0383*   ; VDU 23,0,&A0,targetBufferID%;24,4,4;
04187B 17 00 A0    0384*       db 23,0,0xA0
04187E 00 00       0385*   @bufferId2:    dw 0x0000 ; targetBufferId
041880 18          0386*       db 24 ; reverse byte order
041881 04          0387*       db 4 ; option: Reverse data of the value size within chunk of data of the specified size
041882 04 00       0388*       dw 4 ; size (4 bytes)
041884             0389*   ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
041884             0390*   ; VDU 23,27,&20,targetBufferID%;
041884 17 1B 20    0391*       db 23,27,0x20 ; select bitmap
041887 00 00       0392*   @bufferId1: dw 0x0000 ; targetBufferId
041889             0393*   ; VDU 23,27,&21,width%;height%;0
041889 17 1B 21    0394*       db 23,27,0x21 ; create bitmap from buffer
04188C 00 00       0395*   @width: dw 0x0000
04188E 00 00       0396*   @height: dw 0x0000
041890 00          0397*       db 0x00 ; rgba8888 format
041891             0398*   @end:
041891             0399*   
041891             0400*   ; scratch variables
041891 00 00 00    0401*   bufferId0: dl 0x000000
041894 00 00 00    0402*   bufferId1: dl 0x000000
041897             0403*   
041897             0404*   ; load a vdu buffer from local memory
041897             0405*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
041897             0406*   vdu_load_buffer:
041897 ED 43 C0 18 0407*       ld (@length),bc
       04          
04189C D5          0408*       push de ; save data pointer
04189D             0409*   ; send the vdu command string
04189D 7D          0410*       ld a,l
04189E 32 BD 18 04 0411*       ld (@bufferId),a
0418A2 7C          0412*       ld a,h
0418A3 32 BE 18 04 0413*       ld (@bufferId+1),a
0418A7 21 BA 18 04 0414*       ld hl,@cmd
0418AB 01 08 00 00 0415*       ld bc,@end-@cmd
0418AF 5B DF       0416*       rst.lil $18
0418B1             0417*   ; send the buffer data
0418B1 E1          0418*       pop hl ; pointer to data
0418B2 ED 4B C0 18 0419*       ld bc,(@length)
       04          
0418B7 5B DF       0420*       rst.lil $18 ; send it
0418B9 C9          0421*       ret
0418BA             0422*   ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0418BA 17 00 A0    0423*   @cmd:       db 23,0,0xA0
0418BD 00 00       0424*   @bufferId:	dw 0x0000
0418BF 00          0425*   		    db 0 ; load buffer
0418C0 00 00       0426*   @length:	dw 0x0000
0418C2 00          0427*   @end: db 0 ; padding
0418C3             0428*   
0418C3             0429*   ; Command 14: Consolidate blocks in a buffer
0418C3             0430*   vdu_consolidate_buffer:
0418C3             0431*   ; set parameters for vdu call
0418C3 7D          0432*       ld a,l
0418C4 32 DB 18 04 0433*       ld (@bufferId),a
0418C8 7C          0434*       ld a,h
0418C9 32 DC 18 04 0435*       ld (@bufferId+1),a
0418CD 21 D8 18 04 0436*       ld hl,@beg
0418D1 01 06 00 00 0437*       ld bc,@end-@beg
0418D5 5B DF       0438*       rst.lil $18
0418D7 C9          0439*       ret
0418D8             0440*   ; VDU 23, 0, &A0, bufferId; 14
0418D8 17 00 A0    0441*   @beg: db 23,0,0xA0
0418DB 00 00       0442*   @bufferId: dw 0x0000
0418DD 0E          0443*              db 14
0418DE             0444*   @end:
0418DE             0445*   
0418DE             0446*   ; load an image file to a buffer and make it a bitmap
0418DE             0447*   ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
0418DE             0448*   vdu_load_img:
0418DE             0449*   ; back up image type and dimension parameters
0418DE 22 91 18 04 0450*       ld (bufferId0),hl
0418E2 F5          0451*       push af
0418E3 C5          0452*   	push bc
0418E4 D5          0453*   	push de
0418E5             0454*   ; load the image
0418E5 CD 00 19 04 0455*   	call vdu_load_buffer_from_file
0418E9             0456*   ; now make it a bitmap
0418E9 2A 91 18 04 0457*       ld hl,(bufferId0)
0418ED CD C3 18 04 0458*       call vdu_consolidate_buffer
0418F1 2A 91 18 04 0459*       ld hl,(bufferId0)
0418F5 CD EC 17 04 0460*       call vdu_buff_select
0418F9 D1          0461*   	pop de ; image height
0418FA C1          0462*   	pop bc ; image width
0418FB F1          0463*   	pop af ; image type
0418FC C3 01 18 04 0464*   	jp vdu_bmp_create ; will return to caller from there
041900             0465*   
041900             0466*   ; inputs: hl = bufferId; iy = pointer to filename
041900             0467*   vdu_load_buffer_from_file:
041900 22 91 18 04 0468*       ld (bufferId0),hl
041904             0469*   
041904             0470*   ; clear target buffer
041904 CD AC 1A 04 0471*       call vdu_clear_buffer
041908             0472*   
041908             0473*   ; open the file in read mode
041908             0474*   ; Open a file
041908             0475*   ; HLU: Filename
041908             0476*   ;   C: Mode
041908             0477*   ; Returns:
041908             0478*   ;   A: Filehandle, or 0 if couldn't open
041908 FD E5       0479*   	push iy ; pointer to filename
04190A E1          0480*   	pop hl
04190B 0E 01       0481*   	ld c,fa_read
04190D             0482*       MOSCALL mos_fopen
04190D 3E 0A       0001*M1 			LD	A, function
04190F 5B CF       0002*M1 			RST.LIL	08h
041911 32 4C 19 04 0483*       ld (@filehandle),a
041915             0484*   
041915             0485*   @read_file:
041915             0486*   ; Read a block of data from a file
041915             0487*   ;   C: Filehandle
041915             0488*   ; HLU: Pointer to where to write the data to
041915             0489*   ; DEU: Number of bytes to read
041915             0490*   ; Returns:
041915             0491*   ; DEU: Number of bytes read
041915 3A 4C 19 04 0492*       ld a,(@filehandle)
041919 4F          0493*       ld c,a
04191A 21 00 E0 B7 0494*       ld hl,filedata
04191E 11 00 20 00 0495*       ld de,8192 ; max we can read into onboard sram at one time
041922             0496*       MOSCALL mos_fread
041922 3E 1A       0001*M1 			LD	A, function
041924 5B CF       0002*M1 			RST.LIL	08h
041926             0497*   
041926             0498*   ; test de for zero bytes read
041926 21 00 00 00 0499*       ld hl,0
04192A AF          0500*       xor a ; clear carry
04192B ED 52       0501*       sbc hl,de
04192D CA 43 19 04 0502*       jp z,@close_file
041931             0503*   
041931             0504*   ; load a vdu buffer from local memory
041931             0505*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
041931 2A 91 18 04 0506*       ld hl,(bufferId0)
041935 D5          0507*       push de ; chunksize
041936 C1          0508*       pop bc
041937 11 00 E0 B7 0509*       ld de,filedata
04193B CD 97 18 04 0510*       call vdu_load_buffer
04193F             0511*   
04193F             0512*   ; read the next block
04193F C3 15 19 04 0513*       jp @read_file
041943             0514*   
041943             0515*   ; close the file
041943             0516*   @close_file:
041943 3A 4C 19 04 0517*       ld a,(@filehandle)
041947             0518*       MOSCALL mos_fclose
041947 3E 0B       0001*M1 			LD	A, function
041949 5B CF       0002*M1 			RST.LIL	08h
04194B C9          0519*       ret ; vdu_load_buffer_from_file
04194C             0520*   
04194C 00          0521*   @filehandle: db 0 ; file handle
04194D 00 00 00    0522*   @fil: dl 0 ; pointer to FIL struct
041950             0523*   
041950 00 00 00    0524*   @chunkpointer: dl 0 ; pointer to current chunk
041953             0525*   
041953             0526*   ; File information structure (FILINFO)
041953             0527*   @filinfo:
041953 00 00 00 00 0528*   @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
041957 00 00       0529*   @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
041959 00 00       0530*   @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
04195B 00          0531*   @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
04195C 00 00 00 00 0532*   @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
041969 00 00 00 00 0533*   @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041A69             0042        include "vdu_buffered_api.inc"
041A69             0001*   ; https://agonconsole8.github.io/agon-docs/vdp/Buffered-Commands-API/
041A69             0002*   
041A69             0003*   ; Command 0: Write block to a buffer
041A69             0004*   ; VDU 23, 0, &A0, bufferId; 0, length; <buffer-data>
041A69             0005*   ; inputs: hl = bufferId, bc = length of data, de = pointer to data
041A69             0006*   vdu_write_block_to_buffer:
041A69             0007*   ; back up input parameters
041A69 D5          0008*       push de ; pointer to data
041A6A C5          0009*       push bc ; length of data
041A6B             0010*   ; set up the vdu command string
041A6B 22 8B 1A 04 0011*       ld (@bufferId),hl
041A6F ED 43 8E 1A 0012*       ld (@length),bc
       04          
041A74 AF          0013*       xor a ; load buffer
041A75 32 8D 1A 04 0014*       ld (@bufferId+2),a
041A79 21 88 1A 04 0015*       ld hl,@cmd0
041A7D 01 08 00 00 0016*       ld bc,@end0-@cmd0
041A81 5B DF       0017*       rst.lil $18
041A83             0018*   ; send the buffer data
041A83 C1          0019*       pop bc ; length of data
041A84 E1          0020*       pop hl ; pointer to data (was de)
041A85 5B DF       0021*       rst.lil $18 ; send it
041A87 C9          0022*       ret
041A88             0023*   ; command string data
041A88 17 00 A0    0024*   @cmd0:      db 23,0,0xA0
041A8B 00 00       0025*   @bufferId:	dw 0x0000
041A8D 00          0026*               db 0 ; load buffer
041A8E 00 00       0027*   @length:	dw 0x0000
041A90 00          0028*   @end0:      db 0x00 ; padding
041A91             0029*   ; end vdu_write_block_to_buffer
041A91             0030*   
041A91             0031*   ; Command 1: Call a buffer
041A91             0032*   ; VDU 23, 0, &A0, bufferId; 1
041A91             0033*   ; inputs: hl = bufferId
041A91             0034*   vdu_call_buffer:
041A91 22 A9 1A 04 0035*       ld (@bufferId),hl
041A95 3E 01       0036*       ld a,1 ; call buffer
041A97 32 AB 1A 04 0037*       ld (@bufferId+2),a
041A9B 21 A6 1A 04 0038*       ld hl,@cmd
041A9F 01 06 00 00 0039*       ld bc,@end-@cmd
041AA3 5B DF       0040*       rst.lil $18
041AA5 C9          0041*       ret
041AA6 17 00 A0    0042*   @cmd:     db 23,0,0xA0
041AA9 00 00       0043*   @bufferId: dw 0x0000
041AAB 01          0044*              db 1 ; call buffer
041AAC             0045*   @end:
041AAC             0046*   ; end vdu_call_buffer
041AAC             0047*   
041AAC             0048*   ; Command 2: Clear a buffer
041AAC             0049*   ; VDU 23, 0 &A0, bufferId; 2
041AAC             0050*   ; inputs: hl = bufferId
041AAC             0051*   vdu_clear_buffer:
041AAC 22 C4 1A 04 0052*       ld (@bufferId),hl
041AB0 3E 02       0053*       ld a,2 ; clear buffer
041AB2 32 C6 1A 04 0054*       ld (@bufferId+2),a
041AB6 21 C1 1A 04 0055*       ld hl,@cmd
041ABA 01 06 00 00 0056*       ld bc,@end-@cmd
041ABE 5B DF       0057*       rst.lil $18
041AC0 C9          0058*       ret
041AC1 17 00 A0    0059*   @cmd:     db 23,0,0xA0
041AC4 00 00       0060*   @bufferId: dw 0x0000
041AC6 02          0061*              db 2 ; clear buffer
041AC7             0062*   @end:
041AC7             0063*   ; end vdu_clear_buffer
041AC7             0064*   
041AC7             0065*   ; Clear all buffers
041AC7             0066*   ; inputs: none
041AC7             0067*   vdu_clear_all_buffers:
041AC7             0068*   ; clear all buffers
041AC7 21 D2 1A 04 0069*       ld hl,@beg
041ACB 01 06 00 00 0070*       ld bc,@end-@beg
041ACF 5B DF       0071*       rst.lil $18
041AD1 C9          0072*       ret
041AD2 17 00 A0    0073*   @beg: db 23,0,$A0
041AD5 FF FF       0074*         dw -1 ; bufferId -1 (65535) means clear all buffers
041AD7 02          0075*         db 2  ; command 2: clear a buffer
041AD8             0076*   @end:
041AD8             0077*   ; end vdu_clear_all_buffers
041AD8             0078*   
041AD8             0079*   ; Command 3: Create a writeable buffer
041AD8             0080*   ; VDU 23, 0 &A0, bufferId; 3, length;
041AD8             0081*   ; inputs: hl = bufferId, bc = length
041AD8             0082*   vdu_create_writeable_buffer:
041AD8 22 F5 1A 04 0083*       ld (@bufferId),hl
041ADC ED 43 F8 1A 0084*       ld (@length),bc
       04          
041AE1 3E 03       0085*       ld a,3 ; create writeable buffer
041AE3 32 F7 1A 04 0086*       ld (@bufferId+2),a
041AE7 21 F2 1A 04 0087*       ld hl,@cmd
041AEB 01 08 00 00 0088*       ld bc,@end-@cmd
041AEF 5B DF       0089*       rst.lil $18
041AF1 C9          0090*       ret
041AF2 17 00 A0    0091*   @cmd:     db 23,0,0xA0
041AF5 00 00       0092*   @bufferId: dw 0x0000
041AF7 03          0093*              db 3 ; create writeable buffer
041AF8 00 00       0094*   @length: dw 0x0000
041AFA 00          0095*   @end:     db 0x00 ; padding
041AFB             0096*   ; end vdu_create_writeable_buffer
041AFB             0097*   
041AFB             0098*   ; Command 4: Set output stream to a buffer
041AFB             0099*   ; VDU 23, 0 &A0, bufferId; 4
041AFB             0100*   ; inputs: hl = bufferId
041AFB             0101*   vdu_set_output_stream_buffer:
041AFB 22 13 1B 04 0102*       ld (@bufferId),hl
041AFF 3E 04       0103*       ld a,4 ; set output stream to buffer
041B01 32 15 1B 04 0104*       ld (@bufferId+2),a
041B05 21 10 1B 04 0105*       ld hl,@cmd
041B09 01 06 00 00 0106*       ld bc,@end-@cmd
041B0D 5B DF       0107*       rst.lil $18
041B0F C9          0108*       ret
041B10 17 00 A0    0109*   @cmd:     db 23,0,0xA0
041B13 00 00       0110*   @bufferId: dw 0x0000
041B15 04          0111*              db 4 ; set output stream to buffer
041B16 00          0112*   @end:     db 0x00 ; padding
041B17             0113*   ; end vdu_set_output_stream_buffer
041B17             0114*   
041B17             0115*   ; Command 5: Adjust buffer contents
041B17             0116*   ; VDU 23, 0, &A0, bufferId; 5, operation, offset; [count;] <operand>, [arguments]
041B17             0117*   vdu_adjust_buffer:
041B17 C9          0118*       ret ; TODO: implement
041B18             0119*   ; end vdu_adjust_buffer
041B18             0120*   
041B18             0121*   ; Command 6: Conditionally call a buffer
041B18             0122*   ; VDU 23, 0, &A0, bufferId; 6, operation, checkBufferId; checkOffset; [arguments]
041B18             0123*   vdu_call_buffer_conditional:
041B18 C9          0124*       ret ; TODO: implement
041B19             0125*   ; end vdu_call_buffer_conditional
041B19             0126*   
041B19             0127*   ; Command 7: Jump to a buffer
041B19             0128*   ; VDU 23, 0, &A0, bufferId; 7
041B19             0129*   ; inputs: hl = bufferId
041B19             0130*   vdu_jump_to_buffer:
041B19 22 31 1B 04 0131*       ld (@bufferId),hl
041B1D 3E 07       0132*       ld a,7 ; jump to buffer
041B1F 32 33 1B 04 0133*       ld (@bufferId+2),a
041B23 21 2E 1B 04 0134*       ld hl,@cmd
041B27 01 06 00 00 0135*       ld bc,@end-@cmd
041B2B 5B DF       0136*       rst.lil $18
041B2D C9          0137*       ret
041B2E 17 00 A0    0138*   @cmd:     db 23,0,0xA0
041B31 00 00       0139*   @bufferId: dw 0x0000
041B33 07          0140*              db 7 ; jump to buffer
041B34 00          0141*   @end:     db 0x00 ; padding
041B35             0142*   ; end vdu_jump_to_buffer
041B35             0143*   
041B35             0144*   ; Command 8: Conditional Jump to a buffer
041B35             0145*   ; VDU 23, 0, &A0, bufferId; 8, operation, checkBufferId; checkOffset; [arguments]
041B35             0146*   vdu_jump_to_buffer_conditional:
041B35 C9          0147*       ret ; TODO: implement
041B36             0148*   ; end vdu_jump_to_buffer_conditional
041B36             0149*   
041B36             0150*   ; Command 9: Jump to an offset in a buffer
041B36             0151*   ; VDU 23, 0, &A0, bufferId; 9, offset; offsetHighByte, [blockNumber;]
041B36             0152*   vdu_jump_to_buffer_offset:
041B36 C9          0153*       ret ; TODO: implement
041B37             0154*   ; end vdu_jump_to_buffer_offset
041B37             0155*   
041B37             0156*   ; Command 10: Conditional jump to an offset in a buffer
041B37             0157*   ; VDU 23, 0, &A0, bufferId; 10, offset; offsetHighByte, [blockNumber;] [arguments]
041B37             0158*   vdu_jump_to_buffer_offset_conditional:
041B37 C9          0159*       ret ; TODO: implement
041B38             0160*   ; end vdu_jump_to_buffer_offset_conditional
041B38             0161*   
041B38             0162*   ; Command 11: Call buffer with an offset
041B38             0163*   ; VDU 23, 0, &A0, bufferId; 11, offset; offsetHighByte, [blockNumber;]
041B38             0164*   vdu_call_buffer_offset:
041B38 C9          0165*       ret ; TODO: implement
041B39             0166*   ; end vdu_call_buffer_offset
041B39             0167*   
041B39             0043        include "vdu_fonts.inc"
041B39             0001*   ; select font
041B39             0002*   ; inputs: hl = bufferId, a = font flags
041B39             0003*   ; Flags:
041B39             0004*   ; Bit	Description
041B39             0005*   ; 0	Adjust cursor position to ensure text baseline is aligned
041B39             0006*   ;   0: Do not adjust cursor position (best for changing font on a new line)
041B39             0007*   ;   1: Adjust cursor position (best for changing font in the middle of a line)
041B39             0008*   ; 1-7	Reserved for future use
041B39             0009*   ; VDU 23, 0, &95, 0, bufferId; flags: Select font
041B39             0010*   vdu_font_select:
041B39 22 50 1B 04 0011*       ld (@bufferId),hl
041B3D 32 52 1B 04 0012*       ld (@flags),a
041B41 21 4C 1B 04 0013*       ld hl,@cmd
041B45 01 07 00 00 0014*       ld bc,@end-@cmd
041B49 5B DF       0015*       rst.lil $18
041B4B C9          0016*       ret
041B4C 17 00 95 00 0017*   @cmd: db 23, 0, 0x95, 0
041B50 00 00       0018*   @bufferId: dw 0x0000
041B52 00          0019*   @flags: db 0x00
041B53             0020*   @end:
041B53             0021*   
041B53             0022*   ; create font from buffer
041B53             0023*   ; inputs: hl = bufferId, e = width, d = height, d = ascent, a = flags
041B53             0024*   ; VDU 23, 0, &95, 1, bufferId; width, height, ascent, flags: Create font from buffer
041B53             0025*   vdu_font_create:
041B53 22 78 1B 04 0026*       ld (@bufferId),hl
041B57 ED 53 7A 1B 0027*       ld (@width),de ; also loads height
       04          
041B5C 32 7D 1B 04 0028*       ld (@flags),a
041B60 7A          0029*       ld a,d ; height
041B61 32 7C 1B 04 0030*       ld (@ascent),a ; ascent = height
041B65             0031*   ; consolidate buffer
041B65 CD C3 18 04 0032*       call vdu_consolidate_buffer
041B69             0033*   ; create font
041B69 21 74 1B 04 0034*       ld hl,@cmd
041B6D 01 0A 00 00 0035*       ld bc,@end-@cmd
041B71 5B DF       0036*       rst.lil $18
041B73 C9          0037*       ret
041B74 17 00 95 01 0038*   @cmd: db 23, 0, 0x95, 1
041B78 00 00       0039*   @bufferId: dw 0x0000
041B7A 00          0040*   @width: db 0x00
041B7B 00          0041*   @height: db 0x00
041B7C 00          0042*   @ascent: db 0x00
041B7D 00          0043*   @flags: db 0x00
041B7E             0044*   @end:
041B7E             0045*   
041B7E             0046*   ; set or adjust font property
041B7E             0047*   ; inputs: hl = bufferId, a = field, de = value
041B7E             0048*   ; VDU 23, 0, &95, 2, bufferId; field, value;: Set or adjust font property
041B7E             0049*   vdu_font_property:
041B7E 22 9A 1B 04 0050*       ld (@bufferId),hl
041B82 32 9C 1B 04 0051*       ld (@field),a
041B86 ED 53 9D 1B 0052*       ld (@value),de
       04          
041B8B 21 96 1B 04 0053*       ld hl,@cmd
041B8F 01 09 00 00 0054*       ld bc,@end-@cmd
041B93 5B DF       0055*       rst.lil $18
041B95 C9          0056*       ret
041B96 17 00 95 02 0057*   @cmd: db 23, 0, 0x95, 2
041B9A 00 00       0058*   @bufferId: dw 0x0000
041B9C 00          0059*   @field: db 0x00
041B9D 00 00       0060*   @value: dw 0x0000
041B9F 00          0061*   @end: db 0x00 ; padding
041BA0             0062*   
041BA0             0063*   ; VDU 23, 0, &95, 3, bufferId; [<args>]: Reserved
041BA0             0064*   
041BA0             0065*   ; Clear/Delete font
041BA0             0066*   ; inputs: hl = bufferId
041BA0             0067*   ; VDU 23, 0, &95, 4, bufferId;: Clear/Delete font
041BA0             0068*   vdu_font_clear:
041BA0 22 B3 1B 04 0069*       ld (@bufferId),hl
041BA4 21 AF 1B 04 0070*       ld hl,@cmd
041BA8 01 06 00 00 0071*       ld bc,@end-@cmd
041BAC 5B DF       0072*       rst.lil $18
041BAE C9          0073*       ret
041BAF 17 00 95 04 0074*   @cmd: db 23, 0, 0x95, 4
041BB3 00 00       0075*   @bufferId: dw 0x0000
041BB5 00          0076*   @end: db 0x00 ; padding
041BB6             0077*   
041BB6             0078*   ; Copy system font to buffer
041BB6             0079*   ; inputs: hl = bufferId
041BB6             0080*   ; VDU 23, 0, &95, 5, bufferId;: Copy system font to buffer
041BB6             0081*   vdu_font_copy_system:
041BB6 22 C9 1B 04 0082*       ld (@bufferId),hl
041BBA 21 C5 1B 04 0083*       ld hl,@cmd
041BBE 01 06 00 00 0084*       ld bc,@end-@cmd
041BC2 5B DF       0085*       rst.lil $18
041BC4 C9          0086*       ret
041BC5 17 00 95 05 0087*   @cmd: db 23, 0, 0x95, 5
041BC9 00 00       0088*   @bufferId: dw 0x0000
041BCB 00          0089*   @end: db 0x00 ; padding
041BCC             0044        include "vdu_plot.inc"
041BCC             0001*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
041BCC             0002*   ; PLOT code 	(Decimal) 	Effect
041BCC             0003*   ; &00-&07 	0-7 	Solid line, includes both ends
041BCC             0004*   plot_sl_both: equ 0x00
041BCC             0005*   
041BCC             0006*   ; &08-&0F 	8-15 	Solid line, final point omitted
041BCC             0007*   plot_sl_first: equ 0x08
041BCC             0008*   
041BCC             0009*   ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
041BCC             0010*   ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
041BCC             0011*   
041BCC             0012*   ; &20-&27 	32-39 	Solid line, first point omitted
041BCC             0013*   plot_sl_last: equ 0x20
041BCC             0014*   
041BCC             0015*   ; &28-&2F 	40-47 	Solid line, both points omitted
041BCC             0016*   plot_sl_none: equ 0x28
041BCC             0017*   
041BCC             0018*   ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
041BCC             0019*   ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
041BCC             0020*   
041BCC             0021*   ; &40-&47 	64-71 	Point plot
041BCC             0022*   plot_pt: equ 0x40
041BCC             0023*   
041BCC             0024*   ; &48-&4F 	72-79 	Line fill left and right to non-background §§
041BCC             0025*   plot_lf_lr_non_bg: equ 0x48
041BCC             0026*   
041BCC             0027*   ; &50-&57 	80-87 	Triangle fill
041BCC             0028*   plot_tf: equ 0x50
041BCC             0029*   
041BCC             0030*   ; &58-&5F 	88-95 	Line fill right to background §§
041BCC             0031*   plot_lf_r_bg: equ 0x58
041BCC             0032*   
041BCC             0033*   ; &60-&67 	96-103 	Rectangle fill
041BCC             0034*   plot_rf: equ 0x60
041BCC             0035*   
041BCC             0036*   ; &68-&6F 	104-111 	Line fill left and right to foreground §§
041BCC             0037*   plot_lf_lr_fg: equ 0x60
041BCC             0038*   
041BCC             0039*   ; &70-&77 	112-119 	Parallelogram fill
041BCC             0040*   plot_pf: equ 0x70
041BCC             0041*   
041BCC             0042*   ; &78-&7F 	120-127 	Line fill right to non-foreground §§
041BCC             0043*   plot_lf_r_non_fg: equ 0x78
041BCC             0044*   
041BCC             0045*   ; &80-&87 	128-135 	Not supported (Flood until non-background)
041BCC             0046*   ; &88-&8F 	136-143 	Not supported (Flood until foreground)
041BCC             0047*   
041BCC             0048*   ; &90-&97 	144-151 	Circle outline
041BCC             0049*   plot_co: equ 0x90
041BCC             0050*   
041BCC             0051*   ; &98-&9F 	152-159 	Circle fill
041BCC             0052*   plot_cf: equ 0x98
041BCC             0053*   
041BCC             0054*   ; &A0-&A7 	160-167 	Not supported (Circular arc)
041BCC             0055*   ; &A8-&AF 	168-175 	Not supported (Circular segment)
041BCC             0056*   ; &B0-&B7 	176-183 	Not supported (Circular sector)
041BCC             0057*   
041BCC             0058*   ; &B8-&BF 	184-191 	Rectangle copy/move
041BCC             0059*   plot_rcm: equ 0xB8
041BCC             0060*   
041BCC             0061*   ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
041BCC             0062*   ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
041BCC             0063*   ; &D0-&D7 	208-215 	Not defined
041BCC             0064*   ; &D8-&DF 	216-223 	Not defined
041BCC             0065*   ; &E0-&E7 	224-231 	Not defined
041BCC             0066*   
041BCC             0067*   ; &E8-&EF 	232-239 	Bitmap plot §
041BCC             0068*   plot_bmp: equ 0xE8
041BCC             0069*   
041BCC             0070*   ; &F0-&F7 	240-247 	Not defined
041BCC             0071*   ; &F8-&FF 	248-255 	Not defined
041BCC             0072*   
041BCC             0073*   ; § Support added in Agon Console8 VDP 2.1.0 §§ Support added in
041BCC             0074*   ; Agon Console8 VDP 2.2.0
041BCC             0075*   
041BCC             0076*   ; Within each group of eight plot codes, the effects are as follows:
041BCC             0077*   ; Plot code 	Effect
041BCC             0078*   ; 0 	Move relative
041BCC             0079*   mv_rel: equ 0
041BCC             0080*   
041BCC             0081*   ; 1 	Plot relative in current foreground colour
041BCC             0082*   dr_rel_fg: equ 1
041BCC             0083*   
041BCC             0084*   ; 2 	Not supported (Plot relative in logical inverse colour)
041BCC             0085*   ; 3 	Plot relative in current background colour
041BCC             0086*   dr_rel_bg: equ 3
041BCC             0087*   
041BCC             0088*   ; 4 	Move absolute
041BCC             0089*   mv_abs: equ 4
041BCC             0090*   
041BCC             0091*   ; 5 	Plot absolute in current foreground colour
041BCC             0092*   dr_abs_fg: equ 5
041BCC             0093*   
041BCC             0094*   ; 6 	Not supported (Plot absolute in logical inverse colour)
041BCC             0095*   ; 7 	Plot absolute in current background colour
041BCC             0096*   dr_abs_bg: equ 7
041BCC             0097*   
041BCC             0098*   ; Codes 0-3 use the position data provided as part of the command
041BCC             0099*   ; as a relative position, adding the position given to the current
041BCC             0100*   ; graphical cursor position. Codes 4-7 use the position data provided
041BCC             0101*   ; as part of the command as an absolute position, setting the current
041BCC             0102*   ; graphical cursor position to the position given.
041BCC             0103*   
041BCC             0104*   ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
041BCC             0105*   ; current pixel colour. These operations cannot currently be supported
041BCC             0106*   ; by the graphics system the Agon VDP uses, so these codes are not
041BCC             0107*   ; supported. Support for these codes may be added in a future version
041BCC             0108*   ; of the VDP firmware.
041BCC             0109*   
041BCC             0110*   ; 16 colour palette constants
041BCC             0111*   c_black: equ 0
041BCC             0112*   c_red_dk: equ 1
041BCC             0113*   c_green_dk: equ 2
041BCC             0114*   c_yellow_dk: equ 3
041BCC             0115*   c_blue_dk: equ 4
041BCC             0116*   c_magenta_dk: equ 5
041BCC             0117*   c_cyan_dk: equ 6
041BCC             0118*   c_grey: equ 7
041BCC             0119*   c_grey_dk: equ 8
041BCC             0120*   c_red: equ 9
041BCC             0121*   c_green: equ 10
041BCC             0122*   c_yellow: equ 11
041BCC             0123*   c_blue: equ 12
041BCC             0124*   c_magenta: equ 13
041BCC             0125*   c_cyan: equ 14
041BCC             0126*   c_white: equ 15
041BCC             0127*   
041BCC             0128*   ; VDU 25, mode, x; y;: PLOT command
041BCC             0129*   ; inputs: a=mode, bc=x0, de=y0
041BCC             0130*   vdu_plot:
041BCC 32 E6 1B 04 0131*       ld (@mode),a
041BD0 ED 43 E7 1B 0132*       ld (@x0),bc
       04          
041BD5 ED 53 E9 1B 0133*       ld (@y0),de
       04          
041BDA 21 E5 1B 04 0134*   	ld hl,@cmd
041BDE 01 06 00 00 0135*   	ld bc,@end-@cmd
041BE2 5B DF       0136*   	rst.lil $18
041BE4 C9          0137*   	ret
041BE5 19          0138*   @cmd:   db 25
041BE6 00          0139*   @mode:  db 0
041BE7 00 00       0140*   @x0: 	dw 0
041BE9 00 00       0141*   @y0: 	dw 0
041BEB 00          0142*   @end:   db 0 ; extra byte to soak up deu
041BEC             0143*   
041BEC             0144*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
041BEC             0145*   ; &E8-&EF 	232-239 	Bitmap plot §
041BEC             0146*   ; VDU 25, mode, x; y;: PLOT command
041BEC             0147*   ; inputs: bc=x0, de=y0
041BEC             0148*   ; prerequisites: vdu_buff_select
041BEC             0149*   vdu_plot_bmp:
041BEC ED 43 03 1C 0150*       ld (@x0),bc
       04          
041BF1 ED 53 05 1C 0151*       ld (@y0),de
       04          
041BF6 21 01 1C 04 0152*   	ld hl,@cmd
041BFA 01 06 00 00 0153*   	ld bc,@end-@cmd
041BFE 5B DF       0154*   	rst.lil $18
041C00 C9          0155*   	ret
041C01 19          0156*   @cmd:   db 25
041C02 ED          0157*   @mode:  db plot_bmp+dr_abs_fg ; 0xED
041C03 00 00       0158*   @x0: 	dw 0x0000
041C05 00 00       0159*   @y0: 	dw 0x0000
041C07 00          0160*   @end:   db 0x00 ; padding
041C08             0161*   
041C08             0162*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
041C08             0163*   ; &E8-&EF 	232-239 	Bitmap plot §
041C08             0164*   ; VDU 25, mode, x; y;: PLOT command
041C08             0165*   ; inputs: bc=x0, de=y0
041C08             0166*   ; USING 16.8 FIXED POINT COORDINATES
041C08             0167*   ; inputs: ub.c is x coordinate, ud.e is y coordinate
041C08             0168*   ;   the fractional portiion of the inputs are truncated
041C08             0169*   ;   leaving only the 16-bit integer portion
041C08             0170*   ; prerequisites: vdu_buff_select
041C08             0171*   vdu_plot_bmp168:
041C08             0172*   ; populate in the reverse of normal to keep the
041C08             0173*   ; inputs from stomping on each other
041C08 ED 53 26 1C 0174*       ld (@y0-1),de
       04          
041C0D ED 43 24 1C 0175*       ld (@x0-1),bc
       04          
041C12 3E ED       0176*       ld a,plot_bmp+dr_abs_fg ; 0xED
041C14 32 24 1C 04 0177*       ld (@mode),a ; restore the mode byte that got stomped on by bcu
041C18 21 23 1C 04 0178*   	ld hl,@cmd
041C1C 01 06 00 00 0179*   	ld bc,@end-@cmd
041C20 5B DF       0180*   	rst.lil $18
041C22 C9          0181*   	ret
041C23 19          0182*   @cmd:   db 25
041C24 ED          0183*   @mode:  db plot_bmp+dr_abs_fg ; 0xED
041C25 00 00       0184*   @x0: 	dw 0x0000
041C27 00 00       0185*   @y0: 	dw 0x0000
041C29             0186*   @end:  ; no padding required b/c we shifted de right
041C29             0187*   
041C29             0188*   ; draw a filled rectangle
041C29             0189*   vdu_plot_rf:
041C29 ED 43 50 1C 0190*       ld (@x0),bc
       04          
041C2E ED 53 52 1C 0191*       ld (@y0),de
       04          
041C33 DD 22 56 1C 0192*       ld (@x1),ix
       04          
041C38 FD 22 58 1C 0193*       ld (@y1),iy
       04          
041C3D 3E 19       0194*       ld a,25 ; we have to reload the 2nd plot command
041C3F 32 54 1C 04 0195*       ld (@cmd1),a ; because the 24-bit y0 load stomped on it
041C43 21 4E 1C 04 0196*   	ld hl,@cmd0
041C47 01 0C 00 00 0197*   	ld bc,@end-@cmd0
041C4B 5B DF       0198*   	rst.lil $18
041C4D C9          0199*       ret
041C4E 19          0200*   @cmd0:  db 25 ; plot
041C4F 04          0201*   @arg0:  db plot_sl_both+mv_abs
041C50 00 00       0202*   @x0:    dw 0x0000
041C52 00 00       0203*   @y0:    dw 0x0000
041C54 19          0204*   @cmd1:  db 25 ; plot
041C55 65          0205*   @arg1:  db plot_rf+dr_abs_fg
041C56 00 00       0206*   @x1:    dw 0x0000
041C58 00 00       0207*   @y1:    dw 0x0000
041C5A 00          0208*   @end:   db 0x00 ; padding
041C5B             0209*   
041C5B             0210*   ; draw a filled circle
041C5B             0211*   vdu_plot_cf:
041C5B ED 43 82 1C 0212*       ld (@x0),bc
       04          
041C60 ED 53 84 1C 0213*       ld (@y0),de
       04          
041C65 DD 22 88 1C 0214*       ld (@x1),ix
       04          
041C6A FD 22 8A 1C 0215*       ld (@y1),iy
       04          
041C6F 3E 19       0216*       ld a,25 ; we have to reload the 2nd plot command
041C71 32 86 1C 04 0217*       ld (@cmd1),a ; because the 24-bit y0 load stomped on it
041C75 21 80 1C 04 0218*   	ld hl,@cmd0
041C79 01 0C 00 00 0219*   	ld bc,@end-@cmd0
041C7D 5B DF       0220*   	rst.lil $18
041C7F C9          0221*       ret
041C80 19          0222*   @cmd0:  db 25 ; plot
041C81 04          0223*   @arg0:  db plot_sl_both+mv_abs
041C82 00 00       0224*   @x0:    dw 0x0000
041C84 00 00       0225*   @y0:    dw 0x0000
041C86 19          0226*   @cmd1:  db 25 ; plot
041C87 9D          0227*   @arg1:  db plot_cf+dr_abs_fg
041C88 00 00       0228*   @x1:    dw 0x0000
041C8A 00 00       0229*   @y1:    dw 0x0000
041C8C 00          0230*   @end:   db 0x00 ; padding
041C8D             0045        include "vdu_sound.inc"
041C8D             0001*   ; enable enough additional channels so that total enabled = max_channels
041C8D             0002*   ; inputs: max_channels set
041C8D             0003*   ; returns: nothing
041C8D             0004*   ; destroys: af, bc, hl
041C8D             0005*   vdu_enable_channels:
041C8D 3E 01       0006*       ld a,max_channels
041C8F D6 03       0007*       sub 3 ; subtract number of default channels already enabled
041C91 F2 98 1C 04 0008*       jp p,@loop
041C95 C9          0009*       ret
041C96 3E 03       0010*       ld a,3 ; first non-default channel
041C98             0011*   @loop:
041C98 32 B3 1C 04 0012*       ld (@channel),a
041C9C 21 B0 1C 04 0013*       ld hl,@beg
041CA0 01 05 00 00 0014*       ld bc,@end-@beg
041CA4 F5          0015*       push af
041CA5 5B DF       0016*       rst.lil $18
041CA7 F1          0017*       pop af
041CA8 3C          0018*       inc a
041CA9 FE 01       0019*       cp max_channels
041CAB C2 98 1C 04 0020*       jp nz,@loop
041CAF C9          0021*       ret
041CB0             0022*   @beg:
041CB0 17 00 85    0023*               db 23, 0, $85
041CB3 00          0024*   @channel:   db 0
041CB4 08          0025*               db 8 ; command 8: enable channel
041CB5             0026*   @end:
041CB5             0027*   
041CB5             0028*   ; disable all but the three default sound channels
041CB5             0029*   ; inputs: max_channels set
041CB5             0030*   ; outputs: none
041CB5             0031*   ; destroys: ah,hl,bc
041CB5             0032*   vdu_disable_channels:
041CB5 3E 01       0033*       ld a,max_channels
041CB7 D6 03       0034*       sub 3 ; subtract number of default channels already enabled
041CB9 F2 C0 1C 04 0035*       jp p,@loop
041CBD C9          0036*       ret
041CBE 3E 03       0037*       ld a,3 ; first non-default channel
041CC0             0038*   @loop:
041CC0 32 DB 1C 04 0039*       ld (@channel),a
041CC4 21 D8 1C 04 0040*       ld hl,@beg
041CC8 01 05 00 00 0041*       ld bc,@end-@beg
041CCC F5          0042*       push af
041CCD 5B DF       0043*       rst.lil $18
041CCF F1          0044*       pop af
041CD0 3C          0045*       inc a
041CD1 FE 01       0046*       cp max_channels
041CD3 C2 C0 1C 04 0047*       jp nz,@loop
041CD7 C9          0048*       ret
041CD8             0049*   @beg:
041CD8 17 00 85    0050*       db 23, 0, $85
041CDB 00          0051*   @channel: db 0
041CDC 09          0052*       db 9 ; command 9: disable channel
041CDD             0053*   @end:
041CDD             0054*   
041CDD             0055*   
041CDD             0056*   ; ############################################################
041CDD             0057*   ; VDU SOUND API
041CDD             0058*   ; ############################################################
041CDD             0059*   ; Command 0: Play note
041CDD             0060*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
041CDD             0061*       MACRO PLAY_NOTE channel, volume, frequency, duration
041CDD             0062*       ld hl, @PLAY_NOTE_CMD        ; Start of command block
041CDD             0063*       ld bc, @PLAY_NOTE_END - @PLAY_NOTE_CMD  ; Command block size
041CDD             0064*       rst.lil $18
041CDD             0065*       jr @PLAY_NOTE_END
041CDD             0066*   @PLAY_NOTE_CMD:  db 23, 0, 0x85               ; Command header
041CDD             0067*                    db channel                  ; Channel, 0 (commented out)
041CDD             0068*                    db 0                        ; Play note command
041CDD             0069*                    db volume                   ; Volume
041CDD             0070*                    dw frequency                ; Frequency
041CDD             0071*                    dw duration                 ; Duration
041CDD             0072*   @PLAY_NOTE_END:
041CDD             0073*       ENDMACRO
041CDD             0074*   
041CDD             0075*       MACRO MUTE_CHANNEL channel
041CDD             0076*       ld hl, @MUTE_CHANNEL_CMD     ; Start of command block
041CDD             0077*       ld bc, @MUTE_CHANNEL_END - @MUTE_CHANNEL_CMD  ; Command block size
041CDD             0078*       rst.lil $18
041CDD             0079*       jr @MUTE_CHANNEL_END
041CDD             0080*   @MUTE_CHANNEL_CMD: db 23, 0, 0x85             ; Command header
041CDD             0081*                      db channel                ; Channel, 0 (commented out)
041CDD             0082*                      db 2                      ; Set volume command
041CDD             0083*                      db 0                      ; Volume (mute)
041CDD             0084*   @MUTE_CHANNEL_END:
041CDD             0085*       ENDMACRO
041CDD             0086*   
041CDD             0087*   ; inputs: c = channel, b = volume, hl = frequency; de = duration;
041CDD             0088*   vdu_play_note:
041CDD 79          0089*       ld a,c
041CDE 32 FE 1C 04 0090*       ld (@channel),a
041CE2 78          0091*       ld a,b
041CE3 32 00 1D 04 0092*       ld (@volume),a
041CE7 22 01 1D 04 0093*       ld (@frequency),hl
041CEB ED 53 03 1D 0094*       ld (@duration),de
       04          
041CF0 21 FB 1C 04 0095*       ld hl,@cmd
041CF4 01 0A 00 00 0096*       ld bc,@end-@cmd
041CF8 5B DF       0097*       rst.lil $18
041CFA C9          0098*       ret
041CFB 17 00 85    0099*   @cmd:       db 23, 0, 0x85
041CFE 00          0100*   @channel:   db 0x00
041CFF 00          0101*               db 0x00 ; play note command
041D00 00          0102*   @volume:    db 0x00
041D01 00 00       0103*   @frequency: dw 0x0000
041D03 00 00       0104*   @duration:  dw 0x0000
041D05 00          0105*   @end:       db 0x00 ; padding
041D06             0106*   
041D06             0107*   ; Command 1: Status
041D06             0108*   ; VDU 23, 0, &85, channel, 1
041D06             0109*   ; inputs: a = channel
041D06             0110*   ; Returns a bit mask indicating the status of the specified channel, or 255 if the channel is not valid, or has been disabled. The bit mask is as follows:
041D06             0111*   ; Bit 	Name 	Meaning
041D06             0112*   ; 0 	Active 	When set this indicates the channel is in use (has an active waveform)
041D06             0113*   ; 1 	Playing 	Indicates the channel is actively playing a note, and thus will reject calls to play a new note
041D06             0114*   ; 2 	Indefinite 	Set if the channel is playing an indefinite duration note
041D06             0115*   ; 3 	Has Volume Envelope 	Set if the channel has a volume envelope
041D06             0116*   ; 4 	Has Frequency Envelope 	Set if the channel has a frequency envelope
041D06             0117*   
041D06             0118*   ; Bits 5-7 are reserved for future use and, for enabled channels, will currently always be zero.
041D06             0119*   vdu_channel_status:
041D06 32 18 1D 04 0120*       ld (@channel),a
041D0A 21 15 1D 04 0121*       ld hl,@cmd
041D0E 01 05 00 00 0122*       ld bc,@end-@cmd
041D12 5B DF       0123*       rst.lil $18
041D14 C9          0124*       ret
041D15 17 00 85    0125*   @cmd:       db 23, 0, 0x85
041D18 00          0126*   @channel:   db 0x00
041D19 01          0127*               db 0x01 ; get channel status command
041D1A             0128*   @end:
041D1A             0129*   
041D1A             0130*   ; VDU 23, 0, &85, channel, 2, volume
041D1A             0131*   ; inputs: c = channel, b = volume
041D1A             0132*   ; Sets the volume of the specified channel. The volume is a value from 0 to 127, where 0 is silent and 127 is full volume. Values over 127 will be treated as 127 (with one exception described later).
041D1A             0133*   
041D1A             0134*   ; Specifying a channel of -1 (or 255) will set the global sound system volume level. (Requires Console8 VDP 2.5.0 or later.)
041D1A             0135*   
041D1A             0136*   ; Using this command provides more direct control over a channel than the play note command. It can be used to adjust the volume of a channel that is already playing a note.
041D1A             0137*   vdu_channel_volume:
041D1A 79          0138*       ld a,c
041D1B 32 32 1D 04 0139*       ld (@channel),a
041D1F 78          0140*       ld a,b
041D20 32 34 1D 04 0141*       ld (@volume),a
041D24 21 2F 1D 04 0142*       ld hl,@cmd
041D28 01 06 00 00 0143*       ld bc,@end-@cmd
041D2C 5B DF       0144*       rst.lil $18
041D2E C9          0145*       ret
041D2F 17 00 85    0146*   @cmd:       db 23, 0, 0x85
041D32 00          0147*   @channel:   db 0x00
041D33 02          0148*               db 0x02 ; set volume command
041D34 00          0149*   @volume:    db 0x00
041D35             0150*   @end:
041D35             0151*   
041D35             0152*   ; VDU 23, 0, &85, channel, 3, frequency;
041D35             0153*   
041D35             0154*   ; Sets the frequency of the specified channel. The frequency is a 16-bit value specifying in Hz the frequency of the note to be played.
041D35             0155*   
041D35             0156*   ; Using this command provides more direct control over a channel than the play note command. It can be used to adjust the frequency of a channel that is already playing a note.
041D35             0157*   
041D35             0158*   ; Returns 1 on success, 0 for failure.
041D35             0159*   vdu_channel_frequency:
041D35 79          0160*       ld a,c
041D36 32 4D 1D 04 0161*       ld (@channel),a
041D3A ED 53 4F 1D 0162*       ld (@frequency),de
       04          
041D3F 21 4A 1D 04 0163*       ld hl,@cmd
041D43 01 07 00 00 0164*       ld bc,@end-@cmd
041D47 5B DF       0165*       rst.lil $18
041D49 C9          0166*       ret
041D4A 17 00 85    0167*   @cmd:       db 23, 0, 0x85
041D4D 00          0168*   @channel:   db 0x00
041D4E 03          0169*               db 0x03 ; set frequency command
041D4F 00 00       0170*   @frequency: dw 0x0000
041D51 00          0171*   @end:       db 0x00 ; padding
041D52             0172*   
041D52             0173*   
041D52             0174*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
041D52             0175*   ; inputs: c = channel, b = waveformOrSample, [hl = bufferId]
041D52             0176*   ; Sets the waveform type for a channel to use. The waveformOrSample value is a single byte treated as a signed value.
041D52             0177*   
041D52             0178*   ; Using a negative value for the waveform indicates that a sample should be used instead. For more information see the documentation for the sample command.
041D52             0179*   
041D52             0180*   ; By default a channel is set to use waveform 0 (square wave).
041D52             0181*   
041D52             0182*   ; Valid waveform values are as follows:
041D52             0183*   ; Value 	Waveform
041D52             0184*   ; 0 	Square wave
041D52             0185*   ; 1 	Triangle wave
041D52             0186*   ; 2 	Sawtooth wave
041D52             0187*   ; 3 	Sine wave
041D52             0188*   ; 4 	Noise (simple white noise with no frequency support)
041D52             0189*   ; 5 	VIC Noise (emulates a VIC6561; supports frequency)
041D52             0190*   ; 8 	Sample (specifying a 16-bit buffer ID for sample data)
041D52             0191*   
041D52             0192*   vdu_channel_waveform:
041D52 79          0193*       ld a,c
041D53 32 78 1D 04 0194*       ld (@channel),a
041D57 78          0195*       ld a,b
041D58 32 7A 1D 04 0196*       ld (@waveform),a
041D5C FE 08       0197*       cp 8 ; check if the waveform is a sample
041D5E 28 06       0198*       jr z, @sample
041D60 01 06 00 00 0199*       ld bc,@bufferId-@cmd
041D64 18 08       0200*       jr @sendToVdu
041D66             0201*   @sample:
041D66 22 7B 1D 04 0202*       ld (@bufferId),hl
041D6A 01 08 00 00 0203*       ld bc,@end-@cmd
041D6E             0204*   @sendToVdu:
041D6E 21 75 1D 04 0205*       ld hl,@cmd
041D72 5B DF       0206*       rst.lil $18
041D74 C9          0207*       ret
041D75 17 00 85    0208*   @cmd:       db 23, 0, 0x85
041D78 00          0209*   @channel:   db 0x00
041D79 04          0210*               db 0x04 ; set waveform command
041D7A 00          0211*   @waveform:  db 0x00
041D7B 00 00       0212*   @bufferId:  dw 0x0000
041D7D 00          0213*   @end:       db 0x00 ; padding
041D7E             0214*   
041D7E             0215*   ; VDU 23, 0, &85, channel (ignored), 5, 2, bufferId; format, [sampleRate;]
041D7E             0216*   ; inputs: hl = bufferId; a = format, de = sample rate in Hz
041D7E             0217*   ; The format is a single byte giving the format of the sample data. The following formats are supported:
041D7E             0218*   ; Value	Description
041D7E             0219*   ; 0	8-bit signed
041D7E             0220*   ; 1	8-bit unsigned
041D7E             0221*   ; The format value can also have modifier bits set to modify the behaviour of the sample. The following modifier bits are supported:
041D7E             0222*   ; Value	Description
041D7E             0223*   ; 8	sample rate is sent in the next 16-bits
041D7E             0224*   ; 16	sample is tuneable
041D7E             0225*   ; The default sample rate for samples on the VDP is 16kHz (actually 16.384kHz to be precise).
041D7E             0226*   vdu_buffer_to_sound:
041D7E 22 9E 1D 04 0227*       ld (@bufferId),hl
041D82 C6 08       0228*       add a,8 ; modify format byte to indicate sample rate argument is given
041D84 32 A0 1D 04 0229*       ld (@format),a
041D88 ED 53 A1 1D 0230*       ld (@sampleRate),de
       04          
041D8D 21 98 1D 04 0231*       ld hl,@cmd
041D91 01 0B 00 00 0232*       ld bc,@end-@cmd
041D95 5B DF       0233*       rst.lil $18
041D97 C9          0234*       ret
041D98 17 00 85    0235*   @cmd:       db 23, 0, 0x85
041D9B 00          0236*   @channel:   db 0x00 ; ignored
041D9C 05          0237*               db 0x05 ; buffer to sound command
041D9D 02          0238*               db 0x02 ; command 2 create sample
041D9E 00 00       0239*   @bufferId:  dw 0x0000
041DA0 00          0240*   @format:    db 0x00
041DA1 00 00       0241*   @sampleRate: dw 0x0000
041DA3 00          0242*   @end:       db 0x00 ; padding
041DA4             0243*   
041DA4             0244*   ; Command 13: Set sample rate
041DA4             0245*   ; VDU 23, 0, &85, channel, 13, sampleRate;
041DA4             0246*   ; inputs: c = channel, hl = sampleRate (Hz)
041DA4             0247*   vdu_set_sample_rate:
041DA4 79          0248*       ld a,c
041DA5 32 BB 1D 04 0249*       ld (@channel),a
041DA9 22 BD 1D 04 0250*       ld (@sampleRate),hl
041DAD 21 B8 1D 04 0251*       ld hl,@cmd
041DB1 01 07 00 00 0252*       ld bc,@end-@cmd
041DB5 5B DF       0253*       rst.lil $18
041DB7 C9          0254*       ret
041DB8 17 00 85    0255*   @cmd:       db 23, 0, 0x85
041DBB 00          0256*   @channel:   db 0x00
041DBC 0D          0257*               db 13 ; set sample rate command
041DBD 00 00       0258*   @sampleRate: dw 0x0000
041DBF 00          0259*   @end:       db 0x00 ; padding
041DC0             0260*   
041DC0             0261*   ; load a sound file to a buffer
041DC0             0262*   ; inputs: hl = bufferId ; de = sampleRate in Hz ; iy = pointer to filename
041DC0             0263*   vdu_load_sfx:
041DC0             0264*   ; back up input parameters
041DC0 E5          0265*       push hl ; bufferId
041DC1 D5          0266*       push de ; sample rate
041DC2             0267*   ; load the sound
041DC2 CD 00 19 04 0268*       call vdu_load_buffer_from_file
041DC6             0269*   ; now make the buffer a sound sample
041DC6 D1          0270*       pop de ; sample rate
041DC7 E1          0271*       pop hl ; bufferId
041DC8 AF          0272*       xor a ; zero is the magic number for mono 8-bit signed PCM
041DC9 CD 7E 1D 04 0273*       call vdu_buffer_to_sound
041DCD C9          0274*       ret
041DCE             0275*   
041DCE             0276*   
041DCE 00          0277*   last_channel: db 0
041DCF             0278*   max_channels: equ 1
041DCF             0279*   
041DCF             0280*   ; play a sound effect from an already loaded buffer
041DCF             0281*   ; inputs: hl = bufferId ; bc = duration in milliseconds
041DCF             0282*   vdu_play_sfx:
041DCF 22 07 1E 04 0283*       ld (@bufferId),hl
041DD3 ED 43 11 1E 0284*       ld (@duration),bc
       04          
041DD8 3E 17       0285*       ld a,23
041DDA 32 09 1E 04 0286*       ld (@bufferId+2),a
041DDE 3A CE 1D 04 0287*       ld a,(last_channel)
041DE2 3C          0288*       inc a
041DE3             0289*       ; and 31 ; modulo 32
041DE3 FE 01       0290*       cp max_channels
041DE5 C2 EA 1D 04 0291*       jp nz,@load_channel
041DE9 AF          0292*       xor a
041DEA             0293*   @load_channel:
041DEA 32 CE 1D 04 0294*       ld (last_channel),a
041DEE 32 04 1E 04 0295*       ld (@channel0),a
041DF2 32 0C 1E 04 0296*       ld (@channel1),a
041DF6 21 01 1E 04 0297*       ld hl, @sample
041DFA 01 12 00 00 0298*       ld bc, @sample_end - @sample
041DFE 5B DF       0299*       rst.lil $18
041E00 C9          0300*       ret
041E01             0301*   @sample:
041E01             0302*   ; Command 4: Set waveform
041E01             0303*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
041E01 17 00 85    0304*       .db 23,0,$85                        ; do sound
041E04             0305*   @channel0:
041E04 00 04 08    0306*       .db 0,4,8 ; channel, command, waveform
041E07             0307*   @bufferId:
041E07 00 00       0308*       .dw 0x0000
041E09             0309*   ; Command 0: Play note
041E09             0310*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
041E09 17 00 85    0311*       .db 23,0,$85                        ; do sound
041E0C             0312*   @channel1:
041E0C 00 00 7F    0313*       .db 0,0,127                ; channel, volume
041E0F 00 00       0314*       .dw 0
041E11             0315*   @duration:                              ; freq (tuneable samples only)
041E11 00 00       0316*       .dw 0x0000                        ; duration
041E13             0317*   @sample_end:
041E13 00          0318*       .db 0x00 ; padding
041E14             0319*   
041E14             0320*   ; inputs: c = channel, b = volume, de = sample rate; hl = bufferId;
041E14             0321*   vdu_play_sample:
041E14             0322*       ; populate input parameters
041E14 79          0323*       ld a,c
041E15 32 47 1E 04 0324*       ld (@channel0),a
041E19 32 4F 1E 04 0325*       ld (@channel1),a
041E1D 32 56 1E 04 0326*       ld (@channel2),a
041E21 78          0327*       ld a,b
041E22 32 58 1E 04 0328*       ld (@volume),a
041E26 ED 53 51 1E 0329*       ld (@sampleRate),de
       04          
041E2B 22 4A 1E 04 0330*       ld (@bufferId),hl
041E2F 3E 17       0331*       ld a,23
041E31 32 4C 1E 04 0332*       ld (@cmd1),a
041E35 32 53 1E 04 0333*       ld (@cmd2),a
041E39             0334*       ; prep the vdu command string
041E39 21 44 1E 04 0335*       ld hl, @cmd0
041E3D 01 19 00 00 0336*       ld bc, @end - @cmd0
041E41 5B DF       0337*       rst.lil $18
041E43 C9          0338*       ret
041E44             0339*   ; set waveform command
041E44 17 00 85    0340*   @cmd0:       db 23, 0, 0x85
041E47 00          0341*   @channel0:   db 0x00
041E48 04          0342*                db 0x04 ; set waveform command
041E49 08          0343*   @waveform:   db 0x08 ; sample
041E4A 00 00       0344*   @bufferId:   dw 0x0000
041E4C             0345*   ; set sample rate command
041E4C 17 00 85    0346*   @cmd1:       db 23, 0, 0x85
041E4F 00          0347*   @channel1:   db 0x00
041E50 0D          0348*               db 13 ; set sample rate command
041E51 00 00       0349*   @sampleRate: dw 0x0000
041E53             0350*   ; play note command
041E53 17 00 85    0351*   @cmd2:       db 23, 0, 0x85
041E56 00          0352*   @channel2:   db 0x00
041E57 00          0353*                db 0x00 ; play note command
041E58 00          0354*   @volume:     db 0x00
041E59 00 00       0355*   @frequency:  dw 0x00 ; no effect unless buffer has been set to tuneable sample
041E5B 00 00       0356*   @duration:   dw 0x0000 ; milliseconds: set to -1 to loop indefinitely, 0 to play full duration once
041E5D 00          0357*   @end:        db 0x00 ; padding
041E5E             0046    
041E5E             0047    ; APPLICATION INCLUDES
041E5E             0048        include "layout.inc"
041E5E             0001*   text_right: equ 63       ; 64 columns, zero-based
041E5E             0002*   text_bottom: equ 47      ; 48 rows, zero-based
041E5E             0003*   
041E5E             0004*   ; set text viewport for current playing song
041E5E             0005*   vp_now_playing_left: equ 0
041E5E             0006*   vp_now_playing_top: equ 0
041E5E             0007*   vp_now_playing_right: equ text_right
041E5E             0008*   vp_now_playing_bottom: equ vp_now_playing_top+1
041E5E             0009*   
041E5E             0010*   vp_now_playing:
041E5E 0E 00       0011*       ld c, vp_now_playing_left
041E60 16 00       0012*       ld d, vp_now_playing_top
041E62 1E 3F       0013*       ld e, vp_now_playing_right
041E64 06 01       0014*       ld b, vp_now_playing_bottom
041E66 CD 4B 17 04 0015*       call vdu_set_txt_viewport
041E6A C9          0016*       ret
041E6B             0017*   ; end vp_now_playing
041E6B             0018*   
041E6B             0019*   ; set text viewport for playing breadcrumbs
041E6B             0020*   vp_breadcrumbs_left: equ 0
041E6B             0021*   vp_breadcrumbs_top: equ 1
041E6B             0022*   vp_breadcrumbs_right: equ text_right
041E6B             0023*   vp_breadcrumbs_bottom: equ vp_breadcrumbs_top
041E6B             0024*   
041E6B             0025*   vp_breadcrumbs:
041E6B 0E 00       0026*       ld c, vp_breadcrumbs_left
041E6D 16 01       0027*       ld d, vp_breadcrumbs_top
041E6F 1E 3F       0028*       ld e, vp_breadcrumbs_right
041E71 06 01       0029*       ld b, vp_breadcrumbs_bottom
041E73 CD 4B 17 04 0030*       call vdu_set_txt_viewport
041E77 C9          0031*       ret
041E78             0032*   ; end vp_breadcrumbs
041E78             0033*   
041E78             0034*   ; set text viewport for directory listing
041E78             0035*   vp_dir_left: equ 0
041E78             0036*   vp_dir_top: equ 30
041E78             0037*   vp_dir_right: equ text_right
041E78             0038*   vp_dir_bottom: equ vp_dir_top+10
041E78             0039*   vp_dir:
041E78 0E 00       0040*       ld c,vp_dir_left
041E7A 16 1E       0041*       ld d,vp_dir_top
041E7C 1E 3F       0042*       ld e,vp_dir_right
041E7E 06 28       0043*       ld b,vp_dir_bottom
041E80 CD 4B 17 04 0044*       call vdu_set_txt_viewport
041E84 C9          0045*       ret
041E85             0046*   
041E85             0047*   ; print bottom border of directory listing
041E85             0048*   print_dir_border_bottom:
041E85 0E 00       0049*       ld c,vp_dir_left
041E87 16 28       0050*       ld d,vp_dir_bottom
041E89 1E 3F       0051*       ld e,text_right
041E8B 06 28       0052*       ld b,vp_dir_bottom
041E8D CD 4B 17 04 0053*       call vdu_set_txt_viewport
041E91 21 2C 2E 04 0054*       ld hl,str_thick_dashes
041E95 CD 55 00 04 0055*       call printString
041E99 C9          0056*       ret
041E9A             0057*   ; end vp_dir_border
041E9A             0058*   
041E9A             0059*   vp_prt_reload_left: equ 0
041E9A             0060*   vp_prt_reload_top: equ vp_dir_bottom+1
041E9A             0061*   vp_prt_reload_right: equ text_right
041E9A             0062*   vp_prt_reload_bottom: equ vp_prt_reload_top
041E9A             0063*   vp_prt_reload:
041E9A 0E 00       0064*       ld c,vp_prt_reload_left
041E9C 16 29       0065*       ld d,vp_prt_reload_top
041E9E 1E 3F       0066*       ld e,vp_prt_reload_right
041EA0 06 29       0067*       ld b,vp_prt_reload_bottom
041EA2 CD 4B 17 04 0068*       call vdu_set_txt_viewport
041EA6 CD F2 16 04 0069*       call vdu_cls
041EAA CD 4E 00 04 0070*       call printInline
041EAE 50 52 54 20 0071*       asciz "PRT reload: "
       72 65 6C 6F 
       61 64 3A 20 
       00          
041EBB 2A 62 29 04 0072*       ld hl,(ps_prt_reload)
041EBF CD BA 00 04 0073*       call printDec
041EC3 C9          0074*       ret
041EC4             0049        include "ascii.inc"
041EC4             0001*   agon_jukebox_ascii:
041EC4 20 20 20 5F 0002*       db 32,32,32,95,95,95,95,95,32,32,32,32,95,95,95,95,95,95,95,95,32,95,95,95,95,95,95,95,95,32,32,32,32,95,95,95,95,95,95,95,13,10
       5F 5F 5F 5F 
       20 20 20 20 
       5F 5F 5F 5F 
       5F 5F 5F 5F 
       20 5F 5F 5F 
       5F 5F 5F 5F 
       5F 20 20 20 
       20 5F 5F 5F 
       5F 5F 5F 5F 
       0D 0A       
041EEE 20 20 2F 20 0003*       db 32,32,47,32,32,95,32,32,92,32,32,47,32,32,95,95,95,95,95,47,32,92,95,95,95,95,95,32,32,92,32,32,32,92,32,32,32,32,32,32,92,13,10
       20 5F 20 20 
       5C 20 20 2F 
       20 20 5F 5F 
       5F 5F 5F 2F 
       20 5C 5F 5F 
       5F 5F 5F 20 
       20 5C 20 20 
       20 5C 20 20 
       20 20 20 20 
       5C 0D 0A    
041F19 20 2F 20 20 0004*       db 32,47,32,32,47,95,92,32,32,92,47,32,32,32,92,32,32,95,95,95,32,32,47,32,32,32,124,32,32,32,92,32,32,47,32,32,32,124,32,32,32,92,13,10
       2F 5F 5C 20 
       20 5C 2F 20 
       20 20 5C 20 
       20 5F 5F 5F 
       20 20 2F 20 
       20 20 7C 20 
       20 20 5C 20 
       20 2F 20 20 
       20 7C 20 20 
       20 5C 0D 0A 
041F45 2F 20 20 20 0005*       db 47,32,32,32,32,124,32,32,32,32,92,32,32,32,32,92,95,92,32,32,92,47,32,32,32,32,124,32,32,32,32,92,47,32,32,32,32,124,32,32,32,32,92,13,10
       20 7C 20 20 
       20 20 5C 20 
       20 20 20 5C 
       5F 5C 20 20 
       5C 2F 20 20 
       20 20 7C 20 
       20 20 20 5C 
       2F 20 20 20 
       20 7C 20 20 
       20 20 5C 0D 
       0A          
041F72 5C 5F 5F 5F 0006*       db 92,95,95,95,95,124,95,95,32,32,47,92,95,95,95,95,95,95,32,32,47,92,95,95,95,95,95,95,95,32,32,47,92,95,95,95,95,124,95,95,32,32,47,13,10
       5F 7C 5F 5F 
       20 20 2F 5C 
       5F 5F 5F 5F 
       5F 5F 20 20 
       2F 5C 5F 5F 
       5F 5F 5F 5F 
       5F 20 20 2F 
       5C 5F 5F 5F 
       5F 7C 5F 5F 
       20 20 2F 0D 
       0A          
041F9F 20 20 20 20 0007*       db 32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,32,92,47,13,10
       20 20 20 20 
       5C 2F 20 20 
       20 20 20 20 
       20 20 5C 2F 
       20 20 20 20 
       20 20 20 20 
       20 5C 2F 20 
       20 20 20 20 
       20 20 20 20 
       5C 2F 0D 0A 
041FCB 20 20 20 20 0008*       db 32,32,32,32,32,95,95,95,95,32,95,95,95,95,32,95,95,95,32,95,95,95,95,32,32,95,95,32,95,95,95,95,95,95,95,95,95,95,95,13,10
       20 5F 5F 5F 
       5F 20 5F 5F 
       5F 5F 20 5F 
       5F 5F 20 5F 
       5F 5F 5F 20 
       20 5F 5F 20 
       5F 5F 5F 5F 
       5F 5F 5F 5F 
       5F 5F 5F 0D 
       0A          
041FF4 20 20 20 20 0009*       db 32,32,32,32,124,32,32,32,32,124,32,32,32,32,124,32,32,32,92,32,32,32,32,124,47,32,95,124,92,95,32,32,32,95,95,95,95,95,47,13,10
       7C 20 20 20 
       20 7C 20 20 
       20 20 7C 20 
       20 20 5C 20 
       20 20 20 7C 
       2F 20 5F 7C 
       5C 5F 20 20 
       20 5F 5F 5F 
       5F 5F 2F 0D 
       0A          
04201D 20 20 20 20 0010*       db 32,32,32,32,124,32,32,32,32,124,32,32,32,32,124,32,32,32,47,32,32,32,32,32,32,60,32,32,32,124,32,32,32,32,95,95,41,95,13,10
       7C 20 20 20 
       20 7C 20 20 
       20 20 7C 20 
       20 20 2F 20 
       20 20 20 20 
       20 3C 20 20 
       20 7C 20 20 
       20 20 5F 5F 
       29 5F 0D 0A 
042045 2F 5C 5F 5F 0011*       db 47,92,95,95,124,32,32,32,32,124,32,32,32,32,124,32,32,47,124,32,32,32,32,124,32,32,92,32,32,124,32,32,32,32,32,32,32,32,92,13,10
       7C 20 20 20 
       20 7C 20 20 
       20 20 7C 20 
       20 2F 7C 20 
       20 20 20 7C 
       20 20 5C 20 
       20 7C 20 20 
       20 20 20 20 
       20 20 5C 0D 
       0A          
04206E 5C 5F 5F 5F 0012*       db 92,95,95,95,95,95,95,95,95,124,95,95,95,95,95,95,47,32,124,95,95,95,95,124,95,95,32,92,47,95,95,95,95,95,95,95,32,32,47,13,10
       5F 5F 5F 5F 
       5F 7C 5F 5F 
       5F 5F 5F 5F 
       2F 20 7C 5F 
       5F 5F 5F 7C 
       5F 5F 20 5C 
       2F 5F 5F 5F 
       5F 5F 5F 5F 
       20 20 2F 0D 
       0A          
042097 20 20 20 20 0013*       db 32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,92,47,13,10
       20 20 20 20 
       20 20 20 20 
       20 20 20 20 
       20 20 20 20 
       20 20 20 20 
       20 20 5C 2F 
       20 20 20 20 
       20 20 20 20 
       5C 2F 0D 0A 
0420BF 20 20 20 20 0014*       db 32,32,32,32,95,95,95,95,95,95,95,95,95,95,32,95,95,95,95,95,95,95,95,32,32,95,95,95,95,32,32,95,95,95,13,10
       5F 5F 5F 5F 
       5F 5F 5F 5F 
       5F 5F 20 5F 
       5F 5F 5F 5F 
       5F 5F 5F 20 
       20 5F 5F 5F 
       5F 20 20 5F 
       5F 5F 0D 0A 
0420E3 20 20 20 20 0015*       db 32,32,32,32,92,95,95,95,95,95,95,32,32,32,92,92,95,95,95,95,95,32,32,92,32,92,32,32,32,92,47,32,32,47,13,10
       5C 5F 5F 5F 
       5F 5F 5F 20 
       20 20 5C 5C 
       5F 5F 5F 5F 
       5F 20 20 5C 
       20 5C 20 20 
       20 5C 2F 20 
       20 2F 0D 0A 
042107 20 20 20 20 0016*       db 32,32,32,32,32,124,32,32,32,32,124,32,32,95,47,32,47,32,32,32,124,32,32,32,92,32,92,32,32,32,32,32,47,13,10
       20 7C 20 20 
       20 20 7C 20 
       20 5F 2F 20 
       2F 20 20 20 
       7C 20 20 20 
       5C 20 5C 20 
       20 20 20 20 
       2F 0D 0A    
04212A 20 20 20 20 0017*       db 32,32,32,32,32,124,32,32,32,32,124,32,32,32,92,47,32,32,32,32,124,32,32,32,32,92,47,32,32,32,32,32,92,13,10
       20 7C 20 20 
       20 20 7C 20 
       20 20 5C 2F 
       20 20 20 20 
       7C 20 20 20 
       20 5C 2F 20 
       20 20 20 20 
       5C 0D 0A    
04214D 20 20 20 20 0018*       db 32,32,32,32,32,124,95,95,95,95,95,95,32,32,47,92,95,95,95,95,95,95,95,32,32,47,95,95,95,47,92,32,32,92,13,10
       20 7C 5F 5F 
       5F 5F 5F 5F 
       20 20 2F 5C 
       5F 5F 5F 5F 
       5F 5F 5F 20 
       20 2F 5F 5F 
       5F 2F 5C 20 
       20 5C 0D 0A 
042171 20 20 20 20 0019*       db 32,32,32,32,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,92,95,47,13,10
       20 20 20 20 
       20 20 20 20 
       5C 2F 20 20 
       20 20 20 20 
       20 20 20 5C 
       2F 20 20 20 
       20 20 20 5C 
       5F 2F 0D 0A 
042195             0050        include "input_dir.inc"
042195             0001*   get_input:
042195             0002*   @loop:
042195             0003*   ; wait for the user to push a button
042195             0004*       MOSCALL mos_getkey ; a = ascii code of key pressed
042195 3E 00       0001*M1 			LD	A, function
042197 5B CF       0002*M1 			RST.LIL	08h
042199 F3          0005*       di ; disable interrupts
04219A             0006*       ; rst.lil 10h ; print the key pressed
04219A             0007*   ; app control commands
04219A FE 1B       0008*       cp '\e' ; escape
04219C C8          0009*       ret z ; returns to main, which re-enables interrupts and exits app
04219D             0010*   ; prt time tweaking
04219D FE 5B       0011*       cp '[' ; decrease PRT timer reload value
04219F C2 C1 21 04 0012*       jp nz,@F
0421A3 2A 62 29 04 0013*       ld hl,(ps_prt_reload)
0421A7 11 30 FD FF 0014*       ld de,-720 ; 10 ms
0421AB 19          0015*       add hl,de
0421AC 22 62 29 04 0016*       ld (ps_prt_reload),hl
0421B0 CD 9A 1E 04 0017*       call vp_prt_reload
0421B4 CD 6B 1E 04 0018*       call vp_breadcrumbs
0421B8 CD 65 29 04 0019*       call ps_prt_start
0421BC FB          0020*       ei
0421BD C3 95 21 04 0021*       jp @loop
0421C1             0022*   @@:
0421C1 FE 5D       0023*       cp ']' ; increase PRT timer reload value
0421C3 C2 E5 21 04 0024*       jp nz,@F
0421C7 2A 62 29 04 0025*       ld hl,(ps_prt_reload)
0421CB 11 D0 02 00 0026*       ld de,720 ; 10 ms
0421CF 19          0027*       add hl,de
0421D0 22 62 29 04 0028*       ld (ps_prt_reload),hl
0421D4 CD 9A 1E 04 0029*       call vp_prt_reload
0421D8 CD 6B 1E 04 0030*       call vp_breadcrumbs
0421DC CD 65 29 04 0031*       call ps_prt_start
0421E0 FB          0032*       ei
0421E1 C3 95 21 04 0033*       jp @loop
0421E5             0034*   @@:
0421E5             0035*   ; directory page navigation
0421E5 FE 15       0036*       cp 0x15 ; right arrow
0421E7 CA 21 28 04 0037*       jp z,ps_dir_next_page
0421EB FE 08       0038*       cp 0x08 ; left arrow
0421ED CA 44 28 04 0039*       jp z,ps_dir_prev_page
0421F1             0040*   ; song playing commands
0421F1 FE 72       0041*       cp 'r' ; random song
0421F3 CA 8D 28 04 0042*       jp z,ps_play_random
0421F7 FE 30       0043*       cp '0'
0421F9 DA 13 22 04 0044*       jp c,@no_cmd ; not a song command
0421FD FE 3A       0045*       cp '9'+1
0421FF D2 13 22 04 0046*       jp nc,@no_cmd ; not a song command
042203             0047*   ; new song requested so stop playing current one
042203 F5          0048*       push af ; preserve keypress
042204 CD AE 26 04 0049*       call ps_close_file
042208 F1          0050*       pop af ; restore keypress
042209             0051*   ; get pointer to song filename and play it
042209 D6 30       0052*       sub '0' ; a = index into filename lut
04220B CD 6B 28 04 0053*       call ps_get_song_fn_from_pg_idx ; carry set indicates success
04220F DA F3 25 04 0054*       jp c,play_song ; re-enables interrupts and jp's to get_input when finished
042213             0055*   @no_cmd: ; no valid commands so loop
042213 FB          0056*       ei ; reenable interrupts
042214 C3 95 21 04 0057*       jp @loop
042218             0058*   ; end get_input
042218             0051        include "play_dir.inc"
042218             0001*   ; stream a song from the SD card
042218             0002*   ; inputs: hl = pointer to filename
042218             0003*   ; requirements: the file must be 8-bit signed PCM mono
042218             0004*   ; uses: sound channels 0 and 1, buffers 0x3000 and 0x3001
042218             0005*   ; play_song constants
042218             0006*   ch0_buffer: equ 0x3000
042218             0007*   ch1_buffer: equ 0x3001
042218             0008*   cmd0_buffer: equ 0x3002
042218             0009*   cmd1_buffer: equ 0x3003
042218             0010*   
042218             0011*   ; play_song state variables
042218             0012*   ; current active channel and bufferId's
042218 00          0013*   ps_channel: db 0 ; channel number
042219 00 00 00    0014*   ps_cmdId: dl 0 ; command bufferId
04221C 00 00 00    0015*   ps_sampleId: dl 0 ; sample bufferId
04221F 00 00 00 00 0016*   ps_dir_path:   blkw 256,0 ; path of the current directory
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04241F 00 00 00    0017*   ps_dir_num_files: dl 0 ; number of files/directories in the directory (virtually unlimited)
042422 00 00 00    0018*   ps_dir_num_pages: dl 0 ; number of pages in the directory (virtually unlimited)
042425 00 00 00    0019*   ps_page_num_files: dl 0 ; number of files/directories in the current directory page (max 10)
042428 00 00 00    0020*   ps_pagelast_num_files: dl 0 ; mod(ps_dir_num_files,10)
04242B 00 00 00    0021*   ps_page_cur: dl 0 ; current directory page number
04242E 00          0022*   ps_song_idx_cur: db 0 ; current song index in the directory page
04242F 00 00 00    0023*   ps_song_fn_cur: dl 0 ; pointer to current song filename
042432 00 00 00 00 0024*   ps_page_fn_ptrs: blkw 10*3,0 ; list of filename pointers in the current directory page
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04246E             0025*   
04246E             0026*   ; play_song directory info
04246E             0027*   ps_dir_struct:
04246E 00 00 00 00 0028*   ps_dptr:       blkb  4,0   ; Current read/write offset
042472 00 00 00 00 0029*   ps_clust:      blkb  4,0   ; Current cluster
042476 00 00 00 00 0030*   ps_sect:       blkb  4,0   ; Current sector (0:Read operation has terminated)
04247A 00 00 00    0031*   ps_dir:        blkb  3,0   ; Pointer to the directory item in the win[]
04247D 00 00 00 00 0032*   ps_fn:         blkb  12,0  ; SFN (in/out) {body[8],ext[3],status[1]}
       00 00 00 00 
       00 00 00 00 
042489 00 00 00 00 0033*   ps_blk_ofs:    blkb  4,0   ; Offset of current entry block being processed (0xFFFFFFFF:Invalid)
04248D             0034*   
04248D             0035*   ; play_song file info
04248D 00          0036*   ps_filehandle_cur: db 0 ; file handle
04248E 00 00 00    0037*   ps_chunkpointer: dl 0 ; pointer to current chunk
042491             0038*   ; File information structure (FILINFO)
042491             0039*   ps_filinfo_struct:
042491 00 00 00 00 0040*   ps_filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
042495 00 00       0041*   ps_filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
042497 00 00       0042*   ps_filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
042499 00          0043*   ps_filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
04249A 00 00 00 00 0044*   ps_filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
0424A7 00 00 00 00 0045*   ps_filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0425A7             0046*   
0425A7             0047*   ; buffer for play_song sound data
0425A7             0048*   ps_wav_header: ; marker for top of the wav file header and song data
0425A7             0049*   ; (must be last so buffer doesn't overwrite other program code or data)
0425A7             0050*   ; .wav header data
0425A7             0051*   ; WAV File Structure in Memory with LIST Chunk
0425A7 00 00 00 00 0052*   ps_wav_riff:          blkb 4,0   ; 4 bytes: "RIFF" identifier
0425AB 00 00 00 00 0053*   ps_wav_file_size:     blkb 4,0   ; 4 bytes: Total file size minus 8 bytes for RIFF header
0425AF 00 00 00 00 0054*   ps_wav_wave:          blkb 4,0   ; 4 bytes: "WAVE" identifier
0425B3 00 00 00 00 0055*   ps_wav_fmt_marker:    blkb 4,0   ; 4 bytes: "fmt " subchunk marker
0425B7 00 00 00 00 0056*   ps_wav_fmt_size:      blkb 4,0   ; 4 bytes: Format chunk size (16 for PCM)
0425BB 00 00       0057*   ps_wav_audio_format:  blkb 2,0   ; 2 bytes: Audio format (1 = PCM)
0425BD 00 00       0058*   ps_wav_num_channels:  blkb 2,0   ; 2 bytes: Number of channels (1 = mono, 2 = stereo)
0425BF 00 00 00 00 0059*   ps_wav_sample_rate:   blkb 4,0   ; 4 bytes: Sample rate in Hz (e.g., 32768)
0425C3 00 00 00 00 0060*   ps_wav_byte_rate:     blkb 4,0   ; 4 bytes: Bytes per second (SampleRate * NumChannels * BitsPerSample / 8)
0425C7 00 00       0061*   ps_wav_block_align:   blkb 2,0   ; 2 bytes: Bytes per sample block (NumChannels * BitsPerSample / 8)
0425C9 00 00       0062*   ps_wav_bits_per_sample: blkb 2,0 ; 2 bytes: Bits per sample (e.g., 8 or 16)
0425CB             0063*   
0425CB             0064*   ; LIST Chunk (Extra Metadata)
0425CB 00 00 00 00 0065*   ps_wav_list_marker:   blkb 4,0   ; 4 bytes: "LIST" marker
0425CF 00 00 00 00 0066*   ps_wav_list_size:     blkb 4,0   ; 4 bytes: Size of the LIST chunk (e.g., 26)
0425D3 00 00 00 00 0067*   ps_wav_info_marker:   blkb 4,0   ; 4 bytes: "INFO" marker
0425D7 00 00 00 00 0068*   ps_wav_isft_marker:   blkb 4,0   ; 4 bytes: "ISFT" marker (software identifier)
0425DB 00 00 00 00 0069*   ps_wav_isft_data:     blkb 14,0  ; 14 bytes: Software info string (e.g., "Lavf59.27.100")
       00 00 00 00 
       00 00 00 00 
       00 00       
0425E9 00 00       0070*   ps_wav_isft_padding:  blkb 2,0   ; 2 bytes: Padding/NULL terminator for alignment
0425EB             0071*   
0425EB             0072*   ; Data Chunk
0425EB 00 00 00 00 0073*   ps_wav_data_marker:   blkb 4,0   ; 4 bytes: "data" subchunk marker
0425EF 00 00 00 00 0074*   ps_wav_data_size:     blkb 4,0   ; 4 bytes: Size of the audio data in bytes
0425F3             0075*   ; Total Header Size: 76 bytes
0425F3             0076*   play_song:
0425F3 22 2F 24 04 0077*       ld (ps_song_fn_cur),hl
0425F7             0078*   ; stop the PRT timer
0425F7 CD 82 29 04 0079*       call ps_prt_stop
0425FB             0080*   ; tell the user what they've won
0425FB CD 5E 1E 04 0081*       call vp_now_playing
0425FF CD F2 16 04 0082*       call vdu_cls
042603 2A 2F 24 04 0083*       ld hl,(ps_song_fn_cur)
042607 CD 4E 00 04 0084*       call printInline
04260B 50 6C 61 79 0085*       asciz "Playing song: "
       69 6E 67 20 
       73 6F 6E 67 
       3A 20 00    
04261A 2A 2F 24 04 0086*       ld hl,(ps_song_fn_cur)
04261E CD 55 00 04 0087*       call printString ; print the song filename
042622             0088*   ; highlight the song being played
042622 CD E3 27 04 0089*       call ps_highlight_song
042626             0090*   ; reset text viewport for playing breadcrumbs
042626 CD 6B 1E 04 0091*       call vp_breadcrumbs
04262A             0092*   ; open the file in read mode
04262A             0093*   ; Open a file
04262A             0094*   ; HLU: Filename
04262A             0095*   ;   C: Mode
04262A             0096*   ; Returns:
04262A             0097*   ;   A: Filehandle, or 0 if couldn't open
04262A 2A 2F 24 04 0098*       ld hl,(ps_song_fn_cur)
04262E 0E 01       0099*   	ld c,fa_read
042630             0100*       MOSCALL mos_fopen
042630 3E 0A       0001*M1 			LD	A, function
042632 5B CF       0002*M1 			RST.LIL	08h
042634 32 8D 24 04 0101*       ld (ps_filehandle_cur),a
042638             0102*   ; read the .wav header data and copy it to the buffer
042638 CD BD 28 04 0103*       call ps_read_wav_header
04263C             0104*   ; read the first block of data
04263C CD 49 26 04 0105*       call ps_read_file
042640             0106*   ; enable interrupts and start the PRT timer
042640 FB          0107*       ei
042641 CD 65 29 04 0108*       call ps_prt_start
042645             0109*   ; jump to user input loop:
042645             0110*   ; the play sample interrupt will return to there
042645             0111*   ; and exit app will return to main from there as well
042645 C3 95 21 04 0112*       jp get_input
042649             0113*   ; end play_song
042649             0114*   
042649             0115*   ; read the next 1-second's worth of sound data from the file
042649             0116*   ; and upload it to the sample buffer
042649             0117*   ps_read_file:
042649             0118*   ; disable interrupts so load is guaranteed to complete
042649 F3          0119*       di
04264A             0120*   ; print a playing breadcrumb
04264A 3E 2E       0121*       ld a,'.'
04264C 5B D7       0122*       rst.lil 10h
04264E             0123*   ; Read a block of data from a file
04264E             0124*   ;   C: Filehandle
04264E             0125*   ; HLU: Pointer to where to write the data to
04264E             0126*   ; DEU: Number of bytes to read
04264E             0127*   ; Returns:
04264E             0128*   ; DEU: Number of bytes read
04264E 3A 8D 24 04 0129*       ld a,(ps_filehandle_cur)
042652 4F          0130*       ld c,a
042653 21 00 00 05 0131*       ld hl,ps_wav_data_start
042657 ED 5B BF 25 0132*       ld de,(ps_wav_sample_rate)
       04          
04265C             0133*       MOSCALL mos_fread
04265C 3E 1A       0001*M1 			LD	A, function
04265E 5B CF       0002*M1 			RST.LIL	08h
042660             0134*   ; test de for zero bytes read
042660 21 00 00 00 0135*       ld hl,0
042664 AF          0136*       xor a ; clear carry
042665 ED 52       0137*       sbc hl,de ; hl = 0-chunksize
042667 C2 73 26 04 0138*       jp nz,@load ; we read some data
04266B             0139*   ; no data read so close file and play a random song
04266B CD AE 26 04 0140*       call ps_close_file
04266F C3 8D 28 04 0141*       jp ps_play_random
042673             0142*   ; load a vdu buffer from local memory
042673             0143*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
042673             0144*   @load:
042673 3A 18 22 04 0145*       ld a,(ps_channel)
042677 3C          0146*       inc a
042678 E6 01       0147*       and 1
04267A 32 18 22 04 0148*       ld (ps_channel),a
04267E 21 00 30 00 0149*       ld hl,ch0_buffer
042682 6F          0150*       ld l,a
042683 22 1C 22 04 0151*       ld (ps_sampleId),hl
042687 CD AC 1A 04 0152*       call vdu_clear_buffer
04268B 2A 1C 22 04 0153*       ld hl,(ps_sampleId)
04268F D5          0154*       push de ; chunksize
042690 C1          0155*       pop bc ; how much data to load
042691 11 00 00 05 0156*       ld de,ps_wav_data_start ; pointer to data
042695 CD 97 18 04 0157*       call vdu_load_buffer
042699 C9          0158*       ret
04269A             0159*   ; end ps_read_file
04269A             0160*   
04269A             0161*   ; this is called by the PRT timer interrupt
04269A             0162*   ps_play_sample:
04269A             0163*   ; call the command buffer to play the sound
04269A 2A 1C 22 04 0164*       ld hl,(ps_sampleId)
04269E 2C          0165*       inc l
04269F 2C          0166*       inc l
0426A0 22 19 22 04 0167*       ld (ps_cmdId),hl ; TODO: perhaps not needed
0426A4 CD 91 1A 04 0168*       call vdu_call_buffer
0426A8             0169*   ; load the next chunk of data
0426A8 CD 49 26 04 0170*       call ps_read_file
0426AC             0171*   ; reenable interrupts and return to the user input loop
0426AC FB          0172*       ei
0426AD C9          0173*       ret
0426AE             0174*   ; end ps_play_sample
0426AE             0175*   
0426AE             0176*   ; close the file
0426AE             0177*   ps_close_file:
0426AE CD 82 29 04 0178*       call ps_prt_stop ; stop the PRT timer
0426B2 3A 8D 24 04 0179*       ld a,(ps_filehandle_cur)
0426B6             0180*       MOSCALL mos_fclose
0426B6 3E 0B       0001*M1 			LD	A, function
0426B8 5B CF       0002*M1 			RST.LIL	08h
0426BA C9          0181*       ret
0426BB             0182*   ; end ps_close_file
0426BB             0183*   
0426BB             0184*   ps_get_dir:
0426BB             0185*   ; reset filecounter
0426BB 21 00 00 00 0186*       ld hl,0
0426BF 22 1F 24 04 0187*       ld (ps_dir_num_files),hl
0426C3             0188*   ; initialize pointers to store directory info
0426C3 21 1F 22 04 0189*       ld hl,ps_dir_path  ; where to store result
0426C7 01 FF 00 00 0190*       ld bc,255          ; max length
0426CB             0191*       MOSCALL ffs_getcwd ; MOS api get current working directory
0426CB 3E 9E       0001*M1 			LD	A, function
0426CD 5B CF       0002*M1 			RST.LIL	08h
0426CF             0192*   ; now get dir info
0426CF 21 6E 24 04 0193*       ld hl,ps_dir_struct ; define where to store directory info
0426D3 11 1F 22 04 0194*       ld de,ps_dir_path   ; this is pointer to the path to the directory
0426D7             0195*       MOSCALL ffs_dopen   ; open dir
0426D7 3E 91       0001*M1 			LD	A, function
0426D9 5B CF       0002*M1 			RST.LIL	08h
0426DB             0196*   @readFileInfo:               ; we will loop here until all files have been processed
0426DB 21 6E 24 04 0197*       ld hl,ps_dir_struct      ; HL is where to get directory info
0426DF 11 91 24 04 0198*       ld de,ps_filinfo_struct  ; define where to store current file info
0426E3             0199*       MOSCALL ffs_dread        ; read next item from dir
0426E3 3E 93       0001*M1 			LD	A, function
0426E5 5B CF       0002*M1 			RST.LIL	08h
0426E7 3A A7 24 04 0200*       ld a,(ps_filinfo_fname)  ; get first char of file name
0426EB FE 00       0201*       cp 0                     ; if 0 then we are at the end of the listing
0426ED 28 27       0202*       jr z,@allDone
0426EF ED 5B 1F 24 0203*       ld de,(ps_dir_num_files) ; get the current file counter
       04          
0426F4 21 00 01 00 0204*       ld hl,256 ; bytes per filename
0426F8 CD 55 03 04 0205*       call umul24 ; hl = offset into the filename table
0426FC 13          0206*       inc de                  ; increment the counter
0426FD ED 53 1F 24 0207*       ld (ps_dir_num_files),de
       04          
042702 11 00 00 06 0208*       ld de,ps_dir_fil_list ; get the address of the filename table
042706 19          0209*       add hl,de ; add the offset to the base address
042707 EB          0210*       ex de,hl ; de is the destination address to copy the filename
042708 21 A7 24 04 0211*       ld hl,ps_filinfo_fname   ; this is pointer to the name of current file
04270C 01 00 01 00 0212*       ld bc,256 ; bytes per filename
042710 ED B0       0213*       ldir ; copy the filename to the filename table
042712 C3 DB 26 04 0214*       jp @readFileInfo         ; loop around to check next entry
042716             0215*   @allDone:
042716             0216*   ; compute page statistics
042716 2A 1F 24 04 0217*       ld hl,(ps_dir_num_files) ; get the number of files
04271A 11 0A 00 00 0218*       ld de,10 ; max files per page
04271E CD 6E 03 04 0219*       call udiv24 ; de = hl/10, hl = mod(hl,10)
042722             0220*       SIGN_HLU ; check remainder for zero
042722 19          0001*M1     add hl,de ; 1 cycle
042723 B7          0002*M1     or a ; clear flags ; 1 cycle
042724 ED 52       0003*M1     sbc hl,de ; 2 cycles
042726             0004*M1     ; 4 cycles total
042726 CA 2B 27 04 0221*       jp z,@F ; if zero then we have exactly 10 files
04272A 13          0222*       inc de ; bump the page count
04272B             0223*   @@:
04272B ED 53 22 24 0224*       ld (ps_dir_num_pages),de ; save the number of pages
       04          
042730 22 28 24 04 0225*       ld (ps_pagelast_num_files),hl ; save the number of files on the last page
042734             0226*   ; reset the song index and page to zero and populate the page filename pointers
042734 AF          0227*       xor a
042735 32 2E 24 04 0228*       ld (ps_song_idx_cur),a
042739 21 00 00 00 0229*       ld hl,0
04273D 22 2B 24 04 0230*       ld (ps_page_cur),hl
042741 CD 4E 27 04 0231*       call ps_fill_page_fn_ptrs
042745             0232*   ; close the directory
042745 21 6E 24 04 0233*       ld hl,ps_dir_struct      ; load H: with address of the DIR struct
042749             0234*       MOSCALL ffs_dclose       ; close dir
042749 3E 92       0001*M1 			LD	A, function
04274B 5B CF       0002*M1 			RST.LIL	08h
04274D C9          0235*       ret
04274E             0236*   ; end ps_get_dir
04274E             0237*   
04274E             0238*   ; populate the page filename pointers for the current directory page
04274E             0239*   ; inputs: ps_page_cur
04274E             0240*   ; prerequisites: ps_get_dir called on a valid directory
04274E             0241*   ; outputs: a populated filename pointer list for the current page
04274E             0242*   ; destroys: a, hl, bc, de, ix
04274E             0243*   ps_fill_page_fn_ptrs:
04274E 2A 2B 24 04 0244*       ld hl,(ps_page_cur) ; get the current page number
042752 11 00 0A 00 0245*       ld de,10*256 ; records/page * 256 bytes/record
042756 CD 55 03 04 0246*       call umul24 ; hl = offset into the filename table
04275A 11 00 00 06 0247*       ld de,ps_dir_fil_list ; base address of filename table
04275E 19          0248*       add hl,de ; add the offset to the base address
04275F DD 21 32 24 0249*       ld ix,ps_page_fn_ptrs ; get the address of the page filename pointer table
       04          
042764 11 00 01 00 0250*       ld de,256 ; bytes per filename record
042768 06 0A       0251*       ld b,10 ; number of files per page
04276A             0252*   @loop:
04276A DD 2F 00    0253*       ld (ix),hl ; store the filename pointer
04276D ED 32 03    0254*       lea ix,ix+3 ; bump the index pointer
042770 19          0255*       add hl,de ; add the record size to the filename pointer
042771 10 F7       0256*       djnz @loop
042773 C9          0257*       ret
042774             0258*   ; end ps_fill_page_fn_ptrs
042774             0259*   
042774             0260*   ps_get_page_num_files:
042774             0261*   ; check whether we're at last page
042774 2A 2B 24 04 0262*       ld hl,(ps_page_cur)
042778 ED 5B 22 24 0263*       ld de,(ps_dir_num_pages)
       04          
04277D 1B          0264*       dec de ; zero-based
04277E B7          0265*       or a ; clear carry
04277F ED 52       0266*       sbc hl,de
042781 06 0A       0267*       ld b,10 ; b = default number of files per page
042783 C0          0268*       ret nz ; not the last page
042784 3A 28 24 04 0269*       ld a,(ps_pagelast_num_files) ; get the number of files on the last page
042788 47          0270*       ld b,a ; b = number of files on the last page
042789 C9          0271*       ret
04278A             0272*   ; end ps_get_page_num_files
04278A             0273*   
04278A             0274*   ps_print_dir_page:
04278A             0275*   ; set text viewport for directory listing
04278A CD 78 1E 04 0276*       call vp_dir
04278E CD F2 16 04 0277*       call vdu_cls
042792             0278*   ; loop through the filename pointer table and print out the filenames
042792 CD 74 27 04 0279*       call ps_get_page_num_files ; b = loop counter
042796 AF          0280*       xor a ; song index
042797 DD 21 32 24 0281*       ld ix,ps_page_fn_ptrs
       04          
04279C             0282*   @loop:
04279C C5          0283*       push bc ; save loop counter
04279D F5          0284*       push af ; save song index
04279E CD C8 29 04 0285*       call printHexA ; print the song index
0427A2 DD 27 00    0286*       ld hl,(ix) ; get the filename pointer
0427A5 CD 55 00 04 0287*       call printString ; print the filename
0427A9 CD 6A 00 04 0288*       call printNewLine
0427AD ED 32 03    0289*       lea ix,ix+3 ; bump the filename pointer
0427B0 F1          0290*       pop af ; restore song index
0427B1 3C          0291*       inc a ; increment the song index
0427B2 C1          0292*       pop bc ; restore loop counter
0427B3 10 E7       0293*       djnz @loop
0427B5             0294*   ; print the bottom border
0427B5 CD 85 1E 04 0295*       call print_dir_border_bottom
0427B9 C9          0296*       ret
0427BA             0297*   ; end ps_print_dir_page
0427BA             0298*   
0427BA             0299*   ps_print_dir:
0427BA             0300*   ; loop through the filename table and print out the filenames
0427BA DD 21 00 00 0301*       ld ix,ps_dir_fil_list      ; get the address of the filename table
       06          
0427BF 2A 1F 24 04 0302*       ld hl,(ps_dir_num_files)   ; get the number of files
0427C3 E5          0303*       push hl ; save loop counter
0427C4             0304*   @print_loop:
0427C4 DD E5       0305*       push ix
0427C6 E1          0306*       pop hl ; get the address of the filename
0427C7 CD 55 00 04 0307*       call printString
0427CB CD 6A 00 04 0308*       call printNewLine
0427CF ED 32 7F    0309*       lea ix,ix+127 ; bump the pointer
0427D2 ED 32 7F    0310*       lea ix,ix+127 ; to the next file
0427D5 ED 32 02    0311*       lea ix,ix+2   ; 256 bytes
0427D8 E1          0312*       pop hl ; get the loop counter
0427D9 2B          0313*       dec hl ; decrement the loop counter
0427DA E5          0314*       push hl ; save loop counter
0427DB             0315*       SIGN_HLU ; check for zero
0427DB 19          0001*M1     add hl,de ; 1 cycle
0427DC B7          0002*M1     or a ; clear flags ; 1 cycle
0427DD ED 52       0003*M1     sbc hl,de ; 2 cycles
0427DF             0004*M1     ; 4 cycles total
0427DF 20 E3       0316*       jr nz,@print_loop
0427E1 E1          0317*       pop hl ; dummy pop to balance stack
0427E2 C9          0318*       ret
0427E3             0319*   ; end ps_print_dir
0427E3             0320*   
0427E3             0321*   ps_highlight_song:
0427E3             0322*   ; refresh the directory listing
0427E3 CD 8A 27 04 0323*       call ps_print_dir_page
0427E7             0324*   ; highlight the song being played in the directory listing
0427E7 3A 2E 24 04 0325*       ld a,(ps_song_idx_cur)
0427EB 16 1E       0326*       ld d,vp_dir_top
0427ED 82          0327*       add a,d
0427EE 0E 00       0328*       ld c,vp_dir_left
0427F0 57          0329*       ld d,a
0427F1 1E 3F       0330*       ld e,vp_dir_right
0427F3 47          0331*       ld b,a
0427F4 CD 4B 17 04 0332*       call vdu_set_txt_viewport
0427F8             0333*   ; set text background color
0427F8 3E 8F       0334*       ld a,c_white+128
0427FA CD 23 17 04 0335*       call vdu_colour_text
0427FE             0336*   ; set text foreground color
0427FE 3E 04       0337*       ld a,c_blue_dk
042800 CD 23 17 04 0338*       call vdu_colour_text
042804             0339*   ; print the index and song filename
042804 3A 2E 24 04 0340*       ld a,(ps_song_idx_cur)
042808 CD C8 29 04 0341*       call printHexA
04280C 2A 2F 24 04 0342*       ld hl,(ps_song_fn_cur)
042810 CD 55 00 04 0343*       call printString
042814             0344*   ; set text background color
042814 3E 84       0345*       ld a,c_blue_dk+128
042816 CD 23 17 04 0346*       call vdu_colour_text
04281A             0347*   ; set text foreground color
04281A 3E 0F       0348*       ld a,c_white
04281C CD 23 17 04 0349*       call vdu_colour_text
042820 C9          0350*       ret
042821             0351*   ; end ps_highlight_song
042821             0352*   
042821             0353*   ps_dir_next_page:
042821             0354*   ; advance the page number
042821 2A 2B 24 04 0355*       ld hl,(ps_page_cur) ; get the current page number
042825 23          0356*       inc hl ; increment the page number
042826 ED 5B 22 24 0357*       ld de,(ps_dir_num_pages) ; get the number of pages
       04          
04282B CD 6E 03 04 0358*       call udiv24 ; hl = mod(ps_page_cur+1,ps_dir_num_pages)
04282F 22 2B 24 04 0359*       ld (ps_page_cur),hl ; save the new page number
042833             0360*   ; populate the page filename pointers
042833 CD 4E 27 04 0361*       call ps_fill_page_fn_ptrs
042837             0362*   ; print the new page and reset text viewport to now playing breadcrumbs
042837 CD 8A 27 04 0363*       call ps_print_dir_page
04283B CD 6B 1E 04 0364*       call vp_breadcrumbs
04283F             0365*   ; enable interrupts and jump back to the user input loop
04283F FB          0366*       ei
042840 C3 95 21 04 0367*       jp get_input
042844             0368*   ; end ps_dir_next_page
042844             0369*   
042844             0370*   ps_dir_prev_page:
042844             0371*   ; decrement the page number
042844 2A 2B 24 04 0372*       ld hl,(ps_page_cur) ; get the current page number
042848 2B          0373*       dec hl ; decrement the page number
042849             0374*       SIGN_HLU ; check for zero
042849 19          0001*M1     add hl,de ; 1 cycle
04284A B7          0002*M1     or a ; clear flags ; 1 cycle
04284B ED 52       0003*M1     sbc hl,de ; 2 cycles
04284D             0004*M1     ; 4 cycles total
04284D F2 56 28 04 0375*       jp p,@F ; >= 0 so we're good
042851 2A 22 24 04 0376*       ld hl,(ps_dir_num_pages) ; get the number of pages
042855 2B          0377*       dec hl ; zero-based
042856             0378*   @@:
042856 22 2B 24 04 0379*       ld (ps_page_cur),hl ; save the new page number
04285A             0380*   ; populate the page filename pointers
04285A CD 4E 27 04 0381*       call ps_fill_page_fn_ptrs
04285E             0382*   ; print the new page and reset text viewport to now playing breadcrumbs
04285E CD 8A 27 04 0383*       call ps_print_dir_page
042862 CD 6B 1E 04 0384*       call vp_breadcrumbs
042866             0385*   ; enable interrupts and jump back to the user input loop
042866 FB          0386*       ei
042867 C3 95 21 04 0387*       jp get_input
04286B             0388*   ; end ps_dir_prev_page
04286B             0389*   
04286B             0390*   ; get the filename of the song at the current index
04286B             0391*   ; inputs: a = song index
04286B             0392*   ; returns: carry set if song index in range, new filemame in hl and ps_song_idx_cur, ps_song_fn_cur set to new index
04286B             0393*   ;          carry reset if song index out of range, current filename in hl, ps_song_idx_cur, ps_song_fn_cur unchanged
04286B             0394*   ; destroys: af, bc, de
04286B             0395*   ps_get_song_fn_from_pg_idx:
04286B F5          0396*       push af ; save song index
04286C CD 74 27 04 0397*       call ps_get_page_num_files ; b = number of files on the page
042870 F1          0398*       pop af ; restore song index
042871 B8          0399*       cp b ; compare song index to number of files on the page
042872 2A 2F 24 04 0400*       ld hl,(ps_song_fn_cur) ; get the current song filename
042876 D0          0401*       ret nc ; requested song index is out of range so return current filename and no carry
042877 32 2E 24 04 0402*       ld (ps_song_idx_cur),a ; save the song index
04287B 21 32 24 04 0403*       ld hl,ps_page_fn_ptrs ; get the address of the page filename pointer table
04287F 47          0404*       ld b,a ; song index
042880 0E 03       0405*       ld c,3 ; 3 bytes per filename pointer
042882 ED 4C       0406*       mlt bc ; index into the filename pointer table
042884 09          0407*       add hl,bc ; hl points to the filename pointer
042885 ED 27       0408*       ld hl,(hl) ; hl points to the filename
042887 22 2F 24 04 0409*       ld (ps_song_fn_cur),hl ; save the new song filename
04288B 37          0410*       scf ; set carry to indicate success
04288C C9          0411*       ret
04288D             0412*   ; end ps_get_song_fn_from_pg_idx
04288D             0413*   
04288D             0414*   ; queue a random song on the current page to play next
04288D             0415*   ps_play_random:
04288D             0416*   ; back up current song index
04288D 2A 2F 24 04 0417*       ld hl,(ps_song_fn_cur)
042891 22 BA 28 04 0418*       ld (@songFn),hl
042895             0419*   ; get the number of songs in the current directory
042895 CD 74 27 04 0420*       call ps_get_page_num_files
042899             0421*   ; get a random song index
042899 CD 26 05 04 0422*       call rand_8 ; a = 0-255
04289D 67          0423*       ld h,a
04289E 2E 0A       0424*       ld l,10 ; modulo 10
0428A0 CD 62 05 04 0425*       call udiv8 ; a = mod(a,10)
0428A4 CD 6B 28 04 0426*       call ps_get_song_fn_from_pg_idx
0428A8 EB          0427*       ex de,hl ; setting up cp hl,de
0428A9 2A BA 28 04 0428*       ld hl,(@songFn) ; don't play the same song twice in a row
0428AD B7          0429*       or a ; clear carry
0428AE ED 52       0430*       sbc hl,de
0428B0 CA 8D 28 04 0431*       jp z,ps_play_random ; same song, try again
0428B4 EB          0432*       ex de,hl ; pointer back to hl
0428B5 CD F3 25 04 0433*       call play_song ; hit it
0428B9 C9          0434*       ret
0428BA 00 00 00    0435*   @songFn: dl 0
0428BD             0436*   ; end ps_play_random
0428BD             0437*   
0428BD             0438*   ps_read_wav_header:
0428BD             0439*   ; Read a block of data from a file
0428BD             0440*   ;   C: Filehandle
0428BD             0441*   ; HLU: Pointer to where to write the data to
0428BD             0442*   ; DEU: Number of bytes to read
0428BD             0443*   ; Returns:
0428BD             0444*   ; DEU: Number of bytes read
0428BD 3A 8D 24 04 0445*       ld a,(ps_filehandle_cur)
0428C1 4F          0446*       ld c,a
0428C2 21 A7 25 04 0447*       ld hl,ps_wav_header
0428C6 11 4C 00 00 0448*       ld de,wav_header_size
0428CA             0449*       MOSCALL mos_fread
0428CA 3E 1A       0001*M1 			LD	A, function
0428CC 5B CF       0002*M1 			RST.LIL	08h
0428CE             0450*   ; test de for zero bytes read
0428CE 21 00 00 00 0451*       ld hl,0
0428D2 AF          0452*       xor a ; clear carry
0428D3 ED 52       0453*       sbc hl,de ; hl = 0-chunksize
0428D5 C8          0454*       ret z ; no data read so return zero to caller
0428D6             0455*   ; data read so initialize song variables
0428D6             0456*   ; load play sample command buffers (namely the sample rate for now)
0428D6 CD DB 28 04 0457*       call ps_load_command_buffers
0428DA C9          0458*       ret
0428DB             0459*   ; end ps_read_wav_header
0428DB             0460*   
0428DB             0461*   ps_load_command_buffers:
0428DB 21 02 30 00 0462*       ld hl,cmd0_buffer
0428DF CD AC 1A 04 0463*       call vdu_clear_buffer
0428E3 2A BF 25 04 0464*       ld hl,(ps_wav_sample_rate)
0428E7 22 31 29 04 0465*       ld (ps_sr0),hl
0428EB 3E 17       0466*       ld a,23
0428ED 32 33 29 04 0467*       ld (ps_sr0+2),a
0428F1 21 02 30 00 0468*       ld hl,cmd0_buffer
0428F5 01 1D 00 00 0469*       ld bc,ps_cmd0_end-ps_cmd0
0428F9 11 28 29 04 0470*       ld de,ps_cmd0
0428FD CD 69 1A 04 0471*       call vdu_write_block_to_buffer
042901             0472*   
042901 21 03 30 00 0473*       ld hl,cmd1_buffer
042905 CD AC 1A 04 0474*       call vdu_clear_buffer
042909 2A BF 25 04 0475*       ld hl,(ps_wav_sample_rate)
04290D 22 4E 29 04 0476*       ld (ps_sr1),hl
042911 3E 17       0477*       ld a,23
042913 32 50 29 04 0478*       ld (ps_sr1+2),a
042917 21 03 30 00 0479*       ld hl,cmd1_buffer
04291B 01 1D 00 00 0480*       ld bc,ps_cmd1_end-ps_cmd1
04291F 11 45 29 04 0481*       ld de,ps_cmd1
042923 CD 69 1A 04 0482*       call vdu_write_block_to_buffer
042927 C9          0483*       ret
042928             0484*   ps_cmd0:
042928             0485*   ; vdu_buffer_to_sound command string
042928             0486*   ; Command 5: Buffer to sound
042928             0487*   ; VDU 23, 0, &85, channel (ignored), 5, 2, bufferId; format, [sampleRate;]
042928 17 00 85    0488*       db 23,0,0x85 ; vdu sound command header
04292B 00          0489*       db 0x00 ; channel (ignored)
04292C 05          0490*       db 0x05 ; buffer to sound command
04292D 02          0491*       db 0x02 ; command 2 create sample
04292E 00 30       0492*       dw ch0_buffer
042930 09          0493*       db 1+8 ; 8-bit unsigned PCM mono, 8 = sample rate argument follows
042931             0494*   ps_sr0:
042931 00 00       0495*       dw 0x0000 ; sample rate Hz
042933             0496*   ; vdu_play_sfx command string
042933             0497*   ; Command 4: Set waveform
042933             0498*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
042933 17 00 85    0499*       db 23,0,$85 ; vdu sound command header
042936 00          0500*       db 0 ; channel
042937 04          0501*       db 4 ; set waveform command
042938 08          0502*       db 8 ; waveform 8 = sample
042939 00 30       0503*       dw ch0_buffer ; sample bufferId
04293B             0504*   ; Command 0: Play note
04293B             0505*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
04293B 17 00 85    0506*       db 23,0,$85 ; vdu sound command header
04293E 00          0507*       db 0 ; channel
04293F 00          0508*       db 0 ; play note command
042940 7F          0509*       db 127  ; volume 127 = max
042941 00 00       0510*       dw 0 ; frequency (relevant only for tuneable samples)
042943 00 00       0511*       dw 0 ; duration (ms), zero means play one time in full
042945             0512*   ps_cmd0_end:
042945             0513*   
042945             0514*   ps_cmd1:
042945             0515*   ; vdu_buffer_to_sound command string
042945             0516*   ; Command 5: Buffer to sound
042945             0517*   ; VDU 23, 0, &85, channel (ignored), 5, 2, bufferId; format, [sampleRate;]
042945 17 00 85    0518*       db 23,0,0x85 ; vdu sound command header
042948 00          0519*       db 0x00 ; channel (ignored)
042949 05          0520*       db 0x05 ; buffer to sound command
04294A 02          0521*       db 0x02 ; command 2 create sample
04294B 01 30       0522*       dw ch1_buffer
04294D 09          0523*       db 1+8 ; 8-bit unsigned PCM mono, 8 = sample rate argument follows
04294E             0524*   ps_sr1:
04294E 00 00       0525*       dw 0x0000 ; sample rate Hz
042950             0526*   ; vdu_play_sfx command string
042950             0527*   ; Command 4: Set waveform
042950             0528*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
042950 17 00 85    0529*       db 23,0,$85 ; vdu sound command header
042953 01          0530*       db 1 ; channel
042954 04          0531*       db 4 ; set waveform command
042955 08          0532*       db 8 ; waveform 8 = sample
042956 01 30       0533*       dw ch1_buffer ; sample bufferId
042958             0534*   ; Command 0: Play note
042958             0535*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
042958 17 00 85    0536*       db 23,0,$85 ; vdu sound command header
04295B 01          0537*       db 1 ; channel
04295C 00          0538*       db 0 ; play note command
04295D 7F          0539*       db 127  ; volume 127 = max
04295E 00 00       0540*       dw 0 ; frequency (relevant only for tuneable samples)
042960 00 00       0541*       dw 0 ; duration (ms), zero means play one time in full
042962             0542*   ps_cmd1_end:
042962             0543*   ; end ps_load_command_buffers
042962             0052        include "timer_jukebox.inc"
042962 A1 8C 00    0001*   ps_prt_reload: dl [72000/2]+1 ; 2 ticks per second at 18.432 MHz with a 256 clock divider
042965             0002*   
042965             0003*   ; start PRT timer
042965             0004*   ps_prt_start:
042965 21 00 00 00 0005*       ld hl,0
042969 22 A4 29 04 0006*       ld (ps_prt_irq_counter),hl
04296D 2A 62 29 04 0007*       ld hl,(ps_prt_reload)
042971 ED 29 84    0008*       out0 (TMR1_CTL+TMR_RES_LOW),l
042974 ED 21 85    0009*   	out0 (TMR1_CTL+TMR_RES_HIGH),h
042977             0010*   ; disable timer (in effect, reset it)
042977 3E 0E       0011*       ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_256 | RST_EN_1 | PRT_EN_0
042979 ED 39 83    0012*   	out0 (TMR1_CTL+TMR_REG_CTL),a
04297C             0013*   ; enable timer,with interrupt and CONTINUOUS mode,clock divider 256
04297C 3E 5F       0014*       ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_256 | RST_EN_1 | PRT_EN_1
04297E ED 39 83    0015*   	out0 (TMR1_CTL+TMR_REG_CTL),a
042981 C9          0016*       ret
042982             0017*   
042982             0018*   ; stop PRT timer
042982             0019*   ps_prt_stop:
042982 3E 0E       0020*       ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_256 | RST_EN_1 | PRT_EN_0
042984 ED 39 83    0021*   	out0 (TMR1_CTL+TMR_REG_CTL),a
042987 C9          0022*       ret
042988             0023*   
042988             0024*   ; ===============================================
042988             0025*   ; PRT Timer Interrupt Handling
042988             0026*   ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.asm
042988             0027*   ; -----------------------------------------------
042988             0028*   ps_prt_irq_init:
042988             0029*       ; set up interrupt vector table 2
042988 21 00 00 00 0030*   	ld hl,0
04298C 3A 0C 01 00 0031*   	ld a,($10c)
042990 6F          0032*   	ld l,a
042991 3A 0D 01 00 0033*   	ld a,($10d)
042995 67          0034*   	ld h,a
042996             0035*   
042996             0036*   	; skip over CALL ($c3)
042996 23          0037*   	inc hl
042997             0038*   	; load address of jump into vector table 2 (in ram)
042997 ED 27       0039*   	ld hl,(hl)
042999             0040*   
042999             0041*   	; write CALL ps_prt_irq_handler to vector table 2
042999 3E C3       0042*   	ld a,$c3
04299B 77          0043*   	ld (hl),a
04299C 23          0044*   	inc hl
04299D 11 A5 29 04 0045*   	ld de,ps_prt_irq_handler
0429A1 ED 1F       0046*   	ld (hl),de
0429A3             0047*   
0429A3 C9          0048*       ret
0429A4             0049*   ; end ps_prt_irq_init
0429A4             0050*   
0429A4             0051*   ; interrupt routine for playing the next sample
0429A4             0052*   ps_prt_irq_counter:
0429A4 00          0053*   	db 0
0429A5             0054*   ps_prt_irq_handler:
0429A5 F3          0055*       di
0429A6 08          0056*       ex af,af'
0429A7 D9          0057*       exx
0429A8             0058*   ; clear sysvar_keyascii
0429A8             0059*   	MOSCALL mos_sysvars
0429A8 3E 08       0001*M1 			LD	A, function
0429AA 5B CF       0002*M1 			RST.LIL	08h
0429AC AF          0060*   	xor a
0429AD DD 77 05    0061*   	ld (IX+sysvar_keyascii),a
0429B0             0062*   ; read the timer interrupt and bump the counter
0429B0 ED 38 83    0063*       in0 a,(TMR1_CTL+TMR_REG_CTL)
0429B3 3A A4 29 04 0064*       ld a,(ps_prt_irq_counter)
0429B7 3C          0065*       inc a
0429B8 E6 01       0066*       and 1 ; modulo 2
0429BA 32 A4 29 04 0067*       ld (ps_prt_irq_counter),a
0429BE             0068*   ; if counter zero, play the next sample
0429BE CC 9A 26 04 0069*       call z,ps_play_sample
0429C2 D9          0070*       exx
0429C3 08          0071*       ex af,af'
0429C4 FB          0072*       ei
0429C5 5B ED 4D    0073*       reti.l
0429C8             0074*   ; end ps_prt_irq_handler
0429C8             0053        include "wav.inc"
0429C8             0001*   ; WAV File Structure Offsets and Descriptions
0429C8             0002*   wav_riff:          EQU 0    ; 4 bytes: "RIFF" identifier
0429C8             0003*   wav_file_size:     EQU 4    ; 4 bytes: Total file size minus 8 bytes for RIFF header
0429C8             0004*   wav_wave:          EQU 8    ; 4 bytes: "WAVE" identifier
0429C8             0005*   wav_fmt_marker:    EQU 12   ; 4 bytes: "fmt " subchunk marker
0429C8             0006*   wav_fmt_size:      EQU 16   ; 4 bytes: Format chunk size (16 for PCM)
0429C8             0007*   wav_audio_format:  EQU 20   ; 2 bytes: Audio format (1 = PCM)
0429C8             0008*   wav_num_channels:  EQU 22   ; 2 bytes: Number of channels (1 = mono, 2 = stereo)
0429C8             0009*   wav_sample_rate:   EQU 24   ; 4 bytes: Sample rate in Hz (e.g., 32768)
0429C8             0010*   wav_byte_rate:     EQU 28   ; 4 bytes: Bytes per second (SampleRate * NumChannels * BitsPerSample / 8)
0429C8             0011*   wav_block_align:   EQU 32   ; 2 bytes: Bytes per sample block (NumChannels * BitsPerSample / 8)
0429C8             0012*   wav_bits_per_sample: EQU 34 ; 2 bytes: Bits per sample (e.g., 8 or 16)
0429C8             0013*   
0429C8             0014*   ; LIST Chunk (Extra Metadata)
0429C8             0015*   wav_list_marker:   EQU 36   ; 4 bytes: "LIST" marker
0429C8             0016*   wav_list_size:     EQU 40   ; 4 bytes: Size of the LIST chunk (e.g., 26)
0429C8             0017*   wav_info_marker:   EQU 44   ; 4 bytes: "INFO" marker
0429C8             0018*   wav_isft_marker:   EQU 48   ; 4 bytes: "ISFT" marker (software identifier)
0429C8             0019*   wav_isft_data:     EQU 52   ; 14 bytes: Software info string (e.g., "Lavf59.27.100")
0429C8             0020*   wav_isft_padding:  EQU 66   ; 2 bytes: Padding/NULL terminator for alignment
0429C8             0021*   
0429C8             0022*   ; Data Chunk
0429C8             0023*   wav_data_marker:   EQU 68   ; 4 bytes: "data" subchunk marker
0429C8             0024*   wav_data_size:     EQU 72   ; 4 bytes: Size of the audio data in bytes
0429C8             0025*   wav_data_start:    EQU 76   ; Start of audio data
0429C8             0026*   wav_header_size:   EQU wav_data_start ; Total Header Size: 76 bytes
0429C8             0054        include "debug.inc"
0429C8             0001*   printHexA:
0429C8 F5          0002*       push af
0429C9 C5          0003*       push bc
0429CA CD 9C 00 04 0004*       call printHex8
0429CE 3E 20       0005*       ld a,' '
0429D0 5B D7       0006*       rst.lil 10h
0429D2 C1          0007*       pop bc
0429D3 F1          0008*       pop af
0429D4 C9          0009*       ret
0429D5             0010*   
0429D5             0011*   printHexHL:
0429D5 F5          0012*       push af
0429D6 C5          0013*       push bc
0429D7 CD 96 00 04 0014*       call printHex16
0429DB 3E 20       0015*       ld a,' '
0429DD 5B D7       0016*       rst.lil 10h
0429DF C1          0017*       pop bc
0429E0 F1          0018*       pop af
0429E1 C9          0019*       ret
0429E2             0020*   
0429E2             0021*   printHexUHL:
0429E2 F5          0022*       push af
0429E3 C5          0023*       push bc
0429E4 CD 8E 00 04 0024*       call printHex24
0429E8 3E 20       0025*       ld a,' '
0429EA 5B D7       0026*       rst.lil 10h
0429EC C1          0027*       pop bc
0429ED F1          0028*       pop af
0429EE C9          0029*       ret
0429EF             0030*   
0429EF             0031*   printHexAUHL:
0429EF F5          0032*       push af
0429F0 C5          0033*       push bc
0429F1 CD 9C 00 04 0034*       call printHex8
0429F5 3E 2E       0035*       ld a,'.'
0429F7 5B D7       0036*       rst.lil 10h
0429F9 CD 8E 00 04 0037*       call printHex24
0429FD 3E 20       0038*       ld a,' '
0429FF 5B D7       0039*       rst.lil 10h
042A01 C1          0040*       pop bc
042A02 F1          0041*       pop af
042A03 C9          0042*       ret
042A04             0043*   
042A04             0044*   printHexABHL:
042A04             0045*   ; preserve registers
042A04 C5          0046*       push bc ; b will be ok c will not
042A05 F5          0047*       push af ; will get totally destroyed
042A06             0048*   ; print a
042A06 CD 9C 00 04 0049*       call printHex8
042A0A             0050*   ; print b
042A0A 78          0051*       ld a,b
042A0B CD 9C 00 04 0052*       call printHex8
042A0F             0053*   ; print hl
042A0F CD 96 00 04 0054*       call printHex16
042A13             0055*   ; restore registers
042A13 F1          0056*       pop af
042A14 C1          0057*       pop bc
042A15 C9          0058*       ret
042A16             0059*   
042A16             0060*   printHexBHL:
042A16             0061*   ; preserve registers
042A16 C5          0062*       push bc ; b will be ok c will not
042A17 F5          0063*       push af ; will get totally destroyed
042A18             0064*   ; print b
042A18 78          0065*       ld a,b
042A19 CD 9C 00 04 0066*       call printHex8
042A1D             0067*   ; print hl
042A1D CD 96 00 04 0068*       call printHex16
042A21             0069*   ; restore registers
042A21 F1          0070*       pop af
042A22 C1          0071*       pop bc
042A23 C9          0072*       ret
042A24             0073*   
042A24             0074*   printHexCDE:
042A24             0075*   ; preserve registers
042A24 C5          0076*       push bc ; b will be ok c will not
042A25 F5          0077*       push af ; will get totally destroyed
042A26             0078*   ; print c
042A26 79          0079*       ld a,c
042A27 CD 9C 00 04 0080*       call printHex8
042A2B             0081*   ; print de
042A2B EB          0082*       ex de,hl
042A2C CD 96 00 04 0083*       call printHex16
042A30 EB          0084*       ex de,hl
042A31             0085*   ; restore registers
042A31 F1          0086*       pop af
042A32 C1          0087*       pop bc
042A33 C9          0088*       ret
042A34             0089*   
042A34             0090*   printHexUIX:
042A34             0091*   ; store everything in scratch
042A34 22 23 03 04 0092*       ld (uhl),hl
042A38 ED 43 26 03 0093*       ld (ubc),bc
       04          
042A3D ED 53 29 03 0094*       ld (ude),de
       04          
042A42 DD 22 2C 03 0095*       ld (uix),ix
       04          
042A47 FD 22 2F 03 0096*       ld (uiy),iy
       04          
042A4C F5          0097*       push af ; fml
042A4D             0098*   
042A4D 21 BA 02 04 0099*       ld hl,str_ixu
042A51 CD 55 00 04 0100*       call printString
042A55 2A 2C 03 04 0101*       ld hl,(uix)
042A59 CD 8E 00 04 0102*       call printHex24
042A5D CD 6A 00 04 0103*       call printNewLine
042A61             0104*   
042A61             0105*   ; restore everything
042A61 2A 23 03 04 0106*       ld hl, (uhl)
042A65 ED 4B 26 03 0107*       ld bc, (ubc)
       04          
042A6A ED 5B 29 03 0108*       ld de, (ude)
       04          
042A6F DD 2A 2C 03 0109*       ld ix, (uix)
       04          
042A74 FD 2A 2F 03 0110*       ld iy, (uiy)
       04          
042A79 F1          0111*       pop af
042A7A             0112*   ; all done
042A7A C9          0113*       ret
042A7B             0114*   
042A7B             0115*   
042A7B             0116*   ; print registers to screen in hexidecimal format
042A7B             0117*   ; inputs: none
042A7B             0118*   ; outputs: values of every register printed to screen
042A7B             0119*   ;    values of each register in global scratch memory
042A7B             0120*   ; destroys: nothing
042A7B             0121*   stepRegistersHex:
042A7B             0122*   ; store everything in scratch
042A7B 22 23 03 04 0123*       ld (uhl),hl
042A7F ED 43 26 03 0124*       ld (ubc),bc
       04          
042A84 ED 53 29 03 0125*       ld (ude),de
       04          
042A89 DD 22 2C 03 0126*       ld (uix),ix
       04          
042A8E FD 22 2F 03 0127*       ld (uiy),iy
       04          
042A93 F5          0128*       push af ; fml
042A94 E1          0129*       pop hl ; thanks, zilog
042A95 22 20 03 04 0130*       ld (uaf),hl
042A99 F5          0131*       push af ; dammit
042A9A             0132*   
042A9A             0133*   ; home the cursor
042A9A             0134*       ; call vdu_home_cursor
042A9A             0135*   
042A9A             0136*   ; print each register
042A9A 21 A6 02 04 0137*       ld hl,str_afu
042A9E CD 55 00 04 0138*       call printString
042AA2 2A 20 03 04 0139*       ld hl,(uaf)
042AA6 CD 8E 00 04 0140*       call printHex24
042AAA CD 6A 00 04 0141*       call printNewLine
042AAE             0142*   
042AAE 21 AB 02 04 0143*       ld hl,str_hlu
042AB2 CD 55 00 04 0144*       call printString
042AB6 2A 23 03 04 0145*       ld hl,(uhl)
042ABA CD 8E 00 04 0146*       call printHex24
042ABE CD 6A 00 04 0147*       call printNewLine
042AC2             0148*   
042AC2 21 B0 02 04 0149*       ld hl,str_bcu
042AC6 CD 55 00 04 0150*       call printString
042ACA 2A 26 03 04 0151*       ld hl,(ubc)
042ACE CD 8E 00 04 0152*       call printHex24
042AD2 CD 6A 00 04 0153*       call printNewLine
042AD6             0154*   
042AD6 21 B5 02 04 0155*       ld hl,str_deu
042ADA CD 55 00 04 0156*       call printString
042ADE 2A 29 03 04 0157*       ld hl,(ude)
042AE2 CD 8E 00 04 0158*       call printHex24
042AE6 CD 6A 00 04 0159*       call printNewLine
042AEA             0160*   
042AEA 21 BA 02 04 0161*       ld hl,str_ixu
042AEE CD 55 00 04 0162*       call printString
042AF2 2A 2C 03 04 0163*       ld hl,(uix)
042AF6 CD 8E 00 04 0164*       call printHex24
042AFA CD 6A 00 04 0165*       call printNewLine
042AFE             0166*   
042AFE 21 BF 02 04 0167*       ld hl,str_iyu
042B02 CD 55 00 04 0168*       call printString
042B06 2A 2F 03 04 0169*       ld hl,(uiy)
042B0A CD 8E 00 04 0170*       call printHex24
042B0E CD 6A 00 04 0171*       call printNewLine
042B12             0172*   
042B12             0173*       ; call vsync
042B12             0174*   
042B12 CD 6A 00 04 0175*       call printNewLine
042B16             0176*   
042B16             0177*   ; check for right shift key and quit if pressed
042B16             0178*       MOSCALL mos_getkbmap
042B16 3E 1E       0001*M1 			LD	A, function
042B18 5B CF       0002*M1 			RST.LIL	08h
042B1A             0179*   @stayhere:
042B1A             0180*   ; 7 RightShift
042B1A DD CB 00 76 0181*       bit 6,(ix+0)
042B1E 20 02       0182*       jr nz,@RightShift
042B20 18 F8       0183*       jr @stayhere
042B22             0184*   @RightShift:
042B22 DD CB 0E 86 0185*       res 0,(ix+14) ; debounce the key (hopefully)
042B26 3E 80       0186*       ld a,%10000000
042B28             0187*       ; call multiPurposeDelay
042B28             0188*   
042B28             0189*   ; restore everything
042B28 2A 23 03 04 0190*       ld hl, (uhl)
042B2C ED 4B 26 03 0191*       ld bc, (ubc)
       04          
042B31 ED 5B 29 03 0192*       ld de, (ude)
       04          
042B36 DD 2A 2C 03 0193*       ld ix, (uix)
       04          
042B3B FD 2A 2F 03 0194*       ld iy, (uiy)
       04          
042B40 F1          0195*       pop af
042B41             0196*   ; all done
042B41 C9          0197*       ret
042B42             0198*   
042B42             0199*   ; print registers to screen in hexidecimal format
042B42             0200*   ; inputs: none
042B42             0201*   ; outputs: values of every register printed to screen
042B42             0202*   ;    values of each register in global scratch memory
042B42             0203*   ; destroys: nothing
042B42             0204*   dumpRegistersHex:
042B42             0205*   ; store everything in scratch
042B42 22 23 03 04 0206*       ld (uhl),hl
042B46 ED 43 26 03 0207*       ld (ubc),bc
       04          
042B4B ED 53 29 03 0208*       ld (ude),de
       04          
042B50 DD 22 2C 03 0209*       ld (uix),ix
       04          
042B55 FD 22 2F 03 0210*       ld (uiy),iy
       04          
042B5A F5          0211*       push af ; fml
042B5B E1          0212*       pop hl ; thanks, zilog
042B5C 22 20 03 04 0213*       ld (uaf),hl
042B60 F5          0214*       push af ; dammit
042B61             0215*   
042B61             0216*   ; home the cursor
042B61             0217*       ; call vdu_home_cursor
042B61             0218*       ; call printNewLine
042B61             0219*   
042B61             0220*   ; print each register
042B61 21 A6 02 04 0221*       ld hl,str_afu
042B65 CD 55 00 04 0222*       call printString
042B69 2A 20 03 04 0223*       ld hl,(uaf)
042B6D CD 8E 00 04 0224*       call printHex24
042B71 CD 6A 00 04 0225*       call printNewLine
042B75             0226*   
042B75 21 AB 02 04 0227*       ld hl,str_hlu
042B79 CD 55 00 04 0228*       call printString
042B7D 2A 23 03 04 0229*       ld hl,(uhl)
042B81 CD 8E 00 04 0230*       call printHex24
042B85 CD 6A 00 04 0231*       call printNewLine
042B89             0232*   
042B89 21 B0 02 04 0233*       ld hl,str_bcu
042B8D CD 55 00 04 0234*       call printString
042B91 2A 26 03 04 0235*       ld hl,(ubc)
042B95 CD 8E 00 04 0236*       call printHex24
042B99 CD 6A 00 04 0237*       call printNewLine
042B9D             0238*   
042B9D 21 B5 02 04 0239*       ld hl,str_deu
042BA1 CD 55 00 04 0240*       call printString
042BA5 2A 29 03 04 0241*       ld hl,(ude)
042BA9 CD 8E 00 04 0242*       call printHex24
042BAD CD 6A 00 04 0243*       call printNewLine
042BB1             0244*   
042BB1 21 BA 02 04 0245*       ld hl,str_ixu
042BB5 CD 55 00 04 0246*       call printString
042BB9 2A 2C 03 04 0247*       ld hl,(uix)
042BBD CD 8E 00 04 0248*       call printHex24
042BC1 CD 6A 00 04 0249*       call printNewLine
042BC5             0250*   
042BC5 21 BF 02 04 0251*       ld hl,str_iyu
042BC9 CD 55 00 04 0252*       call printString
042BCD 2A 2F 03 04 0253*       ld hl,(uiy)
042BD1 CD 8E 00 04 0254*       call printHex24
042BD5             0255*   
042BD5 CD 6A 00 04 0256*       call printNewLine
042BD9 CD 6A 00 04 0257*       call printNewLine
042BDD             0258*   ; restore everything
042BDD 2A 23 03 04 0259*       ld hl, (uhl)
042BE1 ED 4B 26 03 0260*       ld bc, (ubc)
       04          
042BE6 ED 5B 29 03 0261*       ld de, (ude)
       04          
042BEB DD 2A 2C 03 0262*       ld ix, (uix)
       04          
042BF0 FD 2A 2F 03 0263*       ld iy, (uiy)
       04          
042BF5 F1          0264*       pop af
042BF6             0265*   ; all done
042BF6 C9          0266*       ret
042BF7             0267*   
042BF7             0268*   dumpRegistersHexPrime:
042BF7 D9          0269*       exx
042BF8 08          0270*       ex af,af'
042BF9 CD 42 2B 04 0271*       call dumpRegistersHex
042BFD 08          0272*       ex af,af'
042BFE D9          0273*       exx
042BFF C9          0274*       ret
042C00             0275*   
042C00             0276*   ; additionally dump prime registers
042C00             0277*   ; inputs: none
042C00             0278*   ; outputs: values of every register printed to screen
042C00             0279*   ; destroys: nothing
042C00             0280*   dumpRegistersHexAll:
042C00 CD 42 2B 04 0281*       call dumpRegistersHex
042C04 08          0282*       ex af,af'
042C05 D9          0283*       exx
042C06 CD 42 2B 04 0284*       call dumpRegistersHex
042C0A 08          0285*       ex af,af'
042C0B D9          0286*       exx
042C0C C9          0287*       ret
042C0D             0288*   
042C0D             0289*   ; print hlu to screen in hexidecimal format
042C0D             0290*   ; inputs: none
042C0D             0291*   ; destroys: nothing
042C0D             0292*   print_hex_hl:
042C0D F5          0293*       push af
042C0E E5          0294*       push hl
042C0F 21 AB 02 04 0295*       ld hl,str_hlu
042C13 CD 55 00 04 0296*       call printString
042C17 E1          0297*       pop hl
042C18 E5          0298*       push hl
042C19 CD 8E 00 04 0299*       call printHex24
042C1D 3E 20       0300*       ld a,' '
042C1F 5B D7       0301*       rst.lil 10h
042C21 E1          0302*       pop hl
042C22 F1          0303*       pop af
042C23 C9          0304*       ret
042C24             0305*   
042C24             0306*   ; print bcu to screen in hexidecimal format
042C24             0307*   ; inputs: none
042C24             0308*   ; destroys: nothing
042C24             0309*   print_hex_bc:
042C24 F5          0310*       push af
042C25 E5          0311*       push hl
042C26 C5          0312*       push bc
042C27 21 B0 02 04 0313*       ld hl,str_bcu
042C2B CD 55 00 04 0314*       call printString
042C2F E1          0315*       pop hl
042C30 E5          0316*       push hl
042C31 CD 8E 00 04 0317*       call printHex24
042C35 3E 20       0318*       ld a,' '
042C37 5B D7       0319*       rst.lil 10h
042C39 C1          0320*       pop bc
042C3A E1          0321*       pop hl
042C3B F1          0322*       pop af
042C3C C9          0323*       ret
042C3D             0324*   
042C3D             0325*   ; print deu to screen in hexidecimal format
042C3D             0326*   ; inputs: none
042C3D             0327*   ; destroys: nothing
042C3D             0328*   print_hex_de:
042C3D F5          0329*       push af
042C3E E5          0330*       push hl
042C3F D5          0331*       push de
042C40 21 B5 02 04 0332*       ld hl,str_deu
042C44 CD 55 00 04 0333*       call printString
042C48 E1          0334*       pop hl
042C49 E5          0335*       push hl
042C4A CD 8E 00 04 0336*       call printHex24
042C4E 3E 20       0337*       ld a,' '
042C50 5B D7       0338*       rst.lil 10h
042C52 D1          0339*       pop de
042C53 E1          0340*       pop hl
042C54 F1          0341*       pop af
042C55 C9          0342*       ret
042C56             0343*   
042C56             0344*   
042C56             0345*   ; inputs: whatever is in the flags register
042C56             0346*   ; outputs: binary representation of flags
042C56             0347*   ;          with a header so we know which is what
042C56             0348*   ; destroys: nothing
042C56             0349*   ; preserves: everything
042C56             0350*   dumpFlags:
042C56             0351*   ; first we curse zilog for not giving direct access to flags
042C56 F5          0352*       push af ; this is so we can send it back unharmed
042C57 F5          0353*       push af ; this is so we can pop it to hl
042C58             0354*   ; store everything in scratch
042C58 22 23 03 04 0355*       ld (uhl),hl
042C5C ED 43 26 03 0356*       ld (ubc),bc
       04          
042C61 ED 53 29 03 0357*       ld (ude),de
       04          
042C66 DD 22 2C 03 0358*       ld (uix),ix
       04          
042C6B FD 22 2F 03 0359*       ld (uiy),iy
       04          
042C70             0360*   ; next we print the header
042C70 21 9C 2C 04 0361*       ld hl,@header
042C74 CD 55 00 04 0362*       call printString
042C78 E1          0363*       pop hl ; flags are now in l
042C79 7D          0364*       ld a,l ; flags are now in a
042C7A CD 5C 02 04 0365*       call printBin8
042C7E CD 6A 00 04 0366*       call printNewLine
042C82             0367*   ; restore everything
042C82 2A 23 03 04 0368*       ld hl, (uhl)
042C86 ED 4B 26 03 0369*       ld bc, (ubc)
       04          
042C8B ED 5B 29 03 0370*       ld de, (ude)
       04          
042C90 DD 2A 2C 03 0371*       ld ix, (uix)
       04          
042C95 FD 2A 2F 03 0372*       ld iy, (uiy)
       04          
042C9A F1          0373*       pop af ; send her home the way she came
042C9B C9          0374*       ret
042C9C             0375*   ; Bit 7 (S): Sign flag
042C9C             0376*   ; Bit 6 (Z): Zero flag
042C9C             0377*   ; Bit 5 (5): Reserved (copy of bit 5 of the result)
042C9C             0378*   ; Bit 4 (H): Half Carry flag
042C9C             0379*   ; Bit 3 (3): Reserved (copy of bit 3 of the result)
042C9C             0380*   ; Bit 2 (PV): Parity/Overflow flag
042C9C             0381*   ; Bit 1 (N): Subtract flag
042C9C             0382*   ; Bit 0 (C): Carry flag
042C9C 53 5A 78 48 0383*   @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
042CA7             0384*   
042CA7             0385*   
042CA7             0386*   ; print bytes from an address to the screen in hexidecimal format
042CA7             0387*   ; inputs: hl = address of first byte to print, a = number of bytes to print
042CA7             0388*   ; outputs: values of each byte printed to screen separated by spaces
042CA7             0389*   ; destroys: nothing
042CA7             0390*   dumpMemoryHex:
042CA7             0391*   ; save registers to the stack
042CA7 C5          0392*       push bc
042CA8 E5          0393*       push hl
042CA9 F5          0394*       push af
042CAA             0395*   
042CAA             0396*   ; print the address and separator
042CAA CD 8E 00 04 0397*       call printHex24
042CAE 3E 3A       0398*       ld a,':'
042CB0 5B D7       0399*       rst.lil 10h
042CB2 3E 20       0400*       ld a,' '
042CB4 5B D7       0401*       rst.lil 10h
042CB6             0402*   
042CB6             0403*   ; set b to be our loop counter
042CB6 F1          0404*       pop af
042CB7 47          0405*       ld b,a
042CB8 E1          0406*       pop hl
042CB9 E5          0407*       push hl
042CBA F5          0408*       push af
042CBB             0409*   @loop:
042CBB             0410*   ; print the byte
042CBB 7E          0411*       ld a,(hl)
042CBC CD 9C 00 04 0412*       call printHex8
042CC0             0413*   ; print a space
042CC0 3E 20       0414*       ld a,' '
042CC2 5B D7       0415*       rst.lil 10h
042CC4 23          0416*       inc hl
042CC5 10 F4       0417*       djnz @loop
042CC7 CD 6A 00 04 0418*       call printNewLine
042CCB             0419*   
042CCB             0420*   ; restore everything
042CCB F1          0421*       pop af
042CCC E1          0422*       pop hl
042CCD C1          0423*       pop bc
042CCE             0424*   
042CCE             0425*   ; all done
042CCE C9          0426*       ret
042CCF             0427*   
042CCF             0428*   
042CCF             0429*   ; print bytes from an address to the screen in binary format
042CCF             0430*   ; inputs: hl = address of first byte to print, a = number of bytes to print
042CCF             0431*   ; outputs: values of each byte printed to screen separated by spaces
042CCF             0432*   ; destroys: nothing
042CCF             0433*   dumpMemoryBin:
042CCF             0434*   ; save all registers to the stack
042CCF F5          0435*       push af
042CD0 C5          0436*       push bc
042CD1 D5          0437*       push de
042CD2 E5          0438*       push hl
042CD3 DD E5       0439*       push ix
042CD5 FD E5       0440*       push iy
042CD7             0441*   
042CD7             0442*   ; set b to be our loop counter
042CD7 47          0443*       ld b,a
042CD8             0444*   @loop:
042CD8             0445*   ; print the byte
042CD8 7E          0446*       ld a,(hl)
042CD9 E5          0447*       push hl
042CDA C5          0448*       push bc
042CDB CD 5C 02 04 0449*       call printBin8
042CDF C1          0450*       pop bc
042CE0             0451*   ; print a space
042CE0 3E 20       0452*       ld a,' '
042CE2 5B D7       0453*       rst.lil 10h
042CE4 E1          0454*       pop hl
042CE5 23          0455*       inc hl
042CE6 10 F0       0456*       djnz @loop
042CE8 CD 6A 00 04 0457*       call printNewLine
042CEC             0458*   
042CEC             0459*   ; restore everything
042CEC FD E1       0460*       pop iy
042CEE DD E1       0461*       pop ix
042CF0 E1          0462*       pop hl
042CF1 D1          0463*       pop de
042CF2 C1          0464*       pop bc
042CF3 F1          0465*       pop af
042CF4             0466*   ; all done
042CF4 C9          0467*       ret
042CF5             0468*   
042CF5             0469*   ; print bytes from an address to the screen in binary format
042CF5             0470*   ; with the bits of each byte in reverse order (lsb first)
042CF5             0471*   ; inputs: hl = address of first byte to print, a = number of bytes to print
042CF5             0472*   ; outputs: values of each byte printed to screen separated by spaces
042CF5             0473*   ; destroys: nothing
042CF5             0474*   dumpMemoryBinRev:
042CF5             0475*   ; save all registers to the stack
042CF5 F5          0476*       push af
042CF6 C5          0477*       push bc
042CF7 D5          0478*       push de
042CF8 E5          0479*       push hl
042CF9 DD E5       0480*       push ix
042CFB FD E5       0481*       push iy
042CFD             0482*   
042CFD             0483*   ; set b to be our loop counter
042CFD 47          0484*       ld b,a
042CFE             0485*   @loop:
042CFE             0486*   ; print the byte
042CFE 7E          0487*       ld a,(hl)
042CFF E5          0488*       push hl
042D00 C5          0489*       push bc
042D01 CD 81 02 04 0490*       call printBin8Rev
042D05 C1          0491*       pop bc
042D06             0492*   ; print a space
042D06 3E 20       0493*       ld a,' '
042D08 5B D7       0494*       rst.lil 10h
042D0A E1          0495*       pop hl
042D0B 23          0496*       inc hl
042D0C 10 F0       0497*       djnz @loop
042D0E CD 6A 00 04 0498*       call printNewLine
042D12             0499*   
042D12             0500*   ; restore everything
042D12 FD E1       0501*       pop iy
042D14 DD E1       0502*       pop ix
042D16 E1          0503*       pop hl
042D17 D1          0504*       pop de
042D18 C1          0505*       pop bc
042D19 F1          0506*       pop af
042D1A             0507*   ; all done
042D1A C9          0508*       ret
042D1B             0509*   
042D1B             0510*   DEBUG_PRINT:
042D1B             0511*       PUSH_ALL
042D1B 08          0001*M1     ex af,af'
042D1C D9          0002*M1     exx
042D1D F5          0003*M1     push af
042D1E E5          0004*M1     push hl
042D1F C5          0005*M1     push bc
042D20 D5          0006*M1     push de
042D21             0007*M1 
042D21 08          0008*M1     ex af,af'
042D22 D9          0009*M1     exx
042D23 F5          0010*M1     push af
042D24 E5          0011*M1     push hl
042D25 C5          0012*M1     push bc
042D26 D5          0013*M1     push de
042D27 DD E5       0014*M1     push ix
042D29 FD E5       0015*M1     push iy
042D2B             0512*       ; ld c,0 ; X
042D2B             0513*       ; ld b,0 ; Y
042D2B             0514*       ; call vdu_move_cursor
042D2B CD 6A 00 04 0515*       call printNewLine
042D2F             0516*       POP_ALL
042D2F FD E1       0001*M1     pop iy
042D31 DD E1       0002*M1     pop ix
042D33 D1          0003*M1     pop de
042D34 C1          0004*M1     pop bc
042D35 E1          0005*M1     pop hl
042D36 F1          0006*M1     pop af
042D37 08          0007*M1     ex af,af'
042D38 D9          0008*M1     exx
042D39             0009*M1 
042D39 D1          0010*M1     pop de
042D3A C1          0011*M1     pop bc
042D3B E1          0012*M1     pop hl
042D3C F1          0013*M1     pop af
042D3D 08          0014*M1     ex af,af'
042D3E D9          0015*M1     exx
042D3F             0517*       PUSH_ALL
042D3F 08          0001*M1     ex af,af'
042D40 D9          0002*M1     exx
042D41 F5          0003*M1     push af
042D42 E5          0004*M1     push hl
042D43 C5          0005*M1     push bc
042D44 D5          0006*M1     push de
042D45             0007*M1 
042D45 08          0008*M1     ex af,af'
042D46 D9          0009*M1     exx
042D47 F5          0010*M1     push af
042D48 E5          0011*M1     push hl
042D49 C5          0012*M1     push bc
042D4A D5          0013*M1     push de
042D4B DD E5       0014*M1     push ix
042D4D FD E5       0015*M1     push iy
042D4F CD 56 2C 04 0518*       call dumpFlags
042D53             0519*       POP_ALL
042D53 FD E1       0001*M1     pop iy
042D55 DD E1       0002*M1     pop ix
042D57 D1          0003*M1     pop de
042D58 C1          0004*M1     pop bc
042D59 E1          0005*M1     pop hl
042D5A F1          0006*M1     pop af
042D5B 08          0007*M1     ex af,af'
042D5C D9          0008*M1     exx
042D5D             0009*M1 
042D5D D1          0010*M1     pop de
042D5E C1          0011*M1     pop bc
042D5F E1          0012*M1     pop hl
042D60 F1          0013*M1     pop af
042D61 08          0014*M1     ex af,af'
042D62 D9          0015*M1     exx
042D63             0520*       PUSH_ALL
042D63 08          0001*M1     ex af,af'
042D64 D9          0002*M1     exx
042D65 F5          0003*M1     push af
042D66 E5          0004*M1     push hl
042D67 C5          0005*M1     push bc
042D68 D5          0006*M1     push de
042D69             0007*M1 
042D69 08          0008*M1     ex af,af'
042D6A D9          0009*M1     exx
042D6B F5          0010*M1     push af
042D6C E5          0011*M1     push hl
042D6D C5          0012*M1     push bc
042D6E D5          0013*M1     push de
042D6F DD E5       0014*M1     push ix
042D71 FD E5       0015*M1     push iy
042D73 CD 42 2B 04 0521*       call dumpRegistersHex
042D77             0522*       ; call waitKeypress
042D77 CD 6A 00 04 0523*       call printNewLine
042D7B             0524*       POP_ALL
042D7B FD E1       0001*M1     pop iy
042D7D DD E1       0002*M1     pop ix
042D7F D1          0003*M1     pop de
042D80 C1          0004*M1     pop bc
042D81 E1          0005*M1     pop hl
042D82 F1          0006*M1     pop af
042D83 08          0007*M1     ex af,af'
042D84 D9          0008*M1     exx
042D85             0009*M1 
042D85 D1          0010*M1     pop de
042D86 C1          0011*M1     pop bc
042D87 E1          0012*M1     pop hl
042D88 F1          0013*M1     pop af
042D89 08          0014*M1     ex af,af'
042D8A D9          0015*M1     exx
042D8B C9          0525*       ret
042D8C             0526*   DEBUG_WAITKEYPRESS:
042D8C             0527*       PUSH_ALL
042D8C 08          0001*M1     ex af,af'
042D8D D9          0002*M1     exx
042D8E F5          0003*M1     push af
042D8F E5          0004*M1     push hl
042D90 C5          0005*M1     push bc
042D91 D5          0006*M1     push de
042D92             0007*M1 
042D92 08          0008*M1     ex af,af'
042D93 D9          0009*M1     exx
042D94 F5          0010*M1     push af
042D95 E5          0011*M1     push hl
042D96 C5          0012*M1     push bc
042D97 D5          0013*M1     push de
042D98 DD E5       0014*M1     push ix
042D9A FD E5       0015*M1     push iy
042D9C CD 48 03 04 0528*       call waitKeypress
042DA0             0529*       POP_ALL
042DA0 FD E1       0001*M1     pop iy
042DA2 DD E1       0002*M1     pop ix
042DA4 D1          0003*M1     pop de
042DA5 C1          0004*M1     pop bc
042DA6 E1          0005*M1     pop hl
042DA7 F1          0006*M1     pop af
042DA8 08          0007*M1     ex af,af'
042DA9 D9          0008*M1     exx
042DAA             0009*M1 
042DAA D1          0010*M1     pop de
042DAB C1          0011*M1     pop bc
042DAC E1          0012*M1     pop hl
042DAD F1          0013*M1     pop af
042DAE 08          0014*M1     ex af,af'
042DAF D9          0015*M1     exx
042DB0 C9          0530*       RET
042DB1             0531*   
042DB1             0532*   dumpVduCmdStr:
042DB1             0533*       PUSH_ALL
042DB1 08          0001*M1     ex af,af'
042DB2 D9          0002*M1     exx
042DB3 F5          0003*M1     push af
042DB4 E5          0004*M1     push hl
042DB5 C5          0005*M1     push bc
042DB6 D5          0006*M1     push de
042DB7             0007*M1 
042DB7 08          0008*M1     ex af,af'
042DB8 D9          0009*M1     exx
042DB9 F5          0010*M1     push af
042DBA E5          0011*M1     push hl
042DBB C5          0012*M1     push bc
042DBC D5          0013*M1     push de
042DBD DD E5       0014*M1     push ix
042DBF FD E5       0015*M1     push iy
042DC1 79          0534*       ld a,c
042DC2 CD A7 2C 04 0535*       call dumpMemoryHex
042DC6 CD 48 03 04 0536*       call waitKeypress
042DCA             0537*       POP_ALL
042DCA FD E1       0001*M1     pop iy
042DCC DD E1       0002*M1     pop ix
042DCE D1          0003*M1     pop de
042DCF C1          0004*M1     pop bc
042DD0 E1          0005*M1     pop hl
042DD1 F1          0006*M1     pop af
042DD2 08          0007*M1     ex af,af'
042DD3 D9          0008*M1     exx
042DD4             0009*M1 
042DD4 D1          0010*M1     pop de
042DD5 C1          0011*M1     pop bc
042DD6 E1          0012*M1     pop hl
042DD7 F1          0013*M1     pop af
042DD8 08          0014*M1     ex af,af'
042DD9 D9          0015*M1     exx
042DDA C9          0538*       ret
042DDB             0539*   ; end dumpVduCmdStr
042DDB             0055    
042DDB             0056    ; --- MAIN PROGRAM FILE ---
042DDB 00          0057    original_screen_mode: db 0
042DDC             0058    
042DDC             0059    init:
042DDC             0060    
042DDC C9          0061        ret
042DDD             0062    ; end init
042DDD             0063    
042DDD 63 64 20 6D 0064    cmd_cd_music: asciz "cd music"
       75 73 69 63 
       00          
042DE6 63 64 20 2E 0065    cmd_cd_up: asciz "cd .."
       2E 00       
042DEC 2D 2D 2D 2D 0066    str_dashes: asciz "---------------------------------------------------------------"
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 00 
042E2C 3D 3D 3D 3D 0067    str_thick_dashes: asciz "==============================================================="
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 00 
042E6C             0068    
042E6C             0069    main:
042E6C 01 00 00 00 0070        ld bc,0
042E70 ED 73 B6 2E 0071        ld (@stack_pointer),sp
       04          
042E75 2A B6 2E 04 0072        ld hl,(@stack_pointer)
042E79 CD E2 29 04 0073        call printHexUHL
042E7D CD 6A 00 04 0074        call printNewLine
042E81 EB          0075        ex de,hl
042E82             0076    @loop:
042E82 03          0077        inc bc
042E83 C5          0078        push bc
042E84 ED 73 B6 2E 0079        ld (@stack_pointer),sp
       04          
042E89 2A B6 2E 04 0080        ld hl,(@stack_pointer)
042E8D CD E2 29 04 0081        call printHexUHL
042E91 CD 6A 00 04 0082        call printNewLine
042E95 B7          0083        or a ; clear carry
042E96 ED 52       0084        sbc hl,de
042E98             0085        SIGN_HLU
042E98 19          0001M1      add hl,de ; 1 cycle
042E99 B7          0002M1      or a ; clear flags ; 1 cycle
042E9A ED 52       0003M1      sbc hl,de ; 2 cycles
042E9C             0004M1      ; 4 cycles total
042E9C C2 82 2E 04 0086        jp nz,@loop
042EA0 2A B6 2E 04 0087        ld hl,(@stack_pointer)
042EA4 CD E2 29 04 0088        call printHexUHL
042EA8 C5          0089        push bc
042EA9 E1          0090        pop hl
042EAA CD E2 29 04 0091        call printHexUHL
042EAE CD 6A 00 04 0092        call printNewLine
042EB2 CD 8C 2D 04 0093        call DEBUG_WAITKEYPRESS
042EB6 00 00 00    0094    @stack_pointer: dl 0
042EB9             0095    ; end main
042EB9             0096    
042EB9             0097    ; must be final include in program so file data does not stomp on program code or other data
042EB9             0098        include "files.inc"
042EB9             0001*   ; THIS MUST BE LAST INCLUDE SO FILE DATA DOES NOT OVERWRITE OTHER CODE OR DATA
042EB9             0002*   
042EB9             0003*   ; buffer for loading files unrelated to audio
042EB9             0004*   ; e.g.: fonts, sprites, etc. (limited to 8k)
042EB9             0005*   filedata: equ 0xB7E000 ; address of onboard 8k sram
042EB9             0006*   
042EB9             0007*   ;     align 256 ; make things nice for indexing into especially ps_dir_fil_list
042EB9             0008*   ; ; buffer for sound data
042EB9             0009*   ps_wav_data_start: equ 0x050000 ;    equ $   ; (042E00) Start of audio data
042EB9             0010*   
042EB9             0011*   ; this list can grow as large as necessary to hold all the files in the directory
042EB9             0012*   ; each entry will be 256 bytes long, the max filename size MOS/FFS supports
042EB9             0013*   ps_dir_fil_list: equ 0x060000 ; equ ps_wav_data_start+65536 ; (052E00) max file data we can load in one chunk is 64k
