PC     Output      Line
040000             0001        assume adl=1
040000             0002        org 0x040000
040000 C3 45 00 04 0003        jp start
040004             0004        align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0005        db "MOS"
040043 00          0006        db 00h
040044 01          0007        db 01h
040045             0008    
040045             0009    start:
040045 F5          0010        push af
040046 C5          0011        push bc
040047 D5          0012        push de
040048 DD E5       0013        push ix
04004A FD E5       0014        push iy
04004C             0015    
04004C CD 15 1D 04 0016        call init
040050 CD 1E 1D 04 0017        call main
040054             0018    
040054             0019    exit:
040054 FD E1       0020        pop iy
040056 DD E1       0021        pop ix
040058 D1          0022        pop de
040059 C1          0023        pop bc
04005A F1          0024        pop af
04005B 21 00 00 00 0025        ld hl,0
04005F             0026    
04005F C9          0027        ret
040060             0028    
040060             0029    ; API INCLUDES
040060             0030        include "mos_api.inc"
040060             0001*   ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.inc
040060             0002*   ; Title:	AGON MOS - API for user projects
040060             0003*   ; Author:	Dean Belfield
040060             0004*   ;			Adapted for agon-ez80asm by Jeroen Venema
040060             0005*   ;			Added MOS error codes for return in HL
040060             0006*   ; Created:	03/08/2022
040060             0007*   ; Last Updated:	10/08/2023
040060             0008*   ;
040060             0009*   ; Modinfo:
040060             0010*   ; 05/08/2022:	Added mos_feof
040060             0011*   ; 09/08/2022:	Added system variables: cursorX, cursorY
040060             0012*   ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040060             0013*   ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040060             0014*   ; 24/09/2022:	Added mos_getError, mos_mkdir
040060             0015*   ; 13/10/2022:	Added mos_oscli
040060             0016*   ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040060             0017*   ; 04/03/2023:	Added sysvar_scrpixelIndex
040060             0018*   ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040060             0019*   ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040060             0020*   ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040060             0021*   ; 22/03/2023:	The VDP commands are now indexed from 0x80
040060             0022*   ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040060             0023*   ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040060             0024*   ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040060             0025*   ; 19/05/2023:	Added sysvar_scrMode
040060             0026*   ; 05/06/2023:	Added sysvar_rtcEnable
040060             0027*   ; 03/08/2023:	Added mos_setkbvector
040060             0028*   ; 10/08/2023:	Added mos_getkbmap
040060             0029*   
040060             0030*   ; VDP control (VDU 23, 0, n)
040060             0031*   ;
040060             0032*   vdp_gp:				EQU 80h
040060             0033*   vdp_keycode:		EQU 81h
040060             0034*   vdp_cursor:			EQU	82h
040060             0035*   vdp_scrchar:		EQU	83h
040060             0036*   vdp_scrpixel:		EQU	84h
040060             0037*   vdp_audio:			EQU	85h
040060             0038*   vdp_mode:			EQU	86h
040060             0039*   vdp_rtc:			EQU	87h
040060             0040*   vdp_keystate:		EQU	88h
040060             0041*   vdp_logicalcoords:	EQU	C0h
040060             0042*   vdp_terminalmode:	EQU	FFh
040060             0043*   
040060             0044*   ; MOS high level functions
040060             0045*   ;
040060             0046*   mos_getkey:			EQU	00h
040060             0047*   mos_load:			EQU	01h
040060             0048*   mos_save:			EQU	02h
040060             0049*   mos_cd:				EQU	03h
040060             0050*   mos_dir:			EQU	04h
040060             0051*   mos_del:			EQU	05h
040060             0052*   mos_ren:			EQU	06h
040060             0053*   mos_mkdir:			EQU	07h
040060             0054*   mos_sysvars:		EQU	08h
040060             0055*   mos_editline:		EQU	09h
040060             0056*   mos_fopen:			EQU	0Ah
040060             0057*   mos_fclose:			EQU	0Bh
040060             0058*   mos_fgetc:			EQU	0Ch
040060             0059*   mos_fputc:			EQU	0Dh
040060             0060*   mos_feof:			EQU	0Eh
040060             0061*   mos_getError:		EQU	0Fh
040060             0062*   mos_oscli:			EQU	10h
040060             0063*   mos_copy:			EQU	11h
040060             0064*   mos_getrtc:			EQU	12h
040060             0065*   mos_setrtc:			EQU	13h
040060             0066*   mos_setintvector:	EQU	14h
040060             0067*   mos_uopen:			EQU	15h
040060             0068*   mos_uclose:			EQU	16h
040060             0069*   mos_ugetc:			EQU	17h
040060             0070*   mos_uputc:			EQU	18h
040060             0071*   mos_getfil:			EQU	19h
040060             0072*   mos_fread:			EQU	1Ah
040060             0073*   mos_fwrite:			EQU	1Bh
040060             0074*   mos_flseek:			EQU	1Ch
040060             0075*   mos_setkbvector:	EQU	1Dh
040060             0076*   mos_getkbmap:		EQU	1Eh
040060             0077*   
040060             0078*   ; MOS program exit codes
040060             0079*   ;
040060             0080*   EXIT_OK:				EQU  0;	"OK",
040060             0081*   EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
040060             0082*   EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
040060             0083*   EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
040060             0084*   EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
040060             0085*   EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
040060             0086*   EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
040060             0087*   EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
040060             0088*   EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
040060             0089*   EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
040060             0090*   EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
040060             0091*   EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
040060             0092*   EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
040060             0093*   EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
040060             0094*   EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
040060             0095*   EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
040060             0096*   EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
040060             0097*   EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
040060             0098*   EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
040060             0099*   EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
040060             0100*   EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
040060             0101*   EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
040060             0102*   ; FatFS file access functions
040060             0103*   ;
040060             0104*   ffs_fopen:			EQU	80h
040060             0105*   ffs_fclose:			EQU	81h
040060             0106*   ffs_fread:			EQU	82h
040060             0107*   ffs_fwrite:			EQU	83h
040060             0108*   ffs_flseek:			EQU	84h
040060             0109*   ffs_ftruncate:		EQU	85h
040060             0110*   ffs_fsync:			EQU	86h
040060             0111*   ffs_fforward:		EQU	87h
040060             0112*   ffs_fexpand:		EQU	88h
040060             0113*   ffs_fgets:			EQU	89h
040060             0114*   ffs_fputc:			EQU	8Ah
040060             0115*   ffs_fputs:			EQU	8Bh
040060             0116*   ffs_fprintf:		EQU	8Ch
040060             0117*   ffs_ftell:			EQU	8Dh
040060             0118*   ffs_feof:			EQU	8Eh
040060             0119*   ffs_fsize:			EQU	8Fh
040060             0120*   ffs_ferror:			EQU	90h
040060             0121*   
040060             0122*   ; FatFS directory access functions
040060             0123*   ;
040060             0124*   ffs_dopen:			EQU	91h
040060             0125*   ffs_dclose:			EQU	92h
040060             0126*   ffs_dread:			EQU	93h
040060             0127*   ffs_dfindfirst:		EQU	94h
040060             0128*   ffs_dfindnext:		EQU	95h
040060             0129*   
040060             0130*   ; FatFS file and directory management functions
040060             0131*   ;
040060             0132*   ffs_stat:			EQU	96h
040060             0133*   ffs_unlink:			EQU	97h
040060             0134*   ffs_rename:			EQU	98h
040060             0135*   ffs_chmod:			EQU	99h
040060             0136*   ffs_utime:			EQU	9Ah
040060             0137*   ffs_mkdir:			EQU	9Bh
040060             0138*   ffs_chdir:			EQU	9Ch
040060             0139*   ffs_chdrive:		EQU	9Dh
040060             0140*   ffs_getcwd:			EQU	9Eh
040060             0141*   
040060             0142*   ; FatFS volume management and system configuration functions
040060             0143*   ;
040060             0144*   ffs_mount:			EQU	9Fh
040060             0145*   ffs_mkfs:			EQU	A0h
040060             0146*   ffs_fdisk:			EQU	A1h
040060             0147*   ffs_getfree:		EQU	A2h
040060             0148*   ffs_getlabel:		EQU	A3h
040060             0149*   ffs_setlabel:		EQU	A4h
040060             0150*   ffs_setcp:			EQU	A5h
040060             0151*   
040060             0152*   ; File access modes
040060             0153*   ;
040060             0154*   fa_read:			EQU	01h
040060             0155*   fa_write:			EQU	02h
040060             0156*   fa_open_existing:	EQU	00h
040060             0157*   fa_create_new:		EQU	04h
040060             0158*   fa_create_always:	EQU	08h
040060             0159*   fa_open_always:		EQU	10h
040060             0160*   fa_open_append:		EQU	30h
040060             0161*   
040060             0162*   ; System variable indexes for api_sysvars
040060             0163*   ; Index into _sysvars in globals.inc
040060             0164*   ;
040060             0165*   sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040060             0166*   sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
040060             0167*   sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040060             0168*   sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
040060             0169*   sysvar_cursorX:			EQU	07h	; 1: Cursor X position
040060             0170*   sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
040060             0171*   sysvar_scrchar:			EQU	09h	; 1: Character read from screen
040060             0172*   sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040060             0173*   sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040060             0174*   sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040060             0175*   sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
040060             0176*   sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
040060             0177*   sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
040060             0178*   sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
040060             0179*   sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
040060             0180*   sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040060             0181*   sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
040060             0182*   sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040060             0183*   sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
040060             0184*   sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
040060             0185*   sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
040060             0186*   sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
040060             0187*   sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
040060             0188*   sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
040060             0189*   sysvar_scrMode:			EQU	27h	; 1: Screen mode
040060             0190*   sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040060             0191*   
040060             0192*   ; Flags for the VPD protocol
040060             0193*   ;
040060             0194*   vdp_pflag_cursor:		EQU	00000001b
040060             0195*   vdp_pflag_scrchar:		EQU	00000010b
040060             0196*   vdp_pflag_point:		EQU	00000100b
040060             0197*   vdp_pflag_audio:		EQU	00001000b
040060             0198*   vdp_pflag_mode:			EQU	00010000b
040060             0199*   vdp_pflag_rtc:			EQU	00100000b
040060             0200*   
040060             0201*   ;
040060             0202*   ; FatFS structures
040060             0203*   ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040060             0204*   ;
040060             0205*   ; Object ID and allocation information (FFOBJID)
040060             0206*   ;
040060             0207*   ; Indexes into FFOBJID structure
040060             0208*   ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
040060             0209*   ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
040060             0210*   ffobjid_attr:		EQU	5	; 1: Object attribute
040060             0211*   ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040060             0212*   ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
040060             0213*   ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
040060             0214*   ;
040060             0215*   ; File object structure (FIL)
040060             0216*   ;
040060             0217*   ; Indexes into FIL structure
040060             0218*   fil_obj:		EQU 0	; 15: Object identifier
040060             0219*   fil_flag:		EQU	15 	;  1: File status flags
040060             0220*   fil_err:		EQU	16	;  1: Abort flag (error code)
040060             0221*   fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
040060             0222*   fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
040060             0223*   fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
040060             0224*   fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
040060             0225*   fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
040060             0226*   ;
040060             0227*   ; Directory object structure (DIR)
040060             0228*   ; Indexes into DIR structure
040060             0229*   dir_obj:		EQU  0	; 15: Object identifier
040060             0230*   dir_dptr:		EQU	15	;  4: Current read/write offset
040060             0231*   dir_clust:		EQU	19	;  4: Current cluster
040060             0232*   dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
040060             0233*   dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
040060             0234*   dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
040060             0235*   dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040060             0236*   ;
040060             0237*   ; File information structure (FILINFO)
040060             0238*   ;
040060             0239*   ; Indexes into FILINFO structure
040060             0240*   filinfo_fsize:		EQU 0	;   4: File size
040060             0241*   filinfo_fdate:		EQU	4	;   2: Modified date
040060             0242*   filinfo_ftime:		EQU	6	;   2: Modified time
040060             0243*   filinfo_fattrib:	EQU	8	;   1: File attribute
040060             0244*   filinfo_altname:	EQU	9	;  13: Alternative file name
040060             0245*   filinfo_fname:		EQU	22	; 256: Primary file name
040060             0246*   ;
040060             0247*   ; Macro for calling the API
040060             0248*   ; Parameters:
040060             0249*   ; - function: One of the function numbers listed above
040060             0250*   ;
040060             0251*   	MACRO	MOSCALL	function
040060             0252*   			LD	A, function
040060             0253*   			RST.LIL	08h
040060             0254*   	ENDMACRO
040060             0031        include "macros.inc"
040060             0001*   
040060             0002*   ; test the sign of HL
040060             0003*   ; inputs: HL obviously
040060             0004*   ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
040060             0005*   ; destroys: flags
040060             0006*       MACRO SIGN_HLU
040060             0007*       add hl,de ; 1 cycle
040060             0008*       or a ; clear flags ; 1 cycle
040060             0009*       sbc hl,de ; 2 cycles
040060             0010*       ; 4 cycles total
040060             0011*       ENDMACRO
040060             0012*   
040060             0013*   ; put the value in A into HLU
040060             0014*   ; affects: HLU
040060             0015*   ; destroys: nothing
040060             0016*   ; note: $ instead of @@ b/c anon labels deprecated in ez80asm
040060             0017*       MACRO A_TO_HLU
040060             0018*       xor a ; 1 cycle
040060             0019*       ld ($+8+1),hl ; 7 cycles
040060             0020*       ld ($+4+3),a ; 5 cycles
040060             0021*       ld hl,0x000000 ; 4 cycles
040060             0022*       ; 17 cycles total
040060             0023*       ENDMACRO
040060             0024*   
040060             0025*   ; alternative: https://discord.com/channels/1158535358624039014/1282290921815408681/1318315567102300220
040060             0026*   ; one cycle less but burns flags
040060             0027*       MACRO A_TO_HLU_ALT
040060             0028*       push hl ; 4 cycles
040060             0029*       ld hl,2 ; 4 cycles
040060             0030*       add hl,sp ; 1 cycle
040060             0031*       ld (hl),a ; 2 cycles
040060             0032*       pop hl ; 4 cycles
040060             0033*       ; 15 cycles total
040060             0034*       ENDMACRO
040060             0035*   
040060             0036*       MACRO hlu_mul256
040060             0037*       add hl,hl ; * 2
040060             0038*       add hl,hl ; * 4
040060             0039*       add hl,hl ; * 8
040060             0040*       add hl,hl ; * 16
040060             0041*       add hl,hl ; * 32
040060             0042*       add hl,hl ; * 64
040060             0043*       add hl,hl ; * 128
040060             0044*       add hl,hl ; * 256
040060             0045*       ENDMACRO
040060             0046*   
040060             0047*   ; https://discord.com/channels/1158535358624039014/1282290921815408681/1317793870070812715
040060             0048*       MACRO SRL_UHL
040060             0049*       dec sp ; 1 cycle
040060             0050*       push hl ; 4 cycles
040060             0051*       inc sp ; 1 cycle
040060             0052*       pop hl ; 4 cycles
040060             0053*       inc hl ; 1 cycle
040060             0054*       dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
040060             0055*       ; 13 cycles total
040060             0056*       ENDMACRO
040060             0057*   
040060             0058*       MACRO printChar char
040060             0059*       LD A, char
040060             0060*       RST.LIL 10h
040060             0061*       ENDMACRO
040060             0062*   
040060             0063*   ; Simulated call to subroutine at HL
040060             0064*   ; inputs: HL pointing to the subroutine address plus whatever the called function expects
040060             0065*   ; outputs: whatever the subroutine does, including HL and BC
040060             0066*   ; destroys: only what the subroutine does, but always BC
040060             0067*       MACRO CALL_HL
040060             0068*       ld bc,$+6 ; Address of first instruction after the jump
040060             0069*       push bc ; which constitutes the return address
040060             0070*       jp (hl) ; Jump to the address in HL
040060             0071*       ENDMACRO
040060             0072*   
040060             0073*   ; Simulated call to subroutine at IX
040060             0074*   ; inputs: IX pointing to the subroutine address plus whatever the called function expects
040060             0075*   ; outputs: whatever the subroutine does, including IX and BC
040060             0076*   ; destroys: only what the subroutine does, but always BC
040060             0077*       MACRO CALL_IX
040060             0078*       ld bc,$+6 ; Address of first instruction after the jump
040060             0079*       push bc ; which constitutes the return address
040060             0080*       jp (ix) ; Jump to the address in IX
040060             0081*       ENDMACRO
040060             0082*   
040060             0083*   ; Simulated call to soubroutinte at IY
040060             0084*   ; inputs: IY pointing to the subroutine address plus whatever the called function expects
040060             0085*   ; outputs: whatever the subroutine does, including IY and BC
040060             0086*   ; destroys: only what the subroutine does, but always BC
040060             0087*       MACRO CALL_IY
040060             0088*       ld bc,$+6 ; Address of first instruction after the jump
040060             0089*       push bc ; which constitutes the return address
040060             0090*       jp (iy) ; Jump to the address in IY
040060             0091*       ENDMACRO
040060             0092*   
040060             0093*   ; put the value in HLU into A
040060             0094*   ; destroys: af
040060             0095*       MACRO HLU_TO_A
040060             0096*       dec sp ; 1 cycle
040060             0097*       push hl ; 4 cycles
040060             0098*       inc sp ; 1 cycle
040060             0099*       pop af ; 4 cycles
040060             0100*       ; 10 cycles total
040060             0101*       ENDMACRO
040060             0102*   
040060             0103*       MACRO PUSH_ALL
040060             0104*       ex af,af'
040060             0105*       exx
040060             0106*       push af
040060             0107*       push hl
040060             0108*       push bc
040060             0109*       push de
040060             0110*   
040060             0111*       ex af,af'
040060             0112*       exx
040060             0113*       push af
040060             0114*       push hl
040060             0115*       push bc
040060             0116*       push de
040060             0117*       push ix
040060             0118*       push iy
040060             0119*       ENDMACRO
040060             0120*   
040060             0121*       MACRO POP_ALL
040060             0122*       pop iy
040060             0123*       pop ix
040060             0124*       pop de
040060             0125*       pop bc
040060             0126*       pop hl
040060             0127*       pop af
040060             0128*       ex af,af'
040060             0129*       exx
040060             0130*   
040060             0131*       pop de
040060             0132*       pop bc
040060             0133*       pop hl
040060             0134*       pop af
040060             0135*       ex af,af'
040060             0136*       exx
040060             0137*       ENDMACRO
040060             0032        include "functions.inc"
040060             0001*   ; Print a zero-terminated string inline with code, e.g.:
040060             0002*   ;
040060             0003*   ;    call printInline
040060             0004*   ;    ASCIZ "Hello, world!\r\n"
040060             0005*   ;
040060             0006*   ; Destroys: HL,AF
040060             0007*   printInline:
040060 E1          0008*       pop hl ; get the return address = pointer to start of string
040061 CD 67 00 04 0009*       call printString ; HL advances to end of string
040065 E5          0010*       push hl ; restore the return address = pointer to end of string
040066 C9          0011*       ret
040067             0012*   
040067             0013*   ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
040067             0014*   ; Print a zero-terminated string
040067             0015*   ; HL: Pointer to string
040067             0016*   ; returns: hl pointed to character after string terminator
040067             0017*   ; destroys: af, hl
040067             0018*   printString:
040067 C5          0019*       PUSH BC
040068 01 00 00 00 0020*       LD BC,0
04006C 3E 00       0021*       LD A,0
04006E 5B DF       0022*       RST.LIL 18h
040070 C1          0023*       POP BC
040071 C9          0024*       RET
040072             0025*   ; print a VDU sequence
040072             0026*   ; HL: Pointer to VDU sequence - <1 byte length> <data>
040072             0027*   sendVDUsequence:
040072 C5          0028*       PUSH BC
040073 01 00 00 00 0029*       LD BC, 0
040077 4E          0030*       LD C, (HL)
040078 5B DF       0031*       RST.LIL 18h
04007A C1          0032*       POP BC
04007B C9          0033*       RET
04007C             0034*   ; Print Newline sequence to VDP
04007C             0035*   ; destroys: nothing
04007C             0036*   printNewLine:
04007C F5          0037*       push af ; for some reason rst.lil 10h sets carry flag
04007D 3E 0D       0038*       LD A, '\r'
04007F 5B D7       0039*       RST.LIL 10h
040081 3E 0A       0040*       LD A, '\n'
040083 5B D7       0041*       RST.LIL 10h
040085 F1          0042*       pop af
040086 C9          0043*       RET
040087             0044*   
040087             0045*   ; print a zero-terminated string at a graphics coordinate
040087             0046*   ; Inputs: HL Pointer to string, BC,DE x,y position (in pixels)
040087             0047*   printStringGfx:
040087 E5          0048*       push hl ; preserve string pointer
040088             0049*   ; move graphics cursor to x,y location
040088 3E 44       0050*       ld a,plot_pt+mv_abs
04008A CD 70 16 04 0051*       call vdu_plot
04008E             0052*   ; print string
04008E E1          0053*       pop hl ; restore string pointer
04008F             0054*   @print_loop:
04008F 7E          0055*       ld a,(hl)
040090 B7          0056*       or a ; check for end of string
040091 C8          0057*       ret z ; if zero, we're done
040092 08          0058*       ex af,af' ; preserve character
040093 3E 05       0059*       ld a,5 ; VDU 5 char to gfx cursor
040095 5B D7       0060*       rst.lil 10h ; send it
040097 08          0061*       ex af,af' ; restore character
040098 5B D7       0062*       rst.lil 10h ; print character
04009A 23          0063*       inc hl
04009B C3 8F 00 04 0064*       jp @print_loop
04009F C9          0065*       ret
0400A0             0066*   ; end printStringGfx
0400A0             0067*   
0400A0             0068*   ; Print a 24-bit HEX number
0400A0             0069*   ; HLU: Number to print
0400A0             0070*   printHex24:
0400A0             0071*       HLU_TO_A
                       M1 Args: none
0400A0 3B          0001*M1     dec sp ; 1 cycle
0400A1 E5          0002*M1     push hl ; 4 cycles
0400A2 33          0003*M1     inc sp ; 1 cycle
0400A3 F1          0004*M1     pop af ; 4 cycles
0400A4             0005*M1     ; 10 cycles total
0400A4 CD AE 00 04 0072*       CALL printHex8
0400A8             0073*   ; Print a 16-bit HEX number
0400A8             0074*   ; HL: Number to print
0400A8             0075*   printHex16:
0400A8 7C          0076*       LD A,H
0400A9 CD AE 00 04 0077*       CALL printHex8
0400AD 7D          0078*       LD A,L
0400AE             0079*   ; Print an 8-bit HEX number
0400AE             0080*   ; A: Number to print
0400AE             0081*   printHex8:
0400AE 4F          0082*       LD C,A
0400AF 1F          0083*       RRA
0400B0 1F          0084*       RRA
0400B1 1F          0085*       RRA
0400B2 1F          0086*       RRA
0400B3 CD B8 00 04 0087*       CALL @F
0400B7 79          0088*       LD A,C
0400B8             0089*   @@:
0400B8 E6 0F       0090*       AND 0Fh
0400BA C6 90       0091*       ADD A,90h
0400BC 27          0092*       DAA
0400BD CE 40       0093*       ADC A,40h
0400BF 27          0094*       DAA
0400C0 5B D7       0095*       RST.LIL 10h
0400C2 C9          0096*       RET
0400C3             0097*   
0400C3             0098*   ; Print a 0x HEX prefix
0400C3             0099*   DisplayHexPrefix:
0400C3 3E 30       0100*       LD A, '0'
0400C5 5B D7       0101*       RST.LIL 10h
0400C7 3E 78       0102*       LD A, 'x'
0400C9 5B D7       0103*       RST.LIL 10h
0400CB C9          0104*       RET
0400CC             0105*   
0400CC             0106*       MACRO printDecBC
0400CC             0107*       push hl
0400CC             0108*       push bc
0400CC             0109*       pop hl
0400CC             0110*       call printDec
0400CC             0111*       pop hl
0400CC             0112*       ENDMACRO
0400CC             0113*   
0400CC             0114*       MACRO printDecDE
0400CC             0115*       push hl
0400CC             0116*       push de
0400CC             0117*       pop hl
0400CC             0118*       call printDec
0400CC             0119*       pop hl
0400CC             0120*       ENDMACRO
0400CC             0121*   
0400CC             0122*       MACRO printDecHL
0400CC             0123*       call printDec
0400CC             0124*       ENDMACRO
0400CC             0125*   
0400CC             0126*       MACRO printDecIX
0400CC             0127*       push hl
0400CC             0128*       push ix
0400CC             0129*       pop hl
0400CC             0130*       call printDec
0400CC             0131*       pop hl
0400CC             0132*       ENDMACRO
0400CC             0133*   
0400CC             0134*       MACRO printDecIY
0400CC             0135*       push hl
0400CC             0136*       push iy
0400CC             0137*       pop hl
0400CC             0138*       call printDec
0400CC             0139*       pop hl
0400CC             0140*       ENDMACRO
0400CC             0141*   
0400CC             0142*   
0400CC             0143*   ; Prints the right justified decimal value in HL without leading zeroes
0400CC             0144*   ; HL : Value to print
0400CC             0145*   ; preserves all registers and flags
0400CC             0146*   printDec:
0400CC             0147*   ; BEGIN MY CODE
0400CC             0148*   ; back up all the things
0400CC F5          0149*       push af
0400CD C5          0150*       push bc
0400CE D5          0151*       push de
0400CF E5          0152*       push hl
0400D0             0153*   ; END MY CODE
0400D0 11 F8 00 04 0154*       LD DE, _printDecBuffer
0400D4 CD 08 01 04 0155*       CALL u24_to_ascii
0400D8             0156*   ; BEGIN MY CODE
0400D8             0157*   ; replace leading zeroes with spaces
0400D8 21 F8 00 04 0158*       LD HL, _printDecBuffer
0400DC 06 07       0159*       ld B, 7 ; if HL was 0, we want to keep the final zero
0400DE             0160*   @loop:
0400DE 7E          0161*       LD A, (HL)
0400DF FE 30       0162*       CP '0'
0400E1 C2 EB 00 04 0163*       JP NZ, @done
0400E5 3E 20       0164*       LD A, ' '
0400E7 77          0165*       LD (HL), A
0400E8 23          0166*       INC HL
0400E9             0167*       ; CALL vdu_cursor_forward
0400E9 10 F3       0168*       DJNZ @loop
0400EB             0169*   @done:
0400EB             0170*   ; END MY CODE
0400EB 21 F8 00 04 0171*       LD HL, _printDecBuffer
0400EF CD 67 00 04 0172*       CALL printString
0400F3             0173*   ; BEGIN MY CODE
0400F3             0174*   ; restore all the things
0400F3 E1          0175*       pop hl
0400F4 D1          0176*       pop de
0400F5 C1          0177*       pop bc
0400F6 F1          0178*       pop af
0400F7             0179*   ; END MY CODE
0400F7 C9          0180*       RET
0400F8 00 00 00 00 0181*   _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040108             0182*   
040108             0183*   ; This routine converts the unsigned 24-bit value in HLU into its ASCII representation,
040108             0184*   ; starting to memory location pointing by DE, in decimal form and with leading zeroes
040108             0185*   ; so it will allways be 8 characters length
040108             0186*   ; HL : Value to convert to string
040108             0187*   ; DE : pointer to buffer, at least 8 byte + 0
040108             0188*   u24_to_ascii:
040108 01 80 69 67 0189*       LD BC,-10000000
04010C CD 3F 01 04 0190*       CALL @one_digit
040110 01 C0 BD F0 0191*       LD BC,-1000000
040114 CD 3F 01 04 0192*       CALL @one_digit
040118 01 60 79 FE 0193*       LD BC,-100000
04011C CD 3F 01 04 0194*       CALL @one_digit
040120 01 F0 D8 FF 0195*       LD BC,-10000
040124 CD 3F 01 04 0196*       CALL @one_digit
040128 01 18 FC FF 0197*       LD BC,-1000
04012C CD 3F 01 04 0198*       CALL @one_digit
040130 01 9C FF FF 0199*       LD BC,-100
040134 CD 3F 01 04 0200*       CALL @one_digit
040138 0E F6       0201*       LD C,-10
04013A CD 3F 01 04 0202*       CALL @one_digit
04013E 48          0203*       LD C,B
04013F             0204*   @one_digit:
04013F 3E 2F       0205*       LD A,'0'-1
040141             0206*   @divide_me:
040141 3C          0207*       INC A
040142 09          0208*       ADD HL,BC
040143 38 FC       0209*       JR C,@divide_me
040145 ED 42       0210*       SBC HL,BC
040147 12          0211*       LD (DE),A
040148 13          0212*       INC DE
040149 C9          0213*       RET
04014A             0214*   
04014A             0215*   print_u24:
04014A D5          0216*       push de
04014B E5          0217*       push hl
04014C 11 F8 00 04 0218*       ld de,_printDecBuffer
040150 CD 08 01 04 0219*       call u24_to_ascii
040154 21 F8 00 04 0220*       ld hl,_printDecBuffer
040158 CD 67 00 04 0221*       call printString
04015C 3E 20       0222*       ld a,' '
04015E 5B D7       0223*       rst.lil 10h
040160 E1          0224*       pop hl
040161 D1          0225*       pop de
040162 C9          0226*       ret
040163             0227*   
040163             0228*   ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
040163             0229*   ; HL : Value to convert to string (integer part in H, fractional part in L)
040163             0230*   ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
040163             0231*   u168_to_ascii:
040163             0232*   ; add a leading space to make room for sign flag if needed
040163 3E 20       0233*       ld a,' '
040165 12          0234*       ld (de),a
040166 13          0235*       inc de
040167             0236*   ; Convert integer part
040167 E5          0237*       push hl ; Save HL (we’ll need the fractional part later)
040168             0238*       ; call hlu_udiv256 ; Shift to get integer portion in HL
040168             0239*       SRL_UHL ; Shift to get integer portion in HL
                       M1 Args: none
040168 3B          0001*M1     dec sp ; 1 cycle
040169 E5          0002*M1     push hl ; 4 cycles
04016A 33          0003*M1     inc sp ; 1 cycle
04016B E1          0004*M1     pop hl ; 4 cycles
04016C 23          0005*M1     inc hl ; 1 cycle
04016D 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
04016F             0007*M1     ; 13 cycles total
04016F 01 F0 D8 FF 0240*       ld bc, -10000
040173 CD 96 01 04 0241*       call @one_int
040177 01 18 FC FF 0242*       ld bc, -1000
04017B CD 96 01 04 0243*       call @one_int
04017F 01 9C FF FF 0244*       ld bc, -100
040183 CD 96 01 04 0245*       call @one_int
040187 0E F6       0246*       ld c, -10
040189 CD 96 01 04 0247*       call @one_int
04018D 48          0248*       ld c, b
04018E CD 96 01 04 0249*       call @one_int
040192 C3 A1 01 04 0250*       jp @frac ; Jump to fractional part conversion
040196             0251*   @one_int:
040196 3E 2F       0252*       ld a, '0' - 1 ; Start ASCII character at '0'
040198             0253*   @divide_me:
040198 3C          0254*       inc a
040199 09          0255*       add hl, bc ; Accumulate until overflow
04019A 38 FC       0256*       jr c, @divide_me
04019C ED 42       0257*       sbc hl, bc ; Remove excess after overflow
04019E 12          0258*       ld (de), a ; Store ASCII digit
04019F 13          0259*       inc de
0401A0 C9          0260*       ret
0401A1             0261*   ; Convert fractional part
0401A1             0262*   @frac:
0401A1 3E 2E       0263*       ld a, '.' ; Decimal point
0401A3 12          0264*       ld (de), a
0401A4 13          0265*       inc de
0401A5 E1          0266*       pop hl ; Restore HL with original fraction
0401A6 06 03       0267*       ld b, 3 ; Loop counter for 3 fractional digits
0401A8             0268*   @frac_loop:
0401A8 26 0A       0269*       ld h, 10 ; Load multiplier for fractional part
0401AA ED 6C       0270*       mlt hl ; Multiply by 10, result in HL (H holds the integer part)
0401AC 3E 30       0271*       ld a, '0'
0401AE 84          0272*       add a, h ; Convert integer part to ASCII
0401AF 12          0273*       ld (de), a
0401B0 13          0274*       inc de
0401B1 10 F5       0275*       djnz @frac_loop ; Repeat for each fractional digit
0401B3             0276*   ; Add null terminator
0401B3 AF          0277*       xor a ; Null terminator
0401B4 12          0278*       ld (de), a
0401B5 C9          0279*       ret
0401B6             0280*   
0401B6             0281*   print_u168:
0401B6 D5          0282*       push de
0401B7 E5          0283*       push hl
0401B8 11 F8 00 04 0284*       ld de,_printDecBuffer
0401BC CD 63 01 04 0285*       call u168_to_ascii
0401C0 21 F8 00 04 0286*       ld hl,_printDecBuffer
0401C4 CD 67 00 04 0287*       call printString
0401C8 E1          0288*       pop hl
0401C9 D1          0289*       pop de
0401CA C9          0290*       ret
0401CB             0291*   
0401CB             0292*   ; signed version of u168_to_ascii
0401CB             0293*   s168_to_ascii:
0401CB D5          0294*       push de ; save starting address of buffer
0401CC CD 70 04 04 0295*       call hlu_abs
0401D0 F5          0296*       push af ; save sign flag
0401D1 CD 63 01 04 0297*       call u168_to_ascii
0401D5 F1          0298*       pop af ; restore sign flag
0401D6 D1          0299*       pop de ; restore starting address of buffer
0401D7 F0          0300*       ret p ; hlu was positive so nothing to do
0401D8 3E 2D       0301*       ld a,'-'
0401DA 12          0302*       ld (de),a
0401DB C9          0303*       ret
0401DC             0304*   
0401DC             0305*   print_s168:
0401DC D5          0306*       push de
0401DD E5          0307*       push hl
0401DE 11 F8 00 04 0308*       ld de,_printDecBuffer
0401E2 CD CB 01 04 0309*       call s168_to_ascii
0401E6 21 F8 00 04 0310*       ld hl,_printDecBuffer
0401EA CD 67 00 04 0311*       call printString
0401EE E1          0312*       pop hl
0401EF D1          0313*       pop de
0401F0 C9          0314*       ret
0401F1             0315*   
0401F1             0316*   print_s168_hl:
0401F1 F5          0317*       push af
0401F2 E5          0318*       push hl
0401F3 CD DC 01 04 0319*       call print_s168
0401F7 3E 20       0320*       ld a,' '
0401F9 5B D7       0321*       rst.lil 10h
0401FB E1          0322*       pop hl
0401FC F1          0323*       pop af
0401FD C9          0324*       ret
0401FE             0325*   
0401FE             0326*   print_s168_bc:
0401FE F5          0327*       push af
0401FF C5          0328*       push bc
040200 E5          0329*       push hl
040201 C5          0330*       push bc
040202 E1          0331*       pop hl
040203 CD DC 01 04 0332*       call print_s168
040207 3E 20       0333*       ld a,' '
040209 5B D7       0334*       rst.lil 10h
04020B E1          0335*       pop hl
04020C C1          0336*       pop bc
04020D F1          0337*       pop af
04020E C9          0338*       ret
04020F             0339*   
04020F             0340*   print_s168_de:
04020F F5          0341*       push af
040210 D5          0342*       push de
040211 E5          0343*       push hl
040212 EB          0344*       ex de,hl
040213 CD DC 01 04 0345*       call print_s168
040217 3E 20       0346*       ld a,' '
040219 5B D7       0347*       rst.lil 10h
04021B E1          0348*       pop hl
04021C D1          0349*       pop de
04021D F1          0350*       pop af
04021E C9          0351*       ret
04021F             0352*   
04021F             0353*   print_s168_hl_bc_de:
04021F F5          0354*       push af
040220 C5          0355*       push bc
040221 D5          0356*       push de
040222 E5          0357*       push hl
040223 CD DC 01 04 0358*       call print_s168
040227 3E 20       0359*       ld a,' '
040229 5B D7       0360*       rst.lil 10h
04022B C5          0361*       push bc
04022C E1          0362*       pop hl
04022D CD DC 01 04 0363*       call print_s168
040231 3E 20       0364*       ld a,' '
040233 5B D7       0365*       rst.lil 10h
040235 EB          0366*       ex de,hl
040236 CD DC 01 04 0367*       call print_s168
04023A 3E 20       0368*       ld a,' '
04023C 5B D7       0369*       rst.lil 10h
04023E E1          0370*       pop hl
04023F D1          0371*       pop de
040240 C1          0372*       pop bc
040241 F1          0373*       pop af
040242 C9          0374*       ret
040243             0375*   
040243             0376*   print_s168_bc_de:
040243 F5          0377*       push af
040244 C5          0378*       push bc
040245 D5          0379*       push de
040246 C5          0380*       push bc
040247 E1          0381*       pop hl
040248 CD DC 01 04 0382*       call print_s168
04024C 3E 20       0383*       ld a,' '
04024E 5B D7       0384*       rst.lil 10h
040250 EB          0385*       ex de,hl
040251 CD DC 01 04 0386*       call print_s168
040255 3E 20       0387*       ld a,' '
040257 5B D7       0388*       rst.lil 10h
040259 E1          0389*       pop hl
04025A D1          0390*       pop de
04025B C1          0391*       pop bc
04025C F1          0392*       pop af
04025D C9          0393*       ret
04025E             0394*   
04025E             0395*   print_s168_a:
04025E F5          0396*       push af
04025F C5          0397*       push bc
040260 E5          0398*       push hl
040261 21 00 00 00 0399*       ld hl,0
040265 6F          0400*       ld l,a
040266 CD F1 01 04 0401*       call print_s168_hl
04026A E1          0402*       pop hl
04026B C1          0403*       pop bc
04026C F1          0404*       pop af
04026D C9          0405*       ret
04026E             0406*   
04026E             0407*   ; #### new functions added by Brandon R. Gates ####
04026E             0408*   
04026E             0409*   ; print the binary representation of the 8-bit value in a
04026E             0410*   ; destroys a, hl, bc
04026E             0411*   printBin8:
04026E 06 08       0412*       ld b,8 ; loop counter for 8 bits
040270 21 8B 02 04 0413*       ld hl,@cmd ; set hl to the low byte of the output string
040274             0414*       ; (which will be the high bit of the value in a)
040274             0415*   @loop:
040274 07          0416*       rlca ; put the next highest bit into carry
040275 38 04       0417*       jr c,@one
040277 36 30       0418*       ld (hl),'0'
040279 18 02       0419*       jr @next_bit
04027B             0420*   @one:
04027B 36 31       0421*       ld (hl),'1'
04027D             0422*   @next_bit:
04027D 23          0423*       inc hl
04027E 10 F4       0424*       djnz @loop
040280             0425*   ; print it
040280 21 8B 02 04 0426*       ld hl,@cmd
040284 01 08 00 00 0427*       ld bc,@end-@cmd
040288 5B DF       0428*       rst.lil $18
04028A C9          0429*       ret
04028B             0430*   @cmd: ds 8 ; eight bytes for eight bits
040293             0431*   @end:
040293             0432*   
040293             0433*   ; print the binary representation of the 8-bit value in a
040293             0434*   ; in reverse order (lsb first)
040293             0435*   ; destroys a, hl, bc
040293             0436*   printBin8Rev:
       FF FF FF FF 
       FF FF FF FF 
040293 06 08       0437*       ld b,8 ; loop counter for 8 bits
040295 21 B0 02 04 0438*       ld hl,@cmd ; set hl to the low byte of the output string
040299             0439*       ; (which will be the high bit of the value in a)
040299             0440*   @loop:
040299 0F          0441*       rrca ; put the next lowest bit into carry
04029A 38 04       0442*       jr c,@one
04029C 36 30       0443*       ld (hl),'0'
04029E 18 02       0444*       jr @next_bit
0402A0             0445*   @one:
0402A0 36 31       0446*       ld (hl),'1'
0402A2             0447*   @next_bit:
0402A2 23          0448*       inc hl
0402A3 10 F4       0449*       djnz @loop
0402A5             0450*   ; print it
0402A5 21 B0 02 04 0451*       ld hl,@cmd
0402A9 01 08 00 00 0452*       ld bc,@end-@cmd
0402AD 5B DF       0453*       rst.lil $18
0402AF C9          0454*       ret
0402B0             0455*   @cmd: ds 8 ; eight bytes for eight bits
0402B8             0456*   @end:
0402B8             0457*   
       FF FF FF FF 
       FF FF FF FF 
0402B8 20 61 66 3D 0458*   str_afu: db " af=",0
       00          
0402BD 20 68 6C 3D 0459*   str_hlu: db " hl=",0
       00          
0402C2 20 62 63 3D 0460*   str_bcu: db " bc=",0
       00          
0402C7 20 64 65 3D 0461*   str_deu: db " de=",0
       00          
0402CC 20 69 78 3D 0462*   str_ixu: db " ix=",0
       00          
0402D1 20 69 79 3D 0463*   str_iyu: db " iy=",0
       00          
0402D6             0464*   
0402D6             0465*   ; print udeuhl to screen in hexidecimal format
0402D6             0466*   ; inputs: none
0402D6             0467*   ; outputs: concatenated hexidecimal udeuhl
0402D6             0468*   ; destroys: nothing
0402D6             0469*   dumpUDEUHLHex:
0402D6             0470*   ; store everything in scratch
0402D6 22 35 03 04 0471*       ld (uhl),hl
0402DA ED 43 38 03 0472*       ld (ubc),bc
       04          
0402DF ED 53 3B 03 0473*       ld (ude),de
       04          
0402E4 DD 22 3E 03 0474*       ld (uix),ix
       04          
0402E9 FD 22 41 03 0475*       ld (uiy),iy
       04          
0402EE F5          0476*       push af
0402EF             0477*   
0402EF             0478*   ; print each register
0402EF             0479*   
0402EF 21 29 03 04 0480*       ld hl,str_udeuhl
0402F3 CD 67 00 04 0481*       call printString
0402F7 2A 3B 03 04 0482*       ld hl,(ude)
0402FB CD A0 00 04 0483*       call printHex24
0402FF 3E 2E       0484*       ld a,'.' ; print a dot to separate the values
040301 5B D7       0485*       rst.lil 10h
040303 2A 35 03 04 0486*       ld hl,(uhl)
040307 CD A0 00 04 0487*       call printHex24
04030B CD 7C 00 04 0488*       call printNewLine
04030F             0489*   
04030F             0490*   ; restore everything
04030F 2A 35 03 04 0491*       ld hl, (uhl)
040313 ED 4B 38 03 0492*       ld bc, (ubc)
       04          
040318 ED 5B 3B 03 0493*       ld de, (ude)
       04          
04031D DD 2A 3E 03 0494*       ld ix, (uix)
       04          
040322 FD 2A 41 03 0495*       ld iy, (uiy)
       04          
040327 F1          0496*       pop af
040328             0497*   ; all done
040328 C9          0498*       ret
040329             0499*   
040329 75 64 65 2E 0500*   str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
040332             0501*   
040332             0502*   ; global scratch memory for registers
040332 00 00 00    0503*   uaf: dl 0
040335 00 00 00    0504*   uhl: dl 0
040338 00 00 00    0505*   ubc: dl 0
04033B 00 00 00    0506*   ude: dl 0
04033E 00 00 00    0507*   uix: dl 0
040341 00 00 00    0508*   uiy: dl 0
040344 00 00 00    0509*   usp: dl 0
040347 00 00 00    0510*   upc: dl 0
04034A             0511*   
04034A             0512*   
04034A             0513*   ; set all the bits in the flag register
04034A             0514*   ; more of an academic exercise than anything useful
04034A             0515*   ; inputs; none
04034A             0516*   ; outputs; a=0,f=255
04034A             0517*   ; destroys: flags, hl
04034A             0518*   ; preserves: a, because why not
04034A             0519*   setAllFlags:
04034A 21 FF 00 00 0520*       ld hl,255
04034E 67          0521*       ld h,a ; four cycles to preserve a is cheap
04034F E5          0522*       push hl
040350 F1          0523*       pop af
040351 C9          0524*       ret
040352             0525*   
040352             0526*   ; reset all the bits in the flag register
040352             0527*   ; unlike its inverse counterpart, this may actually be useful
040352             0528*   ; inputs; none
040352             0529*   ; outputs; a=0,f=0
040352             0530*   ; destroys: flags, hl
040352             0531*   ; preserves: a, because why not
040352             0532*   resetAllFlags:
040352 21 00 00 00 0533*       ld hl,0
040356 67          0534*       ld h,a ; four cycles to preserve a is cheap
040357 E5          0535*       push hl
040358 F1          0536*       pop af
040359 C9          0537*       ret
04035A             0538*   
04035A             0539*   ; wait until user presses a key
04035A             0540*   ; inputs: none
04035A             0541*   ; outputs: ascii code of key pressed in a
04035A             0542*   ; destroys: af,ix
04035A             0543*   waitKeypress:
04035A             0544*       MOSCALL mos_getkey
                       M1 Args: function=mos_getkey 
04035A 3E 00       0001*M1 			LD	A, function
04035C 5B CF       0002*M1 			RST.LIL	08h
04035E C9          0545*       ret
04035F             0546*   
04035F             0547*   ; clear a block of memory by writing a prescribed value to each byte in the range
04035F             0548*   ; inputs: a = value to write, hl = address of first byte, bc = number of bytes
04035F             0549*   ; outputs: memory block is cleared
04035F             0550*   ; destroys: hl, de
04035F             0551*   clear_mem:
04035F 0B          0552*       dec bc ; we do this because we will increment de before writing the first byte
040360 77          0553*       ld (hl),a
040361 E5          0554*       push hl
040362 D1          0555*       pop de
040363 13          0556*       inc de ; target address
040364 ED B0       0557*       ldir
040366 C9          0558*       ret
040367             0033        include "arith24.inc"
040367             0001*   ;------------------------------------------------------------------------
040367             0002*   ;  arith24.asm
040367             0003*   ;  24-bit ez80 arithmetic routines
040367             0004*   ;  Copyright (c) Shawn Sijnstra 2024
040367             0005*   ;  MIT license
040367             0006*   ;
040367             0007*   ;  This library was created as a tool to help make ez80
040367             0008*   ;  24-bit native assembly routines for simple mathematical problems
040367             0009*   ;  more widely available.
040367             0010*   ;
040367             0011*   ;------------------------------------------------------------------------
040367             0012*   
040367             0013*   ;------------------------------------------------------------------------
040367             0014*   ; umul24:	HL = HL*DE (unsigned)
040367             0015*   ; Preserves AF, BC, DE
040367             0016*   ; Uses a fast multiply routine.
040367             0017*   ;------------------------------------------------------------------------
040367             0018*   umul24:
040367 D5          0019*   	push	DE
040368 C5          0020*   	push	BC
040369 F5          0021*   	push	AF
04036A E5          0022*   	push	HL
04036B C1          0023*   	pop		BC
04036C 3E 18       0024*       ld	 	a, 24 ; No. of bits to process
04036E 21 00 00 00 0025*       ld	 	hl, 0 ; Result
040372             0026*   umul24_lp:
040372 29          0027*   	add	hl,hl
040373 EB          0028*   	ex	de,hl
040374 29          0029*   	add	hl,hl
040375 EB          0030*   	ex	de,hl
040376 30 01       0031*   	jr	nc,umul24_nc
040378 09          0032*   	add	hl,bc
040379             0033*   umul24_nc:
040379 3D          0034*   	dec	a
04037A 20 F6       0035*   	jr	nz,umul24_lp
04037C F1          0036*   	pop	af
04037D C1          0037*   	pop	bc
04037E D1          0038*   	pop	de
04037F C9          0039*   	ret
040380             0040*   
040380             0041*   
040380             0042*   ;------------------------------------------------------------------------
040380             0043*   ; udiv24
040380             0044*   ; Unsigned 24-bit division
040380             0045*   ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
040380             0046*   ;
040380             0047*   ; Uses AF BC DE HL
040380             0048*   ; Uses Restoring Division algorithm
040380             0049*   ;------------------------------------------------------------------------
040380             0050*   
040380             0051*   udiv24:
040380 E5          0052*   	push	hl
040381 C1          0053*   	pop		bc	;move dividend to BCU
040382 21 00 00 00 0054*   	ld		hl,0	;result
040386 A7          0055*   	and		a
040387 ED 52       0056*   	sbc		hl,de	;test for div by 0
040389 C8          0057*   	ret		z		;it's zero, carry flag is clear
04038A 19          0058*   	add		hl,de	;HL is 0 again
04038B 3E 18       0059*   	ld		a,24	;number of loops through.
04038D             0060*   udiv1:
04038D C5          0061*   	push	bc	;complicated way of doing this because of lack of access to top bits
04038E E3          0062*   	ex		(sp),hl
04038F 37          0063*   	scf
040390 ED 6A       0064*   	adc	hl,hl
040392 E3          0065*   	ex	(sp),hl
040393 C1          0066*   	pop	bc		;we now have bc = (bc * 2) + 1
040394             0067*   
040394 ED 6A       0068*   	adc	hl,hl
040396 A7          0069*   	and	a		;is this the bug
040397 ED 52       0070*   	sbc	hl,de
040399 30 02       0071*   	jr	nc,udiv2
04039B 19          0072*   	add	hl,de
04039C             0073*   ;	dec	c
04039C 0B          0074*   	dec	bc
04039D             0075*   udiv2:
04039D 3D          0076*   	dec	a
04039E 20 ED       0077*   	jr	nz,udiv1
0403A0 37          0078*   	scf		;flag used for div0 error
0403A1 C5          0079*   	push	bc
0403A2 D1          0080*   	pop		de	;remainder
0403A3 C9          0081*   	ret
0403A4             0082*   
0403A4             0083*   
0403A4             0084*   
0403A4             0085*   ;------------------------------------------------------------------------
0403A4             0086*   ; neg24
0403A4             0087*   ; Returns: HLU = 0-HLU
0403A4             0088*   ; preserves all other registers
0403A4             0089*   ;------------------------------------------------------------------------
0403A4             0090*   neg24:
0403A4 D5          0091*   	push	de
0403A5 EB          0092*   	ex		de,hl
0403A6 21 00 00 00 0093*   	ld		hl,0
0403AA B7          0094*   	or		a
0403AB ED 52       0095*   	sbc		hl,de
0403AD D1          0096*   	pop		de
0403AE C9          0097*   	ret
0403AF             0098*   
0403AF             0099*   ;------------------------------------------------------------------------
0403AF             0100*   ; or_hlu_deu: 24 bit bitwise OR
0403AF             0101*   ; Returns: hlu = hlu OR deu
0403AF             0102*   ; preserves all other registers
0403AF             0103*   ;------------------------------------------------------------------------
0403AF             0104*   or_hlu_deu:
0403AF 22 38 04 04 0105*   	ld	(bitbuf1),hl
0403B3 ED 53 3B 04 0106*   	ld	(bitbuf2),de
       04          
0403B8 D5          0107*   	push	de	;preserve DEU
0403B9 C5          0108*   	push	bc	;preserve BCU
0403BA 06 03       0109*   	ld		b,3
0403BC 21 38 04 04 0110*   	ld	hl,bitbuf1
0403C0 11 38 04 04 0111*   	ld	de,bitbuf1
0403C4             0112*   orloop_24:
0403C4 1A          0113*   	ld	a,(de)
0403C5 B6          0114*   	or	(hl)
0403C6 12          0115*   	ld	(de),a
0403C7 13          0116*   	inc	de
0403C8 23          0117*   	inc	hl
0403C9 10 F9       0118*   	djnz	orloop_24
0403CB 2A 3B 04 04 0119*   	ld	hl,(bitbuf2)
0403CF C1          0120*   	pop		bc	;restore BC
0403D0 D1          0121*   	pop		de	;restore DE
0403D1             0122*   
0403D1             0123*   ;------------------------------------------------------------------------
0403D1             0124*   ; and_hlu_deu: 24 bit bitwise AND
0403D1             0125*   ; Returns: hlu = hlu AND deu
0403D1             0126*   ; preserves all other registers
0403D1             0127*   ;------------------------------------------------------------------------
0403D1             0128*   and_hlu_deu:
0403D1 22 38 04 04 0129*   	ld	(bitbuf1),hl
0403D5 ED 53 3B 04 0130*   	ld	(bitbuf2),de
       04          
0403DA D5          0131*   	push	de	;preserve DEU
0403DB C5          0132*   	push	bc	;preserve BCU
0403DC 06 03       0133*   	ld		b,3
0403DE 21 38 04 04 0134*   	ld	hl,bitbuf1
0403E2 11 38 04 04 0135*   	ld	de,bitbuf1
0403E6             0136*   andloop_24:
0403E6 1A          0137*   	ld	a,(de)
0403E7 A6          0138*   	and	(hl)
0403E8 12          0139*   	ld	(de),a
0403E9 13          0140*   	inc	de
0403EA 23          0141*   	inc	hl
0403EB 10 F9       0142*   	djnz	andloop_24
0403ED 2A 3B 04 04 0143*   	ld	hl,(bitbuf2)
0403F1 C1          0144*   	pop		bc	;restore BC
0403F2 D1          0145*   	pop		de	;restore DE
0403F3             0146*   
0403F3             0147*   ;------------------------------------------------------------------------
0403F3             0148*   ; xor_hlu_deu: 24 bit bitwise XOR
0403F3             0149*   ; Returns: hlu = hlu XOR deu
0403F3             0150*   ; preserves all other registers
0403F3             0151*   ;------------------------------------------------------------------------
0403F3             0152*   xor_hlu_deu:
0403F3 22 38 04 04 0153*   	ld	(bitbuf1),hl
0403F7 ED 53 3B 04 0154*   	ld	(bitbuf2),de
       04          
0403FC D5          0155*   	push	de	;preserve DEU
0403FD C5          0156*   	push	bc	;preserve BCU
0403FE 06 03       0157*   	ld		b,3
040400 21 38 04 04 0158*   	ld	hl,bitbuf1
040404 11 38 04 04 0159*   	ld	de,bitbuf1
040408             0160*   xorloop_24:
040408 1A          0161*   	ld	a,(de)
040409 AE          0162*   	xor	(hl)
04040A 12          0163*   	ld	(de),a
04040B 13          0164*   	inc	de
04040C 23          0165*   	inc	hl
04040D 10 F9       0166*   	djnz	xorloop_24
04040F 2A 3B 04 04 0167*   	ld	hl,(bitbuf2)
040413 C1          0168*   	pop		bc	;restore BC
040414 D1          0169*   	pop		de	;restore DE
040415             0170*   
040415             0171*   ;------------------------------------------------------------------------
040415             0172*   ; shl_hlu: 24 bit shift left hlu by a positions
040415             0173*   ; Returns: hlu = hlu << a
040415             0174*   ;		   a = 0
040415             0175*   ; NOTE: only considers a up to 16 bits.
040415             0176*   ; preserves all other registers
040415             0177*   ; modified by Brandon R. Gates to use a instead of de
040415             0178*   ;------------------------------------------------------------------------
040415             0179*   shl_hlu:
040415 B7          0180*   	or a
040416 C8          0181*   	ret		z		;we're done
040417 29          0182*   	add		hl,hl	;shift HLU left
040418 3D          0183*   	dec a
040419 18 FA       0184*   	jr		shl_hlu
04041B             0185*   
04041B             0186*   ;------------------------------------------------------------------------
04041B             0187*   ; shr_hlu: 24 bit shift right hlu by a positions
04041B             0188*   ; Returns: hlu = hlu >> a
04041B             0189*   ;		   a = 0
04041B             0190*   ; NOTE: only considers a up to 16 bits.
04041B             0191*   ; preserves all other registers
04041B             0192*   ; modified by Brandon R. Gates to use a instead of de
04041B             0193*   ;------------------------------------------------------------------------
04041B             0194*   shr_hlu:
04041B 22 38 04 04 0195*   	ld		(bitbuf1),hl
04041F 21 3A 04 04 0196*   	ld		hl,bitbuf1+2
040423             0197*   @shr_loop:
040423 B7          0198*   	or a
040424 28 0D       0199*   	jr		z,@shr_done		;we're done
040426             0200*   ;carry is clear from or instruction
040426 CB 1E       0201*   	rr		(hl)
040428 2B          0202*   	dec		hl
040429 CB 1E       0203*   	rr		(hl)
04042B 2B          0204*   	dec		hl
04042C CB 1E       0205*   	rr		(hl)
04042E 23          0206*   	inc		hl
04042F 23          0207*   	inc		hl
040430 3D          0208*   	dec a
040431 18 F0       0209*   	jr		@shr_loop
040433             0210*   @shr_done:
040433 2A 38 04 04 0211*   	ld		hl,(bitbuf1)	;collect result
040437 C9          0212*   	ret
040438             0213*   
040438             0214*   ;------------------------------------------------------------------------
040438             0215*   ; Scratch area for calculations
040438             0216*   ;------------------------------------------------------------------------
040438 00 00 00    0217*   bitbuf1:	dw24	0	;bit manipulation buffer 1
04043B 00 00 00    0218*   bitbuf2:	dw24	0	;bit manipulation buffer 2
04043E             0219*   
04043E             0220*   ; -----------------------------------------------------------------------
04043E             0221*   ; Functions added by Brandon R. Gates
04043E             0222*   ; -----------------------------------------------------------------------
04043E             0223*   
04043E             0224*   ;------------------------------------------------------------------------
04043E             0225*   ; shr_hlu_div: Quick division by powers of two based on log2 of A
04043E             0226*   ;              Determines the LSB of A and shifts HLU accordingly.
04043E             0227*   ;              HLU = HLU >> LSB(A)
04043E             0228*   ; Returns: HLU = HLU >> LSB(A)
04043E             0229*   ; Destroys: af
04043E             0230*   ;------------------------------------------------------------------------
04043E             0231*   shr_hlu_log2a:
04043E B7          0232*   	or a    ; check for zero
04043F C8          0233*   	ret z   ; nothing to shift so we're done
040440 C5          0234*   	push 	bc ; preserve
040441 06 00       0235*   	ld		b,0 ; clear b
040443             0236*   @find_bit:
040443 0F          0237*   	rrca ; bit 0 to carry
040444 DA 4D 04 04 0238*   	jp c,@found_bit
040448 04          0239*   	inc b ; next bit
040449 C3 43 04 04 0240*   	jp @find_bit
04044D             0241*   @found_bit:
04044D 78          0242*   	ld a,b
04044E CD 1B 04 04 0243*   	call shr_hlu
040452 C1          0244*   	pop 	bc ; restore
040453 C9          0245*   	ret
040454             0246*   ; end shr_hlu_log2a
040454             0247*   
040454             0248*   ;------------------------------------------------------------------------
040454             0249*   ; shl_hlu_log2a: Quick multiplication by powers of two based on log2 of A
040454             0250*   ;                Determines the LSB of A and shifts HLU accordingly.
040454             0251*   ;                HLU = HLU << LSB(A)
040454             0252*   ; Returns: HLU = HLU << LSB(A)
040454             0253*   ; Destroys: af
040454             0254*   ;------------------------------------------------------------------------
040454             0255*   shl_hlu_log2a:
040454 B7          0256*   	or a    ; check for zero
040455 C8          0257*   	ret z   ; nothing to shift so we're done
040456 C5          0258*   	push 	bc ; preserve
040457 06 00       0259*   	ld		b,0 ; clear b
040459             0260*   @find_bit:
040459 0F          0261*   	rrca ; bit 0 to carry
04045A DA 63 04 04 0262*   	jp c,@found_bit
04045E 04          0263*   	inc b ; next bit
04045F C3 59 04 04 0264*   	jp @find_bit
040463             0265*   @found_bit:
040463 78          0266*   	ld a,b
040464 CD 15 04 04 0267*   	call shl_hlu
040468 C1          0268*   	pop 	bc ; restore
040469 C9          0269*   	ret
04046A             0270*   ; end shl_hlu_log2a
04046A             0034        include "maths.inc"
04046A             0001*   ;------------------------------------------------------------------------
04046A             0002*   ; Scratch area for calculations
04046A             0003*   ;------------------------------------------------------------------------
04046A 00 00 00    0004*   scratch1: dw24 0 ;bit manipulation buffer 1
04046D 00 00 00    0005*   scratch2: dw24 0 ;bit manipulation buffer 2
040470             0006*   
040470             0007*   ; absolute value of hlu
040470             0008*   ; returns: abs(hlu), flags set according to the incoming sign of hlu:
040470             0009*   ;         s1,z0,pv0,n1,c0 if hlu was negative
040470             0010*   ;         s0,z1,pv0,n1,c0 if hlu was zero
040470             0011*   ;         s0,z0,pv0,n1,c0 if hlu was positive
040470             0012*   ; destroys: a
040470             0013*   hlu_abs:
040470 19          0014*       add hl,de
040471 B7          0015*       or a
040472 ED 52       0016*       sbc hl,de
040474 FA 79 04 04 0017*       jp m,@is_neg
040478 C9          0018*       ret ; hlu is positive or zero so we're done
040479             0019*   @is_neg:
040479 F5          0020*       push af ; otherwise, save current flags for return
04047A CD 80 04 04 0021*       call neg_hlu ; negate hlu
04047E F1          0022*       pop af ; get back flags
04047F C9          0023*       ret
040480             0024*   
040480             0025*   ; flip the sign of hlu
040480             0026*   ; inputs: hlu
040480             0027*   ; returns: 0-hlu, flags set appropriately for the result:
040480             0028*   ;         s1,z0,pv0,n1,c1 if result is negative
040480             0029*   ;         s0,z1,pv0,n1,c0 if result is zero
040480             0030*   ;         s0,z0,pv0,n1,c1 if result is positive
040480             0031*   ; destroys a
040480             0032*   neg_hlu:
040480 D5          0033*       push de ; save de
040481 EB          0034*       ex de,hl ; put hl into de
040482 21 00 00 00 0035*       ld hl,0 ; clear hl
040486 AF          0036*       xor a ; clear carry
040487 ED 52       0037*       sbc hl,de ; 0-hlu = -hlu
040489 D1          0038*       pop de ; get de back
04048A C9          0039*       ret ; easy peasy
04048B             0040*   
04048B             0041*   ;------------------------------------------------------------------------
04048B             0042*   ; divide hlu by 2, inspired by above
04048B             0043*   ;------------------------------------------------------------------------
04048B             0044*   hlu_div2:
04048B 22 6A 04 04 0045*       ld (scratch1),hl
04048F 21 6C 04 04 0046*       ld hl,scratch1+2
040493 CB 1E       0047*       rr (hl)
040495 2B          0048*       dec hl
040496 CB 1E       0049*       rr (hl)
040498 2B          0050*       dec hl
040499 CB 1E       0051*       rr (hl)
04049B 23          0052*       inc hl
04049C 23          0053*       inc hl
04049D 2A 6A 04 04 0054*       ld hl,(scratch1)
0404A1 C9          0055*       ret
0404A2             0056*   
0404A2             0057*   ; this is my little hack to divide by 16
0404A2             0058*   hlu_div16:
0404A2 AF          0059*       xor a
0404A3 29          0060*       add hl,hl
0404A4 17          0061*       rla
0404A5 29          0062*       add hl,hl
0404A6 17          0063*       rla
0404A7 29          0064*       add hl,hl
0404A8 17          0065*       rla
0404A9 29          0066*       add hl,hl
0404AA 17          0067*       rla
0404AB 22 B8 04 04 0068*       ld (@scratch),hl
0404AF 32 BB 04 04 0069*       ld (@scratch+3),a
0404B3 2A B9 04 04 0070*       ld hl,(@scratch+1)
0404B7 C9          0071*       ret
0404B8             0072*   @scratch: ds 4
0404BC             0073*   
0404BC             0074*   ; hlu signed division by 256
0404BC             0075*   ; returns: hlu / 256
0404BC             0076*   ; destroys: af
0404BC             0077*   hlu_sdiv256:
       FF FF FF FF 
0404BC AF          0078*       xor a ; assume hl is positive
0404BD 22 D3 04 04 0079*       ld (@buffer),hl
0404C1             0080*       SIGN_HLU
                       M1 Args: none
0404C1 19          0001*M1     add hl,de ; 1 cycle
0404C2 B7          0002*M1     or a ; clear flags ; 1 cycle
0404C3 ED 52       0003*M1     sbc hl,de ; 2 cycles
0404C5             0004*M1     ; 4 cycles total
0404C5 F2 CA 04 04 0081*       jp p,@hl_pos
0404C9 3D          0082*       dec a
0404CA             0083*   @hl_pos:
0404CA 32 D6 04 04 0084*       ld (@buffer+3),a
0404CE 2A D4 04 04 0085*       ld hl,(@buffer+1)
0404D2 C9          0086*       ret
0404D3             0087*   @buffer: ds 4
0404D7             0088*   
0404D7             0089*   ; hlu 1 byte right shift, unsigned
0404D7             0090*   ; returns: hlu / 256, fractional portion in a
0404D7             0091*   ; destroys: af
0404D7             0092*   hlu_udiv256:
       FF FF FF FF 
0404D7 AF          0093*       xor a
0404D8 32 E9 04 04 0094*       ld (@buffer+3),a
0404DC 7D          0095*       ld a,l ; save the fractional portion
0404DD 22 E6 04 04 0096*       ld (@buffer),hl
0404E1 2A E7 04 04 0097*       ld hl,(@buffer+1)
0404E5 C9          0098*       ret
0404E6             0099*   @buffer: ds 4
0404EA             0100*   
0404EA             0101*   ; floor(value,n)
0404EA             0102*   ; inputs: hl = value to floor, de = n
0404EA             0103*   ; outputs: hl = value floored to n
0404EA             0104*   ; destroys: af, hl, bc, de
0404EA             0105*   hlu_floor:
       FF FF FF FF 
0404EA D5          0106*       push de ; save n
0404EB CD 80 03 04 0107*       call udiv24 ; de = quotient, hl = remainder
0404EF E1          0108*       pop hl ; get n back (was de)
0404F0 CD 67 03 04 0109*       call umul24 ; hl = n * quotient
0404F4 C9          0110*       ret
0404F5             0111*   ; end hlu_floor
0404F5             0112*   
0404F5             0113*   ; ceil(value,n)
0404F5             0114*   ; inputs: hl = value to ceil, de = n
0404F5             0115*   ; outputs: hl = value ceiled to n
0404F5             0116*   ; destroys: af, hl, bc, de
0404F5             0117*   hlu_ceiling:
0404F5 D5          0118*       push de ; save n
0404F6 CD 80 03 04 0119*       call udiv24 ; de = quotient, hl = remainder
0404FA             0120*       SIGN_HLU ; test remaider for zero
                       M1 Args: none
0404FA 19          0001*M1     add hl,de ; 1 cycle
0404FB B7          0002*M1     or a ; clear flags ; 1 cycle
0404FC ED 52       0003*M1     sbc hl,de ; 2 cycles
0404FE             0004*M1     ; 4 cycles total
0404FE CA 03 05 04 0121*       jp z,@F ; if zero, nothing to add
040502 13          0122*       inc de ; add 1 to quotient for the ceiling
040503             0123*   @@:
040503 E1          0124*       pop hl ; get n back (was de)
040504 CD 67 03 04 0125*       call umul24 ; hl = n * quotient
040508 C9          0126*       ret
040509             0127*   ; end hlu_ceiling
040509             0128*   
040509 C9          0129*       ret
04050A             0130*   
04050A 00 00 00 00 0131*   add_bcd_arg1: db #00,#00,#00,#00
04050E 00 00 00 00 0132*   add_bcd_arg2: db #00,#00,#00,#00
040512             0133*   
040512             0134*   ; set bcd values in a scratch memory address from registers bcde
040512             0135*   ; input: hl; scratch address,bcde; 8-place bcd number
040512             0136*   ; destroys ; hl
040512             0137*   set_bcd:
040512 73          0138*       ld (hl),e
040513 23          0139*       inc hl
040514 72          0140*       ld (hl),d
040515 23          0141*       inc hl
040516 71          0142*       ld (hl),c
040517 23          0143*       inc hl
040518 70          0144*       ld (hl),b
040519 C9          0145*       ret
04051A             0146*   
04051A             0147*   ; load bcd values from a scratch memory address to bcde
04051A             0148*   ; input: hl; scratch address
04051A             0149*   ; output: bcde; 8-place bcd number
04051A             0150*   ; destroys: hl
04051A             0151*   get_bcd:
04051A 5E          0152*       ld e,(hl)
04051B 23          0153*       inc hl
04051C 56          0154*       ld d,(hl)
04051D 23          0155*       inc hl
04051E 4E          0156*       ld c,(hl)
04051F 23          0157*       inc hl
040520 46          0158*       ld b,(hl)
040521 C9          0159*       ret
040522             0160*   
040522             0161*   ; BCD addition
040522             0162*   ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
040522             0163*   ;       a is the number of bytes holding each number (number of places/2)
040522             0164*   ; outputs: (hl) + (de) --> (hl)
040522             0165*   ; destroys: a,b,de,hl
040522             0166*   add_bcd:
040522 47          0167*       ld b,a ; loop counter
040523 AF          0168*       xor a ; reset a, clear carry flag
040524             0169*   adcec:
040524 1A          0170*       ld a,(de) ; addend to acc
040525 8E          0171*       adc a,(hl) ; add (hl) to acc
040526 27          0172*       daa ; adjust result to bcd
040527 77          0173*       ld (hl),a ; store result
040528 23          0174*       inc hl ; advance memory pointers
040529 13          0175*       inc de
04052A 10 F8       0176*       djnz adcec ; loop until b == 0
04052C C9          0177*       ret
04052D             0178*   
04052D             0179*   ; BCD subtraction
04052D             0180*   ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
04052D             0181*   ;       a is the number of bytes holding each number (number of places/2)
04052D             0182*   ; outputs: (hl) - (de) --> (hl)
04052D             0183*   ; destroys: a,b,de,hl
04052D             0184*   sub_bcd:
04052D 47          0185*       ld b,a ; loop counter
04052E AF          0186*       xor a ; reset a,clear carry flag
04052F             0187*   subdec:
04052F 1A          0188*       ld a,(de) ; subtrahend to acc
040530 9E          0189*       sbc a,(hl) ; subtract (hl) from acc
040531 27          0190*       daa ; adjust result to bcd
040532 77          0191*       ld (hl),a ; store result
040533 23          0192*       inc hl ; advance memory pointers
040534 13          0193*       inc de
040535 10 F8       0194*       djnz subdec ; loop until b == 0
040537 C9          0195*       ret
040538             0196*   
040538             0197*   ; http://www.z80.info/pseudo-random.txt
040538             0198*   rand_8:
040538 C5          0199*       push bc
040539 3A 4C 05 04 0200*       ld a,(r_seed)
04053D 4F          0201*       ld c,a
04053E             0202*   
04053E 0F          0203*       rrca ; multiply by 32
04053F 0F          0204*       rrca
040540 0F          0205*       rrca
040541 EE 1F       0206*       xor 0x1f
040543             0207*   
040543 81          0208*       add a,c
040544 DE FF       0209*       sbc a,255 ; carry
040546             0210*   
040546 32 4C 05 04 0211*       ld (r_seed),a
04054A C1          0212*       pop bc
04054B C9          0213*       ret
04054C 50          0214*   r_seed: defb $50
04054D             0215*   
04054D             0216*   ; https://www.omnimaga.org/asm-language/ez80-optimized-routines/msg399325/#msg399325
04054D             0217*   prng24:
04054D             0218*   ;;Expects ADL mode.
04054D             0219*   ;;Output: HL
04054D             0220*   ;;50cc
04054D             0221*   ;;33 bytes
04054D             0222*   ;;cycle length: 281,474,959,933,440 (about 2.8 trillion)
04054D ED 5B 6E 05 0223*       ld de,(seed1)
       04          
040552 B7          0224*       or a
040553 ED 62       0225*       sbc hl,hl
040555 19          0226*       add hl,de
040556 29          0227*       add hl,hl
040557 29          0228*       add hl,hl
040558 2C          0229*       inc l
040559 19          0230*       add hl,de
04055A 22 6E 05 04 0231*       ld (seed1),hl
04055E 2A 71 05 04 0232*       ld hl,(seed2)
040562 29          0233*       add hl,hl
040563 9F          0234*       sbc a,a
040564 E6 1B       0235*       and %00011011
040566 AD          0236*       xor l
040567 6F          0237*       ld l,a
040568 22 71 05 04 0238*       ld (seed2),hl
04056C 19          0239*       add hl,de
04056D C9          0240*       ret
04056E 00 00 00    0241*   seed1: dl 0
040571 00 00 00    0242*   seed2: dl 0
040574             0243*   
040574             0244*   
040574             0245*   ; https://map.grauw.nl/sources/external/z80bits.html#2.1
040574             0246*   ; 2.1 Restoring 8-bit / 8-bit Unsigned
040574             0247*   ; Input: H = Dividend, L = Divisor, A = 0
040574             0248*   ; Output: H = Quotient, A = Remainder, L = Divisor (unchanged)
040574             0249*   udiv8:
040574 AF          0250*       xor a
040575 06 08       0251*       ld b,8
040577             0252*   @loop:
040577 CB 24       0253*       sla h
040579 17          0254*       rla
04057A BD          0255*       cp l
04057B 38 02       0256*       jr c,$+4
04057D 95          0257*       sub l
04057E 24          0258*       inc h
04057F 10 F6       0259*       djnz @loop
040581 C9          0260*       ret
040582             0035        include "files.inc"
040582             0001*   ; THIS MUST BE LAST INCLUDE SO FILE DATA DOES NOT OVERWRITE OTHER CODE OR DATA
040582             0002*   
040582             0003*   ; buffer for loading files unrelated to audio
040582             0004*   ; e.g.: fonts, sprites, etc. (limited to 8k)
040582             0005*   filedata: equ 0xB7E000 ; address of onboard 8k sram
040582             0006*   
040582             0007*   ;     align 256 ; make things nice for indexing into especially ps_dir_fil_list
040582             0008*   ; ; buffer for sound data
040582             0009*   ps_wav_data_start: equ 0x050000 ;    equ $   ; (042E00) Start of audio data
040582             0010*   
040582             0011*   ; this list can grow as large as necessary to hold all the files in the directory
040582             0012*   ; each entry will be 256 bytes long, the max filename size MOS/FFS supports
040582             0013*   ps_dir_fil_list: equ 0x060000 ; equ ps_wav_data_start+65536 ; (052E00) max file data we can load in one chunk is 64k
040582             0036        include "fixed168.inc"
040582             0001*   ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
040582             0002*   ; uses EZ80 MLT instruction for speed
040582             0003*   ; operation: UHL * A --> UHL
040582             0004*   ; destroys: AF, HL
040582             0005*   smul24x8:
040582             0006*   ; make hl positive and store sign flag
040582 CD 70 04 04 0007*       call hlu_abs
040586 F5          0008*       push af
040587             0009*   ; do the division
040587 CD 92 05 04 0010*       call mul24x8 ; hl = product
04058B             0011*   ; adjust sign of result
04058B F1          0012*       pop af ; sign de
04058C F0          0013*       ret p ; hl was positive, nothing to do
04058D CD 80 04 04 0014*       call neg_hlu ; result is negative
040591 C9          0015*       ret
040592             0016*   
040592             0017*   ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
040592             0018*   ; uses EZ80 MLT instruction for speed
040592             0019*   ; operation: UHL * A --> AUHL
040592             0020*   ; destroys: AF, HL
040592             0021*   mul24x8:
040592 D5          0022*       push de ; preserve de
040593             0023*   ; low byte
040593 5D          0024*       ld e,l
040594 57          0025*       ld d,a
040595 ED 5C       0026*       mlt de
040597 6B          0027*       ld l,e ; product low byte
040598 08          0028*       ex af,af' ; save multiplier
040599 7A          0029*       ld a,d ; carry
04059A 08          0030*       ex af,af' ; save carry, restore multiplier
04059B             0031*   ; high byte
04059B 5C          0032*       ld e,h
04059C 57          0033*       ld d,a
04059D ED 5C       0034*       mlt de
04059F 08          0035*       ex af,af' ; save multiplier, restore carry
0405A0 83          0036*       add a,e ; add carry
0405A1 67          0037*       ld h,a ; product middle byte
0405A2 7A          0038*       ld a,d ; carry
0405A3 08          0039*       ex af,af' ; save carry, restore multiplier
0405A4             0040*   ; upper byte
0405A4 22 BF 05 04 0041*       ld (@scratch),hl ; 7 cycles
0405A8 5F          0042*       ld e,a
0405A9 3A C1 05 04 0043*       ld a,(@scratch+2)
0405AD 57          0044*       ld d,a
0405AE ED 5C       0045*       mlt de
0405B0 08          0046*       ex af,af' ; restore carry
0405B1 8B          0047*       adc a,e ; add carry
0405B2 32 C1 05 04 0048*       ld (@scratch+2),a ; 5 cycles
0405B6 2A BF 05 04 0049*       ld hl,(@scratch) ; 7 cycles
0405BA             0050*   ; highest byte
0405BA 3E 00       0051*       ld a,0 ; preserve carry flag
0405BC 8A          0052*       adc a,d ; product highest byte
0405BD D1          0053*       pop de ; restore de
0405BE C9          0054*       ret
0405BF             0055*   @scratch: ds 3
0405C2             0056*   
       FF FF FF 
0405C2 00 00 00 00 0057*   mul24out: blkb 6,0
       00 00       
0405C8             0058*   
0405C8             0059*   ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
0405C8             0060*   ; operation: UHL * UDE --> mul24out
0405C8             0061*   mul24:
0405C8 DD E5       0062*       push ix ; preserve
0405CA             0063*   ; point to output buffer and clear it
0405CA DD 21 C2 05 0064*       ld ix,mul24out
       04          
0405CF C5          0065*       push bc
0405D0 01 00 00 00 0066*       ld bc,0
0405D4 DD 0F 00    0067*       ld (ix),bc
0405D7 DD 0F 03    0068*       ld (ix+3),bc
0405DA C1          0069*       pop bc
0405DB             0070*   ; STEP 1: UHL * E
0405DB 7B          0071*       ld a,e
0405DC E5          0072*       push hl
0405DD CD 92 05 04 0073*       call mul24x8
0405E1 DD 2F 00    0074*       ld (ix+0),hl
0405E4 DD 77 03    0075*       ld (ix+3),a
0405E7             0076*   ; STEP 2: UHL * D
0405E7 E1          0077*       pop hl
0405E8 E5          0078*       push hl
0405E9 7A          0079*       ld a,d
0405EA CD 92 05 04 0080*       call mul24x8
0405EE CD 07 06 04 0081*       call @accumulate
0405F2             0082*   ; STEP 3: UHL * DEU
0405F2 E1          0083*       pop hl
0405F3 ED 53 37 06 0084*       ld (@de),de
       04          
0405F8 3A 39 06 04 0085*       ld a,(@de+2)
0405FC CD 92 05 04 0086*       call mul24x8
040600 CD 07 06 04 0087*       call @accumulate
040604             0088*   ; all done
040604 DD E1       0089*       pop ix ; restore
040606 C9          0090*       ret
040607             0091*   @accumulate:
040607 DD 23       0092*       inc ix
040609             0093*   ; highest byte of product to carry
040609 DD 77 03    0094*       ld (ix+3),a
04060C             0095*   ; low byte of product
04060C 7D          0096*       ld a,l
04060D DD 86 00    0097*       add a,(ix+0)
040610 DD 77 00    0098*       ld (ix+0),a
040613             0099*   ; high byte of product
040613 7C          0100*       ld a,h
040614 DD 8E 01    0101*       adc a,(ix+1)
040617 DD 77 01    0102*       ld (ix+1),a
04061A             0103*   ; uppper byte of product
04061A 22 34 06 04 0104*       ld (@hl),hl
04061E 3A 36 06 04 0105*       ld a,(@hl+2)
040622 DD 8E 02    0106*       adc a,(ix+2)
040625 DD 77 02    0107*       ld (ix+2),a
040628             0108*   ; carry
040628 3E 00       0109*       ld a,0 ; preserve flags
04062A DD 8E 03    0110*       adc a,(ix+3)
04062D DD 77 03    0111*       ld (ix+3),a
040630 C9          0112*       ret
040631             0113*   
040631 00 00 00    0114*   @ix: dl 0
040634 00 00 00    0115*   @hl: dl 0
040637 00 00 00    0116*   @de: dl 0
04063A             0117*   
04063A             0118*   ; ; UHL * UDE --> UHL (unsigned)
04063A             0119*   ; umul24:
04063A             0120*   ;     call mul24
04063A             0121*   ;     ld hl,(mul24out)
04063A             0122*   ;     ret
04063A             0123*   
04063A             0124*   ; UH.L = UH.L*UD.E (unsigned)
04063A             0125*   umul168:
04063A CD C8 05 04 0126*       call mul24
04063E 2A C3 05 04 0127*       ld hl,(mul24out+1)
040642 C9          0128*       ret
040643             0129*   
040643             0130*   ; UH.L * UD.E --> UH.L (signed)
040643             0131*   smul168:
040643             0132*   ; make everything positive and store sign flags
040643 CD 70 04 04 0133*       call hlu_abs
040647 F5          0134*       push af
040648 EB          0135*       ex de,hl
040649 CD 70 04 04 0136*       call hlu_abs
04064D EB          0137*       ex de,hl
04064E F5          0138*       push af
04064F             0139*   ; do the division
04064F CD 3A 06 04 0140*       call umul168 ; hl = product
040653             0141*   ; adjust sign of result
040653 F1          0142*       pop af ; sign de
040654 FA 5F 06 04 0143*       jp m,@de_neg
040658 F1          0144*       pop af ; sign hl
040659 F0          0145*       ret p ; both positive, nothing to do
04065A             0146*   @hl_neg:
04065A CD 80 04 04 0147*       call neg_hlu ; de pos, hl neg, result is negative
04065E C9          0148*       ret
04065F             0149*   @de_neg:
04065F F1          0150*       pop af
040660 F8          0151*       ret m ; both negative, nothing to do
040661 CD 80 04 04 0152*       call neg_hlu ; result is negative
040665 C9          0153*       ret
040666             0154*   
040666             0155*   ; UH.L / UD.E --> UD.E rem UHL (unsigned)
040666             0156*   ; perform unsigned division of 16.8 fixed place values
040666             0157*   ; with an unsigned 16.8 fixed place result and 24-bit remainder
040666             0158*   udiv168:
040666             0159*   ; back up divisor
040666 ED 53 9D 06 0160*       ld (@ude),de
       04          
04066B             0161*   ; get the 16-bit integer part of the quotient
04066B CD 80 03 04 0162*       call udiv24 ; de = quotient, hl = remainder
04066F             0163*   ; load quotient to upper three bytes of output
04066F ED 53 A4 06 0164*       ld (div168_out+1),de
       04          
040674             0165*   @div256:
040674             0166*   ; multiply remainder by 256
040674             0167*       hlu_mul256
                       M1 Args: none
040674 29          0001*M1     add hl,hl ; * 2
040675 29          0002*M1     add hl,hl ; * 4
040676 29          0003*M1     add hl,hl ; * 8
040677 29          0004*M1     add hl,hl ; * 16
040678 29          0005*M1     add hl,hl ; * 32
040679 29          0006*M1     add hl,hl ; * 64
04067A 29          0007*M1     add hl,hl ; * 128
04067B 29          0008*M1     add hl,hl ; * 256
04067C             0168*   ; skip fractional computation if remainder is zero
04067C             0169*       SIGN_HLU
                       M1 Args: none
04067C 19          0001*M1     add hl,de ; 1 cycle
04067D B7          0002*M1     or a ; clear flags ; 1 cycle
04067E ED 52       0003*M1     sbc hl,de ; 2 cycles
040680             0004*M1     ; 4 cycles total
040680 20 03       0170*       jr nz,@div_frac
040682 AF          0171*       xor a
040683 18 0A       0172*       jr @write_frac
040685             0173*   ; now divide the shifted remainder by the divisor
040685             0174*   @div_frac:
040685 ED 5B 9D 06 0175*       ld de,(@ude) ; get back divisor
       04          
04068A CD 80 03 04 0176*       call udiv24 ; de = quotient, hl = remainder
04068E             0177*   ; load low byte of quotient to low byte of output
04068E 7B          0178*       ld a,e
04068F             0179*   @write_frac:
04068F 32 A3 06 04 0180*       ld (div168_out),a
040693             0181*   ; load de with return value
040693 ED 5B A3 06 0182*       ld de,(div168_out)
       04          
040698             0183*   ; load a with any overflow
040698 3A A6 06 04 0184*       ld a,(div168_out+3)
04069C C9          0185*       ret ; ud.e is the 16.8 result
04069D             0186*   @ude: ds 6
0406A3             0187*   div168_out: ds 4 ; the extra byte is for overflow
0406A7             0188*   
0406A7             0189*   ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
0406A7             0190*   ; perform signed division of 16.8 fixed place values
0406A7             0191*   ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
0406A7             0192*   sdiv168:
0406A7             0193*   ; make everything positive and store sign flags
       FF FF FF FF 
       FF FF FF FF 
       FF FF 
0406A7 CD 70 04 04 0194*       call hlu_abs
0406AB F5          0195*       push af
0406AC EB          0196*       ex de,hl
0406AD CD 70 04 04 0197*       call hlu_abs
0406B1 EB          0198*       ex de,hl
0406B2 F5          0199*       push af
0406B3             0200*   ; do the division
0406B3 CD 66 06 04 0201*       call udiv168 ; de = quotient, hl = remainder
0406B7             0202*   ; adjust sign of result
0406B7 F1          0203*       pop af ; sign de
0406B8 FA C5 06 04 0204*       jp m,@de_neg
0406BC F1          0205*       pop af ; sign hl
0406BD F0          0206*       ret p ; both positive, nothing to do
0406BE             0207*   @hl_neg:
0406BE EB          0208*       ex de,hl ; hl = quotient, de = remainder
0406BF CD 80 04 04 0209*       call neg_hlu ; de pos, hl neg, result is negative
0406C3 EB          0210*       ex de,hl ; de = negated quotient, hl = remainder
0406C4 C9          0211*       ret
0406C5             0212*   @de_neg:
0406C5 F1          0213*       pop af
0406C6 F8          0214*       ret m ; both negative, nothing to do
0406C7 EB          0215*       ex de,hl ; hl = quotient, de = remainder
0406C8 CD 80 04 04 0216*       call neg_hlu ; result is negative
0406CC EB          0217*       ex de,hl ; de = negated quotient, hl = remainder
0406CD C9          0218*       ret
0406CE             0219*   
0406CE             0220*   ; convert signed angles from a 360 to 256 degree circle
0406CE             0221*   ; inputs: uh.l is the angle360 in 16.8 fixed format
0406CE             0222*   ; outputs: uh.l is the angle256 in 16.8 fixed format
0406CE             0223*   ; destroys: TODO
0406CE             0224*   deg_360_to_256:
0406CE D5          0225*       push de ; preserve de
0406CF             0226*   ; make angle positive and store sign flag
0406CF CD 70 04 04 0227*       call hlu_abs
0406D3 F5          0228*       push af
0406D4             0229*   ; multiply by coversion factor of 256/360
0406D4 11 B6 00 00 0230*       ld de,0x0000B6 ; 0.711
0406D8 CD 3A 06 04 0231*       call umul168 ; uh.l = uh.l * 0.711
0406DC             0232*   ; restore sign flag and adjust output accordingly
0406DC F1          0233*       pop af
0406DD F2 E5 06 04 0234*       jp p,@pos ; positive number
0406E1 CD 80 04 04 0235*       call neg_hlu
0406E5             0236*   @pos:
0406E5             0237*   ; restore de and return uh.l as the result
0406E5 D1          0238*       pop de
0406E6 C9          0239*       ret
0406E7             0240*   
0406E7             0241*   ; convert signed angles from a 256 to 360 degree circle
0406E7             0242*   ; inputs: uh.l is the angle256 in 16.8 fixed format
0406E7             0243*   ; outputs: uh.l is the angle360 in 16.8 fixed format
0406E7             0244*   ; destroys: TODO
0406E7             0245*   deg_256_to_360:
0406E7 D5          0246*       push de ; preserve de
0406E8             0247*   ; make angle positive and store sign flag
0406E8 CD 70 04 04 0248*       call hlu_abs
0406EC F5          0249*       push af
0406ED             0250*   ; multiply by coversion factor of 360/256
0406ED 11 68 01 00 0251*       ld de,0x000168 ; 1.406
0406F1 CD 3A 06 04 0252*       call umul168 ; uh.l = uh.l * 1.406
0406F5             0253*   ; restore sign flag and adjust output accordingly
0406F5 F1          0254*       pop af
0406F6 F2 FE 06 04 0255*       jp p,@pos ; positive number
0406FA CD 80 04 04 0256*       call neg_hlu
0406FE             0257*   @pos:
0406FE             0258*   ; restore de and return uh.l as the result
0406FE D1          0259*       pop de
0406FF C9          0260*       ret
040700             0261*   
040700             0262*   ; fixed 16.8 routine
040700             0263*   ; cos(uh.l) --> uh.l
040700             0264*   ; destroys: f, hl
040700             0265*   cos168:
040700 D5          0266*       push de ; preserve de
040701             0267*   ; for cos we simply increment the angle by 90 degrees
040701             0268*   ; or 0x004000 in 16.8 degrees256
040701             0269*   ; which makes it a sin problem
040701 11 00 40 00 0270*       ld de,0x004000
040705 19          0271*       add hl,de ; modulo 256 happens below
040706 D1          0272*       pop de ; restore de
040707             0273*   ; fall through to sin168
040707             0274*   
040707             0275*   ; ---------------------
040707             0276*   ; fixed 16.8 routine
040707             0277*   ; sin(uh.l) --> uh.l
040707             0278*   ; destroys: f, hl
040707             0279*   sin168:
040707 D5          0280*       push de
040708             0281*   ; handle negative angles appropriately
040708 CD 70 04 04 0282*       call hlu_abs
04070C F2 15 07 04 0283*       jp p,@F
040710 11 00 00 FF 0284*       ld de,-256*256
040714 19          0285*       add hl,de
040715             0286*   @@:
040715 2E 03       0287*       ld l,3 ; multiply by 3 to get our lookup index
040717 ED 6C       0288*       mlt hl
040719 11 CD 09 04 0289*       ld de,sin_lut_168 ; grab the lut address
04071D 19          0290*       add hl,de ; bump hl by the index
04071E ED 27       0291*       ld hl,(hl) ; don't try this on a z80!
040720 D1          0292*       pop de
040721 C9          0293*       ret
040722             0294*   
040722             0295*   ; 16.8 fixed inputs / outputs
040722             0296*   ; takes: uh.l as angle in degrees 256
040722             0297*   ;        ud.e as radius
040722             0298*   ; returns ub.c as dx, ud.e as dy, uh.l as radius
040722             0299*   ;        displacements from origin (0,0)
040722             0300*   ; destroys: everything except indexes
040722             0301*   polar_to_cartesian:
040722             0302*   ; back up input parameters
040722 22 51 07 04 0303*       ld (@angle), hl
040726 ED 53 54 07 0304*       ld (@radius), de
       04          
04072B             0305*   ; compute dx = sin(uh.l) * ud.e
04072B CD 07 07 04 0306*       call sin168 ; uh.l = sin(uh.l)
04072F ED 5B 54 07 0307*       ld de,(@radius)
       04          
040734 CD 43 06 04 0308*       call smul168 ; uh.l = dx
040738 E5          0309*       push hl
040739             0310*   ; compute dy = -cos(uh.l) * ud.e
040739 2A 51 07 04 0311*       ld hl,(@angle)
04073D CD 00 07 04 0312*       call cos168 ; uh.l = cos(uh.l)
040741 ED 5B 54 07 0313*       ld de,(@radius)
       04          
040746 CD 43 06 04 0314*       call smul168 ; uh.l = dy
04074A CD 80 04 04 0315*       call neg_hlu ; invert dy for screen coords convention
04074E EB          0316*       ex de,hl ; de = dy for output
04074F C1          0317*       pop bc ; bc = dx for output
040750             0318*   ; and out
040750 C9          0319*       ret
040751             0320*   @angle: ds 3
040754             0321*   @radius: ds 3
040757             0322*   
040757             0323*   ; 16.8 fixed inputs / outputs
040757             0324*   ; inputs: ub.c as dx, ud.e as dy
040757             0325*   ;        displacements from origin (0,0)
040757             0326*   ; returns: uh.l as angle in degrees 256
040757             0327*   ;        ud.e as radius
040757             0328*   ; destroys: everything except indexes
040757             0329*   cartesian_to_polar:
       FF FF FF FF 
       FF FF 
040757 ED 43 B0 07 0330*       ld (dx168),bc ; dx argument for distance168
       04          
04075C ED 53 B6 07 0331*       ld (dy168),de ; dy argument for distance168
       04          
040761             0332*   ; compute radius
040761 CD BC 07 04 0333*       call distance168 ; uh.l = radius
040765 E5          0334*       push hl ; save radius
040766             0335*   ; compute angle
040766 ED 4B B0 07 0336*       ld bc,(dx168) ; dx argument for atan2_168fast
       04          
04076B ED 5B B6 07 0337*       ld de,(dy168) ; dy argument for atan2_168fast
       04          
040770 CD 1C 08 04 0338*       call atan2_168fast ; uh.l = angle
040774             0339*   ; return result
040774 D1          0340*       pop de ; de = radius (was hl)
040775 C9          0341*       ret
040776             0342*   ; end cartesian_to_polar
040776             0343*   
040776             0344*   ; 16.8 fixed inputs / outputs
040776             0345*   ; inputs: ub.c as dx, ud.e as dy
040776             0346*   ;        displacements from origin (0,0)
040776             0347*   ; returns: uh.l as angle in degrees 256
040776             0348*   ;        ud.e as radius
040776             0349*   ; destroys: everything except indexes
040776             0350*   ; note: uses distance168sm which is more accurate for small deltas
040776             0351*   cartesian_to_polar_sm:
040776 ED 43 B0 07 0352*       ld (dx168),bc ; dx argument for distance168
       04          
04077B ED 53 B6 07 0353*       ld (dy168),de ; dy argument for distance168
       04          
040780             0354*   ; compute radius
040780 CD F7 07 04 0355*       call distance168sm ; uh.l = radius
040784 E5          0356*       push hl ; save radius
040785             0357*   ; compute angle
040785 ED 4B B0 07 0358*       ld bc,(dx168) ; dx argument for atan2_168fast
       04          
04078A ED 5B B6 07 0359*       ld de,(dy168) ; dy argument for atan2_168fast
       04          
04078F CD 1C 08 04 0360*       call atan2_168fast ; uh.l = angle
040793             0361*   ; return result
040793 D1          0362*       pop de ; de = radius (was hl)
040794 C9          0363*       ret
040795             0364*   ; end cartesian_to_polar
040795             0365*   
040795             0366*   ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
040795             0367*   ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
040795             0368*   ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
040795             0369*   ;         also populates scratch locations dx168 and dy168
040795             0370*   ; destroys: a,hl,bc,de
040795             0371*   dxy168:
040795             0372*   ; compute dx = x1-x0
040795 AF          0373*       xor a ; clear carry
040796 DD E5       0374*       push ix ; move ix to hl via the stack
040798 E1          0375*       pop hl ; hl = x1
040799 ED 42       0376*       sbc hl,bc ; hl = dx
04079B 22 B0 07 04 0377*       ld (dx168),hl ; dx to scratch
04079F             0378*   ; compute dy = y1-y0
04079F AF          0379*       xor a ; clear carry
0407A0 FD E5       0380*       push iy ; move iy to hl via the stack
0407A2 E1          0381*       pop hl ; hl = y1
0407A3 ED 52       0382*       sbc hl,de ; hl = dy
0407A5 22 B6 07 04 0383*       ld (dy168),hl ; dy to scratch
0407A9             0384*   ; populate output registers and return
0407A9 EB          0385*       ex de,hl ; ud.e = dy
0407AA ED 4B B0 07 0386*       ld bc,(dx168) ; ub.c = dx
       04          
0407AF C9          0387*       ret
0407B0 00 00 00 00 0388*   dx168: blkb 6,0
       00 00       
0407B6 00 00 00 00 0389*   dy168: blkb 6,0
       00 00       
0407BC             0390*   
0407BC             0391*   ; compute the euclidian distance between two cartesian coordinates
0407BC             0392*   ; using the formula d = sqrt(dx^2+dy^2)
0407BC             0393*   ; inputs: dx168 and dy168 are dx and dy in 16.8 fixed format
0407BC             0394*   ; output; uh.l is the 16.8 fixed format distance
0407BC             0395*   ;         also populates scratch locations dx168 and dy168
0407BC             0396*   ; destroys: a,hl,bc,de
0407BC             0397*   ; NOTE: rounds both deltas down to the nearest integer to avoid overflow when squaring,
0407BC             0398*   ;       thus the result will always be an integer, albeit in 16.8 format
0407BC             0399*   distance168:
0407BC             0400*   ; compute dy^2
0407BC 2A B6 07 04 0401*       ld hl,(dy168)
0407C0 CD 70 04 04 0402*       call hlu_abs
0407C4             0403*       ; call hlu_udiv256 ; make integer to avoid overflow
0407C4             0404*       SRL_UHL ; make integer to avoid overflow
                       M1 Args: none
0407C4 3B          0001*M1     dec sp ; 1 cycle
0407C5 E5          0002*M1     push hl ; 4 cycles
0407C6 33          0003*M1     inc sp ; 1 cycle
0407C7 E1          0004*M1     pop hl ; 4 cycles
0407C8 23          0005*M1     inc hl ; 1 cycle
0407C9 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
0407CB             0007*M1     ; 13 cycles total
0407CB E5          0405*       push hl
0407CC D1          0406*       pop de
0407CD CD 67 03 04 0407*       call umul24 ; hl = dy^2
0407D1 E5          0408*       push hl ; save dy^2
0407D2             0409*   ; compute dx^2
0407D2 2A B0 07 04 0410*       ld hl,(dx168)
0407D6 CD 70 04 04 0411*       call hlu_abs
0407DA             0412*       ; call hlu_udiv256 ; make integer to avoid overflow
0407DA             0413*       SRL_UHL ; make integer to avoid overflow
                       M1 Args: none
0407DA 3B          0001*M1     dec sp ; 1 cycle
0407DB E5          0002*M1     push hl ; 4 cycles
0407DC 33          0003*M1     inc sp ; 1 cycle
0407DD E1          0004*M1     pop hl ; 4 cycles
0407DE 23          0005*M1     inc hl ; 1 cycle
0407DF 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
0407E1             0007*M1     ; 13 cycles total
0407E1 E5          0414*       push hl
0407E2 D1          0415*       pop de
0407E3 CD 67 03 04 0416*       call umul24 ; hl = dx^2
0407E7             0417*   ; add dx^2 and dy^2
0407E7 D1          0418*       pop de ; de = dy^2 (was hl)
0407E8 19          0419*       add hl,de ; hl = dx^2 + dy^2
0407E9             0420*   ; compute the square root
0407E9 CD E7 08 04 0421*       call sqrt24 ; de = sqrt(dx^2 + dy^2)
0407ED EB          0422*       ex de,hl ; hl = distance
0407EE             0423*       hlu_mul256 ; convert back to 16.8 fixed
                       M1 Args: none
0407EE 29          0001*M1     add hl,hl ; * 2
0407EF 29          0002*M1     add hl,hl ; * 4
0407F0 29          0003*M1     add hl,hl ; * 8
0407F1 29          0004*M1     add hl,hl ; * 16
0407F2 29          0005*M1     add hl,hl ; * 32
0407F3 29          0006*M1     add hl,hl ; * 64
0407F4 29          0007*M1     add hl,hl ; * 128
0407F5 29          0008*M1     add hl,hl ; * 256
0407F6 C9          0424*       ret
0407F7             0425*   
0407F7             0426*   ; compute the euclidian distance between two cartesian coordinates
0407F7             0427*   ; using the formula d = sqrt(dx^2+dy^2)
0407F7             0428*   ; inputs: dx168 and dy168 are dx and dy in 16.8 fixed format
0407F7             0429*   ; output; uh.l is the 16.8 fixed format distance
0407F7             0430*   ;         also populates scratch locations dx168 and dy168
0407F7             0431*   ; destroys: a,hl,bc,de
0407F7             0432*   ; NOTE: sm means 'small' because it doesn't round down the deltas
0407F7             0433*   ;       making it more accurate for small deltas,
0407F7             0434*   ;       but will overflow if used for screen-sized deltas
0407F7             0435*   distance168sm:
0407F7             0436*   ; compute dy^2
0407F7 2A B6 07 04 0437*       ld hl,(dy168)
0407FB CD 70 04 04 0438*       call hlu_abs
0407FF E5          0439*       push hl
040800 D1          0440*       pop de
040801 CD 67 03 04 0441*       call umul24 ; hl = dy^2
040805 E5          0442*       push hl ; save dy^2
040806             0443*   ; compute dx^2
040806 2A B0 07 04 0444*       ld hl,(dx168)
04080A CD 70 04 04 0445*       call hlu_abs
04080E E5          0446*       push hl
04080F D1          0447*       pop de
040810 CD 67 03 04 0448*       call umul24 ; hl = dx^2
040814             0449*   ; add dx^2 and dy^2
040814 D1          0450*       pop de ; de = dy^2 (was hl)
040815 19          0451*       add hl,de ; hl = dx^2 + dy^2
040816             0452*   ; compute the square root
040816 CD E7 08 04 0453*       call sqrt24 ; de = sqrt(dx^2 + dy^2)
04081A EB          0454*       ex de,hl ; hl = distance
04081B C9          0455*       ret
04081C             0456*   
04081C             0457*   ; atan2_(ub.c,ud.e) --> uh.l
04081C             0458*   ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
04081C             0459*   ;   whether inputs are integers or fractional doesn't matter
04081C             0460*   ;   so long as the sign bit of the upper byte is correct
04081C             0461*   ; output: uh.l is the 16.8 fixed angle in degrees 256
04081C             0462*   ; angles are COMPASS HEADINGS based on
04081C             0463*   ; screen coordinate conventions,where the y axis is flipped
04081C             0464*   ; #E0 224      0       32 #20
04081C             0465*   ;        -x,-y | +x,-y
04081C             0466*   ; #C0 192------+------ 64 #40
04081C             0467*   ;        -x,+y | +x,+y
04081C             0468*   ; #A0 160   128 #80   96 #60
04081C             0469*   atan2_168fast:
04081C             0470*   ; get signs and make everything positive
04081C             0471*   ; get abs(x) and store its original sign
04081C C5          0472*       push bc
04081D E1          0473*       pop hl
04081E CD 70 04 04 0474*       call hlu_abs ; if x was negative this also sets the sign flag
040822 E5          0475*       push hl ; store abs(x)
040823 C1          0476*       pop bc ; bc = abs(x)
040824 F5          0477*       push af ; store sign of x
040825             0478*   ; get abs(y) and store its original sign
040825 EB          0479*       ex de,hl ; hl = y
040826 CD 70 04 04 0480*       call hlu_abs ; if y was negative this also sets the sign flag
04082A EB          0481*       ex de,hl ; de = abs(y)
04082B F5          0482*       push af ; store sign of y
04082C             0483*   ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
04082C             0484*   ; this ensures that our lookup value is between 0 and 1 inclusive
04082C AF          0485*       xor a ; clear the carry flag
04082D D5          0486*       push de
04082E E1          0487*       pop hl
04082F ED 42       0488*       sbc hl,bc
040831 F5          0489*       push af ; save sign of de - bc
040832 F2 3B 08 04 0490*       jp p,@1 ; bc <= de, so we skip ahead
040836             0491*   ; otherwise we swap bc and de
040836 C5          0492*       push bc
040837 E1          0493*       pop hl
040838 EB          0494*       ex de,hl
040839 E5          0495*       push hl
04083A C1          0496*       pop bc
04083B             0497*   @1:
04083B             0498*   ; now we're ready to snag our preliminary result
04083B C5          0499*       push bc
04083C E1          0500*       pop hl
04083D CD AB 08 04 0501*       call atan_168fast ; uh.l comes back with prelim result
040841             0502*   ; now we adjust uh.l based on sign of de - bc
040841 F1          0503*       pop af
040842 F2 4E 08 04 0504*       jp p,@2 ; bc <= de,so we skip ahead
040846 EB          0505*       ex de,hl
040847 21 00 40 00 0506*       ld hl,64*256 ; subtract from 64 (90) degrees
04084B AF          0507*       xor a ; clear the carry flag
04084C ED 52       0508*       sbc hl,de
04084E             0509*   @2:
04084E             0510*   ; adjust the result based on quadrant
04084E             0511*   ; #E0 224      0       32 #20
04084E             0512*   ;        -x,-y | +x,-y
04084E             0513*   ; #C0 192------+------ 64 #40
04084E             0514*   ;        -x,+y | +x,+y
04084E             0515*   ; #A0 160   128 #80   96 #60
04084E F1          0516*       pop af ; sign of y
04084F CA 8C 08 04 0517*       jp z,@y_zero
040853 F2 6C 08 04 0518*       jp p,@y_pos
040857             0519*   ; y neg,check x
040857 F1          0520*       pop af ; sign of x
040858 CA 66 08 04 0521*       jp z,@y_neg_x_zero
04085C F2 6B 08 04 0522*       jp p,@y_neg_x_pos
040860             0523*   ; y neg,x neg
040860             0524*   ; angle is 128 to 256 (270 to 360)
040860             0525*   ; negating the intermediate does the trick
040860 CD 80 04 04 0526*       call neg_hlu
040864 18 31       0527*       jr @zero_hlu
040866             0528*   
040866             0529*   @y_neg_x_zero:
040866             0530*   ; y neg,x zero
040866             0531*   ; angle is 0
040866 21 00 00 00 0532*       ld hl,0
04086A C9          0533*       ret
04086B             0534*   @y_neg_x_pos:
04086B             0535*   ; y neg,x pos
04086B             0536*   ; angle is 0 to 64 (0 to 90)
04086B             0537*   ; so we're good
04086B C9          0538*       ret
04086C             0539*   
04086C             0540*   @y_pos:
04086C F1          0541*       pop af ; sign of x
04086D CA 7C 08 04 0542*       jp z,@y_pos_x_zero
040871 F2 81 08 04 0543*       jp p,@y_pos_x_pos
040875             0544*   ; y pos,x neg
040875             0545*   ; angle is 128 to 192 (180-270)
040875             0546*   ; so we add 128 to intermediate
040875 11 00 80 00 0547*       ld de,128*256
040879 19          0548*       add hl,de
04087A 18 1B       0549*       jr @zero_hlu
04087C             0550*   @y_pos_x_zero:
04087C             0551*   ; y pos,x zero
04087C             0552*   ; angle is 128 (180)
04087C 21 00 80 00 0553*       ld hl,128*256
040880 C9          0554*       ret
040881             0555*   @y_pos_x_pos:
040881             0556*   ; y pos,x pos
040881             0557*   ; angle is 64 to 128 (90 to 180)
040881             0558*   ; neg the intermediate and add 180 degrees
040881 CD 80 04 04 0559*       call neg_hlu
040885 11 00 80 00 0560*       ld de,128*256
040889 19          0561*       add hl,de
04088A 18 0B       0562*       jr @zero_hlu
04088C             0563*   
04088C             0564*   @y_zero:
04088C F1          0565*       pop af ; sign of x
04088D FA 92 08 04 0566*       jp m,@y_zero_x_neg
040891             0567*   ; y zero,x pos
040891             0568*   ; angle is 64 (90),nothing to do
040891 C9          0569*       ret
040892             0570*   @y_zero_x_neg:
040892             0571*   ; y zero ,x neg
040892             0572*   ; angle is 192 (270)
040892 21 00 C0 00 0573*       ld hl,192*256
040896 C9          0574*       ret
040897             0575*   @zero_hlu:
040897 AF          0576*       xor a
040898 22 A5 08 04 0577*       ld (@scratch),hl
04089C 32 A7 08 04 0578*       ld (@scratch+2),a
0408A0 2A A5 08 04 0579*       ld hl,(@scratch)
0408A4 C9          0580*       ret
0408A5             0581*   @scratch: ds 6
0408AB             0582*   
0408AB             0583*   ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0408AB             0584*   ; output: uh.l is the 16.8 fixed format angle in degrees 256
0408AB             0585*   ; destroys: a,hl,bc,de
0408AB             0586*   ; note: only works for angles from 0 to 32 (45) degrees
0408AB             0587*   ;   use atan2_168fast (which calls this proc) to handle the full 256 (360) degrees
0408AB             0588*   atan_168fast:
0408AB             0589*   ; because we use compass headings instead of geometric angles
0408AB             0590*   ; we compute dx/dy which is 1/tan(theta) in the maths world
0408AB             0591*   ; we can do faster unsigned division here because we know dx and dy are positive
       FF FF FF FF 
       FF FF 
0408AB CD 66 06 04 0592*       call udiv168 ; ud.e = dx/dy
0408AF EB          0593*       ex de,hl ; uh.l = dx/dy
0408B0             0594*   ; test uh.l for 0
0408B0 19          0595*       add hl,de
0408B1 B7          0596*       or a
0408B2 ED 52       0597*       sbc hl,de
0408B4 28 22       0598*       jr z,@is_zero
0408B6             0599*   ; test uh.l for 1
0408B6 AF          0600*       xor a ; clear carry
0408B7 EB          0601*       ex de,hl
0408B8 21 00 01 00 0602*       ld hl,1*256 ; 1 in 16.8 fixed format
0408BC ED 52       0603*       sbc hl,de
0408BE 28 13       0604*       jr z,@is_45
0408C0 EB          0605*       ex de,hl
0408C1             0606*   ; no special cases so we move on
0408C1             0607*   ; l contains the fractional portion of tan(uh.l)
0408C1             0608*   ; we multiply it by three to get our lookup table index
0408C1 26 03       0609*       ld h,3
0408C3 ED 6C       0610*       mlt hl ; index into lut
0408C5 11 00 00 00 0611*       ld de,0 ; clear deu
0408C9 54          0612*       ld d,h ; copy hl to de
0408CA 5D          0613*       ld e,l ; de contains our index
0408CB 21 D0 0C 04 0614*       ld hl,atan_lut_168 ; grab the lut address
0408CF 19          0615*       add hl,de ; bump hl by the index
0408D0 ED 27       0616*       ld hl,(hl) ; don't try this on a z80!
0408D2 C9          0617*       ret ; and out
0408D3             0618*   @is_45:
0408D3 21 00 20 00 0619*       ld hl,32*256
0408D7 C9          0620*       ret
0408D8             0621*   ; for the case tan(0)
0408D8             0622*   @is_zero:
0408D8 21 00 00 00 0623*       ld hl,0*256
0408DC C9          0624*       ret
0408DD             0625*   
0408DD             0626*   ; Expects  ADL mode
0408DD             0627*   ; Inputs:  UH.L
0408DD             0628*   ; Outputs: UH.L is the 16.8 square root
0408DD             0629*   ;          UDE is the integer difference inputHL-DE^2
0408DD             0630*   sqrt168:
0408DD CD E7 08 04 0631*       call sqrt24
0408E1 EB          0632*       ex de,hl
0408E2 29          0633*       add hl,hl
0408E3 29          0634*       add hl,hl
0408E4 29          0635*       add hl,hl
0408E5 29          0636*       add hl,hl
0408E6 C9          0637*       ret
0408E7             0638*   
0408E7             0639*   ; credit: xeda112358
0408E7             0640*   ; https://www.cemetech.net/forum/viewtopic.php?t=11178&postdays=0&postorder=asc&start=0
0408E7             0641*   sqrt24:
0408E7             0642*   ; Expects ADL mode
0408E7             0643*   ; Inputs: HL
0408E7             0644*   ; Outputs: DE is the integer square root
0408E7             0645*   ;  HL is the difference inputHL-DE^2
0408E7             0646*   ;  c flag reset
0408E7 01 00 00 00 0647*       ld bc,0 ; clear bcu
0408EB 11 00 00 00 0648*       ld de,0 ; clear deu
0408EF AF          0649*       xor a
0408F0 45          0650*       ld b,l
0408F1 C5          0651*       push bc
0408F2 47          0652*       ld b,a
0408F3 6F          0653*       ld l,a
0408F4             0654*   ; Iteration 1
0408F4 29          0655*       add hl,hl
0408F5 CB 11       0656*       rl c
0408F7 29          0657*       add hl,hl
0408F8 CB 11       0658*       rl c
0408FA 91          0659*       sub c
0408FB 30 04       0660*       jr nc,$+6
0408FD 1C          0661*       inc e
0408FE 1C          0662*       inc e
0408FF 2F          0663*       cpl
040900 4F          0664*       ld c,a
040901             0665*   ; Iteration 2
040901 29          0666*       add hl,hl
040902 CB 11       0667*       rl c
040904 29          0668*       add hl,hl
040905 CB 11       0669*       rl c
040907 CB 13       0670*       rl e
040909 7B          0671*       ld a,e
04090A 91          0672*       sub c
04090B 30 04       0673*       jr nc,$+6
04090D 1C          0674*       inc e
04090E 1C          0675*       inc e
04090F 2F          0676*       cpl
040910 4F          0677*       ld c,a
040911             0678*   ; Iteration 3
040911 29          0679*       add hl,hl
040912 CB 11       0680*       rl c
040914 29          0681*       add hl,hl
040915 CB 11       0682*       rl c
040917 CB 13       0683*       rl e
040919 7B          0684*       ld a,e
04091A 91          0685*       sub c
04091B 30 04       0686*       jr nc,$+6
04091D 1C          0687*       inc e
04091E 1C          0688*       inc e
04091F 2F          0689*       cpl
040920 4F          0690*       ld c,a
040921             0691*   ; Iteration 4
040921 29          0692*       add hl,hl
040922 CB 11       0693*       rl c
040924 29          0694*       add hl,hl
040925 CB 11       0695*       rl c
040927 CB 13       0696*       rl e
040929 7B          0697*       ld a,e
04092A 91          0698*       sub c
04092B 30 04       0699*       jr nc,$+6
04092D 1C          0700*       inc e
04092E 1C          0701*       inc e
04092F 2F          0702*       cpl
040930 4F          0703*       ld c,a
040931             0704*   ; Iteration 5
040931 29          0705*       add hl,hl
040932 CB 11       0706*       rl c
040934 29          0707*       add hl,hl
040935 CB 11       0708*       rl c
040937 CB 13       0709*       rl e
040939 7B          0710*       ld a,e
04093A 91          0711*       sub c
04093B 30 04       0712*       jr nc,$+6
04093D 1C          0713*       inc e
04093E 1C          0714*       inc e
04093F 2F          0715*       cpl
040940 4F          0716*       ld c,a
040941             0717*   ; Iteration 6
040941 29          0718*       add hl,hl
040942 CB 11       0719*       rl c
040944 29          0720*       add hl,hl
040945 CB 11       0721*       rl c
040947 CB 13       0722*       rl e
040949 7B          0723*       ld a,e
04094A 91          0724*       sub c
04094B 30 04       0725*       jr nc,$+6
04094D 1C          0726*       inc e
04094E 1C          0727*       inc e
04094F 2F          0728*       cpl
040950 4F          0729*       ld c,a
040951             0730*   ; Iteration 7
040951 29          0731*       add hl,hl
040952 CB 11       0732*       rl c
040954 29          0733*       add hl,hl
040955 CB 11       0734*       rl c
040957 CB 10       0735*       rl b
040959 EB          0736*       ex de,hl
04095A 29          0737*       add hl,hl
04095B E5          0738*       push hl
04095C ED 42       0739*       sbc hl,bc
04095E 30 06       0740*       jr nc,$+8
040960 7C          0741*       ld a,h
040961 2F          0742*       cpl
040962 47          0743*       ld b,a
040963 7D          0744*       ld a,l
040964 2F          0745*       cpl
040965 4F          0746*       ld c,a
040966 E1          0747*       pop hl
040967 30 02       0748*       jr nc,$+4
040969 23          0749*       inc hl
04096A 23          0750*       inc hl
04096B EB          0751*       ex de,hl
04096C             0752*   ; Iteration 8
04096C 29          0753*       add hl,hl
04096D 69          0754*       ld l,c
04096E 60          0755*       ld h,b
04096F ED 6A       0756*       adc hl,hl
040971 ED 6A       0757*       adc hl,hl
040973 EB          0758*       ex de,hl
040974 29          0759*       add hl,hl
040975 ED 52       0760*       sbc hl,de
040977 19          0761*       add hl,de
040978 EB          0762*       ex de,hl
040979 30 04       0763*       jr nc,$+6
04097B ED 52       0764*       sbc hl,de
04097D 13          0765*       inc de
04097E 13          0766*       inc de
04097F             0767*   ; Iteration 9
04097F F1          0768*       pop af
040980 17          0769*       rla
040981 ED 6A       0770*       adc hl,hl
040983 17          0771*       rla
040984 ED 6A       0772*       adc hl,hl
040986 EB          0773*       ex de,hl
040987 29          0774*       add hl,hl
040988 ED 52       0775*       sbc hl,de
04098A 19          0776*       add hl,de
04098B EB          0777*       ex de,hl
04098C 30 04       0778*       jr nc,$+6
04098E ED 52       0779*       sbc hl,de
040990 13          0780*       inc de
040991 13          0781*       inc de
040992             0782*   ; Iteration 10
040992 17          0783*       rla
040993 ED 6A       0784*       adc hl,hl
040995 17          0785*       rla
040996 ED 6A       0786*       adc hl,hl
040998 EB          0787*       ex de,hl
040999 29          0788*       add hl,hl
04099A ED 52       0789*       sbc hl,de
04099C 19          0790*       add hl,de
04099D EB          0791*       ex de,hl
04099E 30 04       0792*       jr nc,$+6
0409A0 ED 52       0793*       sbc hl,de
0409A2 13          0794*       inc de
0409A3 13          0795*       inc de
0409A4             0796*   ; Iteration 11
0409A4 17          0797*       rla
0409A5 ED 6A       0798*       adc hl,hl
0409A7 17          0799*       rla
0409A8 ED 6A       0800*       adc hl,hl
0409AA EB          0801*       ex de,hl
0409AB 29          0802*       add hl,hl
0409AC ED 52       0803*       sbc hl,de
0409AE 19          0804*       add hl,de
0409AF EB          0805*       ex de,hl
0409B0 30 04       0806*       jr nc,$+6
0409B2 ED 52       0807*       sbc hl,de
0409B4 13          0808*       inc de
0409B5 13          0809*       inc de
0409B6             0810*   ; Iteration 12
0409B6 17          0811*       rla
0409B7 ED 6A       0812*       adc hl,hl
0409B9 17          0813*       rla
0409BA ED 6A       0814*       adc hl,hl
0409BC EB          0815*       ex de,hl
0409BD 29          0816*       add hl,hl
0409BE ED 52       0817*       sbc hl,de
0409C0 19          0818*       add hl,de
0409C1 EB          0819*       ex de,hl
0409C2 30 04       0820*       jr nc,$+6
0409C4 ED 52       0821*       sbc hl,de
0409C6 13          0822*       inc de
0409C7 13          0823*       inc de
0409C8 CB 1A       0824*       rr d
0409CA CB 1B       0825*       rr e
0409CC C9          0826*       ret
0409CD             0827*   
0409CD             0828*   sin_lut_168:
0409CD 00 00 00    0829*       dl 0x000000 ; 0.000 00, 0.000
0409D0 06 00 00    0830*       dl 0x000006 ; 1.406 01, 0.025
0409D3 0C 00 00    0831*       dl 0x00000C ; 2.813 02, 0.049
0409D6 12 00 00    0832*       dl 0x000012 ; 4.219 03, 0.074
0409D9 19 00 00    0833*       dl 0x000019 ; 5.625 04, 0.098
0409DC 1F 00 00    0834*       dl 0x00001F ; 7.031 05, 0.122
0409DF 25 00 00    0835*       dl 0x000025 ; 8.438 06, 0.147
0409E2 2B 00 00    0836*       dl 0x00002B ; 9.844 07, 0.171
0409E5 31 00 00    0837*       dl 0x000031 ; 11.250 08, 0.195
0409E8 38 00 00    0838*       dl 0x000038 ; 12.656 09, 0.219
0409EB 3E 00 00    0839*       dl 0x00003E ; 14.063 0A, 0.243
0409EE 44 00 00    0840*       dl 0x000044 ; 15.469 0B, 0.267
0409F1 4A 00 00    0841*       dl 0x00004A ; 16.875 0C, 0.290
0409F4 50 00 00    0842*       dl 0x000050 ; 18.281 0D, 0.314
0409F7 56 00 00    0843*       dl 0x000056 ; 19.688 0E, 0.337
0409FA 5C 00 00    0844*       dl 0x00005C ; 21.094 0F, 0.360
0409FD 61 00 00    0845*       dl 0x000061 ; 22.500 10, 0.383
040A00 67 00 00    0846*       dl 0x000067 ; 23.906 11, 0.405
040A03 6D 00 00    0847*       dl 0x00006D ; 25.313 12, 0.428
040A06 73 00 00    0848*       dl 0x000073 ; 26.719 13, 0.450
040A09 78 00 00    0849*       dl 0x000078 ; 28.125 14, 0.471
040A0C 7E 00 00    0850*       dl 0x00007E ; 29.531 15, 0.493
040A0F 83 00 00    0851*       dl 0x000083 ; 30.938 16, 0.514
040A12 88 00 00    0852*       dl 0x000088 ; 32.344 17, 0.535
040A15 8E 00 00    0853*       dl 0x00008E ; 33.750 18, 0.556
040A18 93 00 00    0854*       dl 0x000093 ; 35.156 19, 0.576
040A1B 98 00 00    0855*       dl 0x000098 ; 36.563 1A, 0.596
040A1E 9D 00 00    0856*       dl 0x00009D ; 37.969 1B, 0.615
040A21 A2 00 00    0857*       dl 0x0000A2 ; 39.375 1C, 0.634
040A24 A7 00 00    0858*       dl 0x0000A7 ; 40.781 1D, 0.653
040A27 AB 00 00    0859*       dl 0x0000AB ; 42.188 1E, 0.672
040A2A B0 00 00    0860*       dl 0x0000B0 ; 43.594 1F, 0.690
040A2D B5 00 00    0861*       dl 0x0000B5 ; 45.000 20, 0.707
040A30 B9 00 00    0862*       dl 0x0000B9 ; 46.406 21, 0.724
040A33 BD 00 00    0863*       dl 0x0000BD ; 47.813 22, 0.741
040A36 C1 00 00    0864*       dl 0x0000C1 ; 49.219 23, 0.757
040A39 C5 00 00    0865*       dl 0x0000C5 ; 50.625 24, 0.773
040A3C C9 00 00    0866*       dl 0x0000C9 ; 52.031 25, 0.788
040A3F CD 00 00    0867*       dl 0x0000CD ; 53.438 26, 0.803
040A42 D1 00 00    0868*       dl 0x0000D1 ; 54.844 27, 0.818
040A45 D4 00 00    0869*       dl 0x0000D4 ; 56.250 28, 0.831
040A48 D8 00 00    0870*       dl 0x0000D8 ; 57.656 29, 0.845
040A4B DB 00 00    0871*       dl 0x0000DB ; 59.063 2A, 0.858
040A4E DE 00 00    0872*       dl 0x0000DE ; 60.469 2B, 0.870
040A51 E1 00 00    0873*       dl 0x0000E1 ; 61.875 2C, 0.882
040A54 E4 00 00    0874*       dl 0x0000E4 ; 63.281 2D, 0.893
040A57 E7 00 00    0875*       dl 0x0000E7 ; 64.688 2E, 0.904
040A5A EA 00 00    0876*       dl 0x0000EA ; 66.094 2F, 0.914
040A5D EC 00 00    0877*       dl 0x0000EC ; 67.500 30, 0.924
040A60 EE 00 00    0878*       dl 0x0000EE ; 68.906 31, 0.933
040A63 F1 00 00    0879*       dl 0x0000F1 ; 70.313 32, 0.942
040A66 F3 00 00    0880*       dl 0x0000F3 ; 71.719 33, 0.950
040A69 F4 00 00    0881*       dl 0x0000F4 ; 73.125 34, 0.957
040A6C F6 00 00    0882*       dl 0x0000F6 ; 74.531 35, 0.964
040A6F F8 00 00    0883*       dl 0x0000F8 ; 75.938 36, 0.970
040A72 F9 00 00    0884*       dl 0x0000F9 ; 77.344 37, 0.976
040A75 FB 00 00    0885*       dl 0x0000FB ; 78.750 38, 0.981
040A78 FC 00 00    0886*       dl 0x0000FC ; 80.156 39, 0.985
040A7B FD 00 00    0887*       dl 0x0000FD ; 81.563 3A, 0.989
040A7E FE 00 00    0888*       dl 0x0000FE ; 82.969 3B, 0.992
040A81 FE 00 00    0889*       dl 0x0000FE ; 84.375 3C, 0.995
040A84 FF 00 00    0890*       dl 0x0000FF ; 85.781 3D, 0.997
040A87 FF 00 00    0891*       dl 0x0000FF ; 87.188 3E, 0.999
040A8A FF 00 00    0892*       dl 0x0000FF ; 88.594 3F, 1.000
040A8D 00 01 00    0893*       dl 0x000100 ; 90.000 40, 1.000
040A90 FF 00 00    0894*       dl 0x0000FF ; 91.406 41, 1.000
040A93 FF 00 00    0895*       dl 0x0000FF ; 92.813 42, 0.999
040A96 FF 00 00    0896*       dl 0x0000FF ; 94.219 43, 0.997
040A99 FE 00 00    0897*       dl 0x0000FE ; 95.625 44, 0.995
040A9C FE 00 00    0898*       dl 0x0000FE ; 97.031 45, 0.992
040A9F FD 00 00    0899*       dl 0x0000FD ; 98.438 46, 0.989
040AA2 FC 00 00    0900*       dl 0x0000FC ; 99.844 47, 0.985
040AA5 FB 00 00    0901*       dl 0x0000FB ; 101.250 48, 0.981
040AA8 F9 00 00    0902*       dl 0x0000F9 ; 102.656 49, 0.976
040AAB F8 00 00    0903*       dl 0x0000F8 ; 104.063 4A, 0.970
040AAE F6 00 00    0904*       dl 0x0000F6 ; 105.469 4B, 0.964
040AB1 F4 00 00    0905*       dl 0x0000F4 ; 106.875 4C, 0.957
040AB4 F3 00 00    0906*       dl 0x0000F3 ; 108.281 4D, 0.950
040AB7 F1 00 00    0907*       dl 0x0000F1 ; 109.688 4E, 0.942
040ABA EE 00 00    0908*       dl 0x0000EE ; 111.094 4F, 0.933
040ABD EC 00 00    0909*       dl 0x0000EC ; 112.500 50, 0.924
040AC0 EA 00 00    0910*       dl 0x0000EA ; 113.906 51, 0.914
040AC3 E7 00 00    0911*       dl 0x0000E7 ; 115.313 52, 0.904
040AC6 E4 00 00    0912*       dl 0x0000E4 ; 116.719 53, 0.893
040AC9 E1 00 00    0913*       dl 0x0000E1 ; 118.125 54, 0.882
040ACC DE 00 00    0914*       dl 0x0000DE ; 119.531 55, 0.870
040ACF DB 00 00    0915*       dl 0x0000DB ; 120.938 56, 0.858
040AD2 D8 00 00    0916*       dl 0x0000D8 ; 122.344 57, 0.845
040AD5 D4 00 00    0917*       dl 0x0000D4 ; 123.750 58, 0.831
040AD8 D1 00 00    0918*       dl 0x0000D1 ; 125.156 59, 0.818
040ADB CD 00 00    0919*       dl 0x0000CD ; 126.563 5A, 0.803
040ADE C9 00 00    0920*       dl 0x0000C9 ; 127.969 5B, 0.788
040AE1 C5 00 00    0921*       dl 0x0000C5 ; 129.375 5C, 0.773
040AE4 C1 00 00    0922*       dl 0x0000C1 ; 130.781 5D, 0.757
040AE7 BD 00 00    0923*       dl 0x0000BD ; 132.188 5E, 0.741
040AEA B9 00 00    0924*       dl 0x0000B9 ; 133.594 5F, 0.724
040AED B5 00 00    0925*       dl 0x0000B5 ; 135.000 60, 0.707
040AF0 B0 00 00    0926*       dl 0x0000B0 ; 136.406 61, 0.690
040AF3 AB 00 00    0927*       dl 0x0000AB ; 137.813 62, 0.672
040AF6 A7 00 00    0928*       dl 0x0000A7 ; 139.219 63, 0.653
040AF9 A2 00 00    0929*       dl 0x0000A2 ; 140.625 64, 0.634
040AFC 9D 00 00    0930*       dl 0x00009D ; 142.031 65, 0.615
040AFF 98 00 00    0931*       dl 0x000098 ; 143.438 66, 0.596
040B02 93 00 00    0932*       dl 0x000093 ; 144.844 67, 0.576
040B05 8E 00 00    0933*       dl 0x00008E ; 146.250 68, 0.556
040B08 88 00 00    0934*       dl 0x000088 ; 147.656 69, 0.535
040B0B 83 00 00    0935*       dl 0x000083 ; 149.063 6A, 0.514
040B0E 7E 00 00    0936*       dl 0x00007E ; 150.469 6B, 0.493
040B11 78 00 00    0937*       dl 0x000078 ; 151.875 6C, 0.471
040B14 73 00 00    0938*       dl 0x000073 ; 153.281 6D, 0.450
040B17 6D 00 00    0939*       dl 0x00006D ; 154.688 6E, 0.428
040B1A 67 00 00    0940*       dl 0x000067 ; 156.094 6F, 0.405
040B1D 61 00 00    0941*       dl 0x000061 ; 157.500 70, 0.383
040B20 5C 00 00    0942*       dl 0x00005C ; 158.906 71, 0.360
040B23 56 00 00    0943*       dl 0x000056 ; 160.313 72, 0.337
040B26 50 00 00    0944*       dl 0x000050 ; 161.719 73, 0.314
040B29 4A 00 00    0945*       dl 0x00004A ; 163.125 74, 0.290
040B2C 44 00 00    0946*       dl 0x000044 ; 164.531 75, 0.267
040B2F 3E 00 00    0947*       dl 0x00003E ; 165.938 76, 0.243
040B32 38 00 00    0948*       dl 0x000038 ; 167.344 77, 0.219
040B35 31 00 00    0949*       dl 0x000031 ; 168.750 78, 0.195
040B38 2B 00 00    0950*       dl 0x00002B ; 170.156 79, 0.171
040B3B 25 00 00    0951*       dl 0x000025 ; 171.563 7A, 0.147
040B3E 1F 00 00    0952*       dl 0x00001F ; 172.969 7B, 0.122
040B41 19 00 00    0953*       dl 0x000019 ; 174.375 7C, 0.098
040B44 12 00 00    0954*       dl 0x000012 ; 175.781 7D, 0.074
040B47 0C 00 00    0955*       dl 0x00000C ; 177.188 7E, 0.049
040B4A 06 00 00    0956*       dl 0x000006 ; 178.594 7F, 0.025
040B4D 00 00 00    0957*       dl 0x000000 ; 180.000 80, 0.000
040B50 FA FF FF    0958*       dl 0xFFFFFA ; 181.406 81, -0.025
040B53 F4 FF FF    0959*       dl 0xFFFFF4 ; 182.813 82, -0.049
040B56 EE FF FF    0960*       dl 0xFFFFEE ; 184.219 83, -0.074
040B59 E7 FF FF    0961*       dl 0xFFFFE7 ; 185.625 84, -0.098
040B5C E1 FF FF    0962*       dl 0xFFFFE1 ; 187.031 85, -0.122
040B5F DB FF FF    0963*       dl 0xFFFFDB ; 188.438 86, -0.147
040B62 D5 FF FF    0964*       dl 0xFFFFD5 ; 189.844 87, -0.171
040B65 CF FF FF    0965*       dl 0xFFFFCF ; 191.250 88, -0.195
040B68 C8 FF FF    0966*       dl 0xFFFFC8 ; 192.656 89, -0.219
040B6B C2 FF FF    0967*       dl 0xFFFFC2 ; 194.063 8A, -0.243
040B6E BC FF FF    0968*       dl 0xFFFFBC ; 195.469 8B, -0.267
040B71 B6 FF FF    0969*       dl 0xFFFFB6 ; 196.875 8C, -0.290
040B74 B0 FF FF    0970*       dl 0xFFFFB0 ; 198.281 8D, -0.314
040B77 AA FF FF    0971*       dl 0xFFFFAA ; 199.688 8E, -0.337
040B7A A4 FF FF    0972*       dl 0xFFFFA4 ; 201.094 8F, -0.360
040B7D 9F FF FF    0973*       dl 0xFFFF9F ; 202.500 90, -0.383
040B80 99 FF FF    0974*       dl 0xFFFF99 ; 203.906 91, -0.405
040B83 93 FF FF    0975*       dl 0xFFFF93 ; 205.313 92, -0.428
040B86 8D FF FF    0976*       dl 0xFFFF8D ; 206.719 93, -0.450
040B89 88 FF FF    0977*       dl 0xFFFF88 ; 208.125 94, -0.471
040B8C 82 FF FF    0978*       dl 0xFFFF82 ; 209.531 95, -0.493
040B8F 7D FF FF    0979*       dl 0xFFFF7D ; 210.938 96, -0.514
040B92 78 FF FF    0980*       dl 0xFFFF78 ; 212.344 97, -0.535
040B95 72 FF FF    0981*       dl 0xFFFF72 ; 213.750 98, -0.556
040B98 6D FF FF    0982*       dl 0xFFFF6D ; 215.156 99, -0.576
040B9B 68 FF FF    0983*       dl 0xFFFF68 ; 216.563 9A, -0.596
040B9E 63 FF FF    0984*       dl 0xFFFF63 ; 217.969 9B, -0.615
040BA1 5E FF FF    0985*       dl 0xFFFF5E ; 219.375 9C, -0.634
040BA4 59 FF FF    0986*       dl 0xFFFF59 ; 220.781 9D, -0.653
040BA7 55 FF FF    0987*       dl 0xFFFF55 ; 222.188 9E, -0.672
040BAA 50 FF FF    0988*       dl 0xFFFF50 ; 223.594 9F, -0.690
040BAD 4B FF FF    0989*       dl 0xFFFF4B ; 225.000 A0, -0.707
040BB0 47 FF FF    0990*       dl 0xFFFF47 ; 226.406 A1, -0.724
040BB3 43 FF FF    0991*       dl 0xFFFF43 ; 227.813 A2, -0.741
040BB6 3F FF FF    0992*       dl 0xFFFF3F ; 229.219 A3, -0.757
040BB9 3B FF FF    0993*       dl 0xFFFF3B ; 230.625 A4, -0.773
040BBC 37 FF FF    0994*       dl 0xFFFF37 ; 232.031 A5, -0.788
040BBF 33 FF FF    0995*       dl 0xFFFF33 ; 233.438 A6, -0.803
040BC2 2F FF FF    0996*       dl 0xFFFF2F ; 234.844 A7, -0.818
040BC5 2C FF FF    0997*       dl 0xFFFF2C ; 236.250 A8, -0.831
040BC8 28 FF FF    0998*       dl 0xFFFF28 ; 237.656 A9, -0.845
040BCB 25 FF FF    0999*       dl 0xFFFF25 ; 239.063 AA, -0.858
040BCE 22 FF FF    1000*       dl 0xFFFF22 ; 240.469 AB, -0.870
040BD1 1F FF FF    1001*       dl 0xFFFF1F ; 241.875 AC, -0.882
040BD4 1C FF FF    1002*       dl 0xFFFF1C ; 243.281 AD, -0.893
040BD7 19 FF FF    1003*       dl 0xFFFF19 ; 244.688 AE, -0.904
040BDA 16 FF FF    1004*       dl 0xFFFF16 ; 246.094 AF, -0.914
040BDD 14 FF FF    1005*       dl 0xFFFF14 ; 247.500 B0, -0.924
040BE0 12 FF FF    1006*       dl 0xFFFF12 ; 248.906 B1, -0.933
040BE3 0F FF FF    1007*       dl 0xFFFF0F ; 250.313 B2, -0.942
040BE6 0D FF FF    1008*       dl 0xFFFF0D ; 251.719 B3, -0.950
040BE9 0C FF FF    1009*       dl 0xFFFF0C ; 253.125 B4, -0.957
040BEC 0A FF FF    1010*       dl 0xFFFF0A ; 254.531 B5, -0.964
040BEF 08 FF FF    1011*       dl 0xFFFF08 ; 255.938 B6, -0.970
040BF2 07 FF FF    1012*       dl 0xFFFF07 ; 257.344 B7, -0.976
040BF5 05 FF FF    1013*       dl 0xFFFF05 ; 258.750 B8, -0.981
040BF8 04 FF FF    1014*       dl 0xFFFF04 ; 260.156 B9, -0.985
040BFB 03 FF FF    1015*       dl 0xFFFF03 ; 261.563 BA, -0.989
040BFE 02 FF FF    1016*       dl 0xFFFF02 ; 262.969 BB, -0.992
040C01 02 FF FF    1017*       dl 0xFFFF02 ; 264.375 BC, -0.995
040C04 01 FF FF    1018*       dl 0xFFFF01 ; 265.781 BD, -0.997
040C07 01 FF FF    1019*       dl 0xFFFF01 ; 267.188 BE, -0.999
040C0A 01 FF FF    1020*       dl 0xFFFF01 ; 268.594 BF, -1.000
040C0D 00 FF FF    1021*       dl 0xFFFF00 ; 270.000 C0, -1.000
040C10 01 FF FF    1022*       dl 0xFFFF01 ; 271.406 C1, -1.000
040C13 01 FF FF    1023*       dl 0xFFFF01 ; 272.813 C2, -0.999
040C16 01 FF FF    1024*       dl 0xFFFF01 ; 274.219 C3, -0.997
040C19 02 FF FF    1025*       dl 0xFFFF02 ; 275.625 C4, -0.995
040C1C 02 FF FF    1026*       dl 0xFFFF02 ; 277.031 C5, -0.992
040C1F 03 FF FF    1027*       dl 0xFFFF03 ; 278.438 C6, -0.989
040C22 04 FF FF    1028*       dl 0xFFFF04 ; 279.844 C7, -0.985
040C25 05 FF FF    1029*       dl 0xFFFF05 ; 281.250 C8, -0.981
040C28 07 FF FF    1030*       dl 0xFFFF07 ; 282.656 C9, -0.976
040C2B 08 FF FF    1031*       dl 0xFFFF08 ; 284.063 CA, -0.970
040C2E 0A FF FF    1032*       dl 0xFFFF0A ; 285.469 CB, -0.964
040C31 0C FF FF    1033*       dl 0xFFFF0C ; 286.875 CC, -0.957
040C34 0D FF FF    1034*       dl 0xFFFF0D ; 288.281 CD, -0.950
040C37 0F FF FF    1035*       dl 0xFFFF0F ; 289.688 CE, -0.942
040C3A 12 FF FF    1036*       dl 0xFFFF12 ; 291.094 CF, -0.933
040C3D 14 FF FF    1037*       dl 0xFFFF14 ; 292.500 D0, -0.924
040C40 16 FF FF    1038*       dl 0xFFFF16 ; 293.906 D1, -0.914
040C43 19 FF FF    1039*       dl 0xFFFF19 ; 295.313 D2, -0.904
040C46 1C FF FF    1040*       dl 0xFFFF1C ; 296.719 D3, -0.893
040C49 1F FF FF    1041*       dl 0xFFFF1F ; 298.125 D4, -0.882
040C4C 22 FF FF    1042*       dl 0xFFFF22 ; 299.531 D5, -0.870
040C4F 25 FF FF    1043*       dl 0xFFFF25 ; 300.938 D6, -0.858
040C52 28 FF FF    1044*       dl 0xFFFF28 ; 302.344 D7, -0.845
040C55 2C FF FF    1045*       dl 0xFFFF2C ; 303.750 D8, -0.831
040C58 2F FF FF    1046*       dl 0xFFFF2F ; 305.156 D9, -0.818
040C5B 33 FF FF    1047*       dl 0xFFFF33 ; 306.563 DA, -0.803
040C5E 37 FF FF    1048*       dl 0xFFFF37 ; 307.969 DB, -0.788
040C61 3B FF FF    1049*       dl 0xFFFF3B ; 309.375 DC, -0.773
040C64 3F FF FF    1050*       dl 0xFFFF3F ; 310.781 DD, -0.757
040C67 43 FF FF    1051*       dl 0xFFFF43 ; 312.188 DE, -0.741
040C6A 47 FF FF    1052*       dl 0xFFFF47 ; 313.594 DF, -0.724
040C6D 4B FF FF    1053*       dl 0xFFFF4B ; 315.000 E0, -0.707
040C70 50 FF FF    1054*       dl 0xFFFF50 ; 316.406 E1, -0.690
040C73 55 FF FF    1055*       dl 0xFFFF55 ; 317.813 E2, -0.672
040C76 59 FF FF    1056*       dl 0xFFFF59 ; 319.219 E3, -0.653
040C79 5E FF FF    1057*       dl 0xFFFF5E ; 320.625 E4, -0.634
040C7C 63 FF FF    1058*       dl 0xFFFF63 ; 322.031 E5, -0.615
040C7F 68 FF FF    1059*       dl 0xFFFF68 ; 323.438 E6, -0.596
040C82 6D FF FF    1060*       dl 0xFFFF6D ; 324.844 E7, -0.576
040C85 72 FF FF    1061*       dl 0xFFFF72 ; 326.250 E8, -0.556
040C88 78 FF FF    1062*       dl 0xFFFF78 ; 327.656 E9, -0.535
040C8B 7D FF FF    1063*       dl 0xFFFF7D ; 329.063 EA, -0.514
040C8E 82 FF FF    1064*       dl 0xFFFF82 ; 330.469 EB, -0.493
040C91 88 FF FF    1065*       dl 0xFFFF88 ; 331.875 EC, -0.471
040C94 8D FF FF    1066*       dl 0xFFFF8D ; 333.281 ED, -0.450
040C97 93 FF FF    1067*       dl 0xFFFF93 ; 334.688 EE, -0.428
040C9A 99 FF FF    1068*       dl 0xFFFF99 ; 336.094 EF, -0.405
040C9D 9F FF FF    1069*       dl 0xFFFF9F ; 337.500 F0, -0.383
040CA0 A4 FF FF    1070*       dl 0xFFFFA4 ; 338.906 F1, -0.360
040CA3 AA FF FF    1071*       dl 0xFFFFAA ; 340.313 F2, -0.337
040CA6 B0 FF FF    1072*       dl 0xFFFFB0 ; 341.719 F3, -0.314
040CA9 B6 FF FF    1073*       dl 0xFFFFB6 ; 343.125 F4, -0.290
040CAC BC FF FF    1074*       dl 0xFFFFBC ; 344.531 F5, -0.267
040CAF C2 FF FF    1075*       dl 0xFFFFC2 ; 345.938 F6, -0.243
040CB2 C8 FF FF    1076*       dl 0xFFFFC8 ; 347.344 F7, -0.219
040CB5 CF FF FF    1077*       dl 0xFFFFCF ; 348.750 F8, -0.195
040CB8 D5 FF FF    1078*       dl 0xFFFFD5 ; 350.156 F9, -0.171
040CBB DB FF FF    1079*       dl 0xFFFFDB ; 351.563 FA, -0.147
040CBE E1 FF FF    1080*       dl 0xFFFFE1 ; 352.969 FB, -0.122
040CC1 E7 FF FF    1081*       dl 0xFFFFE7 ; 354.375 FC, -0.098
040CC4 EE FF FF    1082*       dl 0xFFFFEE ; 355.781 FD, -0.074
040CC7 F4 FF FF    1083*       dl 0xFFFFF4 ; 357.188 FE, -0.049
040CCA FA FF FF    1084*       dl 0xFFFFFA ; 358.594 FF, -0.025
040CCD 00 00 00    1085*       dl 0x000000 ; 0.000 00, 0.000 for interpolation
040CD0             1086*   
040CD0             1087*   atan_lut_168:
040CD0 00 00 00    1088*       dl 0x000000 ; 000000, 0.000
040CD3 28 00 00    1089*       dl 0x000028 ; 000001, 0.224
040CD6 51 00 00    1090*       dl 0x000051 ; 000002, 0.448
040CD9 7A 00 00    1091*       dl 0x00007A ; 000003, 0.671
040CDC A2 00 00    1092*       dl 0x0000A2 ; 000004, 0.895
040CDF CB 00 00    1093*       dl 0x0000CB ; 000005, 1.119
040CE2 F4 00 00    1094*       dl 0x0000F4 ; 000006, 1.343
040CE5 1D 01 00    1095*       dl 0x00011D ; 000007, 1.566
040CE8 45 01 00    1096*       dl 0x000145 ; 000008, 1.790
040CEB 6E 01 00    1097*       dl 0x00016E ; 000009, 2.013
040CEE 97 01 00    1098*       dl 0x000197 ; 00000A, 2.237
040CF1 BF 01 00    1099*       dl 0x0001BF ; 00000B, 2.460
040CF4 E8 01 00    1100*       dl 0x0001E8 ; 00000C, 2.684
040CF7 11 02 00    1101*       dl 0x000211 ; 00000D, 2.907
040CFA 39 02 00    1102*       dl 0x000239 ; 00000E, 3.130
040CFD 62 02 00    1103*       dl 0x000262 ; 00000F, 3.353
040D00 8B 02 00    1104*       dl 0x00028B ; 000010, 3.576
040D03 B3 02 00    1105*       dl 0x0002B3 ; 000011, 3.799
040D06 DC 02 00    1106*       dl 0x0002DC ; 000012, 4.022
040D09 04 03 00    1107*       dl 0x000304 ; 000013, 4.245
040D0C 2D 03 00    1108*       dl 0x00032D ; 000014, 4.467
040D0F 55 03 00    1109*       dl 0x000355 ; 000015, 4.690
040D12 7E 03 00    1110*       dl 0x00037E ; 000016, 4.912
040D15 A6 03 00    1111*       dl 0x0003A6 ; 000017, 5.134
040D18 CE 03 00    1112*       dl 0x0003CE ; 000018, 5.356
040D1B F7 03 00    1113*       dl 0x0003F7 ; 000019, 5.578
040D1E 1F 04 00    1114*       dl 0x00041F ; 00001A, 5.799
040D21 48 04 00    1115*       dl 0x000448 ; 00001B, 6.021
040D24 70 04 00    1116*       dl 0x000470 ; 00001C, 6.242
040D27 98 04 00    1117*       dl 0x000498 ; 00001D, 6.463
040D2A C0 04 00    1118*       dl 0x0004C0 ; 00001E, 6.684
040D2D E8 04 00    1119*       dl 0x0004E8 ; 00001F, 6.905
040D30 11 05 00    1120*       dl 0x000511 ; 000020, 7.125
040D33 39 05 00    1121*       dl 0x000539 ; 000021, 7.345
040D36 61 05 00    1122*       dl 0x000561 ; 000022, 7.565
040D39 89 05 00    1123*       dl 0x000589 ; 000023, 7.785
040D3C B1 05 00    1124*       dl 0x0005B1 ; 000024, 8.005
040D3F D9 05 00    1125*       dl 0x0005D9 ; 000025, 8.224
040D42 01 06 00    1126*       dl 0x000601 ; 000026, 8.443
040D45 28 06 00    1127*       dl 0x000628 ; 000027, 8.662
040D48 50 06 00    1128*       dl 0x000650 ; 000028, 8.881
040D4B 78 06 00    1129*       dl 0x000678 ; 000029, 9.099
040D4E A0 06 00    1130*       dl 0x0006A0 ; 00002A, 9.317
040D51 C7 06 00    1131*       dl 0x0006C7 ; 00002B, 9.535
040D54 EF 06 00    1132*       dl 0x0006EF ; 00002C, 9.752
040D57 16 07 00    1133*       dl 0x000716 ; 00002D, 9.970
040D5A 3E 07 00    1134*       dl 0x00073E ; 00002E, 10.187
040D5D 65 07 00    1135*       dl 0x000765 ; 00002F, 10.403
040D60 8D 07 00    1136*       dl 0x00078D ; 000030, 10.620
040D63 B4 07 00    1137*       dl 0x0007B4 ; 000031, 10.836
040D66 DB 07 00    1138*       dl 0x0007DB ; 000032, 11.051
040D69 03 08 00    1139*       dl 0x000803 ; 000033, 11.267
040D6C 2A 08 00    1140*       dl 0x00082A ; 000034, 11.482
040D6F 51 08 00    1141*       dl 0x000851 ; 000035, 11.697
040D72 78 08 00    1142*       dl 0x000878 ; 000036, 11.911
040D75 9F 08 00    1143*       dl 0x00089F ; 000037, 12.125
040D78 C6 08 00    1144*       dl 0x0008C6 ; 000038, 12.339
040D7B ED 08 00    1145*       dl 0x0008ED ; 000039, 12.553
040D7E 13 09 00    1146*       dl 0x000913 ; 00003A, 12.766
040D81 3A 09 00    1147*       dl 0x00093A ; 00003B, 12.978
040D84 61 09 00    1148*       dl 0x000961 ; 00003C, 13.191
040D87 87 09 00    1149*       dl 0x000987 ; 00003D, 13.403
040D8A AE 09 00    1150*       dl 0x0009AE ; 00003E, 13.614
040D8D D4 09 00    1151*       dl 0x0009D4 ; 00003F, 13.825
040D90 FB 09 00    1152*       dl 0x0009FB ; 000040, 14.036
040D93 21 0A 00    1153*       dl 0x000A21 ; 000041, 14.247
040D96 47 0A 00    1154*       dl 0x000A47 ; 000042, 14.457
040D99 6D 0A 00    1155*       dl 0x000A6D ; 000043, 14.666
040D9C 94 0A 00    1156*       dl 0x000A94 ; 000044, 14.876
040D9F BA 0A 00    1157*       dl 0x000ABA ; 000045, 15.085
040DA2 E0 0A 00    1158*       dl 0x000AE0 ; 000046, 15.293
040DA5 05 0B 00    1159*       dl 0x000B05 ; 000047, 15.501
040DA8 2B 0B 00    1160*       dl 0x000B2B ; 000048, 15.709
040DAB 51 0B 00    1161*       dl 0x000B51 ; 000049, 15.916
040DAE 77 0B 00    1162*       dl 0x000B77 ; 00004A, 16.123
040DB1 9C 0B 00    1163*       dl 0x000B9C ; 00004B, 16.329
040DB4 C2 0B 00    1164*       dl 0x000BC2 ; 00004C, 16.535
040DB7 E7 0B 00    1165*       dl 0x000BE7 ; 00004D, 16.740
040DBA 0C 0C 00    1166*       dl 0x000C0C ; 00004E, 16.945
040DBD 32 0C 00    1167*       dl 0x000C32 ; 00004F, 17.150
040DC0 57 0C 00    1168*       dl 0x000C57 ; 000050, 17.354
040DC3 7C 0C 00    1169*       dl 0x000C7C ; 000051, 17.558
040DC6 A1 0C 00    1170*       dl 0x000CA1 ; 000052, 17.761
040DC9 C6 0C 00    1171*       dl 0x000CC6 ; 000053, 17.964
040DCC EB 0C 00    1172*       dl 0x000CEB ; 000054, 18.166
040DCF 0F 0D 00    1173*       dl 0x000D0F ; 000055, 18.368
040DD2 34 0D 00    1174*       dl 0x000D34 ; 000056, 18.569
040DD5 58 0D 00    1175*       dl 0x000D58 ; 000057, 18.770
040DD8 7D 0D 00    1176*       dl 0x000D7D ; 000058, 18.970
040DDB A1 0D 00    1177*       dl 0x000DA1 ; 000059, 19.170
040DDE C6 0D 00    1178*       dl 0x000DC6 ; 00005A, 19.370
040DE1 EA 0D 00    1179*       dl 0x000DEA ; 00005B, 19.569
040DE4 0E 0E 00    1180*       dl 0x000E0E ; 00005C, 19.767
040DE7 32 0E 00    1181*       dl 0x000E32 ; 00005D, 19.965
040DEA 56 0E 00    1182*       dl 0x000E56 ; 00005E, 20.163
040DED 7A 0E 00    1183*       dl 0x000E7A ; 00005F, 20.360
040DF0 9E 0E 00    1184*       dl 0x000E9E ; 000060, 20.556
040DF3 C1 0E 00    1185*       dl 0x000EC1 ; 000061, 20.752
040DF6 E5 0E 00    1186*       dl 0x000EE5 ; 000062, 20.947
040DF9 08 0F 00    1187*       dl 0x000F08 ; 000063, 21.142
040DFC 2C 0F 00    1188*       dl 0x000F2C ; 000064, 21.337
040DFF 4F 0F 00    1189*       dl 0x000F4F ; 000065, 21.531
040E02 72 0F 00    1190*       dl 0x000F72 ; 000066, 21.724
040E05 95 0F 00    1191*       dl 0x000F95 ; 000067, 21.917
040E08 B8 0F 00    1192*       dl 0x000FB8 ; 000068, 22.109
040E0B DB 0F 00    1193*       dl 0x000FDB ; 000069, 22.301
040E0E FE 0F 00    1194*       dl 0x000FFE ; 00006A, 22.493
040E11 21 10 00    1195*       dl 0x001021 ; 00006B, 22.683
040E14 44 10 00    1196*       dl 0x001044 ; 00006C, 22.874
040E17 66 10 00    1197*       dl 0x001066 ; 00006D, 23.063
040E1A 89 10 00    1198*       dl 0x001089 ; 00006E, 23.253
040E1D AB 10 00    1199*       dl 0x0010AB ; 00006F, 23.441
040E20 CD 10 00    1200*       dl 0x0010CD ; 000070, 23.629
040E23 EF 10 00    1201*       dl 0x0010EF ; 000071, 23.817
040E26 11 11 00    1202*       dl 0x001111 ; 000072, 24.004
040E29 33 11 00    1203*       dl 0x001133 ; 000073, 24.191
040E2C 55 11 00    1204*       dl 0x001155 ; 000074, 24.376
040E2F 77 11 00    1205*       dl 0x001177 ; 000075, 24.562
040E32 99 11 00    1206*       dl 0x001199 ; 000076, 24.747
040E35 BA 11 00    1207*       dl 0x0011BA ; 000077, 24.931
040E38 DC 11 00    1208*       dl 0x0011DC ; 000078, 25.115
040E3B FD 11 00    1209*       dl 0x0011FD ; 000079, 25.298
040E3E 1E 12 00    1210*       dl 0x00121E ; 00007A, 25.481
040E41 3F 12 00    1211*       dl 0x00123F ; 00007B, 25.663
040E44 60 12 00    1212*       dl 0x001260 ; 00007C, 25.844
040E47 81 12 00    1213*       dl 0x001281 ; 00007D, 26.025
040E4A A2 12 00    1214*       dl 0x0012A2 ; 00007E, 26.206
040E4D C3 12 00    1215*       dl 0x0012C3 ; 00007F, 26.386
040E50 E4 12 00    1216*       dl 0x0012E4 ; 000080, 26.565
040E53 04 13 00    1217*       dl 0x001304 ; 000081, 26.744
040E56 25 13 00    1218*       dl 0x001325 ; 000082, 26.922
040E59 45 13 00    1219*       dl 0x001345 ; 000083, 27.100
040E5C 65 13 00    1220*       dl 0x001365 ; 000084, 27.277
040E5F 85 13 00    1221*       dl 0x001385 ; 000085, 27.453
040E62 A5 13 00    1222*       dl 0x0013A5 ; 000086, 27.629
040E65 C5 13 00    1223*       dl 0x0013C5 ; 000087, 27.805
040E68 E5 13 00    1224*       dl 0x0013E5 ; 000088, 27.979
040E6B 05 14 00    1225*       dl 0x001405 ; 000089, 28.154
040E6E 24 14 00    1226*       dl 0x001424 ; 00008A, 28.327
040E71 44 14 00    1227*       dl 0x001444 ; 00008B, 28.501
040E74 63 14 00    1228*       dl 0x001463 ; 00008C, 28.673
040E77 83 14 00    1229*       dl 0x001483 ; 00008D, 28.845
040E7A A2 14 00    1230*       dl 0x0014A2 ; 00008E, 29.017
040E7D C1 14 00    1231*       dl 0x0014C1 ; 00008F, 29.187
040E80 E0 14 00    1232*       dl 0x0014E0 ; 000090, 29.358
040E83 FF 14 00    1233*       dl 0x0014FF ; 000091, 29.527
040E86 1E 15 00    1234*       dl 0x00151E ; 000092, 29.697
040E89 3C 15 00    1235*       dl 0x00153C ; 000093, 29.865
040E8C 5B 15 00    1236*       dl 0x00155B ; 000094, 30.033
040E8F 79 15 00    1237*       dl 0x001579 ; 000095, 30.201
040E92 98 15 00    1238*       dl 0x001598 ; 000096, 30.368
040E95 B6 15 00    1239*       dl 0x0015B6 ; 000097, 30.534
040E98 D4 15 00    1240*       dl 0x0015D4 ; 000098, 30.700
040E9B F2 15 00    1241*       dl 0x0015F2 ; 000099, 30.865
040E9E 10 16 00    1242*       dl 0x001610 ; 00009A, 31.030
040EA1 2E 16 00    1243*       dl 0x00162E ; 00009B, 31.194
040EA4 4C 16 00    1244*       dl 0x00164C ; 00009C, 31.357
040EA7 6A 16 00    1245*       dl 0x00166A ; 00009D, 31.520
040EAA 87 16 00    1246*       dl 0x001687 ; 00009E, 31.682
040EAD A5 16 00    1247*       dl 0x0016A5 ; 00009F, 31.844
040EB0 C2 16 00    1248*       dl 0x0016C2 ; 0000A0, 32.005
040EB3 DF 16 00    1249*       dl 0x0016DF ; 0000A1, 32.166
040EB6 FC 16 00    1250*       dl 0x0016FC ; 0000A2, 32.326
040EB9 19 17 00    1251*       dl 0x001719 ; 0000A3, 32.486
040EBC 36 17 00    1252*       dl 0x001736 ; 0000A4, 32.645
040EBF 53 17 00    1253*       dl 0x001753 ; 0000A5, 32.803
040EC2 70 17 00    1254*       dl 0x001770 ; 0000A6, 32.961
040EC5 8C 17 00    1255*       dl 0x00178C ; 0000A7, 33.118
040EC8 A9 17 00    1256*       dl 0x0017A9 ; 0000A8, 33.275
040ECB C5 17 00    1257*       dl 0x0017C5 ; 0000A9, 33.431
040ECE E2 17 00    1258*       dl 0x0017E2 ; 0000AA, 33.587
040ED1 FE 17 00    1259*       dl 0x0017FE ; 0000AB, 33.742
040ED4 1A 18 00    1260*       dl 0x00181A ; 0000AC, 33.896
040ED7 36 18 00    1261*       dl 0x001836 ; 0000AD, 34.050
040EDA 52 18 00    1262*       dl 0x001852 ; 0000AE, 34.203
040EDD 6E 18 00    1263*       dl 0x00186E ; 0000AF, 34.356
040EE0 8A 18 00    1264*       dl 0x00188A ; 0000B0, 34.509
040EE3 A5 18 00    1265*       dl 0x0018A5 ; 0000B1, 34.660
040EE6 C1 18 00    1266*       dl 0x0018C1 ; 0000B2, 34.811
040EE9 DC 18 00    1267*       dl 0x0018DC ; 0000B3, 34.962
040EEC F7 18 00    1268*       dl 0x0018F7 ; 0000B4, 35.112
040EEF 13 19 00    1269*       dl 0x001913 ; 0000B5, 35.262
040EF2 2E 19 00    1270*       dl 0x00192E ; 0000B6, 35.410
040EF5 49 19 00    1271*       dl 0x001949 ; 0000B7, 35.559
040EF8 64 19 00    1272*       dl 0x001964 ; 0000B8, 35.707
040EFB 7F 19 00    1273*       dl 0x00197F ; 0000B9, 35.854
040EFE 99 19 00    1274*       dl 0x001999 ; 0000BA, 36.001
040F01 B4 19 00    1275*       dl 0x0019B4 ; 0000BB, 36.147
040F04 CE 19 00    1276*       dl 0x0019CE ; 0000BC, 36.293
040F07 E9 19 00    1277*       dl 0x0019E9 ; 0000BD, 36.438
040F0A 03 1A 00    1278*       dl 0x001A03 ; 0000BE, 36.582
040F0D 1D 1A 00    1279*       dl 0x001A1D ; 0000BF, 36.726
040F10 37 1A 00    1280*       dl 0x001A37 ; 0000C0, 36.870
040F13 51 1A 00    1281*       dl 0x001A51 ; 0000C1, 37.013
040F16 6B 1A 00    1282*       dl 0x001A6B ; 0000C2, 37.155
040F19 85 1A 00    1283*       dl 0x001A85 ; 0000C3, 37.297
040F1C 9F 1A 00    1284*       dl 0x001A9F ; 0000C4, 37.439
040F1F B9 1A 00    1285*       dl 0x001AB9 ; 0000C5, 37.579
040F22 D2 1A 00    1286*       dl 0x001AD2 ; 0000C6, 37.720
040F25 EC 1A 00    1287*       dl 0x001AEC ; 0000C7, 37.859
040F28 05 1B 00    1288*       dl 0x001B05 ; 0000C8, 37.999
040F2B 1E 1B 00    1289*       dl 0x001B1E ; 0000C9, 38.137
040F2E 37 1B 00    1290*       dl 0x001B37 ; 0000CA, 38.276
040F31 50 1B 00    1291*       dl 0x001B50 ; 0000CB, 38.413
040F34 69 1B 00    1292*       dl 0x001B69 ; 0000CC, 38.550
040F37 82 1B 00    1293*       dl 0x001B82 ; 0000CD, 38.687
040F3A 9B 1B 00    1294*       dl 0x001B9B ; 0000CE, 38.823
040F3D B4 1B 00    1295*       dl 0x001BB4 ; 0000CF, 38.959
040F40 CC 1B 00    1296*       dl 0x001BCC ; 0000D0, 39.094
040F43 E5 1B 00    1297*       dl 0x001BE5 ; 0000D1, 39.228
040F46 FD 1B 00    1298*       dl 0x001BFD ; 0000D2, 39.362
040F49 16 1C 00    1299*       dl 0x001C16 ; 0000D3, 39.496
040F4C 2E 1C 00    1300*       dl 0x001C2E ; 0000D4, 39.629
040F4F 46 1C 00    1301*       dl 0x001C46 ; 0000D5, 39.762
040F52 5E 1C 00    1302*       dl 0x001C5E ; 0000D6, 39.894
040F55 76 1C 00    1303*       dl 0x001C76 ; 0000D7, 40.025
040F58 8E 1C 00    1304*       dl 0x001C8E ; 0000D8, 40.156
040F5B A5 1C 00    1305*       dl 0x001CA5 ; 0000D9, 40.286
040F5E BD 1C 00    1306*       dl 0x001CBD ; 0000DA, 40.416
040F61 D5 1C 00    1307*       dl 0x001CD5 ; 0000DB, 40.546
040F64 EC 1C 00    1308*       dl 0x001CEC ; 0000DC, 40.675
040F67 04 1D 00    1309*       dl 0x001D04 ; 0000DD, 40.803
040F6A 1B 1D 00    1310*       dl 0x001D1B ; 0000DE, 40.931
040F6D 32 1D 00    1311*       dl 0x001D32 ; 0000DF, 41.059
040F70 49 1D 00    1312*       dl 0x001D49 ; 0000E0, 41.186
040F73 60 1D 00    1313*       dl 0x001D60 ; 0000E1, 41.312
040F76 77 1D 00    1314*       dl 0x001D77 ; 0000E2, 41.438
040F79 8E 1D 00    1315*       dl 0x001D8E ; 0000E3, 41.564
040F7C A5 1D 00    1316*       dl 0x001DA5 ; 0000E4, 41.689
040F7F BB 1D 00    1317*       dl 0x001DBB ; 0000E5, 41.814
040F82 D2 1D 00    1318*       dl 0x001DD2 ; 0000E6, 41.938
040F85 E9 1D 00    1319*       dl 0x001DE9 ; 0000E7, 42.061
040F88 FF 1D 00    1320*       dl 0x001DFF ; 0000E8, 42.184
040F8B 15 1E 00    1321*       dl 0x001E15 ; 0000E9, 42.307
040F8E 2C 1E 00    1322*       dl 0x001E2C ; 0000EA, 42.429
040F91 42 1E 00    1323*       dl 0x001E42 ; 0000EB, 42.551
040F94 58 1E 00    1324*       dl 0x001E58 ; 0000EC, 42.672
040F97 6E 1E 00    1325*       dl 0x001E6E ; 0000ED, 42.793
040F9A 84 1E 00    1326*       dl 0x001E84 ; 0000EE, 42.913
040F9D 99 1E 00    1327*       dl 0x001E99 ; 0000EF, 43.033
040FA0 AF 1E 00    1328*       dl 0x001EAF ; 0000F0, 43.152
040FA3 C5 1E 00    1329*       dl 0x001EC5 ; 0000F1, 43.271
040FA6 DA 1E 00    1330*       dl 0x001EDA ; 0000F2, 43.390
040FA9 F0 1E 00    1331*       dl 0x001EF0 ; 0000F3, 43.508
040FAC 05 1F 00    1332*       dl 0x001F05 ; 0000F4, 43.625
040FAF 1B 1F 00    1333*       dl 0x001F1B ; 0000F5, 43.742
040FB2 30 1F 00    1334*       dl 0x001F30 ; 0000F6, 43.859
040FB5 45 1F 00    1335*       dl 0x001F45 ; 0000F7, 43.975
040FB8 5A 1F 00    1336*       dl 0x001F5A ; 0000F8, 44.091
040FBB 6F 1F 00    1337*       dl 0x001F6F ; 0000F9, 44.206
040FBE 84 1F 00    1338*       dl 0x001F84 ; 0000FA, 44.321
040FC1 99 1F 00    1339*       dl 0x001F99 ; 0000FB, 44.435
040FC4 AD 1F 00    1340*       dl 0x001FAD ; 0000FC, 44.549
040FC7 C2 1F 00    1341*       dl 0x001FC2 ; 0000FD, 44.662
040FCA D7 1F 00    1342*       dl 0x001FD7 ; 0000FE, 44.775
040FCD EB 1F 00    1343*       dl 0x001FEB ; 0000FF, 44.888
040FD0 00 20 00    1344*       dl 0x002000 ; 000100, 45.000 only needed for interpolation
040FD3             0037        include "timer_test.inc" ; DEBUG
040FD3             0001*   ; prt_reload: dl [72000/2] ; 36000 = 2 ticks per second at 18.432 MHz with a 256 clock divider
040FD3 48 00 00    0002*   prt_reload: dl 72 ; 1 ms at 18.432 MHz with a 256 clock divider
040FD6             0003*   
040FD6             0004*   ; Table 32. Timer Control Registers
040FD6             0005*   TMR_CTL:  equ 80h
040FD6             0006*   TMR1_CTL: equ 83h
040FD6             0007*   TMR2_CTL: equ 86h
040FD6             0008*   TMR3_CTL: equ 89h
040FD6             0009*   TMR4_CTL: equ 8Ch
040FD6             0010*   TMR5_CTL: equ 8Fh
040FD6             0011*   
040FD6             0012*   ; each timer register takes three bytes:
040FD6             0013*   ;   0: control register
040FD6             0014*   ;   1: low byte of timer reset value
040FD6             0015*   ;   2: high byte of timer reset value
040FD6             0016*   ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
040FD6             0017*   ; which correctly force the high and upper bytes of the address bus to zero
040FD6             0018*   
040FD6             0019*   TMR_REG_CTL: equ 0
040FD6             0020*   TMR_RES_LOW: equ 1
040FD6             0021*   TMR_RES_HIGH: equ 2
040FD6             0022*   
040FD6             0023*   ; Timer Control Register Bit Definitions
040FD6             0024*   PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
040FD6             0025*                               ; This bit is reset to 0 every time the TMRx_CTL register is read.
040FD6             0026*   PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
040FD6             0027*                               ; an interrupt signal is sent to the CPU. This bit remains 1 until
040FD6             0028*                               ; the TMRx_CTL register is read.
040FD6             0029*   
040FD6             0030*   IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
040FD6             0031*   IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
040FD6             0032*   
040FD6             0033*   PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
040FD6             0034*                               ;  0,and counting stops when the end-of-count value is reached.
040FD6             0035*   PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
040FD6             0036*                               ; written to the counter when the end-of-count value is reached.
040FD6             0037*   
040FD6             0038*   ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
040FD6             0039*   CLK_DIV_256:  equ %00001100 ;
040FD6             0040*   CLK_DIV_64:   equ %00001000 ;
040FD6             0041*   CLK_DIV_16:   equ %00000100 ;
040FD6             0042*   CLK_DIV_4:    equ %00000000 ;
040FD6             0043*   
040FD6             0044*   RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
040FD6             0045*   RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
040FD6             0046*                               ; When a 1 is written to this bit,the values in the reload registers
040FD6             0047*                               ;  are loaded into the downcounter when the timer restarts. The
040FD6             0048*                               ; programmer must ensure that this bit is set to 1 each time
040FD6             0049*                               ; SINGLE-PASS mode is used.
040FD6             0050*   
040FD6             0051*   ; disable/enable the programmable reload timer
040FD6             0052*   PRT_EN_0:     equ %00000000 ;
040FD6             0053*   PRT_EN_1:     equ %00000001 ;
040FD6             0054*   
040FD6             0055*   ; Table 37. Timer Input Source Select Register
040FD6             0056*   ; Each of the 4 timers are allocated two bits of the 8-bit register
040FD6             0057*   ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
040FD6             0058*   ;   00: System clock / CLK_DIV
040FD6             0059*   ;   01: RTC / CLK_DIV
040FD6             0060*   ;   NOTE: these are the values given in the manual,but it may be a typo
040FD6             0061*   ;   10: GPIO port B pin 1.
040FD6             0062*   ;   11: GPIO port B pin 1.
040FD6             0063*   TMR_ISS:   equ 92h ; register address
040FD6             0064*   
040FD6             0065*   ; Table 51. Real-Time Clock Control Register
040FD6             0066*   RTC_CTRL: equ EDh ; register address
040FD6             0067*   
040FD6             0068*   ; alarm interrupt disable/enable
040FD6             0069*   RTC_ALARM_0:    equ %00000000
040FD6             0070*   RTC_ALARM_1:    equ %10000000
040FD6             0071*   
040FD6             0072*   ; interrupt on alarm disable/enable
040FD6             0073*   RTC_INT_ENT_0:  equ %00000000
040FD6             0074*   RTC_INT_ENT_1:  equ %01000000
040FD6             0075*   
040FD6             0076*   RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
040FD6             0077*   RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
040FD6             0078*   
040FD6             0079*   RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
040FD6             0080*                                   ; On-chip 32768 Hz oscillator is enabled.
040FD6             0081*   RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
040FD6             0082*                                   ; On-chip 32768 Hz oscillator is disabled.
040FD6             0083*   
040FD6             0084*   RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
040FD6             0085*   RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
040FD6             0086*   
040FD6             0087*   RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
040FD6             0088*   RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
040FD6             0089*   
040FD6             0090*   RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
040FD6             0091*                                   ; RTC counter is enabled.
040FD6             0092*   RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
040FD6             0093*                                   ; RTC counter is disabled.
040FD6             0094*   ; start PRT timer
040FD6             0095*   prt_start:
040FD6 21 00 00 00 0096*       ld hl,0
040FDA 22 2A 10 04 0097*       ld (prt_irq_counter),hl
040FDE 2A D3 0F 04 0098*       ld hl,(prt_reload)
040FE2 ED 29 84    0099*       out0 (TMR1_CTL+TMR_RES_LOW),l
040FE5 ED 21 85    0100*   	out0 (TMR1_CTL+TMR_RES_HIGH),h
040FE8             0101*   ; disable timer (in effect, reset it)
040FE8 3E 0E       0102*       ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_256 | RST_EN_1 | PRT_EN_0
040FEA ED 39 83    0103*   	out0 (TMR1_CTL+TMR_REG_CTL),a
040FED             0104*   ; enable timer,with interrupt and CONTINUOUS mode,clock divider 256
040FED 3E 5F       0105*       ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_256 | RST_EN_1 | PRT_EN_1
040FEF ED 39 83    0106*   	out0 (TMR1_CTL+TMR_REG_CTL),a
040FF2 C9          0107*       ret
040FF3             0108*   
040FF3             0109*   ; stop PRT timer
040FF3             0110*   prt_stop:
040FF3 3E 0E       0111*       ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_256 | RST_EN_1 | PRT_EN_0
040FF5 ED 39 83    0112*   	out0 (TMR1_CTL+TMR_REG_CTL),a
040FF8 C9          0113*       ret
040FF9             0114*   
040FF9             0115*   ; ===============================================
040FF9             0116*   ; PRT Timer Interrupt Handling
040FF9             0117*   ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.asm
040FF9             0118*   ; -----------------------------------------------
040FF9             0119*   prt_irq_init:
040FF9             0120*       ; set up interrupt vector table 2
040FF9 21 00 00 00 0121*   	ld hl,0
040FFD 3A 0C 01 00 0122*   	ld a,($10c)
041001 6F          0123*   	ld l,a
041002 3A 0D 01 00 0124*   	ld a,($10d)
041006 67          0125*   	ld h,a
041007             0126*   
041007             0127*   	; skip over CALL ($c3)
041007 23          0128*   	inc hl
041008             0129*   	; load address of jump into vector table 2 (in ram)
041008 ED 27       0130*   	ld hl,(hl)
04100A             0131*   
04100A             0132*   	; write CALL prt_irq_handler to vector table 2
04100A 3E C3       0133*   	ld a,$c3
04100C 77          0134*   	ld (hl),a
04100D 23          0135*   	inc hl
04100E 11 15 10 04 0136*   	ld de,prt_irq_handler
041012 ED 1F       0137*   	ld (hl),de
041014             0138*   
041014 C9          0139*       ret
041015             0140*   
041015             0141*   prt_irq_handler:
041015 F3          0142*   	di
041016 F5          0143*   	push af
041017 E5          0144*       push hl
041018 ED 38 83    0145*   	in0 a,($83)
04101B 2A 2A 10 04 0146*   	ld hl,(prt_irq_counter)
04101F 23          0147*   	inc hl
041020 22 2A 10 04 0148*   	ld (prt_irq_counter),hl
041024 E1          0149*       pop hl
041025 F1          0150*   	pop af
041026 FB          0151*   	ei
041027 5B ED 4D    0152*   	reti.l
04102A             0153*   
04102A             0154*   prt_irq_counter:
04102A 00 00 00    0155*   	.dl 0
04102D             0156*   prt_irq_counter_saved:
04102D 00 00 00    0157*       .dl 0
041030             0158*   
041030             0159*   prt_loop_reset:
041030 E5          0160*       push hl
041031 21 00 00 00 0161*   	ld hl,0
041035 22 2A 10 04 0162*   	ld (prt_irq_counter),hl
041039 22 9B 10 04 0163*       ld (prt_loop_counter),hl
04103D 22 9E 10 04 0164*       ld (prt_loops),hl
041041 CD D6 0F 04 0165*       call prt_start
041045 E1          0166*       pop hl
041046 C9          0167*       ret
041047             0168*   
041047             0169*   prt_loop_start:
041047 E5          0170*       push hl
041048 21 00 00 00 0171*   	ld hl,0
04104C 22 2A 10 04 0172*   	ld (prt_irq_counter),hl
041050 E1          0173*       pop hl
041051 C9          0174*       ret
041052             0175*   
041052             0176*   prt_loop_stop:
041052 E5          0177*       push hl
041053 D5          0178*       push de
041054 2A 2A 10 04 0179*       ld hl,(prt_irq_counter)
041058 ED 5B 9B 10 0180*       ld de,(prt_loop_counter)
       04          
04105D 19          0181*       add hl,de
04105E 22 9B 10 04 0182*       ld (prt_loop_counter),hl
041062 21 00 00 00 0183*       ld hl,0
041066 22 2A 10 04 0184*       ld (prt_irq_counter),hl
04106A 2A 9E 10 04 0185*       ld hl,(prt_loops)
04106E 23          0186*       inc hl
04106F 22 9E 10 04 0187*       ld (prt_loops),hl
041073 D1          0188*       pop de
041074 E1          0189*       pop hl
041075 C9          0190*       ret
041076             0191*   
041076             0192*   ; inputs: bc = y,x text coordinates to print
041076             0193*   prt_loop_print:
041076 F5          0194*       push af
041077 E5          0195*       push hl
041078 C5          0196*       push bc
041079 D5          0197*       push de
04107A DD E5       0198*       push ix
04107C FD E5       0199*       push iy
04107E CD 82 11 04 0200*       call vdu_move_cursor
041082             0201*   
041082 2A 9B 10 04 0202*       ld hl,(prt_loop_counter)
041086 CD CC 00 04 0203*       call printDec
04108A             0204*   
04108A 2A 9E 10 04 0205*       ld hl,(prt_loops)
04108E CD CC 00 04 0206*       call printDec
041092             0207*   
041092 FD E1       0208*       pop iy
041094 DD E1       0209*       pop ix
041096 D1          0210*       pop de
041097 C1          0211*       pop bc
041098 E1          0212*       pop hl
041099 F1          0213*       pop af
04109A C9          0214*       ret
04109B             0215*   
04109B             0216*   prt_loop_counter:
04109B 00 00 00    0217*       .dl 0
04109E             0218*   prt_loops:
04109E 00 00 00    0219*       .dl 0
0410A1             0220*   
0410A1             0221*   ; ===============================================
0410A1             0222*   ; Timer functions
0410A1             0223*   ; -----------------------------------------------
0410A1             0224*   ; set a countdown timer
0410A1             0225*   ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0410A1             0226*   ; returns: hl = current time
0410A1             0227*   tmr_set:
0410A1 FD 2F 03    0228*       ld (iy+3),hl            ; set time remaining
0410A4             0229*       MOSCALL mos_sysvars     ; ix points to syvars table
                       M1 Args: function=mos_sysvars 
0410A4 3E 08       0001*M1 			LD	A, function
0410A6 5B CF       0002*M1 			RST.LIL	08h
0410A8 DD 27 00    0230*       ld hl,(ix+sysvar_time)  ; get current time
0410AB FD 2F 00    0231*       ld (iy+0),hl            ; set start time
0410AE C9          0232*       ret
0410AF             0233*   
0410AF             0234*   ; gets time remaining on a countdown timer
0410AF             0235*   ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0410AF             0236*   ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0410AF             0237*   ;          sign flags: pos = time not expired,zero or neg = time expired
0410AF             0238*   tmr_get:
0410AF             0239*       MOSCALL mos_sysvars     ; ix points to syvars table
                       M1 Args: function=mos_sysvars 
0410AF 3E 08       0001*M1 			LD	A, function
0410B1 5B CF       0002*M1 			RST.LIL	08h
0410B3 DD 17 00    0240*       ld de,(ix+sysvar_time)  ; get current time
0410B6 FD 27 00    0241*       ld hl,(iy+0)            ; get start time
0410B9 AF          0242*       xor a                   ; clear carry
0410BA ED 52       0243*       sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0410BC FD 17 03    0244*       ld de,(iy+3)            ; get timer set value
0410BF AF          0245*       xor a                   ; clear carry
0410C0 ED 5A       0246*       adc hl,de               ; hl = time remaining
0410C2             0247*                               ; (we do adc because add hl,rr doesn't set sign or zero flags)
0410C2 C9          0248*       ret
0410C3             0249*   
0410C3             0250*   tmr_test: ds 6 ; example of a buffer to hold timer data
0410C9             0251*   
       FF FF FF FF 
       FF FF 
0410C9 00 00 00    0252*   timestamp_now: dl 0
0410CC 00 00 00    0253*   timestamp_old: dl 0
0410CF 00 00 00    0254*   timestamp_chg: dl 0
0410D2             0255*   
0410D2             0256*   ; update the global timestamp from the system clock
0410D2             0257*   ; inputs: none
0410D2             0258*   ; returns: hl = time elapsed in 1/120ths of a second
0410D2             0259*   ;          de = current time
0410D2             0260*   ;          ix = pointer to syvars table
0410D2             0261*   ; destroys: af,hl,de,ix
0410D2             0262*   timestamp_tick:
0410D2 ED 5B C9 10 0263*       ld de,(timestamp_now)   ; get previous time
       04          
0410D7 ED 53 CC 10 0264*       ld (timestamp_old),de   ; save previous time
       04          
0410DC             0265*       MOSCALL mos_sysvars     ; ix points to syvars table
                       M1 Args: function=mos_sysvars 
0410DC 3E 08       0001*M1 			LD	A, function
0410DE 5B CF       0002*M1 			RST.LIL	08h
0410E0 DD 27 00    0266*       ld hl,(ix+sysvar_time)  ; get current time
0410E3 22 C9 10 04 0267*       ld (timestamp_now),hl   ; save current time
0410E7 AF          0268*       xor a                   ; clear carry
0410E8 ED 52       0269*       sbc hl,de               ; hl = time elapsed
0410EA 22 CF 10 04 0270*       ld (timestamp_chg),hl   ; save elapsed time
0410EE C9          0271*       ret
0410EF             0272*   
0410EF             0273*   ; set a countdown timer
0410EF             0274*   ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0410EF             0275*   ; requires: timestamp_tick to be called at least once before this function
0410EF             0276*   ; returns: hl = current time
0410EF             0277*   ; destroys: hl
0410EF             0278*   timestamp_tmr_set:
0410EF FD 2F 03    0279*       ld (iy+3),hl            ; set time remaining
0410F2 2A C9 10 04 0280*       ld hl,(timestamp_now)   ; get current timestamp
0410F6 FD 2F 00    0281*       ld (iy+0),hl            ; set start time
0410F9 C9          0282*       ret
0410FA             0283*   
0410FA             0284*   ; gets time remaining on a countdown timer following the global timestamp
0410FA             0285*   ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0410FA             0286*   ; requires: timestamp_tick to be called at least once before this function
0410FA             0287*   ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0410FA             0288*   ;          sign flags: pos = time not expired,zero or neg = time expired
0410FA             0289*   ; destroys: af,hl,de
0410FA             0290*   timestamp_tmr_get:
0410FA ED 5B C9 10 0291*       ld de,(timestamp_now)   ; get current timestamp
       04          
0410FF FD 27 00    0292*       ld hl,(iy+0)            ; get start time
041102 AF          0293*       xor a                   ; clear carry
041103 ED 52       0294*       sbc hl,de               ; hl = time elapsed (will always be zero or negative)
041105 FD 17 03    0295*       ld de,(iy+3)            ; get timer set value
041108 AF          0296*       xor a                   ; clear carry
041109 ED 5A       0297*       adc hl,de               ; hl = time remaining
04110B             0298*                               ; (we do adc because add hl,rr doesn't set sign or zero flags)
04110B C9          0299*       ret
04110C             0300*   
04110C             0301*   ; set a stopwatch
04110C             0302*   ; returns: hl = start time
04110C             0303*   ; destroys: hl,ix
04110C             0304*   stopwatch_set:
04110C             0305*       MOSCALL mos_sysvars     ; ix points to syvars table
                       M1 Args: function=mos_sysvars 
04110C 3E 08       0001*M1 			LD	A, function
04110E 5B CF       0002*M1 			RST.LIL	08h
041110 DD 27 00    0306*       ld hl,(ix+sysvar_time)  ; get current time
041113 22 28 11 04 0307*       ld (stopwatch_started),hl            ; set start time
041117 C9          0308*       ret
041118             0309*   
041118             0310*   ; gets time elapsed on a stopwatch
041118             0311*   ; returns: hl = time elapsed in 1/120ths of a second
041118             0312*   ; destroys: af,hl,de,ix
041118             0313*   stopwatch_get:
041118             0314*       MOSCALL mos_sysvars     ; ix points to syvars table
                       M1 Args: function=mos_sysvars 
041118 3E 08       0001*M1 			LD	A, function
04111A 5B CF       0002*M1 			RST.LIL	08h
04111C DD 27 00    0315*       ld hl,(ix+sysvar_time)  ; get current time
04111F ED 5B 28 11 0316*       ld de,(stopwatch_started)            ; get start time
       04          
041124 AF          0317*       xor a                   ; clear carry
041125 ED 52       0318*       sbc hl,de               ; hl = time elapsed (will always be zero or positive)
041127 C9          0319*       ret
041128             0320*   
041128             0321*   stopwatch_started: ds 3 ; buffer to hold stopwatch start time
04112B             0322*   
04112B             0323*   ; ------------------
04112B             0324*   ; delay routine
04112B             0325*   ; Author: Richard Turrnidge
04112B             0326*   ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.asm
04112B             0327*   ; routine waits a fixed time,then returns
04112B             0328*   ; arrive with A =  the delay byte. One bit to be set only.
04112B             0329*   ; eg. ld A,00000100b
04112B             0330*   
04112B             0331*   multiPurposeDelay:
       FF FF FF 
04112B F5          0332*       push af
04112C C5          0333*       push bc
04112D DD E5       0334*       push ix
04112F 47          0335*       ld b,a
041130 3E 08       0336*       ld a,$08
041132 5B CF       0337*       RST.LIL	08h                 ; get IX pointer to sysvars
041134             0338*   
041134             0339*   waitLoop:
041134             0340*   
041134 DD 7E 00    0341*       ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
041137             0342*   
041137             0343*                                   ;   we check if bit set is same as last time we checked.
041137             0344*                                   ;   bit 0 - don't use
041137             0345*                                   ;   bit 1 - changes 64 times per second
041137             0346*                                   ;   bit 2 - changes 32 times per second
041137             0347*                                   ;   bit 3 - changes 16 times per second
041137             0348*   
041137             0349*                                   ;   bit 4 - changes 8 times per second
041137             0350*                                   ;   bit 5 - changes 4 times per second
041137             0351*                                   ;   bit 6 - changes 2 times per second
041137             0352*                                   ;   bit 7 - changes 1 times per second
041137 A0          0353*       and b
041138 4F          0354*       ld c,a
041139 3A 4A 11 04 0355*       ld a,(oldTimeStamp)
04113D B9          0356*       cp c                        ; is A same as last value?
04113E 28 F4       0357*       jr z,waitLoop              ; loop here if it is
041140 79          0358*       ld a,c
041141 32 4A 11 04 0359*       ld (oldTimeStamp),a        ; set new value
041145             0360*   
041145 DD E1       0361*       pop ix
041147 C1          0362*       pop bc
041148 F1          0363*       pop af
041149 C9          0364*       ret
04114A             0365*   
04114A 00          0366*   oldTimeStamp:   .db 00h
04114B             0038        include "vdu.inc"
04114B             0001*   ; VDU 30: Home cursor
04114B             0002*   vdu_home_cursor:
04114B 3E 1E       0003*       ld a,30
04114D 5B D7       0004*   	rst.lil $10
04114F C9          0005*   	ret
041150             0006*   
041150             0007*   vdu_cursor_on:
041150 21 5B 11 04 0008*   	ld hl,@cmd
041154 01 03 00 00 0009*   	ld bc,@end-@cmd
041158 5B DF       0010*   	rst.lil $18
04115A C9          0011*   	ret
04115B             0012*   @cmd:
04115B 17 01 01    0013*   	db 23,1,1
04115E             0014*   @end:
04115E             0015*   
04115E             0016*   vdu_cursor_off:
04115E 21 69 11 04 0017*   	ld hl,@cmd
041162 01 03 00 00 0018*   	ld bc,@end-@cmd
041166 5B DF       0019*   	rst.lil $18
041168 C9          0020*   	ret
041169             0021*   @cmd:
041169 17 01 00    0022*   	db 23,1,0
04116C             0023*   @end:
04116C             0024*   
04116C             0025*   ; VDU 5: Write text at graphics cursor
04116C             0026*   ; inputs: a is the character to write to the screen
04116C             0027*   ; prerequisites: the graphics cursor at the intended position on screen
04116C             0028*   ; outputs: see the name of the function
04116C             0029*   ; destroys: a, hl, bc
04116C             0030*   vdu_char_to_gfx_cursor:
04116C 32 7C 11 04 0031*   	ld (@arg),a
041170 21 7B 11 04 0032*   	ld hl,@cmd
041174 01 02 00 00 0033*   	ld bc,@end-@cmd
041178 5B DF       0034*   	rst.lil $18
04117A C9          0035*   	ret
04117B 05          0036*   @cmd: db 5
04117C 00          0037*   @arg: db 0
04117D             0038*   @end:
04117D             0039*   ; VDU 9: Move cursor forward one character
04117D             0040*   vdu_cursor_forward:
04117D 3E 09       0041*       ld a,9
04117F 5B D7       0042*   	rst.lil $10
041181 C9          0043*   	ret
041182             0044*   
041182             0045*   ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
041182             0046*   ; inputs: c=x, b=y 8-bit unsigned integers
041182             0047*   vdu_move_cursor:
041182 ED 43 93 11 0048*       ld (@x0),bc
       04          
041187 21 92 11 04 0049*   	ld hl,@cmd
04118B 01 03 00 00 0050*   	ld bc,@end-@cmd
04118F 5B DF       0051*   	rst.lil $18
041191 C9          0052*   	ret
041192 1F          0053*   @cmd: 	db 31
041193 00          0054*   @x0:	db 0
041194 00          0055*   @y0: 	db 0
041195 00          0056*   @end: 	db 0 ; padding
041196             0057*   
041196             0058*   ; VDU 12: Clear text area (CLS)
041196             0059*   vdu_cls:
041196 3E 0C       0060*       ld a,12
041198 5B D7       0061*   	rst.lil $10
04119A C9          0062*   	ret
04119B             0063*   
04119B             0064*   vdu_flip:
04119B 21 A6 11 04 0065*   	ld hl,@cmd
04119F 01 03 00 00 0066*   	ld bc,@end-@cmd
0411A3 5B DF       0067*   	rst.lil $18
0411A5 C9          0068*   	ret
0411A6 17 00 C3    0069*   @cmd: db 23,0,0xC3
0411A9             0070*   @end:
0411A9             0071*   
0411A9             0072*   ; VDU 16: Clear graphics area (CLG)
0411A9             0073*   vdu_clg:
0411A9 3E 10       0074*       ld a,16
0411AB 5B D7       0075*   	rst.lil $10
0411AD C9          0076*   	ret
0411AE             0077*   
0411AE             0078*   ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
0411AE             0079*   ; VDU 23, 7: Scrolling
0411AE             0080*   ;     VDU 23, 7, extent, direction, speed: Scroll the screen
0411AE             0081*   ; inputs: a, extent; l, direction; h; speed
0411AE             0082*   vdu_scroll_down:
0411AE 32 C3 11 04 0083*   	ld (@extent),a
0411B2 22 C4 11 04 0084*   	ld (@dir),hl ; implicitly populates @speed
0411B6 21 C1 11 04 0085*   	ld hl,@cmd
0411BA 01 05 00 00 0086*   	ld bc,@end-@cmd
0411BE 5B DF       0087*   	rst.lil $18     ;; Sending command to VDP
0411C0 C9          0088*   	ret
0411C1 17 07       0089*   @cmd:       db 23,7
0411C3 00          0090*   @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
0411C4 00          0091*   @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
0411C5 00          0092*   @speed:     db 0x00 ; pixels
0411C6 00          0093*   @end:		db 0x00 ; padding
0411C7             0094*   
0411C7             0095*   ; COLOUR MODES
0411C7             0096*   ; Mode	Effect
0411C7             0097*   ; 0	Set on-screen pixel to target colour value
0411C7             0098*   ; 1	OR value with the on-screen pixel
0411C7             0099*   ; 2	AND value with the on-screen pixel
0411C7             0100*   ; 3	XOR value with the on-screen pixel
0411C7             0101*   ; 4	Invert the on-screen pixel
0411C7             0102*   ; 5	No operation
0411C7             0103*   ; 6	AND the inverse of the specified colour with the on-screen pixel
0411C7             0104*   ; 7	OR the inverse of the specified colour with the on-screen pixel
0411C7             0105*   
0411C7             0106*   ; VDU 17, colour: Define text colour (COLOUR)
0411C7             0107*   vdu_colour_text:
0411C7 32 D7 11 04 0108*   	ld (@arg),a
0411CB 21 D6 11 04 0109*   	ld hl,@cmd
0411CF 01 02 00 00 0110*   	ld bc,@end-@cmd
0411D3 5B DF       0111*   	rst.lil $18
0411D5 C9          0112*   	ret
0411D6 11          0113*   @cmd: db 17
0411D7 00          0114*   @arg: db 0
0411D8             0115*   @end:
0411D8             0116*   
0411D8             0117*   ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
0411D8             0118*   ; inputs: a=mode, c=colour (add 128 to set background colour)
0411D8             0119*   vdu_gcol:
0411D8 32 ED 11 04 0120*   	ld (@mode),a
0411DC 79          0121*       ld a,c
0411DD 32 EE 11 04 0122*       ld (@col),a
0411E1 21 EC 11 04 0123*   	ld hl,@cmd
0411E5 01 03 00 00 0124*   	ld bc,@end-@cmd
0411E9 5B DF       0125*   	rst.lil $18
0411EB C9          0126*   	ret
0411EC 12          0127*   @cmd:  db 18
0411ED 00          0128*   @mode: db 0
0411EE 00          0129*   @col:  db 0
0411EF             0130*   @end:
0411EF             0131*   
0411EF             0132*   
0411EF             0133*   ; VDU 28, left, bottom, right, top: Set text viewport **
0411EF             0134*   ; MIND THE LITTLE-ENDIANESS
0411EF             0135*   ; inputs: c=left,b=bottom,e=right,d=top
0411EF             0136*   ; outputs; nothing
0411EF             0137*   ; destroys: a might make it out alive
0411EF             0138*   vdu_set_txt_viewport:
0411EF ED 43 05 12 0139*       ld (@lb),bc
       04          
0411F4 ED 53 07 12 0140*   	ld (@rt),de
       04          
0411F9 21 04 12 04 0141*   	ld hl,@cmd
0411FD 01 05 00 00 0142*   	ld bc,@end-@cmd
041201 5B DF       0143*   	rst.lil $18
041203 C9          0144*   	ret
041204 1C          0145*   @cmd:   db 28 ; set text viewport command
041205 00 00       0146*   @lb: 	dw 0x0000 ; set by bc
041207 00 00       0147*   @rt: 	dw 0x0000 ; set by de
041209 00          0148*   @end:   db 0x00	  ; padding
04120A             0149*   
04120A             0150*   ; Wait for VBLANK interrupt
04120A             0151*   vdu_vblank:
04120A DD E5       0152*       PUSH 	IX
04120C             0153*   	MOSCALL	mos_sysvars
                       M1 Args: function=mos_sysvars 
04120C 3E 08       0001*M1 			LD	A, function
04120E 5B CF       0002*M1 			RST.LIL	08h
041210 DD 7E 00    0154*   	LD	A, (IX + sysvar_time + 0)
041213             0155*   @wait:
041213 DD BE 00    0156*       CP 	A, (IX + sysvar_time + 0)
041216 28 FB       0157*       JR	Z, @wait
041218 DD E1       0158*       POP	IX
04121A C9          0159*       RET
04121B             0160*   
04121B             0161*   ; VDU 29, x; y;: Set graphics origin
04121B             0162*   ; This command sets the graphics origin.
04121B             0163*   ; The origin is the point on the screen where the coordinates (0,0) are located.
04121B             0164*   ; inputs: bc=x0,de=y0
04121B             0165*   ; outputs; nothing
04121B             0166*   ; destroys: a might make it out alive
04121B             0167*   vdu_set_gfx_origin:
04121B ED 43 31 12 0168*       ld (@x0),bc
       04          
041220 ED 53 33 12 0169*       ld (@y0),de
       04          
041225 21 30 12 04 0170*       ld hl,@cmd
041229 01 05 00 00 0171*       ld bc,@end-@cmd
04122D 5B DF       0172*       rst.lil $18
04122F C9          0173*       ret
041230 1D          0174*   @cmd:   db 29 ; set graphics origin command
041231 00 00       0175*   @x0: 	dw 0x0000 ; set by bc
041233 00 00       0176*   @y0: 	dw 0x0000 ; set by de
041235 00          0177*   @end:   db 0x00	  ; padding
041236             0178*   
041236             0179*   ; VDU 24, left; bottom; right; top;: Set graphics viewport
041236             0180*   ; NOTE: the order of the y-coordinate parameters are inverted
041236             0181*   ; 	because we have turned off logical screen scaling
041236             0182*   ; NOTE: coordinates are relative to current gfx origin
041236             0183*   ; inputs: bc=x0,de=y0,ix=x1,iy=y1
041236             0184*   ; outputs; nothing
041236             0185*   ; destroys: a might make it out alive
041236             0186*   vdu_set_gfx_viewport:
041236 ED 43 56 12 0187*       ld (@x0),bc
       04          
04123B FD 22 58 12 0188*       ld (@y1),iy
       04          
041240 DD 22 5A 12 0189*   	ld (@x1),ix
       04          
041245 ED 53 5C 12 0190*   	ld (@y0),de
       04          
04124A 21 55 12 04 0191*   	ld hl,@cmd
04124E 01 09 00 00 0192*   	ld bc,@end-@cmd
041252 5B DF       0193*   	rst.lil $18
041254 C9          0194*   	ret
041255 18          0195*   @cmd:   db 24 ; set graphics viewport command
041256 00 00       0196*   @x0: 	dw 0x0000 ; set by bc
041258 00 00       0197*   @y1: 	dw 0x0000 ; set by iy
04125A 00 00       0198*   @x1: 	dw 0x0000 ; set by ix
04125C 00 00       0199*   @y0: 	dw 0x0000 ; set by de
04125E 00          0200*   @end:   db 0x00	  ; padding
04125F             0201*   
04125F             0202*   ; VDU 26: Reset graphics and text viewports
04125F             0203*   vdu_reset_viewports:
04125F 3E 1A       0204*       ld a,26
041261 5B D7       0205*       rst.lil $10
041263 C9          0206*       ret
041264             0207*   
041264             0208*   ; SCREEN MODES
041264             0209*   ; ===============================
041264             0210*   ; Mode  Horz  Vert  Cols  Refresh
041264             0211*   ; ---   ----  ----  ----  -------
041264             0212*   ; 11    320   240   2     60hz
041264             0213*   ; 139   320   240   2     60hz
041264             0214*   ; 23    512   384   2     60hz
041264             0215*   ; 151   512   384   2     60hz
041264             0216*   ; 6     640   240   2     60hz
041264             0217*   ; 134   640   240   2     60hz
041264             0218*   ; 2     640   480   2     60hz
041264             0219*   ; 130   640   480   2     60hz
041264             0220*   ; 17    800   600   2     60hz
041264             0221*   ; 145   800   600   2     60hz
041264             0222*   ; 18    1024  768   2     60hz
041264             0223*   ; 146   1024  768   2     60hz
041264             0224*   ; ---   ----  ----  ----  -------
041264             0225*   ; 10    320   240   4     60hz
041264             0226*   ; 138   320   240   4     60hz
041264             0227*   ; 22    512   384   4     60hz
041264             0228*   ; 150   512   384   4     60hz
041264             0229*   ; 5     640   240   4     60hz
041264             0230*   ; 133   640   240   4     60hz
041264             0231*   ; 1     640   480   4     60hz
041264             0232*   ; 129   640   480   4     60hz
041264             0233*   ; 16    800   600   4     60hz
041264             0234*   ; 19    1024  768   4     60hz
041264             0235*   ; ---   ----  ----  ----  -------
041264             0236*   ; 9     320   240   16    60hz
041264             0237*   ; 137   320   240   16    60hz
041264             0238*   ; 21    512   384   16    60hz
041264             0239*   ; 149   512   384   16    60hz
041264             0240*   ; 4     640   240   16    60hz
041264             0241*   ; 132   640   240   16    60hz
041264             0242*   ; 0     640   480   16    60hz
041264             0243*   ; 7     n/a   n/a   16    60hz
041264             0244*   ; ---   ----  ----  ----  -------
041264             0245*   ; 8     320   240   64    60hz
041264             0246*   ; 136   320   240   64    60hz
041264             0247*   ; 20    512   384   64    60hz
041264             0248*   ; 3     640   240   64    60hz
041264             0249*   ; ---   ----  ----  ----  -------
041264             0250*   vdu_set_screen_mode:
041264 32 74 12 04 0251*   	ld (@arg),a
041268 21 73 12 04 0252*   	ld hl,@cmd
04126C 01 02 00 00 0253*   	ld bc,@end-@cmd
041270 5B DF       0254*   	rst.lil $18
041272 C9          0255*   	ret
041273 16          0256*   @cmd: db 22 ; set screen mode
041274 00          0257*   @arg: db 0  ; screen mode parameter
041275             0258*   @end:
041275             0259*   
041275             0260*   ; get the current screen mode
041275             0261*   ; inputs: none
041275             0262*   ; outputs: a=screen mode
041275             0263*   ; destroys: af, ix
041275             0264*   vdu_get_screen_mode:
041275             0265*       MOSCALL mos_sysvars
                       M1 Args: function=mos_sysvars 
041275 3E 08       0001*M1 			LD	A, function
041277 5B CF       0002*M1 			RST.LIL	08h
041279 DD 7E 27    0266*       ld a,(IX+sysvar_scrMode)
04127C C9          0267*       ret
04127D             0268*   ; end vdu_get_screen_mode
04127D             0269*   
04127D             0270*   ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
04127D             0271*   ; inputs: a is scaling mode, 1=on, 0=off
04127D             0272*   ; note: default setting on boot is scaling ON
04127D             0273*   vdu_set_scaling:
04127D 32 8F 12 04 0274*   	ld (@arg),a
041281 21 8C 12 04 0275*   	ld hl,@cmd
041285 01 04 00 00 0276*   	ld bc,@end-@cmd
041289 5B DF       0277*   	rst.lil $18
04128B C9          0278*   	ret
04128C 17 00 C0    0279*   @cmd: db 23,0,0xC0
04128F 00          0280*   @arg: db 0  ; scaling on/off
041290             0281*   @end:
041290             0282*   
041290             0283*   ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
041290             0284*   ; inputs: hl=bufferId
041290             0285*   vdu_buff_select:
041290 22 A2 12 04 0286*   	ld (@bufferId),hl
041294 21 9F 12 04 0287*   	ld hl,@cmd
041298 01 05 00 00 0288*   	ld bc,@end-@cmd
04129C 5B DF       0289*   	rst.lil $18
04129E C9          0290*   	ret
04129F 17 1B 20    0291*   @cmd: db 23,27,0x20
0412A2 00 00       0292*   @bufferId: dw 0x0000
0412A4 00          0293*   @end: db 0x00 ; padding
0412A5             0294*   
0412A5             0295*   ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
0412A5             0296*   ; inputs: a=format; bc=width; de=height
0412A5             0297*   ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
0412A5             0298*   ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
0412A5             0299*   ; 0 	RGBA8888 (4-bytes per pixel)
0412A5             0300*   ; 1 	RGBA2222 (1-bytes per pixel)
0412A5             0301*   ; 2 	Mono/Mask (1-bit per pixel)
0412A5             0302*   ; 3 	Reserved for internal use by VDP (“native” format)
0412A5             0303*   vdu_bmp_create:
0412A5 ED 43 C1 12 0304*       ld (@width),bc
       04          
0412AA ED 53 C3 12 0305*       ld (@height),de
       04          
0412AF 32 C5 12 04 0306*       ld (@fmt),a
0412B3 21 BE 12 04 0307*   	ld hl,@cmd
0412B7 01 08 00 00 0308*   	ld bc,@end-@cmd
0412BB 5B DF       0309*   	rst.lil $18
0412BD C9          0310*   	ret
0412BE 17 1B 21    0311*   @cmd:       db 23,27,0x21
0412C1 00 00       0312*   @width:     dw 0x0000
0412C3 00 00       0313*   @height:    dw 0x0000
0412C5 00          0314*   @fmt:       db 0x00
0412C6             0315*   @end:
0412C6             0316*   
0412C6             0317*   ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
0412C6             0318*   ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
0412C6             0319*   vdu_load_img_rgba2_to_8:
0412C6             0320*   ; backup the target buffer id and image dimensions
0412C6 E5          0321*       push hl
0412C7 D5          0322*       push de
0412C8 C5          0323*       push bc
0412C9             0324*   ; load the rgba2 image to working buffer 65534
0412C9 21 FE FF 00 0325*       ld hl,65534 ; temporary working buffer id
0412CD CD A4 13 04 0326*   	call vdu_load_buffer_from_file
0412D1             0327*   ; restore the image dimensions and target buffer id
0412D1 C1          0328*       pop bc
0412D2 D1          0329*       pop de
0412D3 E1          0330*       pop hl
0412D4             0331*   ; fall through to vdu_rgba2_to_8
0412D4             0332*   
0412D4             0333*   ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
0412D4             0334*   ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
0412D4             0335*   ; the "expand bitmap" command is:
0412D4             0336*   ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0412D4             0337*   ; and then to reverse the byte order to fix endian-ness:
0412D4             0338*   ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0412D4             0339*   ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0412D4             0340*   ; VDU 23,27,&20,targetBufferID%;
0412D4             0341*   ; VDU 23,27,&21,width%;height%;0
0412D4             0342*   ; -------------------------------------------------------------------
0412D4             0343*   ; inputs: bc,de image width,height ; hl = targetBufferId
0412D4             0344*   ; prerequisites: rgba2 image data loaded into workingBufferId 65534
0412D4             0345*   vdu_rgba2_to_8:
0412D4             0346*   ; load the image dimensions and buffer id parameters
0412D4 ED 43 30 13 0347*       ld (@width),bc
       04          
0412D9 ED 53 32 13 0348*       ld (@height),de
       04          
0412DE 22 15 13 04 0349*       ld (@bufferId0),hl
0412E2 22 22 13 04 0350*       ld (@bufferId2),hl
0412E6 22 2B 13 04 0351*       ld (@bufferId1),hl
0412EA             0352*   ; clean up bytes that got stomped on by the ID loads
0412EA 3E 48       0353*       ld a,0x48
0412EC 32 17 13 04 0354*       ld (@bufferId0+2),a
0412F0 3E 17       0355*       ld a,23
0412F2 32 2D 13 04 0356*       ld (@bufferId1+2),a
0412F6 3E 18       0357*       ld a,24
0412F8 32 24 13 04 0358*       ld (@bufferId2+2),a
0412FC AF          0359*       xor a
0412FD 32 34 13 04 0360*       ld (@height+2),a
041301             0361*   ; send the vdu command strings
041301 21 0C 13 04 0362*       ld hl,@beg
041305 01 29 00 00 0363*       ld bc,@end-@beg
041309 5B DF       0364*       rst.lil $18
04130B C9          0365*       ret
04130C             0366*   @beg:
04130C             0367*   ; Command 14: Consolidate blocks in a buffer
04130C             0368*   ; VDU 23, 0, &A0, bufferId; 14
04130C 17 00 A0    0369*       db 23,0,0xA0
04130F FE FF       0370*       dw 65534 ; workingBufferId
041311 0E          0371*       db 14 ; consolidate blocks
041312             0372*   ; the "expand bitmap" command is:
041312             0373*   ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
041312 17 00 A0    0374*       db 23,0,0xA0
041315 00 00       0375*   @bufferId0: dw 0x0000 ; targetBufferId
041317 48          0376*       db 0x48 ; given as decimal command 72 in the docs
041318 02          0377*       db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
041319 FE FF       0378*       dw 65534 ; sourceBufferId
04131B 00 7F BF FF 0379*       db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
04131F             0380*   ; reverse the byte order to fix endian-ness:
04131F             0381*   ; Command 24: Reverse the order of data of blocks within a buffer
04131F             0382*   ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
04131F             0383*   ; VDU 23,0,&A0,targetBufferID%;24,4,4;
04131F 17 00 A0    0384*       db 23,0,0xA0
041322 00 00       0385*   @bufferId2:    dw 0x0000 ; targetBufferId
041324 18          0386*       db 24 ; reverse byte order
041325 04          0387*       db 4 ; option: Reverse data of the value size within chunk of data of the specified size
041326 04 00       0388*       dw 4 ; size (4 bytes)
041328             0389*   ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
041328             0390*   ; VDU 23,27,&20,targetBufferID%;
041328 17 1B 20    0391*       db 23,27,0x20 ; select bitmap
04132B 00 00       0392*   @bufferId1: dw 0x0000 ; targetBufferId
04132D             0393*   ; VDU 23,27,&21,width%;height%;0
04132D 17 1B 21    0394*       db 23,27,0x21 ; create bitmap from buffer
041330 00 00       0395*   @width: dw 0x0000
041332 00 00       0396*   @height: dw 0x0000
041334 00          0397*       db 0x00 ; rgba8888 format
041335             0398*   @end:
041335             0399*   
041335             0400*   ; scratch variables
041335 00 00 00    0401*   bufferId0: dl 0x000000
041338 00 00 00    0402*   bufferId1: dl 0x000000
04133B             0403*   
04133B             0404*   ; load a vdu buffer from local memory
04133B             0405*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
04133B             0406*   vdu_load_buffer:
04133B ED 43 64 13 0407*       ld (@length),bc
       04          
041340 D5          0408*       push de ; save data pointer
041341             0409*   ; send the vdu command string
041341 7D          0410*       ld a,l
041342 32 61 13 04 0411*       ld (@bufferId),a
041346 7C          0412*       ld a,h
041347 32 62 13 04 0413*       ld (@bufferId+1),a
04134B 21 5E 13 04 0414*       ld hl,@cmd
04134F 01 08 00 00 0415*       ld bc,@end-@cmd
041353 5B DF       0416*       rst.lil $18
041355             0417*   ; send the buffer data
041355 E1          0418*       pop hl ; pointer to data
041356 ED 4B 64 13 0419*       ld bc,(@length)
       04          
04135B 5B DF       0420*       rst.lil $18 ; send it
04135D C9          0421*       ret
04135E             0422*   ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04135E 17 00 A0    0423*   @cmd:       db 23,0,0xA0
041361 00 00       0424*   @bufferId:	dw 0x0000
041363 00          0425*   		    db 0 ; load buffer
041364 00 00       0426*   @length:	dw 0x0000
041366 00          0427*   @end: db 0 ; padding
041367             0428*   
041367             0429*   ; Command 14: Consolidate blocks in a buffer
041367             0430*   vdu_consolidate_buffer:
041367             0431*   ; set parameters for vdu call
041367 7D          0432*       ld a,l
041368 32 7F 13 04 0433*       ld (@bufferId),a
04136C 7C          0434*       ld a,h
04136D 32 80 13 04 0435*       ld (@bufferId+1),a
041371 21 7C 13 04 0436*       ld hl,@beg
041375 01 06 00 00 0437*       ld bc,@end-@beg
041379 5B DF       0438*       rst.lil $18
04137B C9          0439*       ret
04137C             0440*   ; VDU 23, 0, &A0, bufferId; 14
04137C 17 00 A0    0441*   @beg: db 23,0,0xA0
04137F 00 00       0442*   @bufferId: dw 0x0000
041381 0E          0443*              db 14
041382             0444*   @end:
041382             0445*   
041382             0446*   ; load an image file to a buffer and make it a bitmap
041382             0447*   ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
041382             0448*   vdu_load_img:
041382             0449*   ; back up image type and dimension parameters
041382 22 35 13 04 0450*       ld (bufferId0),hl
041386 F5          0451*       push af
041387 C5          0452*   	push bc
041388 D5          0453*   	push de
041389             0454*   ; load the image
041389 CD A4 13 04 0455*   	call vdu_load_buffer_from_file
04138D             0456*   ; now make it a bitmap
04138D 2A 35 13 04 0457*       ld hl,(bufferId0)
041391 CD 67 13 04 0458*       call vdu_consolidate_buffer
041395 2A 35 13 04 0459*       ld hl,(bufferId0)
041399 CD 90 12 04 0460*       call vdu_buff_select
04139D D1          0461*   	pop de ; image height
04139E C1          0462*   	pop bc ; image width
04139F F1          0463*   	pop af ; image type
0413A0 C3 A5 12 04 0464*   	jp vdu_bmp_create ; will return to caller from there
0413A4             0465*   
0413A4             0466*   ; inputs: hl = bufferId; iy = pointer to filename
0413A4             0467*   vdu_load_buffer_from_file:
0413A4 22 35 13 04 0468*       ld (bufferId0),hl
0413A8             0469*   
0413A8             0470*   ; clear target buffer
0413A8 CD 50 15 04 0471*       call vdu_clear_buffer
0413AC             0472*   
0413AC             0473*   ; open the file in read mode
0413AC             0474*   ; Open a file
0413AC             0475*   ; HLU: Filename
0413AC             0476*   ;   C: Mode
0413AC             0477*   ; Returns:
0413AC             0478*   ;   A: Filehandle, or 0 if couldn't open
0413AC FD E5       0479*   	push iy ; pointer to filename
0413AE E1          0480*   	pop hl
0413AF 0E 01       0481*   	ld c,fa_read
0413B1             0482*       MOSCALL mos_fopen
                       M1 Args: function=mos_fopen 
0413B1 3E 0A       0001*M1 			LD	A, function
0413B3 5B CF       0002*M1 			RST.LIL	08h
0413B5 32 F0 13 04 0483*       ld (@filehandle),a
0413B9             0484*   
0413B9             0485*   @read_file:
0413B9             0486*   ; Read a block of data from a file
0413B9             0487*   ;   C: Filehandle
0413B9             0488*   ; HLU: Pointer to where to write the data to
0413B9             0489*   ; DEU: Number of bytes to read
0413B9             0490*   ; Returns:
0413B9             0491*   ; DEU: Number of bytes read
0413B9 3A F0 13 04 0492*       ld a,(@filehandle)
0413BD 4F          0493*       ld c,a
0413BE 21 00 E0 B7 0494*       ld hl,filedata
0413C2 11 00 20 00 0495*       ld de,8192 ; max we can read into onboard sram at one time
0413C6             0496*       MOSCALL mos_fread
                       M1 Args: function=mos_fread 
0413C6 3E 1A       0001*M1 			LD	A, function
0413C8 5B CF       0002*M1 			RST.LIL	08h
0413CA             0497*   
0413CA             0498*   ; test de for zero bytes read
0413CA 21 00 00 00 0499*       ld hl,0
0413CE AF          0500*       xor a ; clear carry
0413CF ED 52       0501*       sbc hl,de
0413D1 CA E7 13 04 0502*       jp z,@close_file
0413D5             0503*   
0413D5             0504*   ; load a vdu buffer from local memory
0413D5             0505*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0413D5 2A 35 13 04 0506*       ld hl,(bufferId0)
0413D9 D5          0507*       push de ; chunksize
0413DA C1          0508*       pop bc
0413DB 11 00 E0 B7 0509*       ld de,filedata
0413DF CD 3B 13 04 0510*       call vdu_load_buffer
0413E3             0511*   
0413E3             0512*   ; read the next block
0413E3 C3 B9 13 04 0513*       jp @read_file
0413E7             0514*   
0413E7             0515*   ; close the file
0413E7             0516*   @close_file:
0413E7 3A F0 13 04 0517*       ld a,(@filehandle)
0413EB             0518*       MOSCALL mos_fclose
                       M1 Args: function=mos_fclose 
0413EB 3E 0B       0001*M1 			LD	A, function
0413ED 5B CF       0002*M1 			RST.LIL	08h
0413EF C9          0519*       ret ; vdu_load_buffer_from_file
0413F0             0520*   
0413F0 00          0521*   @filehandle: db 0 ; file handle
0413F1 00 00 00    0522*   @fil: dl 0 ; pointer to FIL struct
0413F4             0523*   
0413F4 00 00 00    0524*   @chunkpointer: dl 0 ; pointer to current chunk
0413F7             0525*   
0413F7             0526*   ; File information structure (FILINFO)
0413F7             0527*   @filinfo:
0413F7 00 00 00 00 0528*   @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
0413FB 00 00       0529*   @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
0413FD 00 00       0530*   @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
0413FF 00          0531*   @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
041400 00 00 00 00 0532*   @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
04140D 00 00 00 00 0533*   @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04150D             0039        include "vdu_buffered_api.inc"
04150D             0001*   ; https://agonconsole8.github.io/agon-docs/vdp/Buffered-Commands-API/
04150D             0002*   
04150D             0003*   ; Command 0: Write block to a buffer
04150D             0004*   ; VDU 23, 0, &A0, bufferId; 0, length; <buffer-data>
04150D             0005*   ; inputs: hl = bufferId, bc = length of data, de = pointer to data
04150D             0006*   vdu_write_block_to_buffer:
04150D             0007*   ; back up input parameters
04150D D5          0008*       push de ; pointer to data
04150E C5          0009*       push bc ; length of data
04150F             0010*   ; set up the vdu command string
04150F 22 2F 15 04 0011*       ld (@bufferId),hl
041513 ED 43 32 15 0012*       ld (@length),bc
       04          
041518 AF          0013*       xor a ; load buffer
041519 32 31 15 04 0014*       ld (@bufferId+2),a
04151D 21 2C 15 04 0015*       ld hl,@cmd0
041521 01 08 00 00 0016*       ld bc,@end0-@cmd0
041525 5B DF       0017*       rst.lil $18
041527             0018*   ; send the buffer data
041527 C1          0019*       pop bc ; length of data
041528 E1          0020*       pop hl ; pointer to data (was de)
041529 5B DF       0021*       rst.lil $18 ; send it
04152B C9          0022*       ret
04152C             0023*   ; command string data
04152C 17 00 A0    0024*   @cmd0:      db 23,0,0xA0
04152F 00 00       0025*   @bufferId:	dw 0x0000
041531 00          0026*               db 0 ; load buffer
041532 00 00       0027*   @length:	dw 0x0000
041534 00          0028*   @end0:      db 0x00 ; padding
041535             0029*   ; end vdu_write_block_to_buffer
041535             0030*   
041535             0031*   ; Command 1: Call a buffer
041535             0032*   ; VDU 23, 0, &A0, bufferId; 1
041535             0033*   ; inputs: hl = bufferId
041535             0034*   vdu_call_buffer:
041535 22 4D 15 04 0035*       ld (@bufferId),hl
041539 3E 01       0036*       ld a,1 ; call buffer
04153B 32 4F 15 04 0037*       ld (@bufferId+2),a
04153F 21 4A 15 04 0038*       ld hl,@cmd
041543 01 06 00 00 0039*       ld bc,@end-@cmd
041547 5B DF       0040*       rst.lil $18
041549 C9          0041*       ret
04154A 17 00 A0    0042*   @cmd:     db 23,0,0xA0
04154D 00 00       0043*   @bufferId: dw 0x0000
04154F 01          0044*              db 1 ; call buffer
041550             0045*   @end:
041550             0046*   ; end vdu_call_buffer
041550             0047*   
041550             0048*   ; Command 2: Clear a buffer
041550             0049*   ; VDU 23, 0 &A0, bufferId; 2
041550             0050*   ; inputs: hl = bufferId
041550             0051*   vdu_clear_buffer:
041550 22 68 15 04 0052*       ld (@bufferId),hl
041554 3E 02       0053*       ld a,2 ; clear buffer
041556 32 6A 15 04 0054*       ld (@bufferId+2),a
04155A 21 65 15 04 0055*       ld hl,@cmd
04155E 01 06 00 00 0056*       ld bc,@end-@cmd
041562 5B DF       0057*       rst.lil $18
041564 C9          0058*       ret
041565 17 00 A0    0059*   @cmd:     db 23,0,0xA0
041568 00 00       0060*   @bufferId: dw 0x0000
04156A 02          0061*              db 2 ; clear buffer
04156B             0062*   @end:
04156B             0063*   ; end vdu_clear_buffer
04156B             0064*   
04156B             0065*   ; Clear all buffers
04156B             0066*   ; inputs: none
04156B             0067*   vdu_clear_all_buffers:
04156B             0068*   ; clear all buffers
04156B 21 76 15 04 0069*       ld hl,@beg
04156F 01 06 00 00 0070*       ld bc,@end-@beg
041573 5B DF       0071*       rst.lil $18
041575 C9          0072*       ret
041576 17 00 A0    0073*   @beg: db 23,0,$A0
041579 FF FF       0074*         dw -1 ; bufferId -1 (65535) means clear all buffers
04157B 02          0075*         db 2  ; command 2: clear a buffer
04157C             0076*   @end:
04157C             0077*   ; end vdu_clear_all_buffers
04157C             0078*   
04157C             0079*   ; Command 3: Create a writeable buffer
04157C             0080*   ; VDU 23, 0 &A0, bufferId; 3, length;
04157C             0081*   ; inputs: hl = bufferId, bc = length
04157C             0082*   vdu_create_writeable_buffer:
04157C 22 99 15 04 0083*       ld (@bufferId),hl
041580 ED 43 9C 15 0084*       ld (@length),bc
       04          
041585 3E 03       0085*       ld a,3 ; create writeable buffer
041587 32 9B 15 04 0086*       ld (@bufferId+2),a
04158B 21 96 15 04 0087*       ld hl,@cmd
04158F 01 08 00 00 0088*       ld bc,@end-@cmd
041593 5B DF       0089*       rst.lil $18
041595 C9          0090*       ret
041596 17 00 A0    0091*   @cmd:     db 23,0,0xA0
041599 00 00       0092*   @bufferId: dw 0x0000
04159B 03          0093*              db 3 ; create writeable buffer
04159C 00 00       0094*   @length: dw 0x0000
04159E 00          0095*   @end:     db 0x00 ; padding
04159F             0096*   ; end vdu_create_writeable_buffer
04159F             0097*   
04159F             0098*   ; Command 4: Set output stream to a buffer
04159F             0099*   ; VDU 23, 0 &A0, bufferId; 4
04159F             0100*   ; inputs: hl = bufferId
04159F             0101*   vdu_set_output_stream_buffer:
04159F 22 B7 15 04 0102*       ld (@bufferId),hl
0415A3 3E 04       0103*       ld a,4 ; set output stream to buffer
0415A5 32 B9 15 04 0104*       ld (@bufferId+2),a
0415A9 21 B4 15 04 0105*       ld hl,@cmd
0415AD 01 06 00 00 0106*       ld bc,@end-@cmd
0415B1 5B DF       0107*       rst.lil $18
0415B3 C9          0108*       ret
0415B4 17 00 A0    0109*   @cmd:     db 23,0,0xA0
0415B7 00 00       0110*   @bufferId: dw 0x0000
0415B9 04          0111*              db 4 ; set output stream to buffer
0415BA 00          0112*   @end:     db 0x00 ; padding
0415BB             0113*   ; end vdu_set_output_stream_buffer
0415BB             0114*   
0415BB             0115*   ; Command 5: Adjust buffer contents
0415BB             0116*   ; VDU 23, 0, &A0, bufferId; 5, operation, offset; [count;] <operand>, [arguments]
0415BB             0117*   vdu_adjust_buffer:
0415BB C9          0118*       ret ; TODO: implement
0415BC             0119*   ; end vdu_adjust_buffer
0415BC             0120*   
0415BC             0121*   ; Command 6: Conditionally call a buffer
0415BC             0122*   ; VDU 23, 0, &A0, bufferId; 6, operation, checkBufferId; checkOffset; [arguments]
0415BC             0123*   vdu_call_buffer_conditional:
0415BC C9          0124*       ret ; TODO: implement
0415BD             0125*   ; end vdu_call_buffer_conditional
0415BD             0126*   
0415BD             0127*   ; Command 7: Jump to a buffer
0415BD             0128*   ; VDU 23, 0, &A0, bufferId; 7
0415BD             0129*   ; inputs: hl = bufferId
0415BD             0130*   vdu_jump_to_buffer:
0415BD 22 D5 15 04 0131*       ld (@bufferId),hl
0415C1 3E 07       0132*       ld a,7 ; jump to buffer
0415C3 32 D7 15 04 0133*       ld (@bufferId+2),a
0415C7 21 D2 15 04 0134*       ld hl,@cmd
0415CB 01 06 00 00 0135*       ld bc,@end-@cmd
0415CF 5B DF       0136*       rst.lil $18
0415D1 C9          0137*       ret
0415D2 17 00 A0    0138*   @cmd:     db 23,0,0xA0
0415D5 00 00       0139*   @bufferId: dw 0x0000
0415D7 07          0140*              db 7 ; jump to buffer
0415D8 00          0141*   @end:     db 0x00 ; padding
0415D9             0142*   ; end vdu_jump_to_buffer
0415D9             0143*   
0415D9             0144*   ; Command 8: Conditional Jump to a buffer
0415D9             0145*   ; VDU 23, 0, &A0, bufferId; 8, operation, checkBufferId; checkOffset; [arguments]
0415D9             0146*   vdu_jump_to_buffer_conditional:
0415D9 C9          0147*       ret ; TODO: implement
0415DA             0148*   ; end vdu_jump_to_buffer_conditional
0415DA             0149*   
0415DA             0150*   ; Command 9: Jump to an offset in a buffer
0415DA             0151*   ; VDU 23, 0, &A0, bufferId; 9, offset; offsetHighByte, [blockNumber;]
0415DA             0152*   vdu_jump_to_buffer_offset:
0415DA C9          0153*       ret ; TODO: implement
0415DB             0154*   ; end vdu_jump_to_buffer_offset
0415DB             0155*   
0415DB             0156*   ; Command 10: Conditional jump to an offset in a buffer
0415DB             0157*   ; VDU 23, 0, &A0, bufferId; 10, offset; offsetHighByte, [blockNumber;] [arguments]
0415DB             0158*   vdu_jump_to_buffer_offset_conditional:
0415DB C9          0159*       ret ; TODO: implement
0415DC             0160*   ; end vdu_jump_to_buffer_offset_conditional
0415DC             0161*   
0415DC             0162*   ; Command 11: Call buffer with an offset
0415DC             0163*   ; VDU 23, 0, &A0, bufferId; 11, offset; offsetHighByte, [blockNumber;]
0415DC             0164*   vdu_call_buffer_offset:
0415DC C9          0165*       ret ; TODO: implement
0415DD             0166*   ; end vdu_call_buffer_offset
0415DD             0167*   
0415DD             0040        include "vdu_fonts.inc"
0415DD             0001*   ; select font
0415DD             0002*   ; inputs: hl = bufferId, a = font flags
0415DD             0003*   ; Flags:
0415DD             0004*   ; Bit	Description
0415DD             0005*   ; 0	Adjust cursor position to ensure text baseline is aligned
0415DD             0006*   ;   0: Do not adjust cursor position (best for changing font on a new line)
0415DD             0007*   ;   1: Adjust cursor position (best for changing font in the middle of a line)
0415DD             0008*   ; 1-7	Reserved for future use
0415DD             0009*   ; VDU 23, 0, &95, 0, bufferId; flags: Select font
0415DD             0010*   vdu_font_select:
0415DD 22 F4 15 04 0011*       ld (@bufferId),hl
0415E1 32 F6 15 04 0012*       ld (@flags),a
0415E5 21 F0 15 04 0013*       ld hl,@cmd
0415E9 01 07 00 00 0014*       ld bc,@end-@cmd
0415ED 5B DF       0015*       rst.lil $18
0415EF C9          0016*       ret
0415F0 17 00 95 00 0017*   @cmd: db 23, 0, 0x95, 0
0415F4 00 00       0018*   @bufferId: dw 0x0000
0415F6 00          0019*   @flags: db 0x00
0415F7             0020*   @end:
0415F7             0021*   
0415F7             0022*   ; create font from buffer
0415F7             0023*   ; inputs: hl = bufferId, e = width, d = height, d = ascent, a = flags
0415F7             0024*   ; VDU 23, 0, &95, 1, bufferId; width, height, ascent, flags: Create font from buffer
0415F7             0025*   vdu_font_create:
0415F7 22 1C 16 04 0026*       ld (@bufferId),hl
0415FB ED 53 1E 16 0027*       ld (@width),de ; also loads height
       04          
041600 32 21 16 04 0028*       ld (@flags),a
041604 7A          0029*       ld a,d ; height
041605 32 20 16 04 0030*       ld (@ascent),a ; ascent = height
041609             0031*   ; consolidate buffer
041609 CD 67 13 04 0032*       call vdu_consolidate_buffer
04160D             0033*   ; create font
04160D 21 18 16 04 0034*       ld hl,@cmd
041611 01 0A 00 00 0035*       ld bc,@end-@cmd
041615 5B DF       0036*       rst.lil $18
041617 C9          0037*       ret
041618 17 00 95 01 0038*   @cmd: db 23, 0, 0x95, 1
04161C 00 00       0039*   @bufferId: dw 0x0000
04161E 00          0040*   @width: db 0x00
04161F 00          0041*   @height: db 0x00
041620 00          0042*   @ascent: db 0x00
041621 00          0043*   @flags: db 0x00
041622             0044*   @end:
041622             0045*   
041622             0046*   ; set or adjust font property
041622             0047*   ; inputs: hl = bufferId, a = field, de = value
041622             0048*   ; VDU 23, 0, &95, 2, bufferId; field, value;: Set or adjust font property
041622             0049*   vdu_font_property:
041622 22 3E 16 04 0050*       ld (@bufferId),hl
041626 32 40 16 04 0051*       ld (@field),a
04162A ED 53 41 16 0052*       ld (@value),de
       04          
04162F 21 3A 16 04 0053*       ld hl,@cmd
041633 01 09 00 00 0054*       ld bc,@end-@cmd
041637 5B DF       0055*       rst.lil $18
041639 C9          0056*       ret
04163A 17 00 95 02 0057*   @cmd: db 23, 0, 0x95, 2
04163E 00 00       0058*   @bufferId: dw 0x0000
041640 00          0059*   @field: db 0x00
041641 00 00       0060*   @value: dw 0x0000
041643 00          0061*   @end: db 0x00 ; padding
041644             0062*   
041644             0063*   ; VDU 23, 0, &95, 3, bufferId; [<args>]: Reserved
041644             0064*   
041644             0065*   ; Clear/Delete font
041644             0066*   ; inputs: hl = bufferId
041644             0067*   ; VDU 23, 0, &95, 4, bufferId;: Clear/Delete font
041644             0068*   vdu_font_clear:
041644 22 57 16 04 0069*       ld (@bufferId),hl
041648 21 53 16 04 0070*       ld hl,@cmd
04164C 01 06 00 00 0071*       ld bc,@end-@cmd
041650 5B DF       0072*       rst.lil $18
041652 C9          0073*       ret
041653 17 00 95 04 0074*   @cmd: db 23, 0, 0x95, 4
041657 00 00       0075*   @bufferId: dw 0x0000
041659 00          0076*   @end: db 0x00 ; padding
04165A             0077*   
04165A             0078*   ; Copy system font to buffer
04165A             0079*   ; inputs: hl = bufferId
04165A             0080*   ; VDU 23, 0, &95, 5, bufferId;: Copy system font to buffer
04165A             0081*   vdu_font_copy_system:
04165A 22 6D 16 04 0082*       ld (@bufferId),hl
04165E 21 69 16 04 0083*       ld hl,@cmd
041662 01 06 00 00 0084*       ld bc,@end-@cmd
041666 5B DF       0085*       rst.lil $18
041668 C9          0086*       ret
041669 17 00 95 05 0087*   @cmd: db 23, 0, 0x95, 5
04166D 00 00       0088*   @bufferId: dw 0x0000
04166F 00          0089*   @end: db 0x00 ; padding
041670             0041        include "vdu_plot.inc"
041670             0001*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
041670             0002*   ; PLOT code 	(Decimal) 	Effect
041670             0003*   ; &00-&07 	0-7 	Solid line, includes both ends
041670             0004*   plot_sl_both: equ 0x00
041670             0005*   
041670             0006*   ; &08-&0F 	8-15 	Solid line, final point omitted
041670             0007*   plot_sl_first: equ 0x08
041670             0008*   
041670             0009*   ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
041670             0010*   ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
041670             0011*   
041670             0012*   ; &20-&27 	32-39 	Solid line, first point omitted
041670             0013*   plot_sl_last: equ 0x20
041670             0014*   
041670             0015*   ; &28-&2F 	40-47 	Solid line, both points omitted
041670             0016*   plot_sl_none: equ 0x28
041670             0017*   
041670             0018*   ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
041670             0019*   ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
041670             0020*   
041670             0021*   ; &40-&47 	64-71 	Point plot
041670             0022*   plot_pt: equ 0x40
041670             0023*   
041670             0024*   ; &48-&4F 	72-79 	Line fill left and right to non-background §§
041670             0025*   plot_lf_lr_non_bg: equ 0x48
041670             0026*   
041670             0027*   ; &50-&57 	80-87 	Triangle fill
041670             0028*   plot_tf: equ 0x50
041670             0029*   
041670             0030*   ; &58-&5F 	88-95 	Line fill right to background §§
041670             0031*   plot_lf_r_bg: equ 0x58
041670             0032*   
041670             0033*   ; &60-&67 	96-103 	Rectangle fill
041670             0034*   plot_rf: equ 0x60
041670             0035*   
041670             0036*   ; &68-&6F 	104-111 	Line fill left and right to foreground §§
041670             0037*   plot_lf_lr_fg: equ 0x60
041670             0038*   
041670             0039*   ; &70-&77 	112-119 	Parallelogram fill
041670             0040*   plot_pf: equ 0x70
041670             0041*   
041670             0042*   ; &78-&7F 	120-127 	Line fill right to non-foreground §§
041670             0043*   plot_lf_r_non_fg: equ 0x78
041670             0044*   
041670             0045*   ; &80-&87 	128-135 	Not supported (Flood until non-background)
041670             0046*   ; &88-&8F 	136-143 	Not supported (Flood until foreground)
041670             0047*   
041670             0048*   ; &90-&97 	144-151 	Circle outline
041670             0049*   plot_co: equ 0x90
041670             0050*   
041670             0051*   ; &98-&9F 	152-159 	Circle fill
041670             0052*   plot_cf: equ 0x98
041670             0053*   
041670             0054*   ; &A0-&A7 	160-167 	Not supported (Circular arc)
041670             0055*   ; &A8-&AF 	168-175 	Not supported (Circular segment)
041670             0056*   ; &B0-&B7 	176-183 	Not supported (Circular sector)
041670             0057*   
041670             0058*   ; &B8-&BF 	184-191 	Rectangle copy/move
041670             0059*   plot_rcm: equ 0xB8
041670             0060*   
041670             0061*   ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
041670             0062*   ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
041670             0063*   ; &D0-&D7 	208-215 	Not defined
041670             0064*   ; &D8-&DF 	216-223 	Not defined
041670             0065*   ; &E0-&E7 	224-231 	Not defined
041670             0066*   
041670             0067*   ; &E8-&EF 	232-239 	Bitmap plot §
041670             0068*   plot_bmp: equ 0xE8
041670             0069*   
041670             0070*   ; &F0-&F7 	240-247 	Not defined
041670             0071*   ; &F8-&FF 	248-255 	Not defined
041670             0072*   
041670             0073*   ; § Support added in Agon Console8 VDP 2.1.0 §§ Support added in
041670             0074*   ; Agon Console8 VDP 2.2.0
041670             0075*   
041670             0076*   ; Within each group of eight plot codes, the effects are as follows:
041670             0077*   ; Plot code 	Effect
041670             0078*   ; 0 	Move relative
041670             0079*   mv_rel: equ 0
041670             0080*   
041670             0081*   ; 1 	Plot relative in current foreground colour
041670             0082*   dr_rel_fg: equ 1
041670             0083*   
041670             0084*   ; 2 	Not supported (Plot relative in logical inverse colour)
041670             0085*   ; 3 	Plot relative in current background colour
041670             0086*   dr_rel_bg: equ 3
041670             0087*   
041670             0088*   ; 4 	Move absolute
041670             0089*   mv_abs: equ 4
041670             0090*   
041670             0091*   ; 5 	Plot absolute in current foreground colour
041670             0092*   dr_abs_fg: equ 5
041670             0093*   
041670             0094*   ; 6 	Not supported (Plot absolute in logical inverse colour)
041670             0095*   ; 7 	Plot absolute in current background colour
041670             0096*   dr_abs_bg: equ 7
041670             0097*   
041670             0098*   ; Codes 0-3 use the position data provided as part of the command
041670             0099*   ; as a relative position, adding the position given to the current
041670             0100*   ; graphical cursor position. Codes 4-7 use the position data provided
041670             0101*   ; as part of the command as an absolute position, setting the current
041670             0102*   ; graphical cursor position to the position given.
041670             0103*   
041670             0104*   ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
041670             0105*   ; current pixel colour. These operations cannot currently be supported
041670             0106*   ; by the graphics system the Agon VDP uses, so these codes are not
041670             0107*   ; supported. Support for these codes may be added in a future version
041670             0108*   ; of the VDP firmware.
041670             0109*   
041670             0110*   ; 16 colour palette constants
041670             0111*   c_black: equ 0
041670             0112*   c_red_dk: equ 1
041670             0113*   c_green_dk: equ 2
041670             0114*   c_yellow_dk: equ 3
041670             0115*   c_blue_dk: equ 4
041670             0116*   c_magenta_dk: equ 5
041670             0117*   c_cyan_dk: equ 6
041670             0118*   c_grey: equ 7
041670             0119*   c_grey_dk: equ 8
041670             0120*   c_red: equ 9
041670             0121*   c_green: equ 10
041670             0122*   c_yellow: equ 11
041670             0123*   c_blue: equ 12
041670             0124*   c_magenta: equ 13
041670             0125*   c_cyan: equ 14
041670             0126*   c_white: equ 15
041670             0127*   
041670             0128*   ; VDU 25, mode, x; y;: PLOT command
041670             0129*   ; inputs: a=mode, bc=x0, de=y0
041670             0130*   vdu_plot:
041670 32 8A 16 04 0131*       ld (@mode),a
041674 ED 43 8B 16 0132*       ld (@x0),bc
       04          
041679 ED 53 8D 16 0133*       ld (@y0),de
       04          
04167E 21 89 16 04 0134*   	ld hl,@cmd
041682 01 06 00 00 0135*   	ld bc,@end-@cmd
041686 5B DF       0136*   	rst.lil $18
041688 C9          0137*   	ret
041689 19          0138*   @cmd:   db 25
04168A 00          0139*   @mode:  db 0
04168B 00 00       0140*   @x0: 	dw 0
04168D 00 00       0141*   @y0: 	dw 0
04168F 00          0142*   @end:   db 0 ; extra byte to soak up deu
041690             0143*   
041690             0144*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
041690             0145*   ; &E8-&EF 	232-239 	Bitmap plot §
041690             0146*   ; VDU 25, mode, x; y;: PLOT command
041690             0147*   ; inputs: bc=x0, de=y0
041690             0148*   ; prerequisites: vdu_buff_select
041690             0149*   vdu_plot_bmp:
041690 ED 43 A7 16 0150*       ld (@x0),bc
       04          
041695 ED 53 A9 16 0151*       ld (@y0),de
       04          
04169A 21 A5 16 04 0152*   	ld hl,@cmd
04169E 01 06 00 00 0153*   	ld bc,@end-@cmd
0416A2 5B DF       0154*   	rst.lil $18
0416A4 C9          0155*   	ret
0416A5 19          0156*   @cmd:   db 25
0416A6 ED          0157*   @mode:  db plot_bmp+dr_abs_fg ; 0xED
0416A7 00 00       0158*   @x0: 	dw 0x0000
0416A9 00 00       0159*   @y0: 	dw 0x0000
0416AB 00          0160*   @end:   db 0x00 ; padding
0416AC             0161*   
0416AC             0162*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0416AC             0163*   ; &E8-&EF 	232-239 	Bitmap plot §
0416AC             0164*   ; VDU 25, mode, x; y;: PLOT command
0416AC             0165*   ; inputs: bc=x0, de=y0
0416AC             0166*   ; USING 16.8 FIXED POINT COORDINATES
0416AC             0167*   ; inputs: ub.c is x coordinate, ud.e is y coordinate
0416AC             0168*   ;   the fractional portiion of the inputs are truncated
0416AC             0169*   ;   leaving only the 16-bit integer portion
0416AC             0170*   ; prerequisites: vdu_buff_select
0416AC             0171*   vdu_plot_bmp168:
0416AC             0172*   ; populate in the reverse of normal to keep the
0416AC             0173*   ; inputs from stomping on each other
0416AC ED 53 CA 16 0174*       ld (@y0-1),de
       04          
0416B1 ED 43 C8 16 0175*       ld (@x0-1),bc
       04          
0416B6 3E ED       0176*       ld a,plot_bmp+dr_abs_fg ; 0xED
0416B8 32 C8 16 04 0177*       ld (@mode),a ; restore the mode byte that got stomped on by bcu
0416BC 21 C7 16 04 0178*   	ld hl,@cmd
0416C0 01 06 00 00 0179*   	ld bc,@end-@cmd
0416C4 5B DF       0180*   	rst.lil $18
0416C6 C9          0181*   	ret
0416C7 19          0182*   @cmd:   db 25
0416C8 ED          0183*   @mode:  db plot_bmp+dr_abs_fg ; 0xED
0416C9 00 00       0184*   @x0: 	dw 0x0000
0416CB 00 00       0185*   @y0: 	dw 0x0000
0416CD             0186*   @end:  ; no padding required b/c we shifted de right
0416CD             0187*   
0416CD             0188*   ; draw a filled rectangle
0416CD             0189*   vdu_plot_rf:
0416CD ED 43 F4 16 0190*       ld (@x0),bc
       04          
0416D2 ED 53 F6 16 0191*       ld (@y0),de
       04          
0416D7 DD 22 FA 16 0192*       ld (@x1),ix
       04          
0416DC FD 22 FC 16 0193*       ld (@y1),iy
       04          
0416E1 3E 19       0194*       ld a,25 ; we have to reload the 2nd plot command
0416E3 32 F8 16 04 0195*       ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0416E7 21 F2 16 04 0196*   	ld hl,@cmd0
0416EB 01 0C 00 00 0197*   	ld bc,@end-@cmd0
0416EF 5B DF       0198*   	rst.lil $18
0416F1 C9          0199*       ret
0416F2 19          0200*   @cmd0:  db 25 ; plot
0416F3 04          0201*   @arg0:  db plot_sl_both+mv_abs
0416F4 00 00       0202*   @x0:    dw 0x0000
0416F6 00 00       0203*   @y0:    dw 0x0000
0416F8 19          0204*   @cmd1:  db 25 ; plot
0416F9 65          0205*   @arg1:  db plot_rf+dr_abs_fg
0416FA 00 00       0206*   @x1:    dw 0x0000
0416FC 00 00       0207*   @y1:    dw 0x0000
0416FE 00          0208*   @end:   db 0x00 ; padding
0416FF             0209*   
0416FF             0210*   ; draw a filled circle
0416FF             0211*   vdu_plot_cf:
0416FF ED 43 26 17 0212*       ld (@x0),bc
       04          
041704 ED 53 28 17 0213*       ld (@y0),de
       04          
041709 DD 22 2C 17 0214*       ld (@x1),ix
       04          
04170E FD 22 2E 17 0215*       ld (@y1),iy
       04          
041713 3E 19       0216*       ld a,25 ; we have to reload the 2nd plot command
041715 32 2A 17 04 0217*       ld (@cmd1),a ; because the 24-bit y0 load stomped on it
041719 21 24 17 04 0218*   	ld hl,@cmd0
04171D 01 0C 00 00 0219*   	ld bc,@end-@cmd0
041721 5B DF       0220*   	rst.lil $18
041723 C9          0221*       ret
041724 19          0222*   @cmd0:  db 25 ; plot
041725 04          0223*   @arg0:  db plot_sl_both+mv_abs
041726 00 00       0224*   @x0:    dw 0x0000
041728 00 00       0225*   @y0:    dw 0x0000
04172A 19          0226*   @cmd1:  db 25 ; plot
04172B 9D          0227*   @arg1:  db plot_cf+dr_abs_fg
04172C 00 00       0228*   @x1:    dw 0x0000
04172E 00 00       0229*   @y1:    dw 0x0000
041730 00          0230*   @end:   db 0x00 ; padding
041731             0042        include "vdu_sound.inc"
041731             0001*   ; enable enough additional channels so that total enabled = max_channels
041731             0002*   ; inputs: max_channels set
041731             0003*   ; returns: nothing
041731             0004*   ; destroys: af, bc, hl
041731             0005*   vdu_enable_channels:
041731 3E 01       0006*       ld a,max_channels
041733 D6 03       0007*       sub 3 ; subtract number of default channels already enabled
041735 F2 3C 17 04 0008*       jp p,@loop
041739 C9          0009*       ret
04173A 3E 03       0010*       ld a,3 ; first non-default channel
04173C             0011*   @loop:
04173C 32 57 17 04 0012*       ld (@channel),a
041740 21 54 17 04 0013*       ld hl,@beg
041744 01 05 00 00 0014*       ld bc,@end-@beg
041748 F5          0015*       push af
041749 5B DF       0016*       rst.lil $18
04174B F1          0017*       pop af
04174C 3C          0018*       inc a
04174D FE 01       0019*       cp max_channels
04174F C2 3C 17 04 0020*       jp nz,@loop
041753 C9          0021*       ret
041754             0022*   @beg:
041754 17 00 85    0023*               db 23, 0, $85
041757 00          0024*   @channel:   db 0
041758 08          0025*               db 8 ; command 8: enable channel
041759             0026*   @end:
041759             0027*   
041759             0028*   ; disable all but the three default sound channels
041759             0029*   ; inputs: max_channels set
041759             0030*   ; outputs: none
041759             0031*   ; destroys: ah,hl,bc
041759             0032*   vdu_disable_channels:
041759 3E 01       0033*       ld a,max_channels
04175B D6 03       0034*       sub 3 ; subtract number of default channels already enabled
04175D F2 64 17 04 0035*       jp p,@loop
041761 C9          0036*       ret
041762 3E 03       0037*       ld a,3 ; first non-default channel
041764             0038*   @loop:
041764 32 7F 17 04 0039*       ld (@channel),a
041768 21 7C 17 04 0040*       ld hl,@beg
04176C 01 05 00 00 0041*       ld bc,@end-@beg
041770 F5          0042*       push af
041771 5B DF       0043*       rst.lil $18
041773 F1          0044*       pop af
041774 3C          0045*       inc a
041775 FE 01       0046*       cp max_channels
041777 C2 64 17 04 0047*       jp nz,@loop
04177B C9          0048*       ret
04177C             0049*   @beg:
04177C 17 00 85    0050*       db 23, 0, $85
04177F 00          0051*   @channel: db 0
041780 09          0052*       db 9 ; command 9: disable channel
041781             0053*   @end:
041781             0054*   
041781             0055*   
041781             0056*   ; ############################################################
041781             0057*   ; VDU SOUND API
041781             0058*   ; ############################################################
041781             0059*   ; Command 0: Play note
041781             0060*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
041781             0061*       MACRO PLAY_NOTE channel, volume, frequency, duration
041781             0062*       ld hl, @PLAY_NOTE_CMD        ; Start of command block
041781             0063*       ld bc, @PLAY_NOTE_END - @PLAY_NOTE_CMD  ; Command block size
041781             0064*       rst.lil $18
041781             0065*       jr @PLAY_NOTE_END
041781             0066*   @PLAY_NOTE_CMD:  db 23, 0, 0x85               ; Command header
041781             0067*                    db channel                  ; Channel, 0 (commented out)
041781             0068*                    db 0                        ; Play note command
041781             0069*                    db volume                   ; Volume
041781             0070*                    dw frequency                ; Frequency
041781             0071*                    dw duration                 ; Duration
041781             0072*   @PLAY_NOTE_END:
041781             0073*       ENDMACRO
041781             0074*   
041781             0075*       MACRO MUTE_CHANNEL channel
041781             0076*       ld hl, @MUTE_CHANNEL_CMD     ; Start of command block
041781             0077*       ld bc, @MUTE_CHANNEL_END - @MUTE_CHANNEL_CMD  ; Command block size
041781             0078*       rst.lil $18
041781             0079*       jr @MUTE_CHANNEL_END
041781             0080*   @MUTE_CHANNEL_CMD: db 23, 0, 0x85             ; Command header
041781             0081*                      db channel                ; Channel, 0 (commented out)
041781             0082*                      db 2                      ; Set volume command
041781             0083*                      db 0                      ; Volume (mute)
041781             0084*   @MUTE_CHANNEL_END:
041781             0085*       ENDMACRO
041781             0086*   
041781             0087*   ; inputs: c = channel, b = volume, hl = frequency; de = duration;
041781             0088*   vdu_play_note:
041781 79          0089*       ld a,c
041782 32 A2 17 04 0090*       ld (@channel),a
041786 78          0091*       ld a,b
041787 32 A4 17 04 0092*       ld (@volume),a
04178B 22 A5 17 04 0093*       ld (@frequency),hl
04178F ED 53 A7 17 0094*       ld (@duration),de
       04          
041794 21 9F 17 04 0095*       ld hl,@cmd
041798 01 0A 00 00 0096*       ld bc,@end-@cmd
04179C 5B DF       0097*       rst.lil $18
04179E C9          0098*       ret
04179F 17 00 85    0099*   @cmd:       db 23, 0, 0x85
0417A2 00          0100*   @channel:   db 0x00
0417A3 00          0101*               db 0x00 ; play note command
0417A4 00          0102*   @volume:    db 0x00
0417A5 00 00       0103*   @frequency: dw 0x0000
0417A7 00 00       0104*   @duration:  dw 0x0000
0417A9 00          0105*   @end:       db 0x00 ; padding
0417AA             0106*   
0417AA             0107*   ; Command 1: Status
0417AA             0108*   ; VDU 23, 0, &85, channel, 1
0417AA             0109*   ; inputs: a = channel
0417AA             0110*   ; Returns a bit mask indicating the status of the specified channel, or 255 if the channel is not valid, or has been disabled. The bit mask is as follows:
0417AA             0111*   ; Bit 	Name 	Meaning
0417AA             0112*   ; 0 	Active 	When set this indicates the channel is in use (has an active waveform)
0417AA             0113*   ; 1 	Playing 	Indicates the channel is actively playing a note, and thus will reject calls to play a new note
0417AA             0114*   ; 2 	Indefinite 	Set if the channel is playing an indefinite duration note
0417AA             0115*   ; 3 	Has Volume Envelope 	Set if the channel has a volume envelope
0417AA             0116*   ; 4 	Has Frequency Envelope 	Set if the channel has a frequency envelope
0417AA             0117*   
0417AA             0118*   ; Bits 5-7 are reserved for future use and, for enabled channels, will currently always be zero.
0417AA             0119*   vdu_channel_status:
0417AA 32 BC 17 04 0120*       ld (@channel),a
0417AE 21 B9 17 04 0121*       ld hl,@cmd
0417B2 01 05 00 00 0122*       ld bc,@end-@cmd
0417B6 5B DF       0123*       rst.lil $18
0417B8 C9          0124*       ret
0417B9 17 00 85    0125*   @cmd:       db 23, 0, 0x85
0417BC 00          0126*   @channel:   db 0x00
0417BD 01          0127*               db 0x01 ; get channel status command
0417BE             0128*   @end:
0417BE             0129*   
0417BE             0130*   ; VDU 23, 0, &85, channel, 2, volume
0417BE             0131*   ; inputs: c = channel, b = volume
0417BE             0132*   ; Sets the volume of the specified channel. The volume is a value from 0 to 127, where 0 is silent and 127 is full volume. Values over 127 will be treated as 127 (with one exception described later).
0417BE             0133*   
0417BE             0134*   ; Specifying a channel of -1 (or 255) will set the global sound system volume level. (Requires Console8 VDP 2.5.0 or later.)
0417BE             0135*   
0417BE             0136*   ; Using this command provides more direct control over a channel than the play note command. It can be used to adjust the volume of a channel that is already playing a note.
0417BE             0137*   vdu_channel_volume:
0417BE 79          0138*       ld a,c
0417BF 32 D6 17 04 0139*       ld (@channel),a
0417C3 78          0140*       ld a,b
0417C4 32 D8 17 04 0141*       ld (@volume),a
0417C8 21 D3 17 04 0142*       ld hl,@cmd
0417CC 01 06 00 00 0143*       ld bc,@end-@cmd
0417D0 5B DF       0144*       rst.lil $18
0417D2 C9          0145*       ret
0417D3 17 00 85    0146*   @cmd:       db 23, 0, 0x85
0417D6 00          0147*   @channel:   db 0x00
0417D7 02          0148*               db 0x02 ; set volume command
0417D8 00          0149*   @volume:    db 0x00
0417D9             0150*   @end:
0417D9             0151*   
0417D9             0152*   ; VDU 23, 0, &85, channel, 3, frequency;
0417D9             0153*   
0417D9             0154*   ; Sets the frequency of the specified channel. The frequency is a 16-bit value specifying in Hz the frequency of the note to be played.
0417D9             0155*   
0417D9             0156*   ; Using this command provides more direct control over a channel than the play note command. It can be used to adjust the frequency of a channel that is already playing a note.
0417D9             0157*   
0417D9             0158*   ; Returns 1 on success, 0 for failure.
0417D9             0159*   vdu_channel_frequency:
0417D9 79          0160*       ld a,c
0417DA 32 F1 17 04 0161*       ld (@channel),a
0417DE ED 53 F3 17 0162*       ld (@frequency),de
       04          
0417E3 21 EE 17 04 0163*       ld hl,@cmd
0417E7 01 07 00 00 0164*       ld bc,@end-@cmd
0417EB 5B DF       0165*       rst.lil $18
0417ED C9          0166*       ret
0417EE 17 00 85    0167*   @cmd:       db 23, 0, 0x85
0417F1 00          0168*   @channel:   db 0x00
0417F2 03          0169*               db 0x03 ; set frequency command
0417F3 00 00       0170*   @frequency: dw 0x0000
0417F5 00          0171*   @end:       db 0x00 ; padding
0417F6             0172*   
0417F6             0173*   
0417F6             0174*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
0417F6             0175*   ; inputs: c = channel, b = waveformOrSample, [hl = bufferId]
0417F6             0176*   ; Sets the waveform type for a channel to use. The waveformOrSample value is a single byte treated as a signed value.
0417F6             0177*   
0417F6             0178*   ; Using a negative value for the waveform indicates that a sample should be used instead. For more information see the documentation for the sample command.
0417F6             0179*   
0417F6             0180*   ; By default a channel is set to use waveform 0 (square wave).
0417F6             0181*   
0417F6             0182*   ; Valid waveform values are as follows:
0417F6             0183*   ; Value 	Waveform
0417F6             0184*   ; 0 	Square wave
0417F6             0185*   ; 1 	Triangle wave
0417F6             0186*   ; 2 	Sawtooth wave
0417F6             0187*   ; 3 	Sine wave
0417F6             0188*   ; 4 	Noise (simple white noise with no frequency support)
0417F6             0189*   ; 5 	VIC Noise (emulates a VIC6561; supports frequency)
0417F6             0190*   ; 8 	Sample (specifying a 16-bit buffer ID for sample data)
0417F6             0191*   
0417F6             0192*   vdu_channel_waveform:
0417F6 79          0193*       ld a,c
0417F7 32 1C 18 04 0194*       ld (@channel),a
0417FB 78          0195*       ld a,b
0417FC 32 1E 18 04 0196*       ld (@waveform),a
041800 FE 08       0197*       cp 8 ; check if the waveform is a sample
041802 28 06       0198*       jr z, @sample
041804 01 06 00 00 0199*       ld bc,@bufferId-@cmd
041808 18 08       0200*       jr @sendToVdu
04180A             0201*   @sample:
04180A 22 1F 18 04 0202*       ld (@bufferId),hl
04180E 01 08 00 00 0203*       ld bc,@end-@cmd
041812             0204*   @sendToVdu:
041812 21 19 18 04 0205*       ld hl,@cmd
041816 5B DF       0206*       rst.lil $18
041818 C9          0207*       ret
041819 17 00 85    0208*   @cmd:       db 23, 0, 0x85
04181C 00          0209*   @channel:   db 0x00
04181D 04          0210*               db 0x04 ; set waveform command
04181E 00          0211*   @waveform:  db 0x00
04181F 00 00       0212*   @bufferId:  dw 0x0000
041821 00          0213*   @end:       db 0x00 ; padding
041822             0214*   
041822             0215*   ; VDU 23, 0, &85, channel (ignored), 5, 2, bufferId; format, [sampleRate;]
041822             0216*   ; inputs: hl = bufferId; a = format, de = sample rate in Hz
041822             0217*   ; The format is a single byte giving the format of the sample data. The following formats are supported:
041822             0218*   ; Value	Description
041822             0219*   ; 0	8-bit signed
041822             0220*   ; 1	8-bit unsigned
041822             0221*   ; The format value can also have modifier bits set to modify the behaviour of the sample. The following modifier bits are supported:
041822             0222*   ; Value	Description
041822             0223*   ; 8	sample rate is sent in the next 16-bits
041822             0224*   ; 16	sample is tuneable
041822             0225*   ; The default sample rate for samples on the VDP is 16kHz (actually 16.384kHz to be precise).
041822             0226*   vdu_buffer_to_sound:
041822 22 42 18 04 0227*       ld (@bufferId),hl
041826 C6 08       0228*       add a,8 ; modify format byte to indicate sample rate argument is given
041828 32 44 18 04 0229*       ld (@format),a
04182C ED 53 45 18 0230*       ld (@sampleRate),de
       04          
041831 21 3C 18 04 0231*       ld hl,@cmd
041835 01 0B 00 00 0232*       ld bc,@end-@cmd
041839 5B DF       0233*       rst.lil $18
04183B C9          0234*       ret
04183C 17 00 85    0235*   @cmd:       db 23, 0, 0x85
04183F 00          0236*   @channel:   db 0x00 ; ignored
041840 05          0237*               db 0x05 ; buffer to sound command
041841 02          0238*               db 0x02 ; command 2 create sample
041842 00 00       0239*   @bufferId:  dw 0x0000
041844 00          0240*   @format:    db 0x00
041845 00 00       0241*   @sampleRate: dw 0x0000
041847 00          0242*   @end:       db 0x00 ; padding
041848             0243*   
041848             0244*   ; Command 13: Set sample rate
041848             0245*   ; VDU 23, 0, &85, channel, 13, sampleRate;
041848             0246*   ; inputs: c = channel, hl = sampleRate (Hz)
041848             0247*   vdu_set_sample_rate:
041848 79          0248*       ld a,c
041849 32 5F 18 04 0249*       ld (@channel),a
04184D 22 61 18 04 0250*       ld (@sampleRate),hl
041851 21 5C 18 04 0251*       ld hl,@cmd
041855 01 07 00 00 0252*       ld bc,@end-@cmd
041859 5B DF       0253*       rst.lil $18
04185B C9          0254*       ret
04185C 17 00 85    0255*   @cmd:       db 23, 0, 0x85
04185F 00          0256*   @channel:   db 0x00
041860 0D          0257*               db 13 ; set sample rate command
041861 00 00       0258*   @sampleRate: dw 0x0000
041863 00          0259*   @end:       db 0x00 ; padding
041864             0260*   
041864             0261*   ; load a sound file to a buffer
041864             0262*   ; inputs: hl = bufferId ; de = sampleRate in Hz ; iy = pointer to filename
041864             0263*   vdu_load_sfx:
041864             0264*   ; back up input parameters
041864 E5          0265*       push hl ; bufferId
041865 D5          0266*       push de ; sample rate
041866             0267*   ; load the sound
041866 CD A4 13 04 0268*       call vdu_load_buffer_from_file
04186A             0269*   ; now make the buffer a sound sample
04186A D1          0270*       pop de ; sample rate
04186B E1          0271*       pop hl ; bufferId
04186C AF          0272*       xor a ; zero is the magic number for mono 8-bit signed PCM
04186D CD 22 18 04 0273*       call vdu_buffer_to_sound
041871 C9          0274*       ret
041872             0275*   
041872             0276*   
041872 00          0277*   last_channel: db 0
041873             0278*   max_channels: equ 1
041873             0279*   
041873             0280*   ; play a sound effect from an already loaded buffer
041873             0281*   ; inputs: hl = bufferId ; bc = duration in milliseconds
041873             0282*   vdu_play_sfx:
041873 22 AB 18 04 0283*       ld (@bufferId),hl
041877 ED 43 B5 18 0284*       ld (@duration),bc
       04          
04187C 3E 17       0285*       ld a,23
04187E 32 AD 18 04 0286*       ld (@bufferId+2),a
041882 3A 72 18 04 0287*       ld a,(last_channel)
041886 3C          0288*       inc a
041887             0289*       ; and 31 ; modulo 32
041887 FE 01       0290*       cp max_channels
041889 C2 8E 18 04 0291*       jp nz,@load_channel
04188D AF          0292*       xor a
04188E             0293*   @load_channel:
04188E 32 72 18 04 0294*       ld (last_channel),a
041892 32 A8 18 04 0295*       ld (@channel0),a
041896 32 B0 18 04 0296*       ld (@channel1),a
04189A 21 A5 18 04 0297*       ld hl, @sample
04189E 01 12 00 00 0298*       ld bc, @sample_end - @sample
0418A2 5B DF       0299*       rst.lil $18
0418A4 C9          0300*       ret
0418A5             0301*   @sample:
0418A5             0302*   ; Command 4: Set waveform
0418A5             0303*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
0418A5 17 00 85    0304*       .db 23,0,$85                        ; do sound
0418A8             0305*   @channel0:
0418A8 00 04 08    0306*       .db 0,4,8 ; channel, command, waveform
0418AB             0307*   @bufferId:
0418AB 00 00       0308*       .dw 0x0000
0418AD             0309*   ; Command 0: Play note
0418AD             0310*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
0418AD 17 00 85    0311*       .db 23,0,$85                        ; do sound
0418B0             0312*   @channel1:
0418B0 00 00 7F    0313*       .db 0,0,127                ; channel, volume
0418B3 00 00       0314*       .dw 0
0418B5             0315*   @duration:                              ; freq (tuneable samples only)
0418B5 00 00       0316*       .dw 0x0000                        ; duration
0418B7             0317*   @sample_end:
0418B7 00          0318*       .db 0x00 ; padding
0418B8             0319*   
0418B8             0320*   ; inputs: c = channel, b = volume, de = sample rate; hl = bufferId;
0418B8             0321*   vdu_play_sample:
0418B8             0322*       ; populate input parameters
0418B8 79          0323*       ld a,c
0418B9 32 EB 18 04 0324*       ld (@channel0),a
0418BD 32 F3 18 04 0325*       ld (@channel1),a
0418C1 32 FA 18 04 0326*       ld (@channel2),a
0418C5 78          0327*       ld a,b
0418C6 32 FC 18 04 0328*       ld (@volume),a
0418CA ED 53 F5 18 0329*       ld (@sampleRate),de
       04          
0418CF 22 EE 18 04 0330*       ld (@bufferId),hl
0418D3 3E 17       0331*       ld a,23
0418D5 32 F0 18 04 0332*       ld (@cmd1),a
0418D9 32 F7 18 04 0333*       ld (@cmd2),a
0418DD             0334*       ; prep the vdu command string
0418DD 21 E8 18 04 0335*       ld hl, @cmd0
0418E1 01 19 00 00 0336*       ld bc, @end - @cmd0
0418E5 5B DF       0337*       rst.lil $18
0418E7 C9          0338*       ret
0418E8             0339*   ; set waveform command
0418E8 17 00 85    0340*   @cmd0:       db 23, 0, 0x85
0418EB 00          0341*   @channel0:   db 0x00
0418EC 04          0342*                db 0x04 ; set waveform command
0418ED 08          0343*   @waveform:   db 0x08 ; sample
0418EE 00 00       0344*   @bufferId:   dw 0x0000
0418F0             0345*   ; set sample rate command
0418F0 17 00 85    0346*   @cmd1:       db 23, 0, 0x85
0418F3 00          0347*   @channel1:   db 0x00
0418F4 0D          0348*               db 13 ; set sample rate command
0418F5 00 00       0349*   @sampleRate: dw 0x0000
0418F7             0350*   ; play note command
0418F7 17 00 85    0351*   @cmd2:       db 23, 0, 0x85
0418FA 00          0352*   @channel2:   db 0x00
0418FB 00          0353*                db 0x00 ; play note command
0418FC 00          0354*   @volume:     db 0x00
0418FD 00 00       0355*   @frequency:  dw 0x00 ; no effect unless buffer has been set to tuneable sample
0418FF 00 00       0356*   @duration:   dw 0x0000 ; milliseconds: set to -1 to loop indefinitely, 0 to play full duration once
041901 00          0357*   @end:        db 0x00 ; padding
041902             0043    
041902             0044    ; APPLICATION INCLUDES
041902             0045        include "debug.inc"
041902             0001*   printHexA:
041902 F5          0002*       push af
041903 C5          0003*       push bc
041904 CD AE 00 04 0004*       call printHex8
041908 3E 20       0005*       ld a,' '
04190A 5B D7       0006*       rst.lil 10h
04190C C1          0007*       pop bc
04190D F1          0008*       pop af
04190E C9          0009*       ret
04190F             0010*   
04190F             0011*   printHexHL:
04190F F5          0012*       push af
041910 C5          0013*       push bc
041911 CD A8 00 04 0014*       call printHex16
041915 3E 20       0015*       ld a,' '
041917 5B D7       0016*       rst.lil 10h
041919 C1          0017*       pop bc
04191A F1          0018*       pop af
04191B C9          0019*       ret
04191C             0020*   
04191C             0021*   printHexUHL:
04191C F5          0022*       push af
04191D C5          0023*       push bc
04191E CD A0 00 04 0024*       call printHex24
041922 3E 20       0025*       ld a,' '
041924 5B D7       0026*       rst.lil 10h
041926 C1          0027*       pop bc
041927 F1          0028*       pop af
041928 C9          0029*       ret
041929             0030*   
041929             0031*   printHexAUHL:
041929 F5          0032*       push af
04192A C5          0033*       push bc
04192B CD AE 00 04 0034*       call printHex8
04192F 3E 2E       0035*       ld a,'.'
041931 5B D7       0036*       rst.lil 10h
041933 CD A0 00 04 0037*       call printHex24
041937 3E 20       0038*       ld a,' '
041939 5B D7       0039*       rst.lil 10h
04193B C1          0040*       pop bc
04193C F1          0041*       pop af
04193D C9          0042*       ret
04193E             0043*   
04193E             0044*   printHexABHL:
04193E             0045*   ; preserve registers
04193E C5          0046*       push bc ; b will be ok c will not
04193F F5          0047*       push af ; will get totally destroyed
041940             0048*   ; print a
041940 CD AE 00 04 0049*       call printHex8
041944             0050*   ; print b
041944 78          0051*       ld a,b
041945 CD AE 00 04 0052*       call printHex8
041949             0053*   ; print hl
041949 CD A8 00 04 0054*       call printHex16
04194D             0055*   ; restore registers
04194D F1          0056*       pop af
04194E C1          0057*       pop bc
04194F C9          0058*       ret
041950             0059*   
041950             0060*   printHexBHL:
041950             0061*   ; preserve registers
041950 C5          0062*       push bc ; b will be ok c will not
041951 F5          0063*       push af ; will get totally destroyed
041952             0064*   ; print b
041952 78          0065*       ld a,b
041953 CD AE 00 04 0066*       call printHex8
041957             0067*   ; print hl
041957 CD A8 00 04 0068*       call printHex16
04195B             0069*   ; restore registers
04195B F1          0070*       pop af
04195C C1          0071*       pop bc
04195D C9          0072*       ret
04195E             0073*   
04195E             0074*   printHexCDE:
04195E             0075*   ; preserve registers
04195E C5          0076*       push bc ; b will be ok c will not
04195F F5          0077*       push af ; will get totally destroyed
041960             0078*   ; print c
041960 79          0079*       ld a,c
041961 CD AE 00 04 0080*       call printHex8
041965             0081*   ; print de
041965 EB          0082*       ex de,hl
041966 CD A8 00 04 0083*       call printHex16
04196A EB          0084*       ex de,hl
04196B             0085*   ; restore registers
04196B F1          0086*       pop af
04196C C1          0087*       pop bc
04196D C9          0088*       ret
04196E             0089*   
04196E             0090*   printHexUIX:
04196E             0091*   ; store everything in scratch
04196E 22 35 03 04 0092*       ld (uhl),hl
041972 ED 43 38 03 0093*       ld (ubc),bc
       04          
041977 ED 53 3B 03 0094*       ld (ude),de
       04          
04197C DD 22 3E 03 0095*       ld (uix),ix
       04          
041981 FD 22 41 03 0096*       ld (uiy),iy
       04          
041986 F5          0097*       push af ; fml
041987             0098*   
041987 21 CC 02 04 0099*       ld hl,str_ixu
04198B CD 67 00 04 0100*       call printString
04198F 2A 3E 03 04 0101*       ld hl,(uix)
041993 CD A0 00 04 0102*       call printHex24
041997 CD 7C 00 04 0103*       call printNewLine
04199B             0104*   
04199B             0105*   ; restore everything
04199B 2A 35 03 04 0106*       ld hl, (uhl)
04199F ED 4B 38 03 0107*       ld bc, (ubc)
       04          
0419A4 ED 5B 3B 03 0108*       ld de, (ude)
       04          
0419A9 DD 2A 3E 03 0109*       ld ix, (uix)
       04          
0419AE FD 2A 41 03 0110*       ld iy, (uiy)
       04          
0419B3 F1          0111*       pop af
0419B4             0112*   ; all done
0419B4 C9          0113*       ret
0419B5             0114*   
0419B5             0115*   
0419B5             0116*   ; print registers to screen in hexidecimal format
0419B5             0117*   ; inputs: none
0419B5             0118*   ; outputs: values of every register printed to screen
0419B5             0119*   ;    values of each register in global scratch memory
0419B5             0120*   ; destroys: nothing
0419B5             0121*   stepRegistersHex:
0419B5             0122*   ; store everything in scratch
0419B5 22 35 03 04 0123*       ld (uhl),hl
0419B9 ED 43 38 03 0124*       ld (ubc),bc
       04          
0419BE ED 53 3B 03 0125*       ld (ude),de
       04          
0419C3 DD 22 3E 03 0126*       ld (uix),ix
       04          
0419C8 FD 22 41 03 0127*       ld (uiy),iy
       04          
0419CD F5          0128*       push af ; fml
0419CE E1          0129*       pop hl ; thanks, zilog
0419CF 22 32 03 04 0130*       ld (uaf),hl
0419D3 F5          0131*       push af ; dammit
0419D4             0132*   
0419D4             0133*   ; home the cursor
0419D4             0134*       ; call vdu_home_cursor
0419D4             0135*   
0419D4             0136*   ; print each register
0419D4 21 B8 02 04 0137*       ld hl,str_afu
0419D8 CD 67 00 04 0138*       call printString
0419DC 2A 32 03 04 0139*       ld hl,(uaf)
0419E0 CD A0 00 04 0140*       call printHex24
0419E4 CD 7C 00 04 0141*       call printNewLine
0419E8             0142*   
0419E8 21 BD 02 04 0143*       ld hl,str_hlu
0419EC CD 67 00 04 0144*       call printString
0419F0 2A 35 03 04 0145*       ld hl,(uhl)
0419F4 CD A0 00 04 0146*       call printHex24
0419F8 CD 7C 00 04 0147*       call printNewLine
0419FC             0148*   
0419FC 21 C2 02 04 0149*       ld hl,str_bcu
041A00 CD 67 00 04 0150*       call printString
041A04 2A 38 03 04 0151*       ld hl,(ubc)
041A08 CD A0 00 04 0152*       call printHex24
041A0C CD 7C 00 04 0153*       call printNewLine
041A10             0154*   
041A10 21 C7 02 04 0155*       ld hl,str_deu
041A14 CD 67 00 04 0156*       call printString
041A18 2A 3B 03 04 0157*       ld hl,(ude)
041A1C CD A0 00 04 0158*       call printHex24
041A20 CD 7C 00 04 0159*       call printNewLine
041A24             0160*   
041A24 21 CC 02 04 0161*       ld hl,str_ixu
041A28 CD 67 00 04 0162*       call printString
041A2C 2A 3E 03 04 0163*       ld hl,(uix)
041A30 CD A0 00 04 0164*       call printHex24
041A34 CD 7C 00 04 0165*       call printNewLine
041A38             0166*   
041A38 21 D1 02 04 0167*       ld hl,str_iyu
041A3C CD 67 00 04 0168*       call printString
041A40 2A 41 03 04 0169*       ld hl,(uiy)
041A44 CD A0 00 04 0170*       call printHex24
041A48 CD 7C 00 04 0171*       call printNewLine
041A4C             0172*   
041A4C             0173*       ; call vsync
041A4C             0174*   
041A4C CD 7C 00 04 0175*       call printNewLine
041A50             0176*   
041A50             0177*   ; check for right shift key and quit if pressed
041A50             0178*       MOSCALL mos_getkbmap
                       M1 Args: function=mos_getkbmap 
041A50 3E 1E       0001*M1 			LD	A, function
041A52 5B CF       0002*M1 			RST.LIL	08h
041A54             0179*   @stayhere:
041A54             0180*   ; 7 RightShift
041A54 DD CB 00 76 0181*       bit 6,(ix+0)
041A58 20 02       0182*       jr nz,@RightShift
041A5A 18 F8       0183*       jr @stayhere
041A5C             0184*   @RightShift:
041A5C DD CB 0E 86 0185*       res 0,(ix+14) ; debounce the key (hopefully)
041A60 3E 80       0186*       ld a,%10000000
041A62             0187*       ; call multiPurposeDelay
041A62             0188*   
041A62             0189*   ; restore everything
041A62 2A 35 03 04 0190*       ld hl, (uhl)
041A66 ED 4B 38 03 0191*       ld bc, (ubc)
       04          
041A6B ED 5B 3B 03 0192*       ld de, (ude)
       04          
041A70 DD 2A 3E 03 0193*       ld ix, (uix)
       04          
041A75 FD 2A 41 03 0194*       ld iy, (uiy)
       04          
041A7A F1          0195*       pop af
041A7B             0196*   ; all done
041A7B C9          0197*       ret
041A7C             0198*   
041A7C             0199*   ; print registers to screen in hexidecimal format
041A7C             0200*   ; inputs: none
041A7C             0201*   ; outputs: values of every register printed to screen
041A7C             0202*   ;    values of each register in global scratch memory
041A7C             0203*   ; destroys: nothing
041A7C             0204*   dumpRegistersHex:
041A7C             0205*   ; store everything in scratch
041A7C 22 35 03 04 0206*       ld (uhl),hl
041A80 ED 43 38 03 0207*       ld (ubc),bc
       04          
041A85 ED 53 3B 03 0208*       ld (ude),de
       04          
041A8A DD 22 3E 03 0209*       ld (uix),ix
       04          
041A8F FD 22 41 03 0210*       ld (uiy),iy
       04          
041A94 F5          0211*       push af ; fml
041A95 E1          0212*       pop hl ; thanks, zilog
041A96 22 32 03 04 0213*       ld (uaf),hl
041A9A F5          0214*       push af ; dammit
041A9B             0215*   
041A9B             0216*   ; home the cursor
041A9B             0217*       ; call vdu_home_cursor
041A9B             0218*       ; call printNewLine
041A9B             0219*   
041A9B             0220*   ; print each register
041A9B 21 B8 02 04 0221*       ld hl,str_afu
041A9F CD 67 00 04 0222*       call printString
041AA3 2A 32 03 04 0223*       ld hl,(uaf)
041AA7 CD A0 00 04 0224*       call printHex24
041AAB CD 7C 00 04 0225*       call printNewLine
041AAF             0226*   
041AAF 21 BD 02 04 0227*       ld hl,str_hlu
041AB3 CD 67 00 04 0228*       call printString
041AB7 2A 35 03 04 0229*       ld hl,(uhl)
041ABB CD A0 00 04 0230*       call printHex24
041ABF CD 7C 00 04 0231*       call printNewLine
041AC3             0232*   
041AC3 21 C2 02 04 0233*       ld hl,str_bcu
041AC7 CD 67 00 04 0234*       call printString
041ACB 2A 38 03 04 0235*       ld hl,(ubc)
041ACF CD A0 00 04 0236*       call printHex24
041AD3 CD 7C 00 04 0237*       call printNewLine
041AD7             0238*   
041AD7 21 C7 02 04 0239*       ld hl,str_deu
041ADB CD 67 00 04 0240*       call printString
041ADF 2A 3B 03 04 0241*       ld hl,(ude)
041AE3 CD A0 00 04 0242*       call printHex24
041AE7 CD 7C 00 04 0243*       call printNewLine
041AEB             0244*   
041AEB 21 CC 02 04 0245*       ld hl,str_ixu
041AEF CD 67 00 04 0246*       call printString
041AF3 2A 3E 03 04 0247*       ld hl,(uix)
041AF7 CD A0 00 04 0248*       call printHex24
041AFB CD 7C 00 04 0249*       call printNewLine
041AFF             0250*   
041AFF 21 D1 02 04 0251*       ld hl,str_iyu
041B03 CD 67 00 04 0252*       call printString
041B07 2A 41 03 04 0253*       ld hl,(uiy)
041B0B CD A0 00 04 0254*       call printHex24
041B0F             0255*   
041B0F CD 7C 00 04 0256*       call printNewLine
041B13 CD 7C 00 04 0257*       call printNewLine
041B17             0258*   ; restore everything
041B17 2A 35 03 04 0259*       ld hl, (uhl)
041B1B ED 4B 38 03 0260*       ld bc, (ubc)
       04          
041B20 ED 5B 3B 03 0261*       ld de, (ude)
       04          
041B25 DD 2A 3E 03 0262*       ld ix, (uix)
       04          
041B2A FD 2A 41 03 0263*       ld iy, (uiy)
       04          
041B2F F1          0264*       pop af
041B30             0265*   ; all done
041B30 C9          0266*       ret
041B31             0267*   
041B31             0268*   dumpRegistersHexPrime:
041B31 D9          0269*       exx
041B32 08          0270*       ex af,af'
041B33 CD 7C 1A 04 0271*       call dumpRegistersHex
041B37 08          0272*       ex af,af'
041B38 D9          0273*       exx
041B39 C9          0274*       ret
041B3A             0275*   
041B3A             0276*   ; additionally dump prime registers
041B3A             0277*   ; inputs: none
041B3A             0278*   ; outputs: values of every register printed to screen
041B3A             0279*   ; destroys: nothing
041B3A             0280*   dumpRegistersHexAll:
041B3A CD 7C 1A 04 0281*       call dumpRegistersHex
041B3E 08          0282*       ex af,af'
041B3F D9          0283*       exx
041B40 CD 7C 1A 04 0284*       call dumpRegistersHex
041B44 08          0285*       ex af,af'
041B45 D9          0286*       exx
041B46 C9          0287*       ret
041B47             0288*   
041B47             0289*   ; print hlu to screen in hexidecimal format
041B47             0290*   ; inputs: none
041B47             0291*   ; destroys: nothing
041B47             0292*   print_hex_hl:
041B47 F5          0293*       push af
041B48 E5          0294*       push hl
041B49 21 BD 02 04 0295*       ld hl,str_hlu
041B4D CD 67 00 04 0296*       call printString
041B51 E1          0297*       pop hl
041B52 E5          0298*       push hl
041B53 CD A0 00 04 0299*       call printHex24
041B57 3E 20       0300*       ld a,' '
041B59 5B D7       0301*       rst.lil 10h
041B5B E1          0302*       pop hl
041B5C F1          0303*       pop af
041B5D C9          0304*       ret
041B5E             0305*   
041B5E             0306*   ; print bcu to screen in hexidecimal format
041B5E             0307*   ; inputs: none
041B5E             0308*   ; destroys: nothing
041B5E             0309*   print_hex_bc:
041B5E F5          0310*       push af
041B5F E5          0311*       push hl
041B60 C5          0312*       push bc
041B61 21 C2 02 04 0313*       ld hl,str_bcu
041B65 CD 67 00 04 0314*       call printString
041B69 E1          0315*       pop hl
041B6A E5          0316*       push hl
041B6B CD A0 00 04 0317*       call printHex24
041B6F 3E 20       0318*       ld a,' '
041B71 5B D7       0319*       rst.lil 10h
041B73 C1          0320*       pop bc
041B74 E1          0321*       pop hl
041B75 F1          0322*       pop af
041B76 C9          0323*       ret
041B77             0324*   
041B77             0325*   ; print deu to screen in hexidecimal format
041B77             0326*   ; inputs: none
041B77             0327*   ; destroys: nothing
041B77             0328*   print_hex_de:
041B77 F5          0329*       push af
041B78 E5          0330*       push hl
041B79 D5          0331*       push de
041B7A 21 C7 02 04 0332*       ld hl,str_deu
041B7E CD 67 00 04 0333*       call printString
041B82 E1          0334*       pop hl
041B83 E5          0335*       push hl
041B84 CD A0 00 04 0336*       call printHex24
041B88 3E 20       0337*       ld a,' '
041B8A 5B D7       0338*       rst.lil 10h
041B8C D1          0339*       pop de
041B8D E1          0340*       pop hl
041B8E F1          0341*       pop af
041B8F C9          0342*       ret
041B90             0343*   
041B90             0344*   
041B90             0345*   ; inputs: whatever is in the flags register
041B90             0346*   ; outputs: binary representation of flags
041B90             0347*   ;          with a header so we know which is what
041B90             0348*   ; destroys: nothing
041B90             0349*   ; preserves: everything
041B90             0350*   dumpFlags:
041B90             0351*   ; first we curse zilog for not giving direct access to flags
041B90 F5          0352*       push af ; this is so we can send it back unharmed
041B91 F5          0353*       push af ; this is so we can pop it to hl
041B92             0354*   ; store everything in scratch
041B92 22 35 03 04 0355*       ld (uhl),hl
041B96 ED 43 38 03 0356*       ld (ubc),bc
       04          
041B9B ED 53 3B 03 0357*       ld (ude),de
       04          
041BA0 DD 22 3E 03 0358*       ld (uix),ix
       04          
041BA5 FD 22 41 03 0359*       ld (uiy),iy
       04          
041BAA             0360*   ; next we print the header
041BAA 21 D6 1B 04 0361*       ld hl,@header
041BAE CD 67 00 04 0362*       call printString
041BB2 E1          0363*       pop hl ; flags are now in l
041BB3 7D          0364*       ld a,l ; flags are now in a
041BB4 CD 6E 02 04 0365*       call printBin8
041BB8 CD 7C 00 04 0366*       call printNewLine
041BBC             0367*   ; restore everything
041BBC 2A 35 03 04 0368*       ld hl, (uhl)
041BC0 ED 4B 38 03 0369*       ld bc, (ubc)
       04          
041BC5 ED 5B 3B 03 0370*       ld de, (ude)
       04          
041BCA DD 2A 3E 03 0371*       ld ix, (uix)
       04          
041BCF FD 2A 41 03 0372*       ld iy, (uiy)
       04          
041BD4 F1          0373*       pop af ; send her home the way she came
041BD5 C9          0374*       ret
041BD6             0375*   ; Bit 7 (S): Sign flag
041BD6             0376*   ; Bit 6 (Z): Zero flag
041BD6             0377*   ; Bit 5 (5): Reserved (copy of bit 5 of the result)
041BD6             0378*   ; Bit 4 (H): Half Carry flag
041BD6             0379*   ; Bit 3 (3): Reserved (copy of bit 3 of the result)
041BD6             0380*   ; Bit 2 (PV): Parity/Overflow flag
041BD6             0381*   ; Bit 1 (N): Subtract flag
041BD6             0382*   ; Bit 0 (C): Carry flag
041BD6 53 5A 78 48 0383*   @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
041BE1             0384*   
041BE1             0385*   
041BE1             0386*   ; print bytes from an address to the screen in hexidecimal format
041BE1             0387*   ; inputs: hl = address of first byte to print, a = number of bytes to print
041BE1             0388*   ; outputs: values of each byte printed to screen separated by spaces
041BE1             0389*   ; destroys: nothing
041BE1             0390*   dumpMemoryHex:
041BE1             0391*   ; save registers to the stack
041BE1 C5          0392*       push bc
041BE2 E5          0393*       push hl
041BE3 F5          0394*       push af
041BE4             0395*   
041BE4             0396*   ; print the address and separator
041BE4 CD A0 00 04 0397*       call printHex24
041BE8 3E 3A       0398*       ld a,':'
041BEA 5B D7       0399*       rst.lil 10h
041BEC 3E 20       0400*       ld a,' '
041BEE 5B D7       0401*       rst.lil 10h
041BF0             0402*   
041BF0             0403*   ; set b to be our loop counter
041BF0 F1          0404*       pop af
041BF1 47          0405*       ld b,a
041BF2 E1          0406*       pop hl
041BF3 E5          0407*       push hl
041BF4 F5          0408*       push af
041BF5             0409*   @loop:
041BF5             0410*   ; print the byte
041BF5 7E          0411*       ld a,(hl)
041BF6 CD AE 00 04 0412*       call printHex8
041BFA             0413*   ; print a space
041BFA 3E 20       0414*       ld a,' '
041BFC 5B D7       0415*       rst.lil 10h
041BFE 23          0416*       inc hl
041BFF 10 F4       0417*       djnz @loop
041C01 CD 7C 00 04 0418*       call printNewLine
041C05             0419*   
041C05             0420*   ; restore everything
041C05 F1          0421*       pop af
041C06 E1          0422*       pop hl
041C07 C1          0423*       pop bc
041C08             0424*   
041C08             0425*   ; all done
041C08 C9          0426*       ret
041C09             0427*   
041C09             0428*   
041C09             0429*   ; print bytes from an address to the screen in binary format
041C09             0430*   ; inputs: hl = address of first byte to print, a = number of bytes to print
041C09             0431*   ; outputs: values of each byte printed to screen separated by spaces
041C09             0432*   ; destroys: nothing
041C09             0433*   dumpMemoryBin:
041C09             0434*   ; save all registers to the stack
041C09 F5          0435*       push af
041C0A C5          0436*       push bc
041C0B D5          0437*       push de
041C0C E5          0438*       push hl
041C0D DD E5       0439*       push ix
041C0F FD E5       0440*       push iy
041C11             0441*   
041C11             0442*   ; set b to be our loop counter
041C11 47          0443*       ld b,a
041C12             0444*   @loop:
041C12             0445*   ; print the byte
041C12 7E          0446*       ld a,(hl)
041C13 E5          0447*       push hl
041C14 C5          0448*       push bc
041C15 CD 6E 02 04 0449*       call printBin8
041C19 C1          0450*       pop bc
041C1A             0451*   ; print a space
041C1A 3E 20       0452*       ld a,' '
041C1C 5B D7       0453*       rst.lil 10h
041C1E E1          0454*       pop hl
041C1F 23          0455*       inc hl
041C20 10 F0       0456*       djnz @loop
041C22 CD 7C 00 04 0457*       call printNewLine
041C26             0458*   
041C26             0459*   ; restore everything
041C26 FD E1       0460*       pop iy
041C28 DD E1       0461*       pop ix
041C2A E1          0462*       pop hl
041C2B D1          0463*       pop de
041C2C C1          0464*       pop bc
041C2D F1          0465*       pop af
041C2E             0466*   ; all done
041C2E C9          0467*       ret
041C2F             0468*   
041C2F             0469*   ; print bytes from an address to the screen in binary format
041C2F             0470*   ; with the bits of each byte in reverse order (lsb first)
041C2F             0471*   ; inputs: hl = address of first byte to print, a = number of bytes to print
041C2F             0472*   ; outputs: values of each byte printed to screen separated by spaces
041C2F             0473*   ; destroys: nothing
041C2F             0474*   dumpMemoryBinRev:
041C2F             0475*   ; save all registers to the stack
041C2F F5          0476*       push af
041C30 C5          0477*       push bc
041C31 D5          0478*       push de
041C32 E5          0479*       push hl
041C33 DD E5       0480*       push ix
041C35 FD E5       0481*       push iy
041C37             0482*   
041C37             0483*   ; set b to be our loop counter
041C37 47          0484*       ld b,a
041C38             0485*   @loop:
041C38             0486*   ; print the byte
041C38 7E          0487*       ld a,(hl)
041C39 E5          0488*       push hl
041C3A C5          0489*       push bc
041C3B CD 93 02 04 0490*       call printBin8Rev
041C3F C1          0491*       pop bc
041C40             0492*   ; print a space
041C40 3E 20       0493*       ld a,' '
041C42 5B D7       0494*       rst.lil 10h
041C44 E1          0495*       pop hl
041C45 23          0496*       inc hl
041C46 10 F0       0497*       djnz @loop
041C48 CD 7C 00 04 0498*       call printNewLine
041C4C             0499*   
041C4C             0500*   ; restore everything
041C4C FD E1       0501*       pop iy
041C4E DD E1       0502*       pop ix
041C50 E1          0503*       pop hl
041C51 D1          0504*       pop de
041C52 C1          0505*       pop bc
041C53 F1          0506*       pop af
041C54             0507*   ; all done
041C54 C9          0508*       ret
041C55             0509*   
041C55             0510*   DEBUG_PRINT:
041C55             0511*       PUSH_ALL
                       M1 Args: none
041C55 08          0001*M1     ex af,af'
041C56 D9          0002*M1     exx
041C57 F5          0003*M1     push af
041C58 E5          0004*M1     push hl
041C59 C5          0005*M1     push bc
041C5A D5          0006*M1     push de
041C5B             0007*M1 
041C5B 08          0008*M1     ex af,af'
041C5C D9          0009*M1     exx
041C5D F5          0010*M1     push af
041C5E E5          0011*M1     push hl
041C5F C5          0012*M1     push bc
041C60 D5          0013*M1     push de
041C61 DD E5       0014*M1     push ix
041C63 FD E5       0015*M1     push iy
041C65             0512*       ; ld c,0 ; X
041C65             0513*       ; ld b,0 ; Y
041C65             0514*       ; call vdu_move_cursor
041C65 CD 7C 00 04 0515*       call printNewLine
041C69             0516*       POP_ALL
                       M1 Args: none
041C69 FD E1       0001*M1     pop iy
041C6B DD E1       0002*M1     pop ix
041C6D D1          0003*M1     pop de
041C6E C1          0004*M1     pop bc
041C6F E1          0005*M1     pop hl
041C70 F1          0006*M1     pop af
041C71 08          0007*M1     ex af,af'
041C72 D9          0008*M1     exx
041C73             0009*M1 
041C73 D1          0010*M1     pop de
041C74 C1          0011*M1     pop bc
041C75 E1          0012*M1     pop hl
041C76 F1          0013*M1     pop af
041C77 08          0014*M1     ex af,af'
041C78 D9          0015*M1     exx
041C79             0517*       PUSH_ALL
                       M1 Args: none
041C79 08          0001*M1     ex af,af'
041C7A D9          0002*M1     exx
041C7B F5          0003*M1     push af
041C7C E5          0004*M1     push hl
041C7D C5          0005*M1     push bc
041C7E D5          0006*M1     push de
041C7F             0007*M1 
041C7F 08          0008*M1     ex af,af'
041C80 D9          0009*M1     exx
041C81 F5          0010*M1     push af
041C82 E5          0011*M1     push hl
041C83 C5          0012*M1     push bc
041C84 D5          0013*M1     push de
041C85 DD E5       0014*M1     push ix
041C87 FD E5       0015*M1     push iy
041C89 CD 90 1B 04 0518*       call dumpFlags
041C8D             0519*       POP_ALL
                       M1 Args: none
041C8D FD E1       0001*M1     pop iy
041C8F DD E1       0002*M1     pop ix
041C91 D1          0003*M1     pop de
041C92 C1          0004*M1     pop bc
041C93 E1          0005*M1     pop hl
041C94 F1          0006*M1     pop af
041C95 08          0007*M1     ex af,af'
041C96 D9          0008*M1     exx
041C97             0009*M1 
041C97 D1          0010*M1     pop de
041C98 C1          0011*M1     pop bc
041C99 E1          0012*M1     pop hl
041C9A F1          0013*M1     pop af
041C9B 08          0014*M1     ex af,af'
041C9C D9          0015*M1     exx
041C9D             0520*       PUSH_ALL
                       M1 Args: none
041C9D 08          0001*M1     ex af,af'
041C9E D9          0002*M1     exx
041C9F F5          0003*M1     push af
041CA0 E5          0004*M1     push hl
041CA1 C5          0005*M1     push bc
041CA2 D5          0006*M1     push de
041CA3             0007*M1 
041CA3 08          0008*M1     ex af,af'
041CA4 D9          0009*M1     exx
041CA5 F5          0010*M1     push af
041CA6 E5          0011*M1     push hl
041CA7 C5          0012*M1     push bc
041CA8 D5          0013*M1     push de
041CA9 DD E5       0014*M1     push ix
041CAB FD E5       0015*M1     push iy
041CAD CD 7C 1A 04 0521*       call dumpRegistersHex
041CB1             0522*       ; call waitKeypress
041CB1 CD 7C 00 04 0523*       call printNewLine
041CB5             0524*       POP_ALL
                       M1 Args: none
041CB5 FD E1       0001*M1     pop iy
041CB7 DD E1       0002*M1     pop ix
041CB9 D1          0003*M1     pop de
041CBA C1          0004*M1     pop bc
041CBB E1          0005*M1     pop hl
041CBC F1          0006*M1     pop af
041CBD 08          0007*M1     ex af,af'
041CBE D9          0008*M1     exx
041CBF             0009*M1 
041CBF D1          0010*M1     pop de
041CC0 C1          0011*M1     pop bc
041CC1 E1          0012*M1     pop hl
041CC2 F1          0013*M1     pop af
041CC3 08          0014*M1     ex af,af'
041CC4 D9          0015*M1     exx
041CC5 C9          0525*       ret
041CC6             0526*   DEBUG_WAITKEYPRESS:
041CC6             0527*       PUSH_ALL
                       M1 Args: none
041CC6 08          0001*M1     ex af,af'
041CC7 D9          0002*M1     exx
041CC8 F5          0003*M1     push af
041CC9 E5          0004*M1     push hl
041CCA C5          0005*M1     push bc
041CCB D5          0006*M1     push de
041CCC             0007*M1 
041CCC 08          0008*M1     ex af,af'
041CCD D9          0009*M1     exx
041CCE F5          0010*M1     push af
041CCF E5          0011*M1     push hl
041CD0 C5          0012*M1     push bc
041CD1 D5          0013*M1     push de
041CD2 DD E5       0014*M1     push ix
041CD4 FD E5       0015*M1     push iy
041CD6 CD 5A 03 04 0528*       call waitKeypress
041CDA             0529*       POP_ALL
                       M1 Args: none
041CDA FD E1       0001*M1     pop iy
041CDC DD E1       0002*M1     pop ix
041CDE D1          0003*M1     pop de
041CDF C1          0004*M1     pop bc
041CE0 E1          0005*M1     pop hl
041CE1 F1          0006*M1     pop af
041CE2 08          0007*M1     ex af,af'
041CE3 D9          0008*M1     exx
041CE4             0009*M1 
041CE4 D1          0010*M1     pop de
041CE5 C1          0011*M1     pop bc
041CE6 E1          0012*M1     pop hl
041CE7 F1          0013*M1     pop af
041CE8 08          0014*M1     ex af,af'
041CE9 D9          0015*M1     exx
041CEA C9          0530*       RET
041CEB             0531*   
041CEB             0532*   dumpVduCmdStr:
041CEB             0533*       PUSH_ALL
                       M1 Args: none
041CEB 08          0001*M1     ex af,af'
041CEC D9          0002*M1     exx
041CED F5          0003*M1     push af
041CEE E5          0004*M1     push hl
041CEF C5          0005*M1     push bc
041CF0 D5          0006*M1     push de
041CF1             0007*M1 
041CF1 08          0008*M1     ex af,af'
041CF2 D9          0009*M1     exx
041CF3 F5          0010*M1     push af
041CF4 E5          0011*M1     push hl
041CF5 C5          0012*M1     push bc
041CF6 D5          0013*M1     push de
041CF7 DD E5       0014*M1     push ix
041CF9 FD E5       0015*M1     push iy
041CFB 79          0534*       ld a,c
041CFC CD E1 1B 04 0535*       call dumpMemoryHex
041D00 CD 5A 03 04 0536*       call waitKeypress
041D04             0537*       POP_ALL
                       M1 Args: none
041D04 FD E1       0001*M1     pop iy
041D06 DD E1       0002*M1     pop ix
041D08 D1          0003*M1     pop de
041D09 C1          0004*M1     pop bc
041D0A E1          0005*M1     pop hl
041D0B F1          0006*M1     pop af
041D0C 08          0007*M1     ex af,af'
041D0D D9          0008*M1     exx
041D0E             0009*M1 
041D0E D1          0010*M1     pop de
041D0F C1          0011*M1     pop bc
041D10 E1          0012*M1     pop hl
041D11 F1          0013*M1     pop af
041D12 08          0014*M1     ex af,af'
041D13 D9          0015*M1     exx
041D14 C9          0538*       ret
041D15             0539*   ; end dumpVduCmdStr
041D15             0046    
041D15             0047    ; --- MAIN PROGRAM FILE ---
041D15             0048    init:
041D15             0049    ; initialize play sample timer interrupt handler
041D15 CD F9 0F 04 0050        call prt_irq_init
041D19 CD 7C 00 04 0051        call printNewLine
041D1D C9          0052        ret
041D1E             0053    ; end init
041D1E             0054    
041D1E             0055    main:
041D1E             0056    ; set a loop counter for multiple tests
041D1E 06 0A       0057        ld b,10
041D20             0058    @start:
041D20 C5          0059        push bc
041D21             0060    ; synchronise MOS timer with VBLANK
041D21 CD 0A 12 04 0061        call vdu_vblank
041D25             0062    ; set a MOS timer
041D25 FD 21 C3 10 0063        ld iy,tmr_test
       04          
041D2A 21 78 00 00 0064        ld hl,[120*1] ; 120 ticks per second
041D2E CD A1 10 04 0065        call tmr_set
041D32             0066    ; start the PRT timer
041D32 CD D6 0F 04 0067        call prt_start
041D36             0068    @loop:
041D36             0069    ; check MOS timer
041D36 CD AF 10 04 0070        call tmr_get
041D3A CA 46 1D 04 0071        jp z,@F
041D3E FA 46 1D 04 0072        jp m,@F
041D42 C3 36 1D 04 0073        jp @loop
041D46             0074    @@: ; stop the PRT timer
041D46 CD F3 0F 04 0075        call prt_stop
041D4A             0076    ; display the interrupt count
041D4A 2A 2A 10 04 0077        ld hl,(prt_irq_counter)
041D4E CD CC 00 04 0078        call printDec
041D52 CD 7C 00 04 0079        call printNewLine
041D56             0080    ; decrement the loop counter
041D56 C1          0081        pop bc
041D57 10 C7       0082        djnz @start
041D59 C9          0083        ret
041D5A             0084    ; end main
