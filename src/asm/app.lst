PC     Output      Line
040000             0001        assume adl=1
040000             0002        org 0x040000
040000 C3 45 00 04 0003        jp start
040004             0004        align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0005        db "MOS"
040043 00          0006        db 00h
040044 01          0007        db 01h
040045             0008    
040045             0009    start:
040045 F5          0010        push af
040046 C5          0011        push bc
040047 D5          0012        push de
040048 DD E5       0013        push ix
04004A FD E5       0014        push iy
04004C             0015    
04004C CD 78 2B 04 0016        call init
040050 CD 57 2C 04 0017        call main
040054             0018    
040054             0019    exit:
040054 FD E1       0020        pop iy
040056 DD E1       0021        pop ix
040058 D1          0022        pop de
040059 C1          0023        pop bc
04005A F1          0024        pop af
04005B 21 00 00 00 0025        ld hl,0
04005F             0026    
04005F C9          0027        ret
040060             0028    
040060             0029    ; API INCLUDES
040060             0030        include "mos_api.inc"
040060             0001*   ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.inc
040060             0002*   ; Title:	AGON MOS - API for user projects
040060             0003*   ; Author:	Dean Belfield
040060             0004*   ;			Adapted for agon-ez80asm by Jeroen Venema
040060             0005*   ;			Added MOS error codes for return in HL
040060             0006*   ; Created:	03/08/2022
040060             0007*   ; Last Updated:	10/08/2023
040060             0008*   ;
040060             0009*   ; Modinfo:
040060             0010*   ; 05/08/2022:	Added mos_feof
040060             0011*   ; 09/08/2022:	Added system variables: cursorX, cursorY
040060             0012*   ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040060             0013*   ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040060             0014*   ; 24/09/2022:	Added mos_getError, mos_mkdir
040060             0015*   ; 13/10/2022:	Added mos_oscli
040060             0016*   ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040060             0017*   ; 04/03/2023:	Added sysvar_scrpixelIndex
040060             0018*   ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040060             0019*   ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040060             0020*   ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040060             0021*   ; 22/03/2023:	The VDP commands are now indexed from 0x80
040060             0022*   ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040060             0023*   ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040060             0024*   ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040060             0025*   ; 19/05/2023:	Added sysvar_scrMode
040060             0026*   ; 05/06/2023:	Added sysvar_rtcEnable
040060             0027*   ; 03/08/2023:	Added mos_setkbvector
040060             0028*   ; 10/08/2023:	Added mos_getkbmap
040060             0029*   
040060             0030*   ; VDP control (VDU 23, 0, n)
040060             0031*   ;
040060             0032*   vdp_gp:				EQU 80h
040060             0033*   vdp_keycode:		EQU 81h
040060             0034*   vdp_cursor:			EQU	82h
040060             0035*   vdp_scrchar:		EQU	83h
040060             0036*   vdp_scrpixel:		EQU	84h
040060             0037*   vdp_audio:			EQU	85h
040060             0038*   vdp_mode:			EQU	86h
040060             0039*   vdp_rtc:			EQU	87h
040060             0040*   vdp_keystate:		EQU	88h
040060             0041*   vdp_logicalcoords:	EQU	C0h
040060             0042*   vdp_terminalmode:	EQU	FFh
040060             0043*   
040060             0044*   ; MOS high level functions
040060             0045*   ;
040060             0046*   mos_getkey:			EQU	00h
040060             0047*   mos_load:			EQU	01h
040060             0048*   mos_save:			EQU	02h
040060             0049*   mos_cd:				EQU	03h
040060             0050*   mos_dir:			EQU	04h
040060             0051*   mos_del:			EQU	05h
040060             0052*   mos_ren:			EQU	06h
040060             0053*   mos_mkdir:			EQU	07h
040060             0054*   mos_sysvars:		EQU	08h
040060             0055*   mos_editline:		EQU	09h
040060             0056*   mos_fopen:			EQU	0Ah
040060             0057*   mos_fclose:			EQU	0Bh
040060             0058*   mos_fgetc:			EQU	0Ch
040060             0059*   mos_fputc:			EQU	0Dh
040060             0060*   mos_feof:			EQU	0Eh
040060             0061*   mos_getError:		EQU	0Fh
040060             0062*   mos_oscli:			EQU	10h
040060             0063*   mos_copy:			EQU	11h
040060             0064*   mos_getrtc:			EQU	12h
040060             0065*   mos_setrtc:			EQU	13h
040060             0066*   mos_setintvector:	EQU	14h
040060             0067*   mos_uopen:			EQU	15h
040060             0068*   mos_uclose:			EQU	16h
040060             0069*   mos_ugetc:			EQU	17h
040060             0070*   mos_uputc:			EQU	18h
040060             0071*   mos_getfil:			EQU	19h
040060             0072*   mos_fread:			EQU	1Ah
040060             0073*   mos_fwrite:			EQU	1Bh
040060             0074*   mos_flseek:			EQU	1Ch
040060             0075*   mos_setkbvector:	EQU	1Dh
040060             0076*   mos_getkbmap:		EQU	1Eh
040060             0077*   
040060             0078*   ; MOS program exit codes
040060             0079*   ;
040060             0080*   EXIT_OK:				EQU  0;	"OK",
040060             0081*   EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
040060             0082*   EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
040060             0083*   EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
040060             0084*   EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
040060             0085*   EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
040060             0086*   EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
040060             0087*   EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
040060             0088*   EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
040060             0089*   EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
040060             0090*   EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
040060             0091*   EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
040060             0092*   EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
040060             0093*   EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
040060             0094*   EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
040060             0095*   EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
040060             0096*   EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
040060             0097*   EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
040060             0098*   EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
040060             0099*   EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
040060             0100*   EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
040060             0101*   EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
040060             0102*   ; FatFS file access functions
040060             0103*   ;
040060             0104*   ffs_fopen:			EQU	80h
040060             0105*   ffs_fclose:			EQU	81h
040060             0106*   ffs_fread:			EQU	82h
040060             0107*   ffs_fwrite:			EQU	83h
040060             0108*   ffs_flseek:			EQU	84h
040060             0109*   ffs_ftruncate:		EQU	85h
040060             0110*   ffs_fsync:			EQU	86h
040060             0111*   ffs_fforward:		EQU	87h
040060             0112*   ffs_fexpand:		EQU	88h
040060             0113*   ffs_fgets:			EQU	89h
040060             0114*   ffs_fputc:			EQU	8Ah
040060             0115*   ffs_fputs:			EQU	8Bh
040060             0116*   ffs_fprintf:		EQU	8Ch
040060             0117*   ffs_ftell:			EQU	8Dh
040060             0118*   ffs_feof:			EQU	8Eh
040060             0119*   ffs_fsize:			EQU	8Fh
040060             0120*   ffs_ferror:			EQU	90h
040060             0121*   
040060             0122*   ; FatFS directory access functions
040060             0123*   ;
040060             0124*   ffs_dopen:			EQU	91h
040060             0125*   ffs_dclose:			EQU	92h
040060             0126*   ffs_dread:			EQU	93h
040060             0127*   ffs_dfindfirst:		EQU	94h
040060             0128*   ffs_dfindnext:		EQU	95h
040060             0129*   
040060             0130*   ; FatFS file and directory management functions
040060             0131*   ;
040060             0132*   ffs_stat:			EQU	96h
040060             0133*   ffs_unlink:			EQU	97h
040060             0134*   ffs_rename:			EQU	98h
040060             0135*   ffs_chmod:			EQU	99h
040060             0136*   ffs_utime:			EQU	9Ah
040060             0137*   ffs_mkdir:			EQU	9Bh
040060             0138*   ffs_chdir:			EQU	9Ch
040060             0139*   ffs_chdrive:		EQU	9Dh
040060             0140*   ffs_getcwd:			EQU	9Eh
040060             0141*   
040060             0142*   ; FatFS volume management and system configuration functions
040060             0143*   ;
040060             0144*   ffs_mount:			EQU	9Fh
040060             0145*   ffs_mkfs:			EQU	A0h
040060             0146*   ffs_fdisk:			EQU	A1h
040060             0147*   ffs_getfree:		EQU	A2h
040060             0148*   ffs_getlabel:		EQU	A3h
040060             0149*   ffs_setlabel:		EQU	A4h
040060             0150*   ffs_setcp:			EQU	A5h
040060             0151*   
040060             0152*   ; File access modes
040060             0153*   ;
040060             0154*   fa_read:			EQU	01h
040060             0155*   fa_write:			EQU	02h
040060             0156*   fa_open_existing:	EQU	00h
040060             0157*   fa_create_new:		EQU	04h
040060             0158*   fa_create_always:	EQU	08h
040060             0159*   fa_open_always:		EQU	10h
040060             0160*   fa_open_append:		EQU	30h
040060             0161*   
040060             0162*   ; System variable indexes for api_sysvars
040060             0163*   ; Index into _sysvars in globals.inc
040060             0164*   ;
040060             0165*   sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040060             0166*   sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
040060             0167*   sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040060             0168*   sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
040060             0169*   sysvar_cursorX:			EQU	07h	; 1: Cursor X position
040060             0170*   sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
040060             0171*   sysvar_scrchar:			EQU	09h	; 1: Character read from screen
040060             0172*   sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040060             0173*   sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040060             0174*   sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040060             0175*   sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
040060             0176*   sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
040060             0177*   sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
040060             0178*   sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
040060             0179*   sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
040060             0180*   sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040060             0181*   sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
040060             0182*   sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040060             0183*   sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
040060             0184*   sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
040060             0185*   sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
040060             0186*   sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
040060             0187*   sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
040060             0188*   sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
040060             0189*   sysvar_scrMode:			EQU	27h	; 1: Screen mode
040060             0190*   sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040060             0191*   
040060             0192*   ; Flags for the VPD protocol
040060             0193*   ;
040060             0194*   vdp_pflag_cursor:		EQU	00000001b
040060             0195*   vdp_pflag_scrchar:		EQU	00000010b
040060             0196*   vdp_pflag_point:		EQU	00000100b
040060             0197*   vdp_pflag_audio:		EQU	00001000b
040060             0198*   vdp_pflag_mode:			EQU	00010000b
040060             0199*   vdp_pflag_rtc:			EQU	00100000b
040060             0200*   
040060             0201*   ;
040060             0202*   ; FatFS structures
040060             0203*   ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040060             0204*   ;
040060             0205*   ; Object ID and allocation information (FFOBJID)
040060             0206*   ;
040060             0207*   ; Indexes into FFOBJID structure
040060             0208*   ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
040060             0209*   ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
040060             0210*   ffobjid_attr:		EQU	5	; 1: Object attribute
040060             0211*   ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040060             0212*   ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
040060             0213*   ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
040060             0214*   ;
040060             0215*   ; File object structure (FIL)
040060             0216*   ;
040060             0217*   ; Indexes into FIL structure
040060             0218*   fil_obj:		EQU 0	; 15: Object identifier
040060             0219*   fil_flag:		EQU	15 	;  1: File status flags
040060             0220*   fil_err:		EQU	16	;  1: Abort flag (error code)
040060             0221*   fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
040060             0222*   fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
040060             0223*   fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
040060             0224*   fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
040060             0225*   fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
040060             0226*   ;
040060             0227*   ; Directory object structure (DIR)
040060             0228*   ; Indexes into DIR structure
040060             0229*   dir_obj:		EQU  0	; 15: Object identifier
040060             0230*   dir_dptr:		EQU	15	;  4: Current read/write offset
040060             0231*   dir_clust:		EQU	19	;  4: Current cluster
040060             0232*   dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
040060             0233*   dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
040060             0234*   dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
040060             0235*   dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040060             0236*   ;
040060             0237*   ; File information structure (FILINFO)
040060             0238*   ;
040060             0239*   ; Indexes into FILINFO structure
040060             0240*   filinfo_fsize:		EQU 0	;   4: File size
040060             0241*   filinfo_fdate:		EQU	4	;   2: Modified date
040060             0242*   filinfo_ftime:		EQU	6	;   2: Modified time
040060             0243*   filinfo_fattrib:	EQU	8	;   1: File attribute
040060             0244*   filinfo_altname:	EQU	9	;  13: Alternative file name
040060             0245*   filinfo_fname:		EQU	22	; 256: Primary file name
040060             0246*   filinfo_struct_size: EQU filinfo_fname+256 ; size of the FILINFO structure
040060             0247*   
040060             0248*   ; /* File attribute bits for directory entry (FILINFO.fattrib) */
040060             0249*   AM_RDO: equ 0x01 ; Read only
040060             0250*   AM_HID: equ 0x02 ; Hidden
040060             0251*   AM_SYS: equ 0x04 ; System
040060             0252*   AM_DIR: equ 0x10 ; Directory
040060             0253*   AM_ARC: equ 0x20 ; Archive
040060             0254*   ;
040060             0255*   ; Macro for calling the API
040060             0256*   ; Parameters:
040060             0257*   ; - function: One of the function numbers listed above
040060             0258*   ;
040060             0259*   	MACRO	MOSCALL	function
040060             0260*   			LD	A, function
040060             0261*   			RST.LIL	08h
040060             0262*   	ENDMACRO
040060             0031        include "macros.inc"
040060             0001*   
040060             0002*   ; test the sign of HL
040060             0003*   ; inputs: HL obviously
040060             0004*   ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
040060             0005*   ; destroys: flags
040060             0006*       MACRO SIGN_HLU
040060             0007*       add hl,de ; 1 cycle
040060             0008*       or a ; clear flags ; 1 cycle
040060             0009*       sbc hl,de ; 2 cycles
040060             0010*       ; 4 cycles total
040060             0011*       ENDMACRO
040060             0012*   
040060             0013*   ; put the value in A into HLU
040060             0014*   ; affects: HLU
040060             0015*   ; destroys: nothing
040060             0016*   ; note: $ instead of @@ b/c anon labels deprecated in ez80asm
040060             0017*       MACRO A_TO_HLU
040060             0018*       xor a ; 1 cycle
040060             0019*       ld ($+8+1),hl ; 7 cycles
040060             0020*       ld ($+4+3),a ; 5 cycles
040060             0021*       ld hl,0x000000 ; 4 cycles
040060             0022*       ; 17 cycles total
040060             0023*       ENDMACRO
040060             0024*   
040060             0025*   ; alternative: https://discord.com/channels/1158535358624039014/1282290921815408681/1318315567102300220
040060             0026*   ; one cycle less but burns flags
040060             0027*       MACRO A_TO_HLU_ALT
040060             0028*       push hl ; 4 cycles
040060             0029*       ld hl,2 ; 4 cycles
040060             0030*       add hl,sp ; 1 cycle
040060             0031*       ld (hl),a ; 2 cycles
040060             0032*       pop hl ; 4 cycles
040060             0033*       ; 15 cycles total
040060             0034*       ENDMACRO
040060             0035*   
040060             0036*       MACRO hlu_mul256
040060             0037*       add hl,hl ; * 2
040060             0038*       add hl,hl ; * 4
040060             0039*       add hl,hl ; * 8
040060             0040*       add hl,hl ; * 16
040060             0041*       add hl,hl ; * 32
040060             0042*       add hl,hl ; * 64
040060             0043*       add hl,hl ; * 128
040060             0044*       add hl,hl ; * 256
040060             0045*       ENDMACRO
040060             0046*   
040060             0047*   ; https://discord.com/channels/1158535358624039014/1282290921815408681/1317793870070812715
040060             0048*       MACRO SRL_UHL
040060             0049*       dec sp ; 1 cycle
040060             0050*       push hl ; 4 cycles
040060             0051*       inc sp ; 1 cycle
040060             0052*       pop hl ; 4 cycles
040060             0053*       inc hl ; 1 cycle
040060             0054*       dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
040060             0055*       ; 13 cycles total
040060             0056*       ENDMACRO
040060             0057*   
040060             0058*       MACRO printChar char
040060             0059*       LD A, char
040060             0060*       RST.LIL 10h
040060             0061*       ENDMACRO
040060             0062*   
040060             0063*   ; Simulated call to subroutine at HL
040060             0064*   ; inputs: HL pointing to the subroutine address plus whatever the called function expects
040060             0065*   ; outputs: whatever the subroutine does, including HL and BC
040060             0066*   ; destroys: only what the subroutine does, but always BC
040060             0067*       MACRO CALL_HL
040060             0068*       ld bc,$+6 ; Address of first instruction after the jump
040060             0069*       push bc ; which constitutes the return address
040060             0070*       jp (hl) ; Jump to the address in HL
040060             0071*       ENDMACRO
040060             0072*   
040060             0073*   ; Simulated call to subroutine at IX
040060             0074*   ; inputs: IX pointing to the subroutine address plus whatever the called function expects
040060             0075*   ; outputs: whatever the subroutine does, including IX and BC
040060             0076*   ; destroys: only what the subroutine does, but always BC
040060             0077*       MACRO CALL_IX
040060             0078*       ld bc,$+6 ; Address of first instruction after the jump
040060             0079*       push bc ; which constitutes the return address
040060             0080*       jp (ix) ; Jump to the address in IX
040060             0081*       ENDMACRO
040060             0082*   
040060             0083*   ; Simulated call to soubroutinte at IY
040060             0084*   ; inputs: IY pointing to the subroutine address plus whatever the called function expects
040060             0085*   ; outputs: whatever the subroutine does, including IY and BC
040060             0086*   ; destroys: only what the subroutine does, but always BC
040060             0087*       MACRO CALL_IY
040060             0088*       ld bc,$+6 ; Address of first instruction after the jump
040060             0089*       push bc ; which constitutes the return address
040060             0090*       jp (iy) ; Jump to the address in IY
040060             0091*       ENDMACRO
040060             0092*   
040060             0093*   ; put the value in HLU into A
040060             0094*   ; destroys: af
040060             0095*       MACRO HLU_TO_A
040060             0096*       dec sp ; 1 cycle
040060             0097*       push hl ; 4 cycles
040060             0098*       inc sp ; 1 cycle
040060             0099*       pop af ; 4 cycles
040060             0100*       ; 10 cycles total
040060             0101*       ENDMACRO
040060             0102*   
040060             0103*       MACRO PUSH_ALL
040060             0104*       ex af,af'
040060             0105*       exx
040060             0106*       push af
040060             0107*       push hl
040060             0108*       push bc
040060             0109*       push de
040060             0110*   
040060             0111*       ex af,af'
040060             0112*       exx
040060             0113*       push af
040060             0114*       push hl
040060             0115*       push bc
040060             0116*       push de
040060             0117*       push ix
040060             0118*       push iy
040060             0119*       ENDMACRO
040060             0120*   
040060             0121*       MACRO POP_ALL
040060             0122*       pop iy
040060             0123*       pop ix
040060             0124*       pop de
040060             0125*       pop bc
040060             0126*       pop hl
040060             0127*       pop af
040060             0128*       ex af,af'
040060             0129*       exx
040060             0130*   
040060             0131*       pop de
040060             0132*       pop bc
040060             0133*       pop hl
040060             0134*       pop af
040060             0135*       ex af,af'
040060             0136*       exx
040060             0137*       ENDMACRO
040060             0032        include "functions.inc"
040060             0001*   ; Print a zero-terminated string inline with code, e.g.:
040060             0002*   ;
040060             0003*   ;    call printInline
040060             0004*   ;    ASCIZ "Hello, world!\r\n"
040060             0005*   ;
040060             0006*   ; Destroys: HL,AF
040060             0007*   printInline:
040060 E1          0008*       pop hl ; get the return address = pointer to start of string
040061 CD 67 00 04 0009*       call printString ; HL advances to end of string
040065 E5          0010*       push hl ; restore the return address = pointer to end of string
040066 C9          0011*       ret
040067             0012*   
040067             0013*   ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
040067             0014*   ; Print a zero-terminated string
040067             0015*   ; HL: Pointer to string
040067             0016*   ; returns: hl pointed to character after string terminator
040067             0017*   ; destroys: af, hl
040067             0018*   printString:
040067 C5          0019*       PUSH BC
040068 01 00 00 00 0020*       LD BC,0
04006C 3E 00       0021*       LD A,0
04006E 5B DF       0022*       RST.LIL 18h
040070 C1          0023*       POP BC
040071 C9          0024*       RET
040072             0025*   ; print a VDU sequence
040072             0026*   ; HL: Pointer to VDU sequence - <1 byte length> <data>
040072             0027*   sendVDUsequence:
040072 C5          0028*       PUSH BC
040073 01 00 00 00 0029*       LD BC, 0
040077 4E          0030*       LD C, (HL)
040078 5B DF       0031*       RST.LIL 18h
04007A C1          0032*       POP BC
04007B C9          0033*       RET
04007C             0034*   ; Print Newline sequence to VDP
04007C             0035*   ; destroys: nothing
04007C             0036*   printNewLine:
04007C F5          0037*       push af ; for some reason rst.lil 10h sets carry flag
04007D 3E 0D       0038*       LD A, '\r'
04007F 5B D7       0039*       RST.LIL 10h
040081 3E 0A       0040*       LD A, '\n'
040083 5B D7       0041*       RST.LIL 10h
040085 F1          0042*       pop af
040086 C9          0043*       RET
040087             0044*   
040087             0045*   ; print a zero-terminated string at a graphics coordinate
040087             0046*   ; Inputs: HL Pointer to string, BC,DE x,y position (in pixels)
040087             0047*   printStringGfx:
040087 E5          0048*       push hl ; preserve string pointer
040088             0049*   ; move graphics cursor to x,y location
040088 3E 44       0050*       ld a,plot_pt+mv_abs
04008A CD A1 17 04 0051*       call vdu_plot
04008E             0052*   ; print string
04008E E1          0053*       pop hl ; restore string pointer
04008F             0054*   @print_loop:
04008F 7E          0055*       ld a,(hl)
040090 B7          0056*       or a ; check for end of string
040091 C8          0057*       ret z ; if zero, we're done
040092 08          0058*       ex af,af' ; preserve character
040093 3E 05       0059*       ld a,5 ; VDU 5 char to gfx cursor
040095 5B D7       0060*       rst.lil 10h ; send it
040097 08          0061*       ex af,af' ; restore character
040098 5B D7       0062*       rst.lil 10h ; print character
04009A 23          0063*       inc hl
04009B C3 8F 00 04 0064*       jp @print_loop
04009F C9          0065*       ret
0400A0             0066*   ; end printStringGfx
0400A0             0067*   
0400A0             0068*   ; Print a 24-bit HEX number
0400A0             0069*   ; HLU: Number to print
0400A0             0070*   printHex24:
0400A0             0071*       HLU_TO_A
                       M1 Args: none
0400A0 3B          0001*M1     dec sp ; 1 cycle
0400A1 E5          0002*M1     push hl ; 4 cycles
0400A2 33          0003*M1     inc sp ; 1 cycle
0400A3 F1          0004*M1     pop af ; 4 cycles
0400A4             0005*M1     ; 10 cycles total
0400A4 CD AE 00 04 0072*       CALL printHex8
0400A8             0073*   ; Print a 16-bit HEX number
0400A8             0074*   ; HL: Number to print
0400A8             0075*   printHex16:
0400A8 7C          0076*       LD A,H
0400A9 CD AE 00 04 0077*       CALL printHex8
0400AD 7D          0078*       LD A,L
0400AE             0079*   ; Print an 8-bit HEX number
0400AE             0080*   ; A: Number to print
0400AE             0081*   printHex8:
0400AE 4F          0082*       LD C,A
0400AF 1F          0083*       RRA
0400B0 1F          0084*       RRA
0400B1 1F          0085*       RRA
0400B2 1F          0086*       RRA
0400B3 CD B8 00 04 0087*       CALL @F
0400B7 79          0088*       LD A,C
0400B8             0089*   @@:
0400B8 E6 0F       0090*       AND 0Fh
0400BA C6 90       0091*       ADD A,90h
0400BC 27          0092*       DAA
0400BD CE 40       0093*       ADC A,40h
0400BF 27          0094*       DAA
0400C0 5B D7       0095*       RST.LIL 10h
0400C2 C9          0096*       RET
0400C3             0097*   
0400C3             0098*   ; Print a 0x HEX prefix
0400C3             0099*   DisplayHexPrefix:
0400C3 3E 30       0100*       LD A, '0'
0400C5 5B D7       0101*       RST.LIL 10h
0400C7 3E 78       0102*       LD A, 'x'
0400C9 5B D7       0103*       RST.LIL 10h
0400CB C9          0104*       RET
0400CC             0105*   
0400CC             0106*       MACRO printDecBC
0400CC             0107*       push hl
0400CC             0108*       push bc
0400CC             0109*       pop hl
0400CC             0110*       call printDec
0400CC             0111*       pop hl
0400CC             0112*       ENDMACRO
0400CC             0113*   
0400CC             0114*       MACRO printDecDE
0400CC             0115*       push hl
0400CC             0116*       push de
0400CC             0117*       pop hl
0400CC             0118*       call printDec
0400CC             0119*       pop hl
0400CC             0120*       ENDMACRO
0400CC             0121*   
0400CC             0122*       MACRO printDecHL
0400CC             0123*       call printDec
0400CC             0124*       ENDMACRO
0400CC             0125*   
0400CC             0126*       MACRO printDecIX
0400CC             0127*       push hl
0400CC             0128*       push ix
0400CC             0129*       pop hl
0400CC             0130*       call printDec
0400CC             0131*       pop hl
0400CC             0132*       ENDMACRO
0400CC             0133*   
0400CC             0134*       MACRO printDecIY
0400CC             0135*       push hl
0400CC             0136*       push iy
0400CC             0137*       pop hl
0400CC             0138*       call printDec
0400CC             0139*       pop hl
0400CC             0140*       ENDMACRO
0400CC             0141*   
0400CC             0142*   
0400CC             0143*   ; Prints the right justified decimal value in HL without leading zeroes
0400CC             0144*   ; HL : Value to print
0400CC             0145*   ; preserves all registers and flags
0400CC             0146*   printDec:
0400CC             0147*   ; BEGIN MY CODE
0400CC             0148*   ; back up all the things
0400CC F5          0149*       push af
0400CD C5          0150*       push bc
0400CE D5          0151*       push de
0400CF E5          0152*       push hl
0400D0             0153*   ; END MY CODE
0400D0 11 F8 00 04 0154*       LD DE, _printDecBuffer
0400D4 CD 08 01 04 0155*       CALL u24_to_ascii
0400D8             0156*   ; BEGIN MY CODE
0400D8             0157*   ; replace leading zeroes with spaces
0400D8 21 F8 00 04 0158*       LD HL, _printDecBuffer
0400DC 06 07       0159*       ld B, 7 ; if HL was 0, we want to keep the final zero
0400DE             0160*   @loop:
0400DE 7E          0161*       LD A, (HL)
0400DF FE 30       0162*       CP '0'
0400E1 C2 EB 00 04 0163*       JP NZ, @done
0400E5 3E 20       0164*       LD A, ' '
0400E7 77          0165*       LD (HL), A
0400E8 23          0166*       INC HL
0400E9             0167*       ; CALL vdu_cursor_forward
0400E9 10 F3       0168*       DJNZ @loop
0400EB             0169*   @done:
0400EB             0170*   ; END MY CODE
0400EB 21 F8 00 04 0171*       LD HL, _printDecBuffer
0400EF CD 67 00 04 0172*       CALL printString
0400F3             0173*   ; BEGIN MY CODE
0400F3             0174*   ; restore all the things
0400F3 E1          0175*       pop hl
0400F4 D1          0176*       pop de
0400F5 C1          0177*       pop bc
0400F6 F1          0178*       pop af
0400F7             0179*   ; END MY CODE
0400F7 C9          0180*       RET
0400F8 00 00 00 00 0181*   _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040108             0182*   
040108             0183*   ; This routine converts the unsigned 24-bit value in HLU into its ASCII representation,
040108             0184*   ; starting to memory location pointing by DE, in decimal form and with leading zeroes
040108             0185*   ; so it will allways be 8 characters length
040108             0186*   ; HL : Value to convert to string
040108             0187*   ; DE : pointer to buffer, at least 8 byte + 0
040108             0188*   u24_to_ascii:
040108 01 80 69 67 0189*       LD BC,-10000000
04010C CD 3F 01 04 0190*       CALL @one_digit
040110 01 C0 BD F0 0191*       LD BC,-1000000
040114 CD 3F 01 04 0192*       CALL @one_digit
040118 01 60 79 FE 0193*       LD BC,-100000
04011C CD 3F 01 04 0194*       CALL @one_digit
040120 01 F0 D8 FF 0195*       LD BC,-10000
040124 CD 3F 01 04 0196*       CALL @one_digit
040128 01 18 FC FF 0197*       LD BC,-1000
04012C CD 3F 01 04 0198*       CALL @one_digit
040130 01 9C FF FF 0199*       LD BC,-100
040134 CD 3F 01 04 0200*       CALL @one_digit
040138 0E F6       0201*       LD C,-10
04013A CD 3F 01 04 0202*       CALL @one_digit
04013E 48          0203*       LD C,B
04013F             0204*   @one_digit:
04013F 3E 2F       0205*       LD A,'0'-1
040141             0206*   @divide_me:
040141 3C          0207*       INC A
040142 09          0208*       ADD HL,BC
040143 38 FC       0209*       JR C,@divide_me
040145 ED 42       0210*       SBC HL,BC
040147 12          0211*       LD (DE),A
040148 13          0212*       INC DE
040149 C9          0213*       RET
04014A             0214*   
04014A             0215*   print_u24:
04014A D5          0216*       push de
04014B E5          0217*       push hl
04014C 11 F8 00 04 0218*       ld de,_printDecBuffer
040150 CD 08 01 04 0219*       call u24_to_ascii
040154 21 F8 00 04 0220*       ld hl,_printDecBuffer
040158 CD 67 00 04 0221*       call printString
04015C 3E 20       0222*       ld a,' '
04015E 5B D7       0223*       rst.lil 10h
040160 E1          0224*       pop hl
040161 D1          0225*       pop de
040162 C9          0226*       ret
040163             0227*   
040163             0228*   ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
040163             0229*   ; HL : Value to convert to string (integer part in H, fractional part in L)
040163             0230*   ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
040163             0231*   u168_to_ascii:
040163             0232*   ; add a leading space to make room for sign flag if needed
040163 3E 20       0233*       ld a,' '
040165 12          0234*       ld (de),a
040166 13          0235*       inc de
040167             0236*   ; Convert integer part
040167 E5          0237*       push hl ; Save HL (we’ll need the fractional part later)
040168             0238*       ; call hlu_udiv256 ; Shift to get integer portion in HL
040168             0239*       SRL_UHL ; Shift to get integer portion in HL
                       M1 Args: none
040168 3B          0001*M1     dec sp ; 1 cycle
040169 E5          0002*M1     push hl ; 4 cycles
04016A 33          0003*M1     inc sp ; 1 cycle
04016B E1          0004*M1     pop hl ; 4 cycles
04016C 23          0005*M1     inc hl ; 1 cycle
04016D 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
04016F             0007*M1     ; 13 cycles total
04016F 01 F0 D8 FF 0240*       ld bc, -10000
040173 CD 96 01 04 0241*       call @one_int
040177 01 18 FC FF 0242*       ld bc, -1000
04017B CD 96 01 04 0243*       call @one_int
04017F 01 9C FF FF 0244*       ld bc, -100
040183 CD 96 01 04 0245*       call @one_int
040187 0E F6       0246*       ld c, -10
040189 CD 96 01 04 0247*       call @one_int
04018D 48          0248*       ld c, b
04018E CD 96 01 04 0249*       call @one_int
040192 C3 A1 01 04 0250*       jp @frac ; Jump to fractional part conversion
040196             0251*   @one_int:
040196 3E 2F       0252*       ld a, '0' - 1 ; Start ASCII character at '0'
040198             0253*   @divide_me:
040198 3C          0254*       inc a
040199 09          0255*       add hl, bc ; Accumulate until overflow
04019A 38 FC       0256*       jr c, @divide_me
04019C ED 42       0257*       sbc hl, bc ; Remove excess after overflow
04019E 12          0258*       ld (de), a ; Store ASCII digit
04019F 13          0259*       inc de
0401A0 C9          0260*       ret
0401A1             0261*   ; Convert fractional part
0401A1             0262*   @frac:
0401A1 3E 2E       0263*       ld a, '.' ; Decimal point
0401A3 12          0264*       ld (de), a
0401A4 13          0265*       inc de
0401A5 E1          0266*       pop hl ; Restore HL with original fraction
0401A6 06 03       0267*       ld b, 3 ; Loop counter for 3 fractional digits
0401A8             0268*   @frac_loop:
0401A8 26 0A       0269*       ld h, 10 ; Load multiplier for fractional part
0401AA ED 6C       0270*       mlt hl ; Multiply by 10, result in HL (H holds the integer part)
0401AC 3E 30       0271*       ld a, '0'
0401AE 84          0272*       add a, h ; Convert integer part to ASCII
0401AF 12          0273*       ld (de), a
0401B0 13          0274*       inc de
0401B1 10 F5       0275*       djnz @frac_loop ; Repeat for each fractional digit
0401B3             0276*   ; Add null terminator
0401B3 AF          0277*       xor a ; Null terminator
0401B4 12          0278*       ld (de), a
0401B5 C9          0279*       ret
0401B6             0280*   
0401B6             0281*   print_u168:
0401B6 D5          0282*       push de
0401B7 E5          0283*       push hl
0401B8 11 F8 00 04 0284*       ld de,_printDecBuffer
0401BC CD 63 01 04 0285*       call u168_to_ascii
0401C0 21 F8 00 04 0286*       ld hl,_printDecBuffer
0401C4 CD 67 00 04 0287*       call printString
0401C8 E1          0288*       pop hl
0401C9 D1          0289*       pop de
0401CA C9          0290*       ret
0401CB             0291*   
0401CB             0292*   ; signed version of u168_to_ascii
0401CB             0293*   s168_to_ascii:
0401CB D5          0294*       push de ; save starting address of buffer
0401CC CD 70 04 04 0295*       call hlu_abs
0401D0 F5          0296*       push af ; save sign flag
0401D1 CD 63 01 04 0297*       call u168_to_ascii
0401D5 F1          0298*       pop af ; restore sign flag
0401D6 D1          0299*       pop de ; restore starting address of buffer
0401D7 F0          0300*       ret p ; hlu was positive so nothing to do
0401D8 3E 2D       0301*       ld a,'-'
0401DA 12          0302*       ld (de),a
0401DB C9          0303*       ret
0401DC             0304*   
0401DC             0305*   print_s168:
0401DC D5          0306*       push de
0401DD E5          0307*       push hl
0401DE 11 F8 00 04 0308*       ld de,_printDecBuffer
0401E2 CD CB 01 04 0309*       call s168_to_ascii
0401E6 21 F8 00 04 0310*       ld hl,_printDecBuffer
0401EA CD 67 00 04 0311*       call printString
0401EE E1          0312*       pop hl
0401EF D1          0313*       pop de
0401F0 C9          0314*       ret
0401F1             0315*   
0401F1             0316*   print_s168_hl:
0401F1 F5          0317*       push af
0401F2 E5          0318*       push hl
0401F3 CD DC 01 04 0319*       call print_s168
0401F7 3E 20       0320*       ld a,' '
0401F9 5B D7       0321*       rst.lil 10h
0401FB E1          0322*       pop hl
0401FC F1          0323*       pop af
0401FD C9          0324*       ret
0401FE             0325*   
0401FE             0326*   print_s168_bc:
0401FE F5          0327*       push af
0401FF C5          0328*       push bc
040200 E5          0329*       push hl
040201 C5          0330*       push bc
040202 E1          0331*       pop hl
040203 CD DC 01 04 0332*       call print_s168
040207 3E 20       0333*       ld a,' '
040209 5B D7       0334*       rst.lil 10h
04020B E1          0335*       pop hl
04020C C1          0336*       pop bc
04020D F1          0337*       pop af
04020E C9          0338*       ret
04020F             0339*   
04020F             0340*   print_s168_de:
04020F F5          0341*       push af
040210 D5          0342*       push de
040211 E5          0343*       push hl
040212 EB          0344*       ex de,hl
040213 CD DC 01 04 0345*       call print_s168
040217 3E 20       0346*       ld a,' '
040219 5B D7       0347*       rst.lil 10h
04021B E1          0348*       pop hl
04021C D1          0349*       pop de
04021D F1          0350*       pop af
04021E C9          0351*       ret
04021F             0352*   
04021F             0353*   print_s168_hl_bc_de:
04021F F5          0354*       push af
040220 C5          0355*       push bc
040221 D5          0356*       push de
040222 E5          0357*       push hl
040223 CD DC 01 04 0358*       call print_s168
040227 3E 20       0359*       ld a,' '
040229 5B D7       0360*       rst.lil 10h
04022B C5          0361*       push bc
04022C E1          0362*       pop hl
04022D CD DC 01 04 0363*       call print_s168
040231 3E 20       0364*       ld a,' '
040233 5B D7       0365*       rst.lil 10h
040235 EB          0366*       ex de,hl
040236 CD DC 01 04 0367*       call print_s168
04023A 3E 20       0368*       ld a,' '
04023C 5B D7       0369*       rst.lil 10h
04023E E1          0370*       pop hl
04023F D1          0371*       pop de
040240 C1          0372*       pop bc
040241 F1          0373*       pop af
040242 C9          0374*       ret
040243             0375*   
040243             0376*   print_s168_bc_de:
040243 F5          0377*       push af
040244 C5          0378*       push bc
040245 D5          0379*       push de
040246 C5          0380*       push bc
040247 E1          0381*       pop hl
040248 CD DC 01 04 0382*       call print_s168
04024C 3E 20       0383*       ld a,' '
04024E 5B D7       0384*       rst.lil 10h
040250 EB          0385*       ex de,hl
040251 CD DC 01 04 0386*       call print_s168
040255 3E 20       0387*       ld a,' '
040257 5B D7       0388*       rst.lil 10h
040259 E1          0389*       pop hl
04025A D1          0390*       pop de
04025B C1          0391*       pop bc
04025C F1          0392*       pop af
04025D C9          0393*       ret
04025E             0394*   
04025E             0395*   print_s168_a:
04025E F5          0396*       push af
04025F C5          0397*       push bc
040260 E5          0398*       push hl
040261 21 00 00 00 0399*       ld hl,0
040265 6F          0400*       ld l,a
040266 CD F1 01 04 0401*       call print_s168_hl
04026A E1          0402*       pop hl
04026B C1          0403*       pop bc
04026C F1          0404*       pop af
04026D C9          0405*       ret
04026E             0406*   
04026E             0407*   ; #### new functions added by Brandon R. Gates ####
04026E             0408*   
04026E             0409*   ; print the binary representation of the 8-bit value in a
04026E             0410*   ; destroys a, hl, bc
04026E             0411*   printBin8:
04026E 06 08       0412*       ld b,8 ; loop counter for 8 bits
040270 21 8B 02 04 0413*       ld hl,@cmd ; set hl to the low byte of the output string
040274             0414*       ; (which will be the high bit of the value in a)
040274             0415*   @loop:
040274 07          0416*       rlca ; put the next highest bit into carry
040275 38 04       0417*       jr c,@one
040277 36 30       0418*       ld (hl),'0'
040279 18 02       0419*       jr @next_bit
04027B             0420*   @one:
04027B 36 31       0421*       ld (hl),'1'
04027D             0422*   @next_bit:
04027D 23          0423*       inc hl
04027E 10 F4       0424*       djnz @loop
040280             0425*   ; print it
040280 21 8B 02 04 0426*       ld hl,@cmd
040284 01 08 00 00 0427*       ld bc,@end-@cmd
040288 5B DF       0428*       rst.lil $18
04028A C9          0429*       ret
04028B             0430*   @cmd: ds 8 ; eight bytes for eight bits
040293             0431*   @end:
040293             0432*   
040293             0433*   ; print the binary representation of the 8-bit value in a
040293             0434*   ; in reverse order (lsb first)
040293             0435*   ; destroys a, hl, bc
040293             0436*   printBin8Rev:
       FF FF FF FF 
       FF FF FF FF 
040293 06 08       0437*       ld b,8 ; loop counter for 8 bits
040295 21 B0 02 04 0438*       ld hl,@cmd ; set hl to the low byte of the output string
040299             0439*       ; (which will be the high bit of the value in a)
040299             0440*   @loop:
040299 0F          0441*       rrca ; put the next lowest bit into carry
04029A 38 04       0442*       jr c,@one
04029C 36 30       0443*       ld (hl),'0'
04029E 18 02       0444*       jr @next_bit
0402A0             0445*   @one:
0402A0 36 31       0446*       ld (hl),'1'
0402A2             0447*   @next_bit:
0402A2 23          0448*       inc hl
0402A3 10 F4       0449*       djnz @loop
0402A5             0450*   ; print it
0402A5 21 B0 02 04 0451*       ld hl,@cmd
0402A9 01 08 00 00 0452*       ld bc,@end-@cmd
0402AD 5B DF       0453*       rst.lil $18
0402AF C9          0454*       ret
0402B0             0455*   @cmd: ds 8 ; eight bytes for eight bits
0402B8             0456*   @end:
0402B8             0457*   
       FF FF FF FF 
       FF FF FF FF 
0402B8 20 61 66 3D 0458*   str_afu: db " af=",0
       00          
0402BD 20 68 6C 3D 0459*   str_hlu: db " hl=",0
       00          
0402C2 20 62 63 3D 0460*   str_bcu: db " bc=",0
       00          
0402C7 20 64 65 3D 0461*   str_deu: db " de=",0
       00          
0402CC 20 69 78 3D 0462*   str_ixu: db " ix=",0
       00          
0402D1 20 69 79 3D 0463*   str_iyu: db " iy=",0
       00          
0402D6             0464*   
0402D6             0465*   ; print udeuhl to screen in hexidecimal format
0402D6             0466*   ; inputs: none
0402D6             0467*   ; outputs: concatenated hexidecimal udeuhl
0402D6             0468*   ; destroys: nothing
0402D6             0469*   dumpUDEUHLHex:
0402D6             0470*   ; store everything in scratch
0402D6 22 35 03 04 0471*       ld (uhl),hl
0402DA ED 43 38 03 0472*       ld (ubc),bc
       04          
0402DF ED 53 3B 03 0473*       ld (ude),de
       04          
0402E4 DD 22 3E 03 0474*       ld (uix),ix
       04          
0402E9 FD 22 41 03 0475*       ld (uiy),iy
       04          
0402EE F5          0476*       push af
0402EF             0477*   
0402EF             0478*   ; print each register
0402EF             0479*   
0402EF 21 29 03 04 0480*       ld hl,str_udeuhl
0402F3 CD 67 00 04 0481*       call printString
0402F7 2A 3B 03 04 0482*       ld hl,(ude)
0402FB CD A0 00 04 0483*       call printHex24
0402FF 3E 2E       0484*       ld a,'.' ; print a dot to separate the values
040301 5B D7       0485*       rst.lil 10h
040303 2A 35 03 04 0486*       ld hl,(uhl)
040307 CD A0 00 04 0487*       call printHex24
04030B CD 7C 00 04 0488*       call printNewLine
04030F             0489*   
04030F             0490*   ; restore everything
04030F 2A 35 03 04 0491*       ld hl, (uhl)
040313 ED 4B 38 03 0492*       ld bc, (ubc)
       04          
040318 ED 5B 3B 03 0493*       ld de, (ude)
       04          
04031D DD 2A 3E 03 0494*       ld ix, (uix)
       04          
040322 FD 2A 41 03 0495*       ld iy, (uiy)
       04          
040327 F1          0496*       pop af
040328             0497*   ; all done
040328 C9          0498*       ret
040329             0499*   
040329 75 64 65 2E 0500*   str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
040332             0501*   
040332             0502*   ; global scratch memory for registers
040332 00 00 00    0503*   uaf: dl 0
040335 00 00 00    0504*   uhl: dl 0
040338 00 00 00    0505*   ubc: dl 0
04033B 00 00 00    0506*   ude: dl 0
04033E 00 00 00    0507*   uix: dl 0
040341 00 00 00    0508*   uiy: dl 0
040344 00 00 00    0509*   usp: dl 0
040347 00 00 00    0510*   upc: dl 0
04034A             0511*   
04034A             0512*   
04034A             0513*   ; set all the bits in the flag register
04034A             0514*   ; more of an academic exercise than anything useful
04034A             0515*   ; inputs; none
04034A             0516*   ; outputs; a=0,f=255
04034A             0517*   ; destroys: flags, hl
04034A             0518*   ; preserves: a, because why not
04034A             0519*   setAllFlags:
04034A 21 FF 00 00 0520*       ld hl,255
04034E 67          0521*       ld h,a ; four cycles to preserve a is cheap
04034F E5          0522*       push hl
040350 F1          0523*       pop af
040351 C9          0524*       ret
040352             0525*   
040352             0526*   ; reset all the bits in the flag register
040352             0527*   ; unlike its inverse counterpart, this may actually be useful
040352             0528*   ; inputs; none
040352             0529*   ; outputs; a=0,f=0
040352             0530*   ; destroys: flags, hl
040352             0531*   ; preserves: a, because why not
040352             0532*   resetAllFlags:
040352 21 00 00 00 0533*       ld hl,0
040356 67          0534*       ld h,a ; four cycles to preserve a is cheap
040357 E5          0535*       push hl
040358 F1          0536*       pop af
040359 C9          0537*       ret
04035A             0538*   
04035A             0539*   ; wait until user presses a key
04035A             0540*   ; inputs: none
04035A             0541*   ; outputs: ascii code of key pressed in a
04035A             0542*   ; destroys: af,ix
04035A             0543*   waitKeypress:
04035A             0544*       MOSCALL mos_getkey
                       M1 Args: function=mos_getkey 
04035A 3E 00       0001*M1 			LD	A, function
04035C 5B CF       0002*M1 			RST.LIL	08h
04035E C9          0545*       ret
04035F             0546*   
04035F             0547*   ; clear a block of memory by writing a prescribed value to each byte in the range
04035F             0548*   ; inputs: a = value to write, hl = address of first byte, bc = number of bytes
04035F             0549*   ; outputs: memory block is cleared
04035F             0550*   ; destroys: hl, de
04035F             0551*   clear_mem:
04035F 0B          0552*       dec bc ; we do this because we will increment de before writing the first byte
040360 77          0553*       ld (hl),a
040361 E5          0554*       push hl
040362 D1          0555*       pop de
040363 13          0556*       inc de ; target address
040364 ED B0       0557*       ldir
040366 C9          0558*       ret
040367             0033        include "arith24.inc"
040367             0001*   ;------------------------------------------------------------------------
040367             0002*   ;  arith24.asm
040367             0003*   ;  24-bit ez80 arithmetic routines
040367             0004*   ;  Copyright (c) Shawn Sijnstra 2024
040367             0005*   ;  MIT license
040367             0006*   ;
040367             0007*   ;  This library was created as a tool to help make ez80
040367             0008*   ;  24-bit native assembly routines for simple mathematical problems
040367             0009*   ;  more widely available.
040367             0010*   ;
040367             0011*   ;------------------------------------------------------------------------
040367             0012*   
040367             0013*   ;------------------------------------------------------------------------
040367             0014*   ; umul24:	HL = HL*DE (unsigned)
040367             0015*   ; Preserves AF, BC, DE
040367             0016*   ; Uses a fast multiply routine.
040367             0017*   ;------------------------------------------------------------------------
040367             0018*   umul24:
040367 D5          0019*   	push	DE
040368 C5          0020*   	push	BC
040369 F5          0021*   	push	AF
04036A E5          0022*   	push	HL
04036B C1          0023*   	pop		BC
04036C 3E 18       0024*       ld	 	a, 24 ; No. of bits to process
04036E 21 00 00 00 0025*       ld	 	hl, 0 ; Result
040372             0026*   umul24_lp:
040372 29          0027*   	add	hl,hl
040373 EB          0028*   	ex	de,hl
040374 29          0029*   	add	hl,hl
040375 EB          0030*   	ex	de,hl
040376 30 01       0031*   	jr	nc,umul24_nc
040378 09          0032*   	add	hl,bc
040379             0033*   umul24_nc:
040379 3D          0034*   	dec	a
04037A 20 F6       0035*   	jr	nz,umul24_lp
04037C F1          0036*   	pop	af
04037D C1          0037*   	pop	bc
04037E D1          0038*   	pop	de
04037F C9          0039*   	ret
040380             0040*   
040380             0041*   
040380             0042*   ;------------------------------------------------------------------------
040380             0043*   ; udiv24
040380             0044*   ; Unsigned 24-bit division
040380             0045*   ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
040380             0046*   ;
040380             0047*   ; Uses AF BC DE HL
040380             0048*   ; Uses Restoring Division algorithm
040380             0049*   ;------------------------------------------------------------------------
040380             0050*   
040380             0051*   udiv24:
040380 E5          0052*   	push	hl
040381 C1          0053*   	pop		bc	;move dividend to BCU
040382 21 00 00 00 0054*   	ld		hl,0	;result
040386 A7          0055*   	and		a
040387 ED 52       0056*   	sbc		hl,de	;test for div by 0
040389 C8          0057*   	ret		z		;it's zero, carry flag is clear
04038A 19          0058*   	add		hl,de	;HL is 0 again
04038B 3E 18       0059*   	ld		a,24	;number of loops through.
04038D             0060*   udiv1:
04038D C5          0061*   	push	bc	;complicated way of doing this because of lack of access to top bits
04038E E3          0062*   	ex		(sp),hl
04038F 37          0063*   	scf
040390 ED 6A       0064*   	adc	hl,hl
040392 E3          0065*   	ex	(sp),hl
040393 C1          0066*   	pop	bc		;we now have bc = (bc * 2) + 1
040394             0067*   
040394 ED 6A       0068*   	adc	hl,hl
040396 A7          0069*   	and	a		;is this the bug
040397 ED 52       0070*   	sbc	hl,de
040399 30 02       0071*   	jr	nc,udiv2
04039B 19          0072*   	add	hl,de
04039C             0073*   ;	dec	c
04039C 0B          0074*   	dec	bc
04039D             0075*   udiv2:
04039D 3D          0076*   	dec	a
04039E 20 ED       0077*   	jr	nz,udiv1
0403A0 37          0078*   	scf		;flag used for div0 error
0403A1 C5          0079*   	push	bc
0403A2 D1          0080*   	pop		de	;remainder
0403A3 C9          0081*   	ret
0403A4             0082*   
0403A4             0083*   
0403A4             0084*   
0403A4             0085*   ;------------------------------------------------------------------------
0403A4             0086*   ; neg24
0403A4             0087*   ; Returns: HLU = 0-HLU
0403A4             0088*   ; preserves all other registers
0403A4             0089*   ;------------------------------------------------------------------------
0403A4             0090*   neg24:
0403A4 D5          0091*   	push	de
0403A5 EB          0092*   	ex		de,hl
0403A6 21 00 00 00 0093*   	ld		hl,0
0403AA B7          0094*   	or		a
0403AB ED 52       0095*   	sbc		hl,de
0403AD D1          0096*   	pop		de
0403AE C9          0097*   	ret
0403AF             0098*   
0403AF             0099*   ;------------------------------------------------------------------------
0403AF             0100*   ; or_hlu_deu: 24 bit bitwise OR
0403AF             0101*   ; Returns: hlu = hlu OR deu
0403AF             0102*   ; preserves all other registers
0403AF             0103*   ;------------------------------------------------------------------------
0403AF             0104*   or_hlu_deu:
0403AF 22 38 04 04 0105*   	ld	(bitbuf1),hl
0403B3 ED 53 3B 04 0106*   	ld	(bitbuf2),de
       04          
0403B8 D5          0107*   	push	de	;preserve DEU
0403B9 C5          0108*   	push	bc	;preserve BCU
0403BA 06 03       0109*   	ld		b,3
0403BC 21 38 04 04 0110*   	ld	hl,bitbuf1
0403C0 11 38 04 04 0111*   	ld	de,bitbuf1
0403C4             0112*   orloop_24:
0403C4 1A          0113*   	ld	a,(de)
0403C5 B6          0114*   	or	(hl)
0403C6 12          0115*   	ld	(de),a
0403C7 13          0116*   	inc	de
0403C8 23          0117*   	inc	hl
0403C9 10 F9       0118*   	djnz	orloop_24
0403CB 2A 3B 04 04 0119*   	ld	hl,(bitbuf2)
0403CF C1          0120*   	pop		bc	;restore BC
0403D0 D1          0121*   	pop		de	;restore DE
0403D1             0122*   
0403D1             0123*   ;------------------------------------------------------------------------
0403D1             0124*   ; and_hlu_deu: 24 bit bitwise AND
0403D1             0125*   ; Returns: hlu = hlu AND deu
0403D1             0126*   ; preserves all other registers
0403D1             0127*   ;------------------------------------------------------------------------
0403D1             0128*   and_hlu_deu:
0403D1 22 38 04 04 0129*   	ld	(bitbuf1),hl
0403D5 ED 53 3B 04 0130*   	ld	(bitbuf2),de
       04          
0403DA D5          0131*   	push	de	;preserve DEU
0403DB C5          0132*   	push	bc	;preserve BCU
0403DC 06 03       0133*   	ld		b,3
0403DE 21 38 04 04 0134*   	ld	hl,bitbuf1
0403E2 11 38 04 04 0135*   	ld	de,bitbuf1
0403E6             0136*   andloop_24:
0403E6 1A          0137*   	ld	a,(de)
0403E7 A6          0138*   	and	(hl)
0403E8 12          0139*   	ld	(de),a
0403E9 13          0140*   	inc	de
0403EA 23          0141*   	inc	hl
0403EB 10 F9       0142*   	djnz	andloop_24
0403ED 2A 3B 04 04 0143*   	ld	hl,(bitbuf2)
0403F1 C1          0144*   	pop		bc	;restore BC
0403F2 D1          0145*   	pop		de	;restore DE
0403F3             0146*   
0403F3             0147*   ;------------------------------------------------------------------------
0403F3             0148*   ; xor_hlu_deu: 24 bit bitwise XOR
0403F3             0149*   ; Returns: hlu = hlu XOR deu
0403F3             0150*   ; preserves all other registers
0403F3             0151*   ;------------------------------------------------------------------------
0403F3             0152*   xor_hlu_deu:
0403F3 22 38 04 04 0153*   	ld	(bitbuf1),hl
0403F7 ED 53 3B 04 0154*   	ld	(bitbuf2),de
       04          
0403FC D5          0155*   	push	de	;preserve DEU
0403FD C5          0156*   	push	bc	;preserve BCU
0403FE 06 03       0157*   	ld		b,3
040400 21 38 04 04 0158*   	ld	hl,bitbuf1
040404 11 38 04 04 0159*   	ld	de,bitbuf1
040408             0160*   xorloop_24:
040408 1A          0161*   	ld	a,(de)
040409 AE          0162*   	xor	(hl)
04040A 12          0163*   	ld	(de),a
04040B 13          0164*   	inc	de
04040C 23          0165*   	inc	hl
04040D 10 F9       0166*   	djnz	xorloop_24
04040F 2A 3B 04 04 0167*   	ld	hl,(bitbuf2)
040413 C1          0168*   	pop		bc	;restore BC
040414 D1          0169*   	pop		de	;restore DE
040415             0170*   
040415             0171*   ;------------------------------------------------------------------------
040415             0172*   ; shl_hlu: 24 bit shift left hlu by a positions
040415             0173*   ; Returns: hlu = hlu << a
040415             0174*   ;		   a = 0
040415             0175*   ; NOTE: only considers a up to 16 bits.
040415             0176*   ; preserves all other registers
040415             0177*   ; modified by Brandon R. Gates to use a instead of de
040415             0178*   ;------------------------------------------------------------------------
040415             0179*   shl_hlu:
040415 B7          0180*   	or a
040416 C8          0181*   	ret		z		;we're done
040417 29          0182*   	add		hl,hl	;shift HLU left
040418 3D          0183*   	dec a
040419 18 FA       0184*   	jr		shl_hlu
04041B             0185*   
04041B             0186*   ;------------------------------------------------------------------------
04041B             0187*   ; shr_hlu: 24 bit shift right hlu by a positions
04041B             0188*   ; Returns: hlu = hlu >> a
04041B             0189*   ;		   a = 0
04041B             0190*   ; NOTE: only considers a up to 16 bits.
04041B             0191*   ; preserves all other registers
04041B             0192*   ; modified by Brandon R. Gates to use a instead of de
04041B             0193*   ;------------------------------------------------------------------------
04041B             0194*   shr_hlu:
04041B 22 38 04 04 0195*   	ld		(bitbuf1),hl
04041F 21 3A 04 04 0196*   	ld		hl,bitbuf1+2
040423             0197*   @shr_loop:
040423 B7          0198*   	or a
040424 28 0D       0199*   	jr		z,@shr_done		;we're done
040426             0200*   ;carry is clear from or instruction
040426 CB 1E       0201*   	rr		(hl)
040428 2B          0202*   	dec		hl
040429 CB 1E       0203*   	rr		(hl)
04042B 2B          0204*   	dec		hl
04042C CB 1E       0205*   	rr		(hl)
04042E 23          0206*   	inc		hl
04042F 23          0207*   	inc		hl
040430 3D          0208*   	dec a
040431 18 F0       0209*   	jr		@shr_loop
040433             0210*   @shr_done:
040433 2A 38 04 04 0211*   	ld		hl,(bitbuf1)	;collect result
040437 C9          0212*   	ret
040438             0213*   
040438             0214*   ;------------------------------------------------------------------------
040438             0215*   ; Scratch area for calculations
040438             0216*   ;------------------------------------------------------------------------
040438 00 00 00    0217*   bitbuf1:	dw24	0	;bit manipulation buffer 1
04043B 00 00 00    0218*   bitbuf2:	dw24	0	;bit manipulation buffer 2
04043E             0219*   
04043E             0220*   ; -----------------------------------------------------------------------
04043E             0221*   ; Functions added by Brandon R. Gates
04043E             0222*   ; -----------------------------------------------------------------------
04043E             0223*   
04043E             0224*   ;------------------------------------------------------------------------
04043E             0225*   ; shr_hlu_div: Quick division by powers of two based on log2 of A
04043E             0226*   ;              Determines the LSB of A and shifts HLU accordingly.
04043E             0227*   ;              HLU = HLU >> LSB(A)
04043E             0228*   ; Returns: HLU = HLU >> LSB(A)
04043E             0229*   ; Destroys: af
04043E             0230*   ;------------------------------------------------------------------------
04043E             0231*   shr_hlu_log2a:
04043E B7          0232*   	or a    ; check for zero
04043F C8          0233*   	ret z   ; nothing to shift so we're done
040440 C5          0234*   	push 	bc ; preserve
040441 06 00       0235*   	ld		b,0 ; clear b
040443             0236*   @find_bit:
040443 0F          0237*   	rrca ; bit 0 to carry
040444 DA 4D 04 04 0238*   	jp c,@found_bit
040448 04          0239*   	inc b ; next bit
040449 C3 43 04 04 0240*   	jp @find_bit
04044D             0241*   @found_bit:
04044D 78          0242*   	ld a,b
04044E CD 1B 04 04 0243*   	call shr_hlu
040452 C1          0244*   	pop 	bc ; restore
040453 C9          0245*   	ret
040454             0246*   ; end shr_hlu_log2a
040454             0247*   
040454             0248*   ;------------------------------------------------------------------------
040454             0249*   ; shl_hlu_log2a: Quick multiplication by powers of two based on log2 of A
040454             0250*   ;                Determines the LSB of A and shifts HLU accordingly.
040454             0251*   ;                HLU = HLU << LSB(A)
040454             0252*   ; Returns: HLU = HLU << LSB(A)
040454             0253*   ; Destroys: af
040454             0254*   ;------------------------------------------------------------------------
040454             0255*   shl_hlu_log2a:
040454 B7          0256*   	or a    ; check for zero
040455 C8          0257*   	ret z   ; nothing to shift so we're done
040456 C5          0258*   	push 	bc ; preserve
040457 06 00       0259*   	ld		b,0 ; clear b
040459             0260*   @find_bit:
040459 0F          0261*   	rrca ; bit 0 to carry
04045A DA 63 04 04 0262*   	jp c,@found_bit
04045E 04          0263*   	inc b ; next bit
04045F C3 59 04 04 0264*   	jp @find_bit
040463             0265*   @found_bit:
040463 78          0266*   	ld a,b
040464 CD 15 04 04 0267*   	call shl_hlu
040468 C1          0268*   	pop 	bc ; restore
040469 C9          0269*   	ret
04046A             0270*   ; end shl_hlu_log2a
04046A             0034        include "maths.inc"
04046A             0001*   ;------------------------------------------------------------------------
04046A             0002*   ; Scratch area for calculations
04046A             0003*   ;------------------------------------------------------------------------
04046A 00 00 00    0004*   scratch1: dw24 0 ;bit manipulation buffer 1
04046D 00 00 00    0005*   scratch2: dw24 0 ;bit manipulation buffer 2
040470             0006*   
040470             0007*   ; absolute value of hlu
040470             0008*   ; returns: abs(hlu), flags set according to the incoming sign of hlu:
040470             0009*   ;         s1,z0,pv0,n1,c0 if hlu was negative
040470             0010*   ;         s0,z1,pv0,n1,c0 if hlu was zero
040470             0011*   ;         s0,z0,pv0,n1,c0 if hlu was positive
040470             0012*   ; destroys: a
040470             0013*   hlu_abs:
040470 19          0014*       add hl,de
040471 B7          0015*       or a
040472 ED 52       0016*       sbc hl,de
040474 FA 79 04 04 0017*       jp m,@is_neg
040478 C9          0018*       ret ; hlu is positive or zero so we're done
040479             0019*   @is_neg:
040479 F5          0020*       push af ; otherwise, save current flags for return
04047A CD 80 04 04 0021*       call neg_hlu ; negate hlu
04047E F1          0022*       pop af ; get back flags
04047F C9          0023*       ret
040480             0024*   
040480             0025*   ; flip the sign of hlu
040480             0026*   ; inputs: hlu
040480             0027*   ; returns: 0-hlu, flags set appropriately for the result:
040480             0028*   ;         s1,z0,pv0,n1,c1 if result is negative
040480             0029*   ;         s0,z1,pv0,n1,c0 if result is zero
040480             0030*   ;         s0,z0,pv0,n1,c1 if result is positive
040480             0031*   ; destroys a
040480             0032*   neg_hlu:
040480 D5          0033*       push de ; save de
040481 EB          0034*       ex de,hl ; put hl into de
040482 21 00 00 00 0035*       ld hl,0 ; clear hl
040486 AF          0036*       xor a ; clear carry
040487 ED 52       0037*       sbc hl,de ; 0-hlu = -hlu
040489 D1          0038*       pop de ; get de back
04048A C9          0039*       ret ; easy peasy
04048B             0040*   
04048B             0041*   ;------------------------------------------------------------------------
04048B             0042*   ; divide hlu by 2, inspired by above
04048B             0043*   ;------------------------------------------------------------------------
04048B             0044*   hlu_div2:
04048B 22 6A 04 04 0045*       ld (scratch1),hl
04048F 21 6C 04 04 0046*       ld hl,scratch1+2
040493 CB 1E       0047*       rr (hl)
040495 2B          0048*       dec hl
040496 CB 1E       0049*       rr (hl)
040498 2B          0050*       dec hl
040499 CB 1E       0051*       rr (hl)
04049B 23          0052*       inc hl
04049C 23          0053*       inc hl
04049D 2A 6A 04 04 0054*       ld hl,(scratch1)
0404A1 C9          0055*       ret
0404A2             0056*   
0404A2             0057*   ; this is my little hack to divide by 16
0404A2             0058*   hlu_div16:
0404A2 AF          0059*       xor a
0404A3 29          0060*       add hl,hl
0404A4 17          0061*       rla
0404A5 29          0062*       add hl,hl
0404A6 17          0063*       rla
0404A7 29          0064*       add hl,hl
0404A8 17          0065*       rla
0404A9 29          0066*       add hl,hl
0404AA 17          0067*       rla
0404AB 22 B8 04 04 0068*       ld (@scratch),hl
0404AF 32 BB 04 04 0069*       ld (@scratch+3),a
0404B3 2A B9 04 04 0070*       ld hl,(@scratch+1)
0404B7 C9          0071*       ret
0404B8             0072*   @scratch: ds 4
0404BC             0073*   
0404BC             0074*   ; hlu signed division by 256
0404BC             0075*   ; returns: hlu / 256
0404BC             0076*   ; destroys: af
0404BC             0077*   hlu_sdiv256:
       FF FF FF FF 
0404BC AF          0078*       xor a ; assume hl is positive
0404BD 22 D3 04 04 0079*       ld (@buffer),hl
0404C1             0080*       SIGN_HLU
                       M1 Args: none
0404C1 19          0001*M1     add hl,de ; 1 cycle
0404C2 B7          0002*M1     or a ; clear flags ; 1 cycle
0404C3 ED 52       0003*M1     sbc hl,de ; 2 cycles
0404C5             0004*M1     ; 4 cycles total
0404C5 F2 CA 04 04 0081*       jp p,@hl_pos
0404C9 3D          0082*       dec a
0404CA             0083*   @hl_pos:
0404CA 32 D6 04 04 0084*       ld (@buffer+3),a
0404CE 2A D4 04 04 0085*       ld hl,(@buffer+1)
0404D2 C9          0086*       ret
0404D3             0087*   @buffer: ds 4
0404D7             0088*   
0404D7             0089*   ; hlu 1 byte right shift, unsigned
0404D7             0090*   ; returns: hlu / 256, fractional portion in a
0404D7             0091*   ; destroys: af
0404D7             0092*   hlu_udiv256:
       FF FF FF FF 
0404D7 AF          0093*       xor a
0404D8 32 E9 04 04 0094*       ld (@buffer+3),a
0404DC 7D          0095*       ld a,l ; save the fractional portion
0404DD 22 E6 04 04 0096*       ld (@buffer),hl
0404E1 2A E7 04 04 0097*       ld hl,(@buffer+1)
0404E5 C9          0098*       ret
0404E6             0099*   @buffer: ds 4
0404EA             0100*   
0404EA             0101*   ; floor(value,n)
0404EA             0102*   ; inputs: hl = value to floor, de = n
0404EA             0103*   ; outputs: hl = value floored to n
0404EA             0104*   ; destroys: af, hl, bc, de
0404EA             0105*   hlu_floor:
       FF FF FF FF 
0404EA D5          0106*       push de ; save n
0404EB CD 80 03 04 0107*       call udiv24 ; de = quotient, hl = remainder
0404EF E1          0108*       pop hl ; get n back (was de)
0404F0 CD 67 03 04 0109*       call umul24 ; hl = n * quotient
0404F4 C9          0110*       ret
0404F5             0111*   ; end hlu_floor
0404F5             0112*   
0404F5             0113*   ; ceil(value,n)
0404F5             0114*   ; inputs: hl = value to ceil, de = n
0404F5             0115*   ; outputs: hl = value ceiled to n
0404F5             0116*   ; destroys: af, hl, bc, de
0404F5             0117*   hlu_ceiling:
0404F5 D5          0118*       push de ; save n
0404F6 CD 80 03 04 0119*       call udiv24 ; de = quotient, hl = remainder
0404FA             0120*       SIGN_HLU ; test remaider for zero
                       M1 Args: none
0404FA 19          0001*M1     add hl,de ; 1 cycle
0404FB B7          0002*M1     or a ; clear flags ; 1 cycle
0404FC ED 52       0003*M1     sbc hl,de ; 2 cycles
0404FE             0004*M1     ; 4 cycles total
0404FE CA 03 05 04 0121*       jp z,@F ; if zero, nothing to add
040502 13          0122*       inc de ; add 1 to quotient for the ceiling
040503             0123*   @@:
040503 E1          0124*       pop hl ; get n back (was de)
040504 CD 67 03 04 0125*       call umul24 ; hl = n * quotient
040508 C9          0126*       ret
040509             0127*   ; end hlu_ceiling
040509             0128*   
040509 C9          0129*       ret
04050A             0130*   
04050A 00 00 00 00 0131*   add_bcd_arg1: db #00,#00,#00,#00
04050E 00 00 00 00 0132*   add_bcd_arg2: db #00,#00,#00,#00
040512             0133*   
040512             0134*   ; set bcd values in a scratch memory address from registers bcde
040512             0135*   ; input: hl; scratch address,bcde; 8-place bcd number
040512             0136*   ; destroys ; hl
040512             0137*   set_bcd:
040512 73          0138*       ld (hl),e
040513 23          0139*       inc hl
040514 72          0140*       ld (hl),d
040515 23          0141*       inc hl
040516 71          0142*       ld (hl),c
040517 23          0143*       inc hl
040518 70          0144*       ld (hl),b
040519 C9          0145*       ret
04051A             0146*   
04051A             0147*   ; load bcd values from a scratch memory address to bcde
04051A             0148*   ; input: hl; scratch address
04051A             0149*   ; output: bcde; 8-place bcd number
04051A             0150*   ; destroys: hl
04051A             0151*   get_bcd:
04051A 5E          0152*       ld e,(hl)
04051B 23          0153*       inc hl
04051C 56          0154*       ld d,(hl)
04051D 23          0155*       inc hl
04051E 4E          0156*       ld c,(hl)
04051F 23          0157*       inc hl
040520 46          0158*       ld b,(hl)
040521 C9          0159*       ret
040522             0160*   
040522             0161*   ; BCD addition
040522             0162*   ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
040522             0163*   ;       a is the number of bytes holding each number (number of places/2)
040522             0164*   ; outputs: (hl) + (de) --> (hl)
040522             0165*   ; destroys: a,b,de,hl
040522             0166*   add_bcd:
040522 47          0167*       ld b,a ; loop counter
040523 AF          0168*       xor a ; reset a, clear carry flag
040524             0169*   adcec:
040524 1A          0170*       ld a,(de) ; addend to acc
040525 8E          0171*       adc a,(hl) ; add (hl) to acc
040526 27          0172*       daa ; adjust result to bcd
040527 77          0173*       ld (hl),a ; store result
040528 23          0174*       inc hl ; advance memory pointers
040529 13          0175*       inc de
04052A 10 F8       0176*       djnz adcec ; loop until b == 0
04052C C9          0177*       ret
04052D             0178*   
04052D             0179*   ; BCD subtraction
04052D             0180*   ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
04052D             0181*   ;       a is the number of bytes holding each number (number of places/2)
04052D             0182*   ; outputs: (hl) - (de) --> (hl)
04052D             0183*   ; destroys: a,b,de,hl
04052D             0184*   sub_bcd:
04052D 47          0185*       ld b,a ; loop counter
04052E AF          0186*       xor a ; reset a,clear carry flag
04052F             0187*   subdec:
04052F 1A          0188*       ld a,(de) ; subtrahend to acc
040530 9E          0189*       sbc a,(hl) ; subtract (hl) from acc
040531 27          0190*       daa ; adjust result to bcd
040532 77          0191*       ld (hl),a ; store result
040533 23          0192*       inc hl ; advance memory pointers
040534 13          0193*       inc de
040535 10 F8       0194*       djnz subdec ; loop until b == 0
040537 C9          0195*       ret
040538             0196*   
040538             0197*   ; http://www.z80.info/pseudo-random.txt
040538             0198*   rand_8:
040538 C5          0199*       push bc
040539 3A 4C 05 04 0200*       ld a,(r_seed)
04053D 4F          0201*       ld c,a
04053E             0202*   
04053E 0F          0203*       rrca ; multiply by 32
04053F 0F          0204*       rrca
040540 0F          0205*       rrca
040541 EE 1F       0206*       xor 0x1f
040543             0207*   
040543 81          0208*       add a,c
040544 DE FF       0209*       sbc a,255 ; carry
040546             0210*   
040546 32 4C 05 04 0211*       ld (r_seed),a
04054A C1          0212*       pop bc
04054B C9          0213*       ret
04054C 50          0214*   r_seed: defb $50
04054D             0215*   
04054D             0216*   ; https://www.omnimaga.org/asm-language/ez80-optimized-routines/msg399325/#msg399325
04054D             0217*   prng24:
04054D             0218*   ;;Expects ADL mode.
04054D             0219*   ;;Output: HL
04054D             0220*   ;;50cc
04054D             0221*   ;;33 bytes
04054D             0222*   ;;cycle length: 281,474,959,933,440 (about 2.8 trillion)
04054D ED 5B 6E 05 0223*       ld de,(seed1)
       04          
040552 B7          0224*       or a
040553 ED 62       0225*       sbc hl,hl
040555 19          0226*       add hl,de
040556 29          0227*       add hl,hl
040557 29          0228*       add hl,hl
040558 2C          0229*       inc l
040559 19          0230*       add hl,de
04055A 22 6E 05 04 0231*       ld (seed1),hl
04055E 2A 71 05 04 0232*       ld hl,(seed2)
040562 29          0233*       add hl,hl
040563 9F          0234*       sbc a,a
040564 E6 1B       0235*       and %00011011
040566 AD          0236*       xor l
040567 6F          0237*       ld l,a
040568 22 71 05 04 0238*       ld (seed2),hl
04056C 19          0239*       add hl,de
04056D C9          0240*       ret
04056E 00 00 00    0241*   seed1: dl 0
040571 00 00 00    0242*   seed2: dl 0
040574             0243*   
040574             0244*   
040574             0245*   ; https://map.grauw.nl/sources/external/z80bits.html#2.1
040574             0246*   ; 2.1 Restoring 8-bit / 8-bit Unsigned
040574             0247*   ; Input: H = Dividend, L = Divisor, A = 0
040574             0248*   ; Output: H = Quotient, A = Remainder, L = Divisor (unchanged)
040574             0249*   udiv8:
040574 AF          0250*       xor a
040575 06 08       0251*       ld b,8
040577             0252*   @loop:
040577 CB 24       0253*       sla h
040579 17          0254*       rla
04057A BD          0255*       cp l
04057B 38 02       0256*       jr c,$+4
04057D 95          0257*       sub l
04057E 24          0258*       inc h
04057F 10 F6       0259*       djnz @loop
040581 C9          0260*       ret
040582             0035        include "fonts.inc"
040582             0001*   fonts_load:
040582 DD 21 B3 05 0002*       ld ix,font_list ; pointer to font list lookup
       04          
040587 06 01       0003*       ld b,num_fonts ; loop counter
040589             0004*   
040589             0005*   @load_loop:
040589 C5          0006*       push bc ; save loop counter
04058A             0007*   
04058A             0008*   ; load font into a buffer
04058A DD 27 06    0009*       ld hl,(ix+font_list_bufferId)
04058D DD 31 09    0010*       ld iy,(ix+font_list_filename)
040590 CD D5 14 04 0011*       call vdu_load_buffer_from_file
040594             0012*   
040594             0013*   ; create font from buffer
040594 DD 27 06    0014*       ld hl,(ix+font_list_bufferId)
040597 DD 5E 00    0015*       ld e,(ix+font_list_width)
04059A DD 56 03    0016*       ld d,(ix+font_list_height)
04059D 3E 00       0017*       ld a,0 ; flags
04059F CD 28 17 04 0018*       call vdu_font_create
0405A3             0019*   
0405A3             0020*   ; select font
0405A3 DD 27 06    0021*       ld hl,(ix+font_list_bufferId)
0405A6 3E 01       0022*       ld a,1 ; flags
0405A8 CD 0E 17 04 0023*       call vdu_font_select
0405AC             0024*   
0405AC             0025*   ; ; debug print filename
0405AC             0026*   ;     call printNewLine
0405AC             0027*   ;     ld hl,(ix+font_list_filename)
0405AC             0028*   ;     call printString
0405AC             0029*   
0405AC             0030*   ; advance font_list pointer to next record
0405AC ED 32 0C    0031*       lea ix,ix+font_list_record_size
0405AF             0032*   
0405AF             0033*   ; restore loop counter
0405AF C1          0034*       pop bc
0405B0 10 D7       0035*       djnz @load_loop
0405B2             0036*   
0405B2             0037*   ; all done
0405B2 C9          0038*       ret
0405B3             0036        include "fonts_list.inc"
0405B3             0001*   ; Generated by asm_config_editor.py
0405B3             0002*   font_list_record_size: equ 12
0405B3             0003*   font_list_width: equ 0
0405B3             0004*   font_list_height: equ 3
0405B3             0005*   font_list_bufferId: equ 6
0405B3             0006*   font_list_filename: equ 9
0405B3             0007*   
0405B3             0008*   ; num_fonts: equ 28
0405B3             0009*   num_fonts: equ 1
0405B3             0010*   
0405B3             0011*   ; Index list:
0405B3             0012*   ; amiga_forever_16x16: equ 64000
0405B3             0013*   ; amiga_forever_16x24: equ 64001
0405B3             0014*   ; amiga_forever_8x16: equ 64002
0405B3             0015*   ; amiga_forever_8x8: equ 64003
0405B3             0016*   ; computer_pixel_7_10x15: equ 64004
0405B3             0017*   ; computer_pixel_7_10x24: equ 64005
0405B3             0018*   ; computer_pixel_7_8x12: equ 64006
0405B3             0019*   ; computer_pixel_7_8x14: equ 64007
0405B3             0020*   ; computer_pixel_7_8x16: equ 64008
0405B3             0021*   ; dopecre_8x8: equ 64009
0405B3             0022*   ; gamer_2_8x8: equ 64010
0405B3             0023*   ; Lat15_VGA8_8x8: equ 64011
0405B3             0024*   ; Lat2_Terminus12x6_6x12: equ 64012
0405B3             0025*   ; Lat2_TerminusBold14_8x14: equ 64013
0405B3             0026*   ; Lat2_VGA14_8x14: equ 64014
0405B3             0027*   ; Lat2_VGA16_8x16: equ 64015
0405B3             0028*   Lat2_VGA8_8x8: equ 64016
0405B3             0029*   ; Lat38_VGA8_8x8: equ 64017
0405B3             0030*   ; Lat7_Fixed13_8x13: equ 64018
0405B3             0031*   ; Lat7_Terminus12x6_6x12: equ 64019
0405B3             0032*   ; Lat7_TerminusBold16_8x16: equ 64020
0405B3             0033*   ; Lat7_VGA14_8x14: equ 64021
0405B3             0034*   ; Lat7_VGA16_8x16: equ 64022
0405B3             0035*   ; Lat7_VGA8_8x8: equ 64023
0405B3             0036*   ; planetary_contact_8x8: equ 64024
0405B3             0037*   ; scriptorium_12x14: equ 64025
0405B3             0038*   ; Squarewave_Bold_8x12: equ 64026
0405B3             0039*   ; super_mario_bros_2_8x8: equ 64027
0405B3             0040*   ; wendy_neue_6x6: equ 64028
0405B3             0041*   
0405B3             0042*   font_list: ; width; height; bufferId; filename;:
0405B3             0043*   	; dl 16, 16, 64000, fn_amiga_forever_16x16
0405B3             0044*   	; dl 16, 24, 64001, fn_amiga_forever_16x24
0405B3             0045*   	; dl 8, 16, 64002, fn_amiga_forever_8x16
0405B3             0046*   	; dl 8, 8, 64003, fn_amiga_forever_8x8
0405B3             0047*   	; dl 10, 15, 64004, fn_computer_pixel_7_10x15
0405B3             0048*   	; dl 10, 24, 64005, fn_computer_pixel_7_10x24
0405B3             0049*   	; dl 8, 12, 64006, fn_computer_pixel_7_8x12
0405B3             0050*   	; dl 8, 14, 64007, fn_computer_pixel_7_8x14
0405B3             0051*   	; dl 8, 16, 64008, fn_computer_pixel_7_8x16
0405B3             0052*   	; dl 8, 8, 64009, fn_dopecre_8x8
0405B3             0053*   	; dl 8, 8, 64010, fn_gamer_2_8x8
0405B3             0054*   	; dl 8, 8, 64011, fn_Lat15_VGA8_8x8
0405B3             0055*   	; dl 6, 12, 64012, fn_Lat2_Terminus12x6_6x12
0405B3             0056*   	; dl 8, 14, 64013, fn_Lat2_TerminusBold14_8x14
0405B3             0057*   	; dl 8, 14, 64014, fn_Lat2_VGA14_8x14
0405B3             0058*   	; dl 8, 16, 64015, fn_Lat2_VGA16_8x16
0405B3 08 00 00 08 0059*   	dl 8, 8, 64016, fn_Lat2_VGA8_8x8
       00 00 10 FA 
       00 BF 05 04 
0405BF             0060*   	; dl 8, 8, 64017, fn_Lat38_VGA8_8x8
0405BF             0061*   	; dl 8, 13, 64018, fn_Lat7_Fixed13_8x13
0405BF             0062*   	; dl 6, 12, 64019, fn_Lat7_Terminus12x6_6x12
0405BF             0063*   	; dl 8, 16, 64020, fn_Lat7_TerminusBold16_8x16
0405BF             0064*   	; dl 8, 14, 64021, fn_Lat7_VGA14_8x14
0405BF             0065*   	; dl 8, 16, 64022, fn_Lat7_VGA16_8x16
0405BF             0066*   	; dl 8, 8, 64023, fn_Lat7_VGA8_8x8
0405BF             0067*   	; dl 8, 8, 64024, fn_planetary_contact_8x8
0405BF             0068*   	; dl 12, 14, 64025, fn_scriptorium_12x14
0405BF             0069*   	; dl 8, 12, 64026, fn_Squarewave_Bold_8x12
0405BF             0070*   	; dl 8, 8, 64027, fn_super_mario_bros_2_8x8
0405BF             0071*   	; dl 6, 6, 64028, fn_wendy_neue_6x6
0405BF             0072*   
0405BF             0073*   ; files_list: ; filename:
0405BF             0074*   ; fn_amiga_forever_16x16: db "fonts/amiga_forever_16x16.font",0
0405BF             0075*   ; fn_amiga_forever_16x24: db "fonts/amiga_forever_16x24.font",0
0405BF             0076*   ; fn_amiga_forever_8x16: db "fonts/amiga_forever_8x16.font",0
0405BF             0077*   ; fn_amiga_forever_8x8: db "fonts/amiga_forever_8x8.font",0
0405BF             0078*   ; fn_computer_pixel_7_10x15: db "fonts/computer_pixel_7_10x15.font",0
0405BF             0079*   ; fn_computer_pixel_7_10x24: db "fonts/computer_pixel_7_10x24.font",0
0405BF             0080*   ; fn_computer_pixel_7_8x12: db "fonts/computer_pixel_7_8x12.font",0
0405BF             0081*   ; fn_computer_pixel_7_8x14: db "fonts/computer_pixel_7_8x14.font",0
0405BF             0082*   ; fn_computer_pixel_7_8x16: db "fonts/computer_pixel_7_8x16.font",0
0405BF             0083*   ; fn_dopecre_8x8: db "fonts/dopecre_8x8.font",0
0405BF             0084*   ; fn_gamer_2_8x8: db "fonts/gamer_2_8x8.font",0
0405BF             0085*   ; fn_Lat15_VGA8_8x8: db "fonts/Lat15-VGA8_8x8.font",0
0405BF             0086*   ; fn_Lat2_Terminus12x6_6x12: db "fonts/Lat2-Terminus12x6_6x12.font",0
0405BF             0087*   ; fn_Lat2_TerminusBold14_8x14: db "fonts/Lat2-TerminusBold14_8x14.font",0
0405BF             0088*   ; fn_Lat2_VGA14_8x14: db "fonts/Lat2-VGA14_8x14.font",0
0405BF             0089*   ; fn_Lat2_VGA16_8x16: db "fonts/Lat2-VGA16_8x16.font",0
0405BF 66 6F 6E 74 0090*   fn_Lat2_VGA8_8x8: db "fonts/Lat2-VGA8_8x8.font",0
       73 2F 4C 61 
       74 32 2D 56 
       47 41 38 5F 
       38 78 38 2E 
       66 6F 6E 74 
       00          
0405D8             0091*   ; fn_Lat38_VGA8_8x8: db "fonts/Lat38-VGA8_8x8.font",0
0405D8             0092*   ; fn_Lat7_Fixed13_8x13: db "fonts/Lat7-Fixed13_8x13.font",0
0405D8             0093*   ; fn_Lat7_Terminus12x6_6x12: db "fonts/Lat7-Terminus12x6_6x12.font",0
0405D8             0094*   ; fn_Lat7_TerminusBold16_8x16: db "fonts/Lat7-TerminusBold16_8x16.font",0
0405D8             0095*   ; fn_Lat7_VGA14_8x14: db "fonts/Lat7-VGA14_8x14.font",0
0405D8             0096*   ; fn_Lat7_VGA16_8x16: db "fonts/Lat7-VGA16_8x16.font",0
0405D8             0097*   ; fn_Lat7_VGA8_8x8: db "fonts/Lat7-VGA8_8x8.font",0
0405D8             0098*   ; fn_planetary_contact_8x8: db "fonts/planetary_contact_8x8.font",0
0405D8             0099*   ; fn_scriptorium_12x14: db "fonts/scriptorium_12x14.font",0
0405D8             0100*   ; fn_Squarewave_Bold_8x12: db "fonts/Squarewave_Bold_8x12.font",0
0405D8             0101*   ; fn_super_mario_bros_2_8x8: db "fonts/super_mario_bros_2_8x8.font",0
0405D8             0102*   ; fn_wendy_neue_6x6: db "fonts/wendy_neue_6x6.font",0
0405D8             0037        include "fixed168.inc"
0405D8             0001*   ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
0405D8             0002*   ; uses EZ80 MLT instruction for speed
0405D8             0003*   ; operation: UHL * A --> UHL
0405D8             0004*   ; destroys: AF, HL
0405D8             0005*   smul24x8:
0405D8             0006*   ; make hl positive and store sign flag
0405D8 CD 70 04 04 0007*       call hlu_abs
0405DC F5          0008*       push af
0405DD             0009*   ; do the division
0405DD CD E8 05 04 0010*       call mul24x8 ; hl = product
0405E1             0011*   ; adjust sign of result
0405E1 F1          0012*       pop af ; sign de
0405E2 F0          0013*       ret p ; hl was positive, nothing to do
0405E3 CD 80 04 04 0014*       call neg_hlu ; result is negative
0405E7 C9          0015*       ret
0405E8             0016*   
0405E8             0017*   ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
0405E8             0018*   ; uses EZ80 MLT instruction for speed
0405E8             0019*   ; operation: UHL * A --> AUHL
0405E8             0020*   ; destroys: AF, HL
0405E8             0021*   mul24x8:
0405E8 D5          0022*       push de ; preserve de
0405E9             0023*   ; low byte
0405E9 5D          0024*       ld e,l
0405EA 57          0025*       ld d,a
0405EB ED 5C       0026*       mlt de
0405ED 6B          0027*       ld l,e ; product low byte
0405EE 08          0028*       ex af,af' ; save multiplier
0405EF 7A          0029*       ld a,d ; carry
0405F0 08          0030*       ex af,af' ; save carry, restore multiplier
0405F1             0031*   ; high byte
0405F1 5C          0032*       ld e,h
0405F2 57          0033*       ld d,a
0405F3 ED 5C       0034*       mlt de
0405F5 08          0035*       ex af,af' ; save multiplier, restore carry
0405F6 83          0036*       add a,e ; add carry
0405F7 67          0037*       ld h,a ; product middle byte
0405F8 7A          0038*       ld a,d ; carry
0405F9 08          0039*       ex af,af' ; save carry, restore multiplier
0405FA             0040*   ; upper byte
0405FA 22 15 06 04 0041*       ld (@scratch),hl ; 7 cycles
0405FE 5F          0042*       ld e,a
0405FF 3A 17 06 04 0043*       ld a,(@scratch+2)
040603 57          0044*       ld d,a
040604 ED 5C       0045*       mlt de
040606 08          0046*       ex af,af' ; restore carry
040607 8B          0047*       adc a,e ; add carry
040608 32 17 06 04 0048*       ld (@scratch+2),a ; 5 cycles
04060C 2A 15 06 04 0049*       ld hl,(@scratch) ; 7 cycles
040610             0050*   ; highest byte
040610 3E 00       0051*       ld a,0 ; preserve carry flag
040612 8A          0052*       adc a,d ; product highest byte
040613 D1          0053*       pop de ; restore de
040614 C9          0054*       ret
040615             0055*   @scratch: ds 3
040618             0056*   
       FF FF FF 
040618 00 00 00 00 0057*   mul24out: blkb 6,0
       00 00       
04061E             0058*   
04061E             0059*   ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
04061E             0060*   ; operation: UHL * UDE --> mul24out
04061E             0061*   mul24:
04061E DD E5       0062*       push ix ; preserve
040620             0063*   ; point to output buffer and clear it
040620 DD 21 18 06 0064*       ld ix,mul24out
       04          
040625 C5          0065*       push bc
040626 01 00 00 00 0066*       ld bc,0
04062A DD 0F 00    0067*       ld (ix),bc
04062D DD 0F 03    0068*       ld (ix+3),bc
040630 C1          0069*       pop bc
040631             0070*   ; STEP 1: UHL * E
040631 7B          0071*       ld a,e
040632 E5          0072*       push hl
040633 CD E8 05 04 0073*       call mul24x8
040637 DD 2F 00    0074*       ld (ix+0),hl
04063A DD 77 03    0075*       ld (ix+3),a
04063D             0076*   ; STEP 2: UHL * D
04063D E1          0077*       pop hl
04063E E5          0078*       push hl
04063F 7A          0079*       ld a,d
040640 CD E8 05 04 0080*       call mul24x8
040644 CD 5D 06 04 0081*       call @accumulate
040648             0082*   ; STEP 3: UHL * DEU
040648 E1          0083*       pop hl
040649 ED 53 8D 06 0084*       ld (@de),de
       04          
04064E 3A 8F 06 04 0085*       ld a,(@de+2)
040652 CD E8 05 04 0086*       call mul24x8
040656 CD 5D 06 04 0087*       call @accumulate
04065A             0088*   ; all done
04065A DD E1       0089*       pop ix ; restore
04065C C9          0090*       ret
04065D             0091*   @accumulate:
04065D DD 23       0092*       inc ix
04065F             0093*   ; highest byte of product to carry
04065F DD 77 03    0094*       ld (ix+3),a
040662             0095*   ; low byte of product
040662 7D          0096*       ld a,l
040663 DD 86 00    0097*       add a,(ix+0)
040666 DD 77 00    0098*       ld (ix+0),a
040669             0099*   ; high byte of product
040669 7C          0100*       ld a,h
04066A DD 8E 01    0101*       adc a,(ix+1)
04066D DD 77 01    0102*       ld (ix+1),a
040670             0103*   ; uppper byte of product
040670 22 8A 06 04 0104*       ld (@hl),hl
040674 3A 8C 06 04 0105*       ld a,(@hl+2)
040678 DD 8E 02    0106*       adc a,(ix+2)
04067B DD 77 02    0107*       ld (ix+2),a
04067E             0108*   ; carry
04067E 3E 00       0109*       ld a,0 ; preserve flags
040680 DD 8E 03    0110*       adc a,(ix+3)
040683 DD 77 03    0111*       ld (ix+3),a
040686 C9          0112*       ret
040687             0113*   
040687 00 00 00    0114*   @ix: dl 0
04068A 00 00 00    0115*   @hl: dl 0
04068D 00 00 00    0116*   @de: dl 0
040690             0117*   
040690             0118*   ; ; UHL * UDE --> UHL (unsigned)
040690             0119*   ; umul24:
040690             0120*   ;     call mul24
040690             0121*   ;     ld hl,(mul24out)
040690             0122*   ;     ret
040690             0123*   
040690             0124*   ; UH.L = UH.L*UD.E (unsigned)
040690             0125*   umul168:
040690 CD 1E 06 04 0126*       call mul24
040694 2A 19 06 04 0127*       ld hl,(mul24out+1)
040698 C9          0128*       ret
040699             0129*   
040699             0130*   ; UH.L * UD.E --> UH.L (signed)
040699             0131*   smul168:
040699             0132*   ; make everything positive and store sign flags
040699 CD 70 04 04 0133*       call hlu_abs
04069D F5          0134*       push af
04069E EB          0135*       ex de,hl
04069F CD 70 04 04 0136*       call hlu_abs
0406A3 EB          0137*       ex de,hl
0406A4 F5          0138*       push af
0406A5             0139*   ; do the division
0406A5 CD 90 06 04 0140*       call umul168 ; hl = product
0406A9             0141*   ; adjust sign of result
0406A9 F1          0142*       pop af ; sign de
0406AA FA B5 06 04 0143*       jp m,@de_neg
0406AE F1          0144*       pop af ; sign hl
0406AF F0          0145*       ret p ; both positive, nothing to do
0406B0             0146*   @hl_neg:
0406B0 CD 80 04 04 0147*       call neg_hlu ; de pos, hl neg, result is negative
0406B4 C9          0148*       ret
0406B5             0149*   @de_neg:
0406B5 F1          0150*       pop af
0406B6 F8          0151*       ret m ; both negative, nothing to do
0406B7 CD 80 04 04 0152*       call neg_hlu ; result is negative
0406BB C9          0153*       ret
0406BC             0154*   
0406BC             0155*   ; UH.L / UD.E --> UD.E rem UHL (unsigned)
0406BC             0156*   ; perform unsigned division of 16.8 fixed place values
0406BC             0157*   ; with an unsigned 16.8 fixed place result and 24-bit remainder
0406BC             0158*   udiv168:
0406BC             0159*   ; back up divisor
0406BC ED 53 F3 06 0160*       ld (@ude),de
       04          
0406C1             0161*   ; get the 16-bit integer part of the quotient
0406C1 CD 80 03 04 0162*       call udiv24 ; de = quotient, hl = remainder
0406C5             0163*   ; load quotient to upper three bytes of output
0406C5 ED 53 FA 06 0164*       ld (div168_out+1),de
       04          
0406CA             0165*   @div256:
0406CA             0166*   ; multiply remainder by 256
0406CA             0167*       hlu_mul256
                       M1 Args: none
0406CA 29          0001*M1     add hl,hl ; * 2
0406CB 29          0002*M1     add hl,hl ; * 4
0406CC 29          0003*M1     add hl,hl ; * 8
0406CD 29          0004*M1     add hl,hl ; * 16
0406CE 29          0005*M1     add hl,hl ; * 32
0406CF 29          0006*M1     add hl,hl ; * 64
0406D0 29          0007*M1     add hl,hl ; * 128
0406D1 29          0008*M1     add hl,hl ; * 256
0406D2             0168*   ; skip fractional computation if remainder is zero
0406D2             0169*       SIGN_HLU
                       M1 Args: none
0406D2 19          0001*M1     add hl,de ; 1 cycle
0406D3 B7          0002*M1     or a ; clear flags ; 1 cycle
0406D4 ED 52       0003*M1     sbc hl,de ; 2 cycles
0406D6             0004*M1     ; 4 cycles total
0406D6 20 03       0170*       jr nz,@div_frac
0406D8 AF          0171*       xor a
0406D9 18 0A       0172*       jr @write_frac
0406DB             0173*   ; now divide the shifted remainder by the divisor
0406DB             0174*   @div_frac:
0406DB ED 5B F3 06 0175*       ld de,(@ude) ; get back divisor
       04          
0406E0 CD 80 03 04 0176*       call udiv24 ; de = quotient, hl = remainder
0406E4             0177*   ; load low byte of quotient to low byte of output
0406E4 7B          0178*       ld a,e
0406E5             0179*   @write_frac:
0406E5 32 F9 06 04 0180*       ld (div168_out),a
0406E9             0181*   ; load de with return value
0406E9 ED 5B F9 06 0182*       ld de,(div168_out)
       04          
0406EE             0183*   ; load a with any overflow
0406EE 3A FC 06 04 0184*       ld a,(div168_out+3)
0406F2 C9          0185*       ret ; ud.e is the 16.8 result
0406F3             0186*   @ude: ds 6
0406F9             0187*   div168_out: ds 4 ; the extra byte is for overflow
0406FD             0188*   
0406FD             0189*   ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
0406FD             0190*   ; perform signed division of 16.8 fixed place values
0406FD             0191*   ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
0406FD             0192*   sdiv168:
0406FD             0193*   ; make everything positive and store sign flags
       FF FF FF FF 
       FF FF FF FF 
       FF FF 
0406FD CD 70 04 04 0194*       call hlu_abs
040701 F5          0195*       push af
040702 EB          0196*       ex de,hl
040703 CD 70 04 04 0197*       call hlu_abs
040707 EB          0198*       ex de,hl
040708 F5          0199*       push af
040709             0200*   ; do the division
040709 CD BC 06 04 0201*       call udiv168 ; de = quotient, hl = remainder
04070D             0202*   ; adjust sign of result
04070D F1          0203*       pop af ; sign de
04070E FA 1B 07 04 0204*       jp m,@de_neg
040712 F1          0205*       pop af ; sign hl
040713 F0          0206*       ret p ; both positive, nothing to do
040714             0207*   @hl_neg:
040714 EB          0208*       ex de,hl ; hl = quotient, de = remainder
040715 CD 80 04 04 0209*       call neg_hlu ; de pos, hl neg, result is negative
040719 EB          0210*       ex de,hl ; de = negated quotient, hl = remainder
04071A C9          0211*       ret
04071B             0212*   @de_neg:
04071B F1          0213*       pop af
04071C F8          0214*       ret m ; both negative, nothing to do
04071D EB          0215*       ex de,hl ; hl = quotient, de = remainder
04071E CD 80 04 04 0216*       call neg_hlu ; result is negative
040722 EB          0217*       ex de,hl ; de = negated quotient, hl = remainder
040723 C9          0218*       ret
040724             0219*   
040724             0220*   ; convert signed angles from a 360 to 256 degree circle
040724             0221*   ; inputs: uh.l is the angle360 in 16.8 fixed format
040724             0222*   ; outputs: uh.l is the angle256 in 16.8 fixed format
040724             0223*   ; destroys: TODO
040724             0224*   deg_360_to_256:
040724 D5          0225*       push de ; preserve de
040725             0226*   ; make angle positive and store sign flag
040725 CD 70 04 04 0227*       call hlu_abs
040729 F5          0228*       push af
04072A             0229*   ; multiply by coversion factor of 256/360
04072A 11 B6 00 00 0230*       ld de,0x0000B6 ; 0.711
04072E CD 90 06 04 0231*       call umul168 ; uh.l = uh.l * 0.711
040732             0232*   ; restore sign flag and adjust output accordingly
040732 F1          0233*       pop af
040733 F2 3B 07 04 0234*       jp p,@pos ; positive number
040737 CD 80 04 04 0235*       call neg_hlu
04073B             0236*   @pos:
04073B             0237*   ; restore de and return uh.l as the result
04073B D1          0238*       pop de
04073C C9          0239*       ret
04073D             0240*   
04073D             0241*   ; convert signed angles from a 256 to 360 degree circle
04073D             0242*   ; inputs: uh.l is the angle256 in 16.8 fixed format
04073D             0243*   ; outputs: uh.l is the angle360 in 16.8 fixed format
04073D             0244*   ; destroys: TODO
04073D             0245*   deg_256_to_360:
04073D D5          0246*       push de ; preserve de
04073E             0247*   ; make angle positive and store sign flag
04073E CD 70 04 04 0248*       call hlu_abs
040742 F5          0249*       push af
040743             0250*   ; multiply by coversion factor of 360/256
040743 11 68 01 00 0251*       ld de,0x000168 ; 1.406
040747 CD 90 06 04 0252*       call umul168 ; uh.l = uh.l * 1.406
04074B             0253*   ; restore sign flag and adjust output accordingly
04074B F1          0254*       pop af
04074C F2 54 07 04 0255*       jp p,@pos ; positive number
040750 CD 80 04 04 0256*       call neg_hlu
040754             0257*   @pos:
040754             0258*   ; restore de and return uh.l as the result
040754 D1          0259*       pop de
040755 C9          0260*       ret
040756             0261*   
040756             0262*   ; fixed 16.8 routine
040756             0263*   ; cos(uh.l) --> uh.l
040756             0264*   ; destroys: f, hl
040756             0265*   cos168:
040756 D5          0266*       push de ; preserve de
040757             0267*   ; for cos we simply increment the angle by 90 degrees
040757             0268*   ; or 0x004000 in 16.8 degrees256
040757             0269*   ; which makes it a sin problem
040757 11 00 40 00 0270*       ld de,0x004000
04075B 19          0271*       add hl,de ; modulo 256 happens below
04075C D1          0272*       pop de ; restore de
04075D             0273*   ; fall through to sin168
04075D             0274*   
04075D             0275*   ; ---------------------
04075D             0276*   ; fixed 16.8 routine
04075D             0277*   ; sin(uh.l) --> uh.l
04075D             0278*   ; destroys: f, hl
04075D             0279*   sin168:
04075D D5          0280*       push de
04075E             0281*   ; handle negative angles appropriately
04075E CD 70 04 04 0282*       call hlu_abs
040762 F2 6B 07 04 0283*       jp p,@F
040766 11 00 00 FF 0284*       ld de,-256*256
04076A 19          0285*       add hl,de
04076B             0286*   @@:
04076B 2E 03       0287*       ld l,3 ; multiply by 3 to get our lookup index
04076D ED 6C       0288*       mlt hl
04076F 11 23 0A 04 0289*       ld de,sin_lut_168 ; grab the lut address
040773 19          0290*       add hl,de ; bump hl by the index
040774 ED 27       0291*       ld hl,(hl) ; don't try this on a z80!
040776 D1          0292*       pop de
040777 C9          0293*       ret
040778             0294*   
040778             0295*   ; 16.8 fixed inputs / outputs
040778             0296*   ; takes: uh.l as angle in degrees 256
040778             0297*   ;        ud.e as radius
040778             0298*   ; returns ub.c as dx, ud.e as dy, uh.l as radius
040778             0299*   ;        displacements from origin (0,0)
040778             0300*   ; destroys: everything except indexes
040778             0301*   polar_to_cartesian:
040778             0302*   ; back up input parameters
040778 22 A7 07 04 0303*       ld (@angle), hl
04077C ED 53 AA 07 0304*       ld (@radius), de
       04          
040781             0305*   ; compute dx = sin(uh.l) * ud.e
040781 CD 5D 07 04 0306*       call sin168 ; uh.l = sin(uh.l)
040785 ED 5B AA 07 0307*       ld de,(@radius)
       04          
04078A CD 99 06 04 0308*       call smul168 ; uh.l = dx
04078E E5          0309*       push hl
04078F             0310*   ; compute dy = -cos(uh.l) * ud.e
04078F 2A A7 07 04 0311*       ld hl,(@angle)
040793 CD 56 07 04 0312*       call cos168 ; uh.l = cos(uh.l)
040797 ED 5B AA 07 0313*       ld de,(@radius)
       04          
04079C CD 99 06 04 0314*       call smul168 ; uh.l = dy
0407A0 CD 80 04 04 0315*       call neg_hlu ; invert dy for screen coords convention
0407A4 EB          0316*       ex de,hl ; de = dy for output
0407A5 C1          0317*       pop bc ; bc = dx for output
0407A6             0318*   ; and out
0407A6 C9          0319*       ret
0407A7             0320*   @angle: ds 3
0407AA             0321*   @radius: ds 3
0407AD             0322*   
0407AD             0323*   ; 16.8 fixed inputs / outputs
0407AD             0324*   ; inputs: ub.c as dx, ud.e as dy
0407AD             0325*   ;        displacements from origin (0,0)
0407AD             0326*   ; returns: uh.l as angle in degrees 256
0407AD             0327*   ;        ud.e as radius
0407AD             0328*   ; destroys: everything except indexes
0407AD             0329*   cartesian_to_polar:
       FF FF FF FF 
       FF FF 
0407AD ED 43 06 08 0330*       ld (dx168),bc ; dx argument for distance168
       04          
0407B2 ED 53 0C 08 0331*       ld (dy168),de ; dy argument for distance168
       04          
0407B7             0332*   ; compute radius
0407B7 CD 12 08 04 0333*       call distance168 ; uh.l = radius
0407BB E5          0334*       push hl ; save radius
0407BC             0335*   ; compute angle
0407BC ED 4B 06 08 0336*       ld bc,(dx168) ; dx argument for atan2_168fast
       04          
0407C1 ED 5B 0C 08 0337*       ld de,(dy168) ; dy argument for atan2_168fast
       04          
0407C6 CD 72 08 04 0338*       call atan2_168fast ; uh.l = angle
0407CA             0339*   ; return result
0407CA D1          0340*       pop de ; de = radius (was hl)
0407CB C9          0341*       ret
0407CC             0342*   ; end cartesian_to_polar
0407CC             0343*   
0407CC             0344*   ; 16.8 fixed inputs / outputs
0407CC             0345*   ; inputs: ub.c as dx, ud.e as dy
0407CC             0346*   ;        displacements from origin (0,0)
0407CC             0347*   ; returns: uh.l as angle in degrees 256
0407CC             0348*   ;        ud.e as radius
0407CC             0349*   ; destroys: everything except indexes
0407CC             0350*   ; note: uses distance168sm which is more accurate for small deltas
0407CC             0351*   cartesian_to_polar_sm:
0407CC ED 43 06 08 0352*       ld (dx168),bc ; dx argument for distance168
       04          
0407D1 ED 53 0C 08 0353*       ld (dy168),de ; dy argument for distance168
       04          
0407D6             0354*   ; compute radius
0407D6 CD 4D 08 04 0355*       call distance168sm ; uh.l = radius
0407DA E5          0356*       push hl ; save radius
0407DB             0357*   ; compute angle
0407DB ED 4B 06 08 0358*       ld bc,(dx168) ; dx argument for atan2_168fast
       04          
0407E0 ED 5B 0C 08 0359*       ld de,(dy168) ; dy argument for atan2_168fast
       04          
0407E5 CD 72 08 04 0360*       call atan2_168fast ; uh.l = angle
0407E9             0361*   ; return result
0407E9 D1          0362*       pop de ; de = radius (was hl)
0407EA C9          0363*       ret
0407EB             0364*   ; end cartesian_to_polar
0407EB             0365*   
0407EB             0366*   ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0407EB             0367*   ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0407EB             0368*   ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
0407EB             0369*   ;         also populates scratch locations dx168 and dy168
0407EB             0370*   ; destroys: a,hl,bc,de
0407EB             0371*   dxy168:
0407EB             0372*   ; compute dx = x1-x0
0407EB AF          0373*       xor a ; clear carry
0407EC DD E5       0374*       push ix ; move ix to hl via the stack
0407EE E1          0375*       pop hl ; hl = x1
0407EF ED 42       0376*       sbc hl,bc ; hl = dx
0407F1 22 06 08 04 0377*       ld (dx168),hl ; dx to scratch
0407F5             0378*   ; compute dy = y1-y0
0407F5 AF          0379*       xor a ; clear carry
0407F6 FD E5       0380*       push iy ; move iy to hl via the stack
0407F8 E1          0381*       pop hl ; hl = y1
0407F9 ED 52       0382*       sbc hl,de ; hl = dy
0407FB 22 0C 08 04 0383*       ld (dy168),hl ; dy to scratch
0407FF             0384*   ; populate output registers and return
0407FF EB          0385*       ex de,hl ; ud.e = dy
040800 ED 4B 06 08 0386*       ld bc,(dx168) ; ub.c = dx
       04          
040805 C9          0387*       ret
040806 00 00 00 00 0388*   dx168: blkb 6,0
       00 00       
04080C 00 00 00 00 0389*   dy168: blkb 6,0
       00 00       
040812             0390*   
040812             0391*   ; compute the euclidian distance between two cartesian coordinates
040812             0392*   ; using the formula d = sqrt(dx^2+dy^2)
040812             0393*   ; inputs: dx168 and dy168 are dx and dy in 16.8 fixed format
040812             0394*   ; output; uh.l is the 16.8 fixed format distance
040812             0395*   ;         also populates scratch locations dx168 and dy168
040812             0396*   ; destroys: a,hl,bc,de
040812             0397*   ; NOTE: rounds both deltas down to the nearest integer to avoid overflow when squaring,
040812             0398*   ;       thus the result will always be an integer, albeit in 16.8 format
040812             0399*   distance168:
040812             0400*   ; compute dy^2
040812 2A 0C 08 04 0401*       ld hl,(dy168)
040816 CD 70 04 04 0402*       call hlu_abs
04081A             0403*       ; call hlu_udiv256 ; make integer to avoid overflow
04081A             0404*       SRL_UHL ; make integer to avoid overflow
                       M1 Args: none
04081A 3B          0001*M1     dec sp ; 1 cycle
04081B E5          0002*M1     push hl ; 4 cycles
04081C 33          0003*M1     inc sp ; 1 cycle
04081D E1          0004*M1     pop hl ; 4 cycles
04081E 23          0005*M1     inc hl ; 1 cycle
04081F 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
040821             0007*M1     ; 13 cycles total
040821 E5          0405*       push hl
040822 D1          0406*       pop de
040823 CD 67 03 04 0407*       call umul24 ; hl = dy^2
040827 E5          0408*       push hl ; save dy^2
040828             0409*   ; compute dx^2
040828 2A 06 08 04 0410*       ld hl,(dx168)
04082C CD 70 04 04 0411*       call hlu_abs
040830             0412*       ; call hlu_udiv256 ; make integer to avoid overflow
040830             0413*       SRL_UHL ; make integer to avoid overflow
                       M1 Args: none
040830 3B          0001*M1     dec sp ; 1 cycle
040831 E5          0002*M1     push hl ; 4 cycles
040832 33          0003*M1     inc sp ; 1 cycle
040833 E1          0004*M1     pop hl ; 4 cycles
040834 23          0005*M1     inc hl ; 1 cycle
040835 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
040837             0007*M1     ; 13 cycles total
040837 E5          0414*       push hl
040838 D1          0415*       pop de
040839 CD 67 03 04 0416*       call umul24 ; hl = dx^2
04083D             0417*   ; add dx^2 and dy^2
04083D D1          0418*       pop de ; de = dy^2 (was hl)
04083E 19          0419*       add hl,de ; hl = dx^2 + dy^2
04083F             0420*   ; compute the square root
04083F CD 3D 09 04 0421*       call sqrt24 ; de = sqrt(dx^2 + dy^2)
040843 EB          0422*       ex de,hl ; hl = distance
040844             0423*       hlu_mul256 ; convert back to 16.8 fixed
                       M1 Args: none
040844 29          0001*M1     add hl,hl ; * 2
040845 29          0002*M1     add hl,hl ; * 4
040846 29          0003*M1     add hl,hl ; * 8
040847 29          0004*M1     add hl,hl ; * 16
040848 29          0005*M1     add hl,hl ; * 32
040849 29          0006*M1     add hl,hl ; * 64
04084A 29          0007*M1     add hl,hl ; * 128
04084B 29          0008*M1     add hl,hl ; * 256
04084C C9          0424*       ret
04084D             0425*   
04084D             0426*   ; compute the euclidian distance between two cartesian coordinates
04084D             0427*   ; using the formula d = sqrt(dx^2+dy^2)
04084D             0428*   ; inputs: dx168 and dy168 are dx and dy in 16.8 fixed format
04084D             0429*   ; output; uh.l is the 16.8 fixed format distance
04084D             0430*   ;         also populates scratch locations dx168 and dy168
04084D             0431*   ; destroys: a,hl,bc,de
04084D             0432*   ; NOTE: sm means 'small' because it doesn't round down the deltas
04084D             0433*   ;       making it more accurate for small deltas,
04084D             0434*   ;       but will overflow if used for screen-sized deltas
04084D             0435*   distance168sm:
04084D             0436*   ; compute dy^2
04084D 2A 0C 08 04 0437*       ld hl,(dy168)
040851 CD 70 04 04 0438*       call hlu_abs
040855 E5          0439*       push hl
040856 D1          0440*       pop de
040857 CD 67 03 04 0441*       call umul24 ; hl = dy^2
04085B E5          0442*       push hl ; save dy^2
04085C             0443*   ; compute dx^2
04085C 2A 06 08 04 0444*       ld hl,(dx168)
040860 CD 70 04 04 0445*       call hlu_abs
040864 E5          0446*       push hl
040865 D1          0447*       pop de
040866 CD 67 03 04 0448*       call umul24 ; hl = dx^2
04086A             0449*   ; add dx^2 and dy^2
04086A D1          0450*       pop de ; de = dy^2 (was hl)
04086B 19          0451*       add hl,de ; hl = dx^2 + dy^2
04086C             0452*   ; compute the square root
04086C CD 3D 09 04 0453*       call sqrt24 ; de = sqrt(dx^2 + dy^2)
040870 EB          0454*       ex de,hl ; hl = distance
040871 C9          0455*       ret
040872             0456*   
040872             0457*   ; atan2_(ub.c,ud.e) --> uh.l
040872             0458*   ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040872             0459*   ;   whether inputs are integers or fractional doesn't matter
040872             0460*   ;   so long as the sign bit of the upper byte is correct
040872             0461*   ; output: uh.l is the 16.8 fixed angle in degrees 256
040872             0462*   ; angles are COMPASS HEADINGS based on
040872             0463*   ; screen coordinate conventions,where the y axis is flipped
040872             0464*   ; #E0 224      0       32 #20
040872             0465*   ;        -x,-y | +x,-y
040872             0466*   ; #C0 192------+------ 64 #40
040872             0467*   ;        -x,+y | +x,+y
040872             0468*   ; #A0 160   128 #80   96 #60
040872             0469*   atan2_168fast:
040872             0470*   ; get signs and make everything positive
040872             0471*   ; get abs(x) and store its original sign
040872 C5          0472*       push bc
040873 E1          0473*       pop hl
040874 CD 70 04 04 0474*       call hlu_abs ; if x was negative this also sets the sign flag
040878 E5          0475*       push hl ; store abs(x)
040879 C1          0476*       pop bc ; bc = abs(x)
04087A F5          0477*       push af ; store sign of x
04087B             0478*   ; get abs(y) and store its original sign
04087B EB          0479*       ex de,hl ; hl = y
04087C CD 70 04 04 0480*       call hlu_abs ; if y was negative this also sets the sign flag
040880 EB          0481*       ex de,hl ; de = abs(y)
040881 F5          0482*       push af ; store sign of y
040882             0483*   ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
040882             0484*   ; this ensures that our lookup value is between 0 and 1 inclusive
040882 AF          0485*       xor a ; clear the carry flag
040883 D5          0486*       push de
040884 E1          0487*       pop hl
040885 ED 42       0488*       sbc hl,bc
040887 F5          0489*       push af ; save sign of de - bc
040888 F2 91 08 04 0490*       jp p,@1 ; bc <= de, so we skip ahead
04088C             0491*   ; otherwise we swap bc and de
04088C C5          0492*       push bc
04088D E1          0493*       pop hl
04088E EB          0494*       ex de,hl
04088F E5          0495*       push hl
040890 C1          0496*       pop bc
040891             0497*   @1:
040891             0498*   ; now we're ready to snag our preliminary result
040891 C5          0499*       push bc
040892 E1          0500*       pop hl
040893 CD 01 09 04 0501*       call atan_168fast ; uh.l comes back with prelim result
040897             0502*   ; now we adjust uh.l based on sign of de - bc
040897 F1          0503*       pop af
040898 F2 A4 08 04 0504*       jp p,@2 ; bc <= de,so we skip ahead
04089C EB          0505*       ex de,hl
04089D 21 00 40 00 0506*       ld hl,64*256 ; subtract from 64 (90) degrees
0408A1 AF          0507*       xor a ; clear the carry flag
0408A2 ED 52       0508*       sbc hl,de
0408A4             0509*   @2:
0408A4             0510*   ; adjust the result based on quadrant
0408A4             0511*   ; #E0 224      0       32 #20
0408A4             0512*   ;        -x,-y | +x,-y
0408A4             0513*   ; #C0 192------+------ 64 #40
0408A4             0514*   ;        -x,+y | +x,+y
0408A4             0515*   ; #A0 160   128 #80   96 #60
0408A4 F1          0516*       pop af ; sign of y
0408A5 CA E2 08 04 0517*       jp z,@y_zero
0408A9 F2 C2 08 04 0518*       jp p,@y_pos
0408AD             0519*   ; y neg,check x
0408AD F1          0520*       pop af ; sign of x
0408AE CA BC 08 04 0521*       jp z,@y_neg_x_zero
0408B2 F2 C1 08 04 0522*       jp p,@y_neg_x_pos
0408B6             0523*   ; y neg,x neg
0408B6             0524*   ; angle is 128 to 256 (270 to 360)
0408B6             0525*   ; negating the intermediate does the trick
0408B6 CD 80 04 04 0526*       call neg_hlu
0408BA 18 31       0527*       jr @zero_hlu
0408BC             0528*   
0408BC             0529*   @y_neg_x_zero:
0408BC             0530*   ; y neg,x zero
0408BC             0531*   ; angle is 0
0408BC 21 00 00 00 0532*       ld hl,0
0408C0 C9          0533*       ret
0408C1             0534*   @y_neg_x_pos:
0408C1             0535*   ; y neg,x pos
0408C1             0536*   ; angle is 0 to 64 (0 to 90)
0408C1             0537*   ; so we're good
0408C1 C9          0538*       ret
0408C2             0539*   
0408C2             0540*   @y_pos:
0408C2 F1          0541*       pop af ; sign of x
0408C3 CA D2 08 04 0542*       jp z,@y_pos_x_zero
0408C7 F2 D7 08 04 0543*       jp p,@y_pos_x_pos
0408CB             0544*   ; y pos,x neg
0408CB             0545*   ; angle is 128 to 192 (180-270)
0408CB             0546*   ; so we add 128 to intermediate
0408CB 11 00 80 00 0547*       ld de,128*256
0408CF 19          0548*       add hl,de
0408D0 18 1B       0549*       jr @zero_hlu
0408D2             0550*   @y_pos_x_zero:
0408D2             0551*   ; y pos,x zero
0408D2             0552*   ; angle is 128 (180)
0408D2 21 00 80 00 0553*       ld hl,128*256
0408D6 C9          0554*       ret
0408D7             0555*   @y_pos_x_pos:
0408D7             0556*   ; y pos,x pos
0408D7             0557*   ; angle is 64 to 128 (90 to 180)
0408D7             0558*   ; neg the intermediate and add 180 degrees
0408D7 CD 80 04 04 0559*       call neg_hlu
0408DB 11 00 80 00 0560*       ld de,128*256
0408DF 19          0561*       add hl,de
0408E0 18 0B       0562*       jr @zero_hlu
0408E2             0563*   
0408E2             0564*   @y_zero:
0408E2 F1          0565*       pop af ; sign of x
0408E3 FA E8 08 04 0566*       jp m,@y_zero_x_neg
0408E7             0567*   ; y zero,x pos
0408E7             0568*   ; angle is 64 (90),nothing to do
0408E7 C9          0569*       ret
0408E8             0570*   @y_zero_x_neg:
0408E8             0571*   ; y zero ,x neg
0408E8             0572*   ; angle is 192 (270)
0408E8 21 00 C0 00 0573*       ld hl,192*256
0408EC C9          0574*       ret
0408ED             0575*   @zero_hlu:
0408ED AF          0576*       xor a
0408EE 22 FB 08 04 0577*       ld (@scratch),hl
0408F2 32 FD 08 04 0578*       ld (@scratch+2),a
0408F6 2A FB 08 04 0579*       ld hl,(@scratch)
0408FA C9          0580*       ret
0408FB             0581*   @scratch: ds 6
040901             0582*   
040901             0583*   ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040901             0584*   ; output: uh.l is the 16.8 fixed format angle in degrees 256
040901             0585*   ; destroys: a,hl,bc,de
040901             0586*   ; note: only works for angles from 0 to 32 (45) degrees
040901             0587*   ;   use atan2_168fast (which calls this proc) to handle the full 256 (360) degrees
040901             0588*   atan_168fast:
040901             0589*   ; because we use compass headings instead of geometric angles
040901             0590*   ; we compute dx/dy which is 1/tan(theta) in the maths world
040901             0591*   ; we can do faster unsigned division here because we know dx and dy are positive
       FF FF FF FF 
       FF FF 
040901 CD BC 06 04 0592*       call udiv168 ; ud.e = dx/dy
040905 EB          0593*       ex de,hl ; uh.l = dx/dy
040906             0594*   ; test uh.l for 0
040906 19          0595*       add hl,de
040907 B7          0596*       or a
040908 ED 52       0597*       sbc hl,de
04090A 28 22       0598*       jr z,@is_zero
04090C             0599*   ; test uh.l for 1
04090C AF          0600*       xor a ; clear carry
04090D EB          0601*       ex de,hl
04090E 21 00 01 00 0602*       ld hl,1*256 ; 1 in 16.8 fixed format
040912 ED 52       0603*       sbc hl,de
040914 28 13       0604*       jr z,@is_45
040916 EB          0605*       ex de,hl
040917             0606*   ; no special cases so we move on
040917             0607*   ; l contains the fractional portion of tan(uh.l)
040917             0608*   ; we multiply it by three to get our lookup table index
040917 26 03       0609*       ld h,3
040919 ED 6C       0610*       mlt hl ; index into lut
04091B 11 00 00 00 0611*       ld de,0 ; clear deu
04091F 54          0612*       ld d,h ; copy hl to de
040920 5D          0613*       ld e,l ; de contains our index
040921 21 26 0D 04 0614*       ld hl,atan_lut_168 ; grab the lut address
040925 19          0615*       add hl,de ; bump hl by the index
040926 ED 27       0616*       ld hl,(hl) ; don't try this on a z80!
040928 C9          0617*       ret ; and out
040929             0618*   @is_45:
040929 21 00 20 00 0619*       ld hl,32*256
04092D C9          0620*       ret
04092E             0621*   ; for the case tan(0)
04092E             0622*   @is_zero:
04092E 21 00 00 00 0623*       ld hl,0*256
040932 C9          0624*       ret
040933             0625*   
040933             0626*   ; Expects  ADL mode
040933             0627*   ; Inputs:  UH.L
040933             0628*   ; Outputs: UH.L is the 16.8 square root
040933             0629*   ;          UDE is the integer difference inputHL-DE^2
040933             0630*   sqrt168:
040933 CD 3D 09 04 0631*       call sqrt24
040937 EB          0632*       ex de,hl
040938 29          0633*       add hl,hl
040939 29          0634*       add hl,hl
04093A 29          0635*       add hl,hl
04093B 29          0636*       add hl,hl
04093C C9          0637*       ret
04093D             0638*   
04093D             0639*   ; credit: xeda112358
04093D             0640*   ; https://www.cemetech.net/forum/viewtopic.php?t=11178&postdays=0&postorder=asc&start=0
04093D             0641*   sqrt24:
04093D             0642*   ; Expects ADL mode
04093D             0643*   ; Inputs: HL
04093D             0644*   ; Outputs: DE is the integer square root
04093D             0645*   ;  HL is the difference inputHL-DE^2
04093D             0646*   ;  c flag reset
04093D 01 00 00 00 0647*       ld bc,0 ; clear bcu
040941 11 00 00 00 0648*       ld de,0 ; clear deu
040945 AF          0649*       xor a
040946 45          0650*       ld b,l
040947 C5          0651*       push bc
040948 47          0652*       ld b,a
040949 6F          0653*       ld l,a
04094A             0654*   ; Iteration 1
04094A 29          0655*       add hl,hl
04094B CB 11       0656*       rl c
04094D 29          0657*       add hl,hl
04094E CB 11       0658*       rl c
040950 91          0659*       sub c
040951 30 04       0660*       jr nc,$+6
040953 1C          0661*       inc e
040954 1C          0662*       inc e
040955 2F          0663*       cpl
040956 4F          0664*       ld c,a
040957             0665*   ; Iteration 2
040957 29          0666*       add hl,hl
040958 CB 11       0667*       rl c
04095A 29          0668*       add hl,hl
04095B CB 11       0669*       rl c
04095D CB 13       0670*       rl e
04095F 7B          0671*       ld a,e
040960 91          0672*       sub c
040961 30 04       0673*       jr nc,$+6
040963 1C          0674*       inc e
040964 1C          0675*       inc e
040965 2F          0676*       cpl
040966 4F          0677*       ld c,a
040967             0678*   ; Iteration 3
040967 29          0679*       add hl,hl
040968 CB 11       0680*       rl c
04096A 29          0681*       add hl,hl
04096B CB 11       0682*       rl c
04096D CB 13       0683*       rl e
04096F 7B          0684*       ld a,e
040970 91          0685*       sub c
040971 30 04       0686*       jr nc,$+6
040973 1C          0687*       inc e
040974 1C          0688*       inc e
040975 2F          0689*       cpl
040976 4F          0690*       ld c,a
040977             0691*   ; Iteration 4
040977 29          0692*       add hl,hl
040978 CB 11       0693*       rl c
04097A 29          0694*       add hl,hl
04097B CB 11       0695*       rl c
04097D CB 13       0696*       rl e
04097F 7B          0697*       ld a,e
040980 91          0698*       sub c
040981 30 04       0699*       jr nc,$+6
040983 1C          0700*       inc e
040984 1C          0701*       inc e
040985 2F          0702*       cpl
040986 4F          0703*       ld c,a
040987             0704*   ; Iteration 5
040987 29          0705*       add hl,hl
040988 CB 11       0706*       rl c
04098A 29          0707*       add hl,hl
04098B CB 11       0708*       rl c
04098D CB 13       0709*       rl e
04098F 7B          0710*       ld a,e
040990 91          0711*       sub c
040991 30 04       0712*       jr nc,$+6
040993 1C          0713*       inc e
040994 1C          0714*       inc e
040995 2F          0715*       cpl
040996 4F          0716*       ld c,a
040997             0717*   ; Iteration 6
040997 29          0718*       add hl,hl
040998 CB 11       0719*       rl c
04099A 29          0720*       add hl,hl
04099B CB 11       0721*       rl c
04099D CB 13       0722*       rl e
04099F 7B          0723*       ld a,e
0409A0 91          0724*       sub c
0409A1 30 04       0725*       jr nc,$+6
0409A3 1C          0726*       inc e
0409A4 1C          0727*       inc e
0409A5 2F          0728*       cpl
0409A6 4F          0729*       ld c,a
0409A7             0730*   ; Iteration 7
0409A7 29          0731*       add hl,hl
0409A8 CB 11       0732*       rl c
0409AA 29          0733*       add hl,hl
0409AB CB 11       0734*       rl c
0409AD CB 10       0735*       rl b
0409AF EB          0736*       ex de,hl
0409B0 29          0737*       add hl,hl
0409B1 E5          0738*       push hl
0409B2 ED 42       0739*       sbc hl,bc
0409B4 30 06       0740*       jr nc,$+8
0409B6 7C          0741*       ld a,h
0409B7 2F          0742*       cpl
0409B8 47          0743*       ld b,a
0409B9 7D          0744*       ld a,l
0409BA 2F          0745*       cpl
0409BB 4F          0746*       ld c,a
0409BC E1          0747*       pop hl
0409BD 30 02       0748*       jr nc,$+4
0409BF 23          0749*       inc hl
0409C0 23          0750*       inc hl
0409C1 EB          0751*       ex de,hl
0409C2             0752*   ; Iteration 8
0409C2 29          0753*       add hl,hl
0409C3 69          0754*       ld l,c
0409C4 60          0755*       ld h,b
0409C5 ED 6A       0756*       adc hl,hl
0409C7 ED 6A       0757*       adc hl,hl
0409C9 EB          0758*       ex de,hl
0409CA 29          0759*       add hl,hl
0409CB ED 52       0760*       sbc hl,de
0409CD 19          0761*       add hl,de
0409CE EB          0762*       ex de,hl
0409CF 30 04       0763*       jr nc,$+6
0409D1 ED 52       0764*       sbc hl,de
0409D3 13          0765*       inc de
0409D4 13          0766*       inc de
0409D5             0767*   ; Iteration 9
0409D5 F1          0768*       pop af
0409D6 17          0769*       rla
0409D7 ED 6A       0770*       adc hl,hl
0409D9 17          0771*       rla
0409DA ED 6A       0772*       adc hl,hl
0409DC EB          0773*       ex de,hl
0409DD 29          0774*       add hl,hl
0409DE ED 52       0775*       sbc hl,de
0409E0 19          0776*       add hl,de
0409E1 EB          0777*       ex de,hl
0409E2 30 04       0778*       jr nc,$+6
0409E4 ED 52       0779*       sbc hl,de
0409E6 13          0780*       inc de
0409E7 13          0781*       inc de
0409E8             0782*   ; Iteration 10
0409E8 17          0783*       rla
0409E9 ED 6A       0784*       adc hl,hl
0409EB 17          0785*       rla
0409EC ED 6A       0786*       adc hl,hl
0409EE EB          0787*       ex de,hl
0409EF 29          0788*       add hl,hl
0409F0 ED 52       0789*       sbc hl,de
0409F2 19          0790*       add hl,de
0409F3 EB          0791*       ex de,hl
0409F4 30 04       0792*       jr nc,$+6
0409F6 ED 52       0793*       sbc hl,de
0409F8 13          0794*       inc de
0409F9 13          0795*       inc de
0409FA             0796*   ; Iteration 11
0409FA 17          0797*       rla
0409FB ED 6A       0798*       adc hl,hl
0409FD 17          0799*       rla
0409FE ED 6A       0800*       adc hl,hl
040A00 EB          0801*       ex de,hl
040A01 29          0802*       add hl,hl
040A02 ED 52       0803*       sbc hl,de
040A04 19          0804*       add hl,de
040A05 EB          0805*       ex de,hl
040A06 30 04       0806*       jr nc,$+6
040A08 ED 52       0807*       sbc hl,de
040A0A 13          0808*       inc de
040A0B 13          0809*       inc de
040A0C             0810*   ; Iteration 12
040A0C 17          0811*       rla
040A0D ED 6A       0812*       adc hl,hl
040A0F 17          0813*       rla
040A10 ED 6A       0814*       adc hl,hl
040A12 EB          0815*       ex de,hl
040A13 29          0816*       add hl,hl
040A14 ED 52       0817*       sbc hl,de
040A16 19          0818*       add hl,de
040A17 EB          0819*       ex de,hl
040A18 30 04       0820*       jr nc,$+6
040A1A ED 52       0821*       sbc hl,de
040A1C 13          0822*       inc de
040A1D 13          0823*       inc de
040A1E CB 1A       0824*       rr d
040A20 CB 1B       0825*       rr e
040A22 C9          0826*       ret
040A23             0827*   
040A23             0828*   sin_lut_168:
040A23 00 00 00    0829*       dl 0x000000 ; 0.000 00, 0.000
040A26 06 00 00    0830*       dl 0x000006 ; 1.406 01, 0.025
040A29 0C 00 00    0831*       dl 0x00000C ; 2.813 02, 0.049
040A2C 12 00 00    0832*       dl 0x000012 ; 4.219 03, 0.074
040A2F 19 00 00    0833*       dl 0x000019 ; 5.625 04, 0.098
040A32 1F 00 00    0834*       dl 0x00001F ; 7.031 05, 0.122
040A35 25 00 00    0835*       dl 0x000025 ; 8.438 06, 0.147
040A38 2B 00 00    0836*       dl 0x00002B ; 9.844 07, 0.171
040A3B 31 00 00    0837*       dl 0x000031 ; 11.250 08, 0.195
040A3E 38 00 00    0838*       dl 0x000038 ; 12.656 09, 0.219
040A41 3E 00 00    0839*       dl 0x00003E ; 14.063 0A, 0.243
040A44 44 00 00    0840*       dl 0x000044 ; 15.469 0B, 0.267
040A47 4A 00 00    0841*       dl 0x00004A ; 16.875 0C, 0.290
040A4A 50 00 00    0842*       dl 0x000050 ; 18.281 0D, 0.314
040A4D 56 00 00    0843*       dl 0x000056 ; 19.688 0E, 0.337
040A50 5C 00 00    0844*       dl 0x00005C ; 21.094 0F, 0.360
040A53 61 00 00    0845*       dl 0x000061 ; 22.500 10, 0.383
040A56 67 00 00    0846*       dl 0x000067 ; 23.906 11, 0.405
040A59 6D 00 00    0847*       dl 0x00006D ; 25.313 12, 0.428
040A5C 73 00 00    0848*       dl 0x000073 ; 26.719 13, 0.450
040A5F 78 00 00    0849*       dl 0x000078 ; 28.125 14, 0.471
040A62 7E 00 00    0850*       dl 0x00007E ; 29.531 15, 0.493
040A65 83 00 00    0851*       dl 0x000083 ; 30.938 16, 0.514
040A68 88 00 00    0852*       dl 0x000088 ; 32.344 17, 0.535
040A6B 8E 00 00    0853*       dl 0x00008E ; 33.750 18, 0.556
040A6E 93 00 00    0854*       dl 0x000093 ; 35.156 19, 0.576
040A71 98 00 00    0855*       dl 0x000098 ; 36.563 1A, 0.596
040A74 9D 00 00    0856*       dl 0x00009D ; 37.969 1B, 0.615
040A77 A2 00 00    0857*       dl 0x0000A2 ; 39.375 1C, 0.634
040A7A A7 00 00    0858*       dl 0x0000A7 ; 40.781 1D, 0.653
040A7D AB 00 00    0859*       dl 0x0000AB ; 42.188 1E, 0.672
040A80 B0 00 00    0860*       dl 0x0000B0 ; 43.594 1F, 0.690
040A83 B5 00 00    0861*       dl 0x0000B5 ; 45.000 20, 0.707
040A86 B9 00 00    0862*       dl 0x0000B9 ; 46.406 21, 0.724
040A89 BD 00 00    0863*       dl 0x0000BD ; 47.813 22, 0.741
040A8C C1 00 00    0864*       dl 0x0000C1 ; 49.219 23, 0.757
040A8F C5 00 00    0865*       dl 0x0000C5 ; 50.625 24, 0.773
040A92 C9 00 00    0866*       dl 0x0000C9 ; 52.031 25, 0.788
040A95 CD 00 00    0867*       dl 0x0000CD ; 53.438 26, 0.803
040A98 D1 00 00    0868*       dl 0x0000D1 ; 54.844 27, 0.818
040A9B D4 00 00    0869*       dl 0x0000D4 ; 56.250 28, 0.831
040A9E D8 00 00    0870*       dl 0x0000D8 ; 57.656 29, 0.845
040AA1 DB 00 00    0871*       dl 0x0000DB ; 59.063 2A, 0.858
040AA4 DE 00 00    0872*       dl 0x0000DE ; 60.469 2B, 0.870
040AA7 E1 00 00    0873*       dl 0x0000E1 ; 61.875 2C, 0.882
040AAA E4 00 00    0874*       dl 0x0000E4 ; 63.281 2D, 0.893
040AAD E7 00 00    0875*       dl 0x0000E7 ; 64.688 2E, 0.904
040AB0 EA 00 00    0876*       dl 0x0000EA ; 66.094 2F, 0.914
040AB3 EC 00 00    0877*       dl 0x0000EC ; 67.500 30, 0.924
040AB6 EE 00 00    0878*       dl 0x0000EE ; 68.906 31, 0.933
040AB9 F1 00 00    0879*       dl 0x0000F1 ; 70.313 32, 0.942
040ABC F3 00 00    0880*       dl 0x0000F3 ; 71.719 33, 0.950
040ABF F4 00 00    0881*       dl 0x0000F4 ; 73.125 34, 0.957
040AC2 F6 00 00    0882*       dl 0x0000F6 ; 74.531 35, 0.964
040AC5 F8 00 00    0883*       dl 0x0000F8 ; 75.938 36, 0.970
040AC8 F9 00 00    0884*       dl 0x0000F9 ; 77.344 37, 0.976
040ACB FB 00 00    0885*       dl 0x0000FB ; 78.750 38, 0.981
040ACE FC 00 00    0886*       dl 0x0000FC ; 80.156 39, 0.985
040AD1 FD 00 00    0887*       dl 0x0000FD ; 81.563 3A, 0.989
040AD4 FE 00 00    0888*       dl 0x0000FE ; 82.969 3B, 0.992
040AD7 FE 00 00    0889*       dl 0x0000FE ; 84.375 3C, 0.995
040ADA FF 00 00    0890*       dl 0x0000FF ; 85.781 3D, 0.997
040ADD FF 00 00    0891*       dl 0x0000FF ; 87.188 3E, 0.999
040AE0 FF 00 00    0892*       dl 0x0000FF ; 88.594 3F, 1.000
040AE3 00 01 00    0893*       dl 0x000100 ; 90.000 40, 1.000
040AE6 FF 00 00    0894*       dl 0x0000FF ; 91.406 41, 1.000
040AE9 FF 00 00    0895*       dl 0x0000FF ; 92.813 42, 0.999
040AEC FF 00 00    0896*       dl 0x0000FF ; 94.219 43, 0.997
040AEF FE 00 00    0897*       dl 0x0000FE ; 95.625 44, 0.995
040AF2 FE 00 00    0898*       dl 0x0000FE ; 97.031 45, 0.992
040AF5 FD 00 00    0899*       dl 0x0000FD ; 98.438 46, 0.989
040AF8 FC 00 00    0900*       dl 0x0000FC ; 99.844 47, 0.985
040AFB FB 00 00    0901*       dl 0x0000FB ; 101.250 48, 0.981
040AFE F9 00 00    0902*       dl 0x0000F9 ; 102.656 49, 0.976
040B01 F8 00 00    0903*       dl 0x0000F8 ; 104.063 4A, 0.970
040B04 F6 00 00    0904*       dl 0x0000F6 ; 105.469 4B, 0.964
040B07 F4 00 00    0905*       dl 0x0000F4 ; 106.875 4C, 0.957
040B0A F3 00 00    0906*       dl 0x0000F3 ; 108.281 4D, 0.950
040B0D F1 00 00    0907*       dl 0x0000F1 ; 109.688 4E, 0.942
040B10 EE 00 00    0908*       dl 0x0000EE ; 111.094 4F, 0.933
040B13 EC 00 00    0909*       dl 0x0000EC ; 112.500 50, 0.924
040B16 EA 00 00    0910*       dl 0x0000EA ; 113.906 51, 0.914
040B19 E7 00 00    0911*       dl 0x0000E7 ; 115.313 52, 0.904
040B1C E4 00 00    0912*       dl 0x0000E4 ; 116.719 53, 0.893
040B1F E1 00 00    0913*       dl 0x0000E1 ; 118.125 54, 0.882
040B22 DE 00 00    0914*       dl 0x0000DE ; 119.531 55, 0.870
040B25 DB 00 00    0915*       dl 0x0000DB ; 120.938 56, 0.858
040B28 D8 00 00    0916*       dl 0x0000D8 ; 122.344 57, 0.845
040B2B D4 00 00    0917*       dl 0x0000D4 ; 123.750 58, 0.831
040B2E D1 00 00    0918*       dl 0x0000D1 ; 125.156 59, 0.818
040B31 CD 00 00    0919*       dl 0x0000CD ; 126.563 5A, 0.803
040B34 C9 00 00    0920*       dl 0x0000C9 ; 127.969 5B, 0.788
040B37 C5 00 00    0921*       dl 0x0000C5 ; 129.375 5C, 0.773
040B3A C1 00 00    0922*       dl 0x0000C1 ; 130.781 5D, 0.757
040B3D BD 00 00    0923*       dl 0x0000BD ; 132.188 5E, 0.741
040B40 B9 00 00    0924*       dl 0x0000B9 ; 133.594 5F, 0.724
040B43 B5 00 00    0925*       dl 0x0000B5 ; 135.000 60, 0.707
040B46 B0 00 00    0926*       dl 0x0000B0 ; 136.406 61, 0.690
040B49 AB 00 00    0927*       dl 0x0000AB ; 137.813 62, 0.672
040B4C A7 00 00    0928*       dl 0x0000A7 ; 139.219 63, 0.653
040B4F A2 00 00    0929*       dl 0x0000A2 ; 140.625 64, 0.634
040B52 9D 00 00    0930*       dl 0x00009D ; 142.031 65, 0.615
040B55 98 00 00    0931*       dl 0x000098 ; 143.438 66, 0.596
040B58 93 00 00    0932*       dl 0x000093 ; 144.844 67, 0.576
040B5B 8E 00 00    0933*       dl 0x00008E ; 146.250 68, 0.556
040B5E 88 00 00    0934*       dl 0x000088 ; 147.656 69, 0.535
040B61 83 00 00    0935*       dl 0x000083 ; 149.063 6A, 0.514
040B64 7E 00 00    0936*       dl 0x00007E ; 150.469 6B, 0.493
040B67 78 00 00    0937*       dl 0x000078 ; 151.875 6C, 0.471
040B6A 73 00 00    0938*       dl 0x000073 ; 153.281 6D, 0.450
040B6D 6D 00 00    0939*       dl 0x00006D ; 154.688 6E, 0.428
040B70 67 00 00    0940*       dl 0x000067 ; 156.094 6F, 0.405
040B73 61 00 00    0941*       dl 0x000061 ; 157.500 70, 0.383
040B76 5C 00 00    0942*       dl 0x00005C ; 158.906 71, 0.360
040B79 56 00 00    0943*       dl 0x000056 ; 160.313 72, 0.337
040B7C 50 00 00    0944*       dl 0x000050 ; 161.719 73, 0.314
040B7F 4A 00 00    0945*       dl 0x00004A ; 163.125 74, 0.290
040B82 44 00 00    0946*       dl 0x000044 ; 164.531 75, 0.267
040B85 3E 00 00    0947*       dl 0x00003E ; 165.938 76, 0.243
040B88 38 00 00    0948*       dl 0x000038 ; 167.344 77, 0.219
040B8B 31 00 00    0949*       dl 0x000031 ; 168.750 78, 0.195
040B8E 2B 00 00    0950*       dl 0x00002B ; 170.156 79, 0.171
040B91 25 00 00    0951*       dl 0x000025 ; 171.563 7A, 0.147
040B94 1F 00 00    0952*       dl 0x00001F ; 172.969 7B, 0.122
040B97 19 00 00    0953*       dl 0x000019 ; 174.375 7C, 0.098
040B9A 12 00 00    0954*       dl 0x000012 ; 175.781 7D, 0.074
040B9D 0C 00 00    0955*       dl 0x00000C ; 177.188 7E, 0.049
040BA0 06 00 00    0956*       dl 0x000006 ; 178.594 7F, 0.025
040BA3 00 00 00    0957*       dl 0x000000 ; 180.000 80, 0.000
040BA6 FA FF FF    0958*       dl 0xFFFFFA ; 181.406 81, -0.025
040BA9 F4 FF FF    0959*       dl 0xFFFFF4 ; 182.813 82, -0.049
040BAC EE FF FF    0960*       dl 0xFFFFEE ; 184.219 83, -0.074
040BAF E7 FF FF    0961*       dl 0xFFFFE7 ; 185.625 84, -0.098
040BB2 E1 FF FF    0962*       dl 0xFFFFE1 ; 187.031 85, -0.122
040BB5 DB FF FF    0963*       dl 0xFFFFDB ; 188.438 86, -0.147
040BB8 D5 FF FF    0964*       dl 0xFFFFD5 ; 189.844 87, -0.171
040BBB CF FF FF    0965*       dl 0xFFFFCF ; 191.250 88, -0.195
040BBE C8 FF FF    0966*       dl 0xFFFFC8 ; 192.656 89, -0.219
040BC1 C2 FF FF    0967*       dl 0xFFFFC2 ; 194.063 8A, -0.243
040BC4 BC FF FF    0968*       dl 0xFFFFBC ; 195.469 8B, -0.267
040BC7 B6 FF FF    0969*       dl 0xFFFFB6 ; 196.875 8C, -0.290
040BCA B0 FF FF    0970*       dl 0xFFFFB0 ; 198.281 8D, -0.314
040BCD AA FF FF    0971*       dl 0xFFFFAA ; 199.688 8E, -0.337
040BD0 A4 FF FF    0972*       dl 0xFFFFA4 ; 201.094 8F, -0.360
040BD3 9F FF FF    0973*       dl 0xFFFF9F ; 202.500 90, -0.383
040BD6 99 FF FF    0974*       dl 0xFFFF99 ; 203.906 91, -0.405
040BD9 93 FF FF    0975*       dl 0xFFFF93 ; 205.313 92, -0.428
040BDC 8D FF FF    0976*       dl 0xFFFF8D ; 206.719 93, -0.450
040BDF 88 FF FF    0977*       dl 0xFFFF88 ; 208.125 94, -0.471
040BE2 82 FF FF    0978*       dl 0xFFFF82 ; 209.531 95, -0.493
040BE5 7D FF FF    0979*       dl 0xFFFF7D ; 210.938 96, -0.514
040BE8 78 FF FF    0980*       dl 0xFFFF78 ; 212.344 97, -0.535
040BEB 72 FF FF    0981*       dl 0xFFFF72 ; 213.750 98, -0.556
040BEE 6D FF FF    0982*       dl 0xFFFF6D ; 215.156 99, -0.576
040BF1 68 FF FF    0983*       dl 0xFFFF68 ; 216.563 9A, -0.596
040BF4 63 FF FF    0984*       dl 0xFFFF63 ; 217.969 9B, -0.615
040BF7 5E FF FF    0985*       dl 0xFFFF5E ; 219.375 9C, -0.634
040BFA 59 FF FF    0986*       dl 0xFFFF59 ; 220.781 9D, -0.653
040BFD 55 FF FF    0987*       dl 0xFFFF55 ; 222.188 9E, -0.672
040C00 50 FF FF    0988*       dl 0xFFFF50 ; 223.594 9F, -0.690
040C03 4B FF FF    0989*       dl 0xFFFF4B ; 225.000 A0, -0.707
040C06 47 FF FF    0990*       dl 0xFFFF47 ; 226.406 A1, -0.724
040C09 43 FF FF    0991*       dl 0xFFFF43 ; 227.813 A2, -0.741
040C0C 3F FF FF    0992*       dl 0xFFFF3F ; 229.219 A3, -0.757
040C0F 3B FF FF    0993*       dl 0xFFFF3B ; 230.625 A4, -0.773
040C12 37 FF FF    0994*       dl 0xFFFF37 ; 232.031 A5, -0.788
040C15 33 FF FF    0995*       dl 0xFFFF33 ; 233.438 A6, -0.803
040C18 2F FF FF    0996*       dl 0xFFFF2F ; 234.844 A7, -0.818
040C1B 2C FF FF    0997*       dl 0xFFFF2C ; 236.250 A8, -0.831
040C1E 28 FF FF    0998*       dl 0xFFFF28 ; 237.656 A9, -0.845
040C21 25 FF FF    0999*       dl 0xFFFF25 ; 239.063 AA, -0.858
040C24 22 FF FF    1000*       dl 0xFFFF22 ; 240.469 AB, -0.870
040C27 1F FF FF    1001*       dl 0xFFFF1F ; 241.875 AC, -0.882
040C2A 1C FF FF    1002*       dl 0xFFFF1C ; 243.281 AD, -0.893
040C2D 19 FF FF    1003*       dl 0xFFFF19 ; 244.688 AE, -0.904
040C30 16 FF FF    1004*       dl 0xFFFF16 ; 246.094 AF, -0.914
040C33 14 FF FF    1005*       dl 0xFFFF14 ; 247.500 B0, -0.924
040C36 12 FF FF    1006*       dl 0xFFFF12 ; 248.906 B1, -0.933
040C39 0F FF FF    1007*       dl 0xFFFF0F ; 250.313 B2, -0.942
040C3C 0D FF FF    1008*       dl 0xFFFF0D ; 251.719 B3, -0.950
040C3F 0C FF FF    1009*       dl 0xFFFF0C ; 253.125 B4, -0.957
040C42 0A FF FF    1010*       dl 0xFFFF0A ; 254.531 B5, -0.964
040C45 08 FF FF    1011*       dl 0xFFFF08 ; 255.938 B6, -0.970
040C48 07 FF FF    1012*       dl 0xFFFF07 ; 257.344 B7, -0.976
040C4B 05 FF FF    1013*       dl 0xFFFF05 ; 258.750 B8, -0.981
040C4E 04 FF FF    1014*       dl 0xFFFF04 ; 260.156 B9, -0.985
040C51 03 FF FF    1015*       dl 0xFFFF03 ; 261.563 BA, -0.989
040C54 02 FF FF    1016*       dl 0xFFFF02 ; 262.969 BB, -0.992
040C57 02 FF FF    1017*       dl 0xFFFF02 ; 264.375 BC, -0.995
040C5A 01 FF FF    1018*       dl 0xFFFF01 ; 265.781 BD, -0.997
040C5D 01 FF FF    1019*       dl 0xFFFF01 ; 267.188 BE, -0.999
040C60 01 FF FF    1020*       dl 0xFFFF01 ; 268.594 BF, -1.000
040C63 00 FF FF    1021*       dl 0xFFFF00 ; 270.000 C0, -1.000
040C66 01 FF FF    1022*       dl 0xFFFF01 ; 271.406 C1, -1.000
040C69 01 FF FF    1023*       dl 0xFFFF01 ; 272.813 C2, -0.999
040C6C 01 FF FF    1024*       dl 0xFFFF01 ; 274.219 C3, -0.997
040C6F 02 FF FF    1025*       dl 0xFFFF02 ; 275.625 C4, -0.995
040C72 02 FF FF    1026*       dl 0xFFFF02 ; 277.031 C5, -0.992
040C75 03 FF FF    1027*       dl 0xFFFF03 ; 278.438 C6, -0.989
040C78 04 FF FF    1028*       dl 0xFFFF04 ; 279.844 C7, -0.985
040C7B 05 FF FF    1029*       dl 0xFFFF05 ; 281.250 C8, -0.981
040C7E 07 FF FF    1030*       dl 0xFFFF07 ; 282.656 C9, -0.976
040C81 08 FF FF    1031*       dl 0xFFFF08 ; 284.063 CA, -0.970
040C84 0A FF FF    1032*       dl 0xFFFF0A ; 285.469 CB, -0.964
040C87 0C FF FF    1033*       dl 0xFFFF0C ; 286.875 CC, -0.957
040C8A 0D FF FF    1034*       dl 0xFFFF0D ; 288.281 CD, -0.950
040C8D 0F FF FF    1035*       dl 0xFFFF0F ; 289.688 CE, -0.942
040C90 12 FF FF    1036*       dl 0xFFFF12 ; 291.094 CF, -0.933
040C93 14 FF FF    1037*       dl 0xFFFF14 ; 292.500 D0, -0.924
040C96 16 FF FF    1038*       dl 0xFFFF16 ; 293.906 D1, -0.914
040C99 19 FF FF    1039*       dl 0xFFFF19 ; 295.313 D2, -0.904
040C9C 1C FF FF    1040*       dl 0xFFFF1C ; 296.719 D3, -0.893
040C9F 1F FF FF    1041*       dl 0xFFFF1F ; 298.125 D4, -0.882
040CA2 22 FF FF    1042*       dl 0xFFFF22 ; 299.531 D5, -0.870
040CA5 25 FF FF    1043*       dl 0xFFFF25 ; 300.938 D6, -0.858
040CA8 28 FF FF    1044*       dl 0xFFFF28 ; 302.344 D7, -0.845
040CAB 2C FF FF    1045*       dl 0xFFFF2C ; 303.750 D8, -0.831
040CAE 2F FF FF    1046*       dl 0xFFFF2F ; 305.156 D9, -0.818
040CB1 33 FF FF    1047*       dl 0xFFFF33 ; 306.563 DA, -0.803
040CB4 37 FF FF    1048*       dl 0xFFFF37 ; 307.969 DB, -0.788
040CB7 3B FF FF    1049*       dl 0xFFFF3B ; 309.375 DC, -0.773
040CBA 3F FF FF    1050*       dl 0xFFFF3F ; 310.781 DD, -0.757
040CBD 43 FF FF    1051*       dl 0xFFFF43 ; 312.188 DE, -0.741
040CC0 47 FF FF    1052*       dl 0xFFFF47 ; 313.594 DF, -0.724
040CC3 4B FF FF    1053*       dl 0xFFFF4B ; 315.000 E0, -0.707
040CC6 50 FF FF    1054*       dl 0xFFFF50 ; 316.406 E1, -0.690
040CC9 55 FF FF    1055*       dl 0xFFFF55 ; 317.813 E2, -0.672
040CCC 59 FF FF    1056*       dl 0xFFFF59 ; 319.219 E3, -0.653
040CCF 5E FF FF    1057*       dl 0xFFFF5E ; 320.625 E4, -0.634
040CD2 63 FF FF    1058*       dl 0xFFFF63 ; 322.031 E5, -0.615
040CD5 68 FF FF    1059*       dl 0xFFFF68 ; 323.438 E6, -0.596
040CD8 6D FF FF    1060*       dl 0xFFFF6D ; 324.844 E7, -0.576
040CDB 72 FF FF    1061*       dl 0xFFFF72 ; 326.250 E8, -0.556
040CDE 78 FF FF    1062*       dl 0xFFFF78 ; 327.656 E9, -0.535
040CE1 7D FF FF    1063*       dl 0xFFFF7D ; 329.063 EA, -0.514
040CE4 82 FF FF    1064*       dl 0xFFFF82 ; 330.469 EB, -0.493
040CE7 88 FF FF    1065*       dl 0xFFFF88 ; 331.875 EC, -0.471
040CEA 8D FF FF    1066*       dl 0xFFFF8D ; 333.281 ED, -0.450
040CED 93 FF FF    1067*       dl 0xFFFF93 ; 334.688 EE, -0.428
040CF0 99 FF FF    1068*       dl 0xFFFF99 ; 336.094 EF, -0.405
040CF3 9F FF FF    1069*       dl 0xFFFF9F ; 337.500 F0, -0.383
040CF6 A4 FF FF    1070*       dl 0xFFFFA4 ; 338.906 F1, -0.360
040CF9 AA FF FF    1071*       dl 0xFFFFAA ; 340.313 F2, -0.337
040CFC B0 FF FF    1072*       dl 0xFFFFB0 ; 341.719 F3, -0.314
040CFF B6 FF FF    1073*       dl 0xFFFFB6 ; 343.125 F4, -0.290
040D02 BC FF FF    1074*       dl 0xFFFFBC ; 344.531 F5, -0.267
040D05 C2 FF FF    1075*       dl 0xFFFFC2 ; 345.938 F6, -0.243
040D08 C8 FF FF    1076*       dl 0xFFFFC8 ; 347.344 F7, -0.219
040D0B CF FF FF    1077*       dl 0xFFFFCF ; 348.750 F8, -0.195
040D0E D5 FF FF    1078*       dl 0xFFFFD5 ; 350.156 F9, -0.171
040D11 DB FF FF    1079*       dl 0xFFFFDB ; 351.563 FA, -0.147
040D14 E1 FF FF    1080*       dl 0xFFFFE1 ; 352.969 FB, -0.122
040D17 E7 FF FF    1081*       dl 0xFFFFE7 ; 354.375 FC, -0.098
040D1A EE FF FF    1082*       dl 0xFFFFEE ; 355.781 FD, -0.074
040D1D F4 FF FF    1083*       dl 0xFFFFF4 ; 357.188 FE, -0.049
040D20 FA FF FF    1084*       dl 0xFFFFFA ; 358.594 FF, -0.025
040D23 00 00 00    1085*       dl 0x000000 ; 0.000 00, 0.000 for interpolation
040D26             1086*   
040D26             1087*   atan_lut_168:
040D26 00 00 00    1088*       dl 0x000000 ; 000000, 0.000
040D29 28 00 00    1089*       dl 0x000028 ; 000001, 0.224
040D2C 51 00 00    1090*       dl 0x000051 ; 000002, 0.448
040D2F 7A 00 00    1091*       dl 0x00007A ; 000003, 0.671
040D32 A2 00 00    1092*       dl 0x0000A2 ; 000004, 0.895
040D35 CB 00 00    1093*       dl 0x0000CB ; 000005, 1.119
040D38 F4 00 00    1094*       dl 0x0000F4 ; 000006, 1.343
040D3B 1D 01 00    1095*       dl 0x00011D ; 000007, 1.566
040D3E 45 01 00    1096*       dl 0x000145 ; 000008, 1.790
040D41 6E 01 00    1097*       dl 0x00016E ; 000009, 2.013
040D44 97 01 00    1098*       dl 0x000197 ; 00000A, 2.237
040D47 BF 01 00    1099*       dl 0x0001BF ; 00000B, 2.460
040D4A E8 01 00    1100*       dl 0x0001E8 ; 00000C, 2.684
040D4D 11 02 00    1101*       dl 0x000211 ; 00000D, 2.907
040D50 39 02 00    1102*       dl 0x000239 ; 00000E, 3.130
040D53 62 02 00    1103*       dl 0x000262 ; 00000F, 3.353
040D56 8B 02 00    1104*       dl 0x00028B ; 000010, 3.576
040D59 B3 02 00    1105*       dl 0x0002B3 ; 000011, 3.799
040D5C DC 02 00    1106*       dl 0x0002DC ; 000012, 4.022
040D5F 04 03 00    1107*       dl 0x000304 ; 000013, 4.245
040D62 2D 03 00    1108*       dl 0x00032D ; 000014, 4.467
040D65 55 03 00    1109*       dl 0x000355 ; 000015, 4.690
040D68 7E 03 00    1110*       dl 0x00037E ; 000016, 4.912
040D6B A6 03 00    1111*       dl 0x0003A6 ; 000017, 5.134
040D6E CE 03 00    1112*       dl 0x0003CE ; 000018, 5.356
040D71 F7 03 00    1113*       dl 0x0003F7 ; 000019, 5.578
040D74 1F 04 00    1114*       dl 0x00041F ; 00001A, 5.799
040D77 48 04 00    1115*       dl 0x000448 ; 00001B, 6.021
040D7A 70 04 00    1116*       dl 0x000470 ; 00001C, 6.242
040D7D 98 04 00    1117*       dl 0x000498 ; 00001D, 6.463
040D80 C0 04 00    1118*       dl 0x0004C0 ; 00001E, 6.684
040D83 E8 04 00    1119*       dl 0x0004E8 ; 00001F, 6.905
040D86 11 05 00    1120*       dl 0x000511 ; 000020, 7.125
040D89 39 05 00    1121*       dl 0x000539 ; 000021, 7.345
040D8C 61 05 00    1122*       dl 0x000561 ; 000022, 7.565
040D8F 89 05 00    1123*       dl 0x000589 ; 000023, 7.785
040D92 B1 05 00    1124*       dl 0x0005B1 ; 000024, 8.005
040D95 D9 05 00    1125*       dl 0x0005D9 ; 000025, 8.224
040D98 01 06 00    1126*       dl 0x000601 ; 000026, 8.443
040D9B 28 06 00    1127*       dl 0x000628 ; 000027, 8.662
040D9E 50 06 00    1128*       dl 0x000650 ; 000028, 8.881
040DA1 78 06 00    1129*       dl 0x000678 ; 000029, 9.099
040DA4 A0 06 00    1130*       dl 0x0006A0 ; 00002A, 9.317
040DA7 C7 06 00    1131*       dl 0x0006C7 ; 00002B, 9.535
040DAA EF 06 00    1132*       dl 0x0006EF ; 00002C, 9.752
040DAD 16 07 00    1133*       dl 0x000716 ; 00002D, 9.970
040DB0 3E 07 00    1134*       dl 0x00073E ; 00002E, 10.187
040DB3 65 07 00    1135*       dl 0x000765 ; 00002F, 10.403
040DB6 8D 07 00    1136*       dl 0x00078D ; 000030, 10.620
040DB9 B4 07 00    1137*       dl 0x0007B4 ; 000031, 10.836
040DBC DB 07 00    1138*       dl 0x0007DB ; 000032, 11.051
040DBF 03 08 00    1139*       dl 0x000803 ; 000033, 11.267
040DC2 2A 08 00    1140*       dl 0x00082A ; 000034, 11.482
040DC5 51 08 00    1141*       dl 0x000851 ; 000035, 11.697
040DC8 78 08 00    1142*       dl 0x000878 ; 000036, 11.911
040DCB 9F 08 00    1143*       dl 0x00089F ; 000037, 12.125
040DCE C6 08 00    1144*       dl 0x0008C6 ; 000038, 12.339
040DD1 ED 08 00    1145*       dl 0x0008ED ; 000039, 12.553
040DD4 13 09 00    1146*       dl 0x000913 ; 00003A, 12.766
040DD7 3A 09 00    1147*       dl 0x00093A ; 00003B, 12.978
040DDA 61 09 00    1148*       dl 0x000961 ; 00003C, 13.191
040DDD 87 09 00    1149*       dl 0x000987 ; 00003D, 13.403
040DE0 AE 09 00    1150*       dl 0x0009AE ; 00003E, 13.614
040DE3 D4 09 00    1151*       dl 0x0009D4 ; 00003F, 13.825
040DE6 FB 09 00    1152*       dl 0x0009FB ; 000040, 14.036
040DE9 21 0A 00    1153*       dl 0x000A21 ; 000041, 14.247
040DEC 47 0A 00    1154*       dl 0x000A47 ; 000042, 14.457
040DEF 6D 0A 00    1155*       dl 0x000A6D ; 000043, 14.666
040DF2 94 0A 00    1156*       dl 0x000A94 ; 000044, 14.876
040DF5 BA 0A 00    1157*       dl 0x000ABA ; 000045, 15.085
040DF8 E0 0A 00    1158*       dl 0x000AE0 ; 000046, 15.293
040DFB 05 0B 00    1159*       dl 0x000B05 ; 000047, 15.501
040DFE 2B 0B 00    1160*       dl 0x000B2B ; 000048, 15.709
040E01 51 0B 00    1161*       dl 0x000B51 ; 000049, 15.916
040E04 77 0B 00    1162*       dl 0x000B77 ; 00004A, 16.123
040E07 9C 0B 00    1163*       dl 0x000B9C ; 00004B, 16.329
040E0A C2 0B 00    1164*       dl 0x000BC2 ; 00004C, 16.535
040E0D E7 0B 00    1165*       dl 0x000BE7 ; 00004D, 16.740
040E10 0C 0C 00    1166*       dl 0x000C0C ; 00004E, 16.945
040E13 32 0C 00    1167*       dl 0x000C32 ; 00004F, 17.150
040E16 57 0C 00    1168*       dl 0x000C57 ; 000050, 17.354
040E19 7C 0C 00    1169*       dl 0x000C7C ; 000051, 17.558
040E1C A1 0C 00    1170*       dl 0x000CA1 ; 000052, 17.761
040E1F C6 0C 00    1171*       dl 0x000CC6 ; 000053, 17.964
040E22 EB 0C 00    1172*       dl 0x000CEB ; 000054, 18.166
040E25 0F 0D 00    1173*       dl 0x000D0F ; 000055, 18.368
040E28 34 0D 00    1174*       dl 0x000D34 ; 000056, 18.569
040E2B 58 0D 00    1175*       dl 0x000D58 ; 000057, 18.770
040E2E 7D 0D 00    1176*       dl 0x000D7D ; 000058, 18.970
040E31 A1 0D 00    1177*       dl 0x000DA1 ; 000059, 19.170
040E34 C6 0D 00    1178*       dl 0x000DC6 ; 00005A, 19.370
040E37 EA 0D 00    1179*       dl 0x000DEA ; 00005B, 19.569
040E3A 0E 0E 00    1180*       dl 0x000E0E ; 00005C, 19.767
040E3D 32 0E 00    1181*       dl 0x000E32 ; 00005D, 19.965
040E40 56 0E 00    1182*       dl 0x000E56 ; 00005E, 20.163
040E43 7A 0E 00    1183*       dl 0x000E7A ; 00005F, 20.360
040E46 9E 0E 00    1184*       dl 0x000E9E ; 000060, 20.556
040E49 C1 0E 00    1185*       dl 0x000EC1 ; 000061, 20.752
040E4C E5 0E 00    1186*       dl 0x000EE5 ; 000062, 20.947
040E4F 08 0F 00    1187*       dl 0x000F08 ; 000063, 21.142
040E52 2C 0F 00    1188*       dl 0x000F2C ; 000064, 21.337
040E55 4F 0F 00    1189*       dl 0x000F4F ; 000065, 21.531
040E58 72 0F 00    1190*       dl 0x000F72 ; 000066, 21.724
040E5B 95 0F 00    1191*       dl 0x000F95 ; 000067, 21.917
040E5E B8 0F 00    1192*       dl 0x000FB8 ; 000068, 22.109
040E61 DB 0F 00    1193*       dl 0x000FDB ; 000069, 22.301
040E64 FE 0F 00    1194*       dl 0x000FFE ; 00006A, 22.493
040E67 21 10 00    1195*       dl 0x001021 ; 00006B, 22.683
040E6A 44 10 00    1196*       dl 0x001044 ; 00006C, 22.874
040E6D 66 10 00    1197*       dl 0x001066 ; 00006D, 23.063
040E70 89 10 00    1198*       dl 0x001089 ; 00006E, 23.253
040E73 AB 10 00    1199*       dl 0x0010AB ; 00006F, 23.441
040E76 CD 10 00    1200*       dl 0x0010CD ; 000070, 23.629
040E79 EF 10 00    1201*       dl 0x0010EF ; 000071, 23.817
040E7C 11 11 00    1202*       dl 0x001111 ; 000072, 24.004
040E7F 33 11 00    1203*       dl 0x001133 ; 000073, 24.191
040E82 55 11 00    1204*       dl 0x001155 ; 000074, 24.376
040E85 77 11 00    1205*       dl 0x001177 ; 000075, 24.562
040E88 99 11 00    1206*       dl 0x001199 ; 000076, 24.747
040E8B BA 11 00    1207*       dl 0x0011BA ; 000077, 24.931
040E8E DC 11 00    1208*       dl 0x0011DC ; 000078, 25.115
040E91 FD 11 00    1209*       dl 0x0011FD ; 000079, 25.298
040E94 1E 12 00    1210*       dl 0x00121E ; 00007A, 25.481
040E97 3F 12 00    1211*       dl 0x00123F ; 00007B, 25.663
040E9A 60 12 00    1212*       dl 0x001260 ; 00007C, 25.844
040E9D 81 12 00    1213*       dl 0x001281 ; 00007D, 26.025
040EA0 A2 12 00    1214*       dl 0x0012A2 ; 00007E, 26.206
040EA3 C3 12 00    1215*       dl 0x0012C3 ; 00007F, 26.386
040EA6 E4 12 00    1216*       dl 0x0012E4 ; 000080, 26.565
040EA9 04 13 00    1217*       dl 0x001304 ; 000081, 26.744
040EAC 25 13 00    1218*       dl 0x001325 ; 000082, 26.922
040EAF 45 13 00    1219*       dl 0x001345 ; 000083, 27.100
040EB2 65 13 00    1220*       dl 0x001365 ; 000084, 27.277
040EB5 85 13 00    1221*       dl 0x001385 ; 000085, 27.453
040EB8 A5 13 00    1222*       dl 0x0013A5 ; 000086, 27.629
040EBB C5 13 00    1223*       dl 0x0013C5 ; 000087, 27.805
040EBE E5 13 00    1224*       dl 0x0013E5 ; 000088, 27.979
040EC1 05 14 00    1225*       dl 0x001405 ; 000089, 28.154
040EC4 24 14 00    1226*       dl 0x001424 ; 00008A, 28.327
040EC7 44 14 00    1227*       dl 0x001444 ; 00008B, 28.501
040ECA 63 14 00    1228*       dl 0x001463 ; 00008C, 28.673
040ECD 83 14 00    1229*       dl 0x001483 ; 00008D, 28.845
040ED0 A2 14 00    1230*       dl 0x0014A2 ; 00008E, 29.017
040ED3 C1 14 00    1231*       dl 0x0014C1 ; 00008F, 29.187
040ED6 E0 14 00    1232*       dl 0x0014E0 ; 000090, 29.358
040ED9 FF 14 00    1233*       dl 0x0014FF ; 000091, 29.527
040EDC 1E 15 00    1234*       dl 0x00151E ; 000092, 29.697
040EDF 3C 15 00    1235*       dl 0x00153C ; 000093, 29.865
040EE2 5B 15 00    1236*       dl 0x00155B ; 000094, 30.033
040EE5 79 15 00    1237*       dl 0x001579 ; 000095, 30.201
040EE8 98 15 00    1238*       dl 0x001598 ; 000096, 30.368
040EEB B6 15 00    1239*       dl 0x0015B6 ; 000097, 30.534
040EEE D4 15 00    1240*       dl 0x0015D4 ; 000098, 30.700
040EF1 F2 15 00    1241*       dl 0x0015F2 ; 000099, 30.865
040EF4 10 16 00    1242*       dl 0x001610 ; 00009A, 31.030
040EF7 2E 16 00    1243*       dl 0x00162E ; 00009B, 31.194
040EFA 4C 16 00    1244*       dl 0x00164C ; 00009C, 31.357
040EFD 6A 16 00    1245*       dl 0x00166A ; 00009D, 31.520
040F00 87 16 00    1246*       dl 0x001687 ; 00009E, 31.682
040F03 A5 16 00    1247*       dl 0x0016A5 ; 00009F, 31.844
040F06 C2 16 00    1248*       dl 0x0016C2 ; 0000A0, 32.005
040F09 DF 16 00    1249*       dl 0x0016DF ; 0000A1, 32.166
040F0C FC 16 00    1250*       dl 0x0016FC ; 0000A2, 32.326
040F0F 19 17 00    1251*       dl 0x001719 ; 0000A3, 32.486
040F12 36 17 00    1252*       dl 0x001736 ; 0000A4, 32.645
040F15 53 17 00    1253*       dl 0x001753 ; 0000A5, 32.803
040F18 70 17 00    1254*       dl 0x001770 ; 0000A6, 32.961
040F1B 8C 17 00    1255*       dl 0x00178C ; 0000A7, 33.118
040F1E A9 17 00    1256*       dl 0x0017A9 ; 0000A8, 33.275
040F21 C5 17 00    1257*       dl 0x0017C5 ; 0000A9, 33.431
040F24 E2 17 00    1258*       dl 0x0017E2 ; 0000AA, 33.587
040F27 FE 17 00    1259*       dl 0x0017FE ; 0000AB, 33.742
040F2A 1A 18 00    1260*       dl 0x00181A ; 0000AC, 33.896
040F2D 36 18 00    1261*       dl 0x001836 ; 0000AD, 34.050
040F30 52 18 00    1262*       dl 0x001852 ; 0000AE, 34.203
040F33 6E 18 00    1263*       dl 0x00186E ; 0000AF, 34.356
040F36 8A 18 00    1264*       dl 0x00188A ; 0000B0, 34.509
040F39 A5 18 00    1265*       dl 0x0018A5 ; 0000B1, 34.660
040F3C C1 18 00    1266*       dl 0x0018C1 ; 0000B2, 34.811
040F3F DC 18 00    1267*       dl 0x0018DC ; 0000B3, 34.962
040F42 F7 18 00    1268*       dl 0x0018F7 ; 0000B4, 35.112
040F45 13 19 00    1269*       dl 0x001913 ; 0000B5, 35.262
040F48 2E 19 00    1270*       dl 0x00192E ; 0000B6, 35.410
040F4B 49 19 00    1271*       dl 0x001949 ; 0000B7, 35.559
040F4E 64 19 00    1272*       dl 0x001964 ; 0000B8, 35.707
040F51 7F 19 00    1273*       dl 0x00197F ; 0000B9, 35.854
040F54 99 19 00    1274*       dl 0x001999 ; 0000BA, 36.001
040F57 B4 19 00    1275*       dl 0x0019B4 ; 0000BB, 36.147
040F5A CE 19 00    1276*       dl 0x0019CE ; 0000BC, 36.293
040F5D E9 19 00    1277*       dl 0x0019E9 ; 0000BD, 36.438
040F60 03 1A 00    1278*       dl 0x001A03 ; 0000BE, 36.582
040F63 1D 1A 00    1279*       dl 0x001A1D ; 0000BF, 36.726
040F66 37 1A 00    1280*       dl 0x001A37 ; 0000C0, 36.870
040F69 51 1A 00    1281*       dl 0x001A51 ; 0000C1, 37.013
040F6C 6B 1A 00    1282*       dl 0x001A6B ; 0000C2, 37.155
040F6F 85 1A 00    1283*       dl 0x001A85 ; 0000C3, 37.297
040F72 9F 1A 00    1284*       dl 0x001A9F ; 0000C4, 37.439
040F75 B9 1A 00    1285*       dl 0x001AB9 ; 0000C5, 37.579
040F78 D2 1A 00    1286*       dl 0x001AD2 ; 0000C6, 37.720
040F7B EC 1A 00    1287*       dl 0x001AEC ; 0000C7, 37.859
040F7E 05 1B 00    1288*       dl 0x001B05 ; 0000C8, 37.999
040F81 1E 1B 00    1289*       dl 0x001B1E ; 0000C9, 38.137
040F84 37 1B 00    1290*       dl 0x001B37 ; 0000CA, 38.276
040F87 50 1B 00    1291*       dl 0x001B50 ; 0000CB, 38.413
040F8A 69 1B 00    1292*       dl 0x001B69 ; 0000CC, 38.550
040F8D 82 1B 00    1293*       dl 0x001B82 ; 0000CD, 38.687
040F90 9B 1B 00    1294*       dl 0x001B9B ; 0000CE, 38.823
040F93 B4 1B 00    1295*       dl 0x001BB4 ; 0000CF, 38.959
040F96 CC 1B 00    1296*       dl 0x001BCC ; 0000D0, 39.094
040F99 E5 1B 00    1297*       dl 0x001BE5 ; 0000D1, 39.228
040F9C FD 1B 00    1298*       dl 0x001BFD ; 0000D2, 39.362
040F9F 16 1C 00    1299*       dl 0x001C16 ; 0000D3, 39.496
040FA2 2E 1C 00    1300*       dl 0x001C2E ; 0000D4, 39.629
040FA5 46 1C 00    1301*       dl 0x001C46 ; 0000D5, 39.762
040FA8 5E 1C 00    1302*       dl 0x001C5E ; 0000D6, 39.894
040FAB 76 1C 00    1303*       dl 0x001C76 ; 0000D7, 40.025
040FAE 8E 1C 00    1304*       dl 0x001C8E ; 0000D8, 40.156
040FB1 A5 1C 00    1305*       dl 0x001CA5 ; 0000D9, 40.286
040FB4 BD 1C 00    1306*       dl 0x001CBD ; 0000DA, 40.416
040FB7 D5 1C 00    1307*       dl 0x001CD5 ; 0000DB, 40.546
040FBA EC 1C 00    1308*       dl 0x001CEC ; 0000DC, 40.675
040FBD 04 1D 00    1309*       dl 0x001D04 ; 0000DD, 40.803
040FC0 1B 1D 00    1310*       dl 0x001D1B ; 0000DE, 40.931
040FC3 32 1D 00    1311*       dl 0x001D32 ; 0000DF, 41.059
040FC6 49 1D 00    1312*       dl 0x001D49 ; 0000E0, 41.186
040FC9 60 1D 00    1313*       dl 0x001D60 ; 0000E1, 41.312
040FCC 77 1D 00    1314*       dl 0x001D77 ; 0000E2, 41.438
040FCF 8E 1D 00    1315*       dl 0x001D8E ; 0000E3, 41.564
040FD2 A5 1D 00    1316*       dl 0x001DA5 ; 0000E4, 41.689
040FD5 BB 1D 00    1317*       dl 0x001DBB ; 0000E5, 41.814
040FD8 D2 1D 00    1318*       dl 0x001DD2 ; 0000E6, 41.938
040FDB E9 1D 00    1319*       dl 0x001DE9 ; 0000E7, 42.061
040FDE FF 1D 00    1320*       dl 0x001DFF ; 0000E8, 42.184
040FE1 15 1E 00    1321*       dl 0x001E15 ; 0000E9, 42.307
040FE4 2C 1E 00    1322*       dl 0x001E2C ; 0000EA, 42.429
040FE7 42 1E 00    1323*       dl 0x001E42 ; 0000EB, 42.551
040FEA 58 1E 00    1324*       dl 0x001E58 ; 0000EC, 42.672
040FED 6E 1E 00    1325*       dl 0x001E6E ; 0000ED, 42.793
040FF0 84 1E 00    1326*       dl 0x001E84 ; 0000EE, 42.913
040FF3 99 1E 00    1327*       dl 0x001E99 ; 0000EF, 43.033
040FF6 AF 1E 00    1328*       dl 0x001EAF ; 0000F0, 43.152
040FF9 C5 1E 00    1329*       dl 0x001EC5 ; 0000F1, 43.271
040FFC DA 1E 00    1330*       dl 0x001EDA ; 0000F2, 43.390
040FFF F0 1E 00    1331*       dl 0x001EF0 ; 0000F3, 43.508
041002 05 1F 00    1332*       dl 0x001F05 ; 0000F4, 43.625
041005 1B 1F 00    1333*       dl 0x001F1B ; 0000F5, 43.742
041008 30 1F 00    1334*       dl 0x001F30 ; 0000F6, 43.859
04100B 45 1F 00    1335*       dl 0x001F45 ; 0000F7, 43.975
04100E 5A 1F 00    1336*       dl 0x001F5A ; 0000F8, 44.091
041011 6F 1F 00    1337*       dl 0x001F6F ; 0000F9, 44.206
041014 84 1F 00    1338*       dl 0x001F84 ; 0000FA, 44.321
041017 99 1F 00    1339*       dl 0x001F99 ; 0000FB, 44.435
04101A AD 1F 00    1340*       dl 0x001FAD ; 0000FC, 44.549
04101D C2 1F 00    1341*       dl 0x001FC2 ; 0000FD, 44.662
041020 D7 1F 00    1342*       dl 0x001FD7 ; 0000FE, 44.775
041023 EB 1F 00    1343*       dl 0x001FEB ; 0000FF, 44.888
041026 00 20 00    1344*       dl 0x002000 ; 000100, 45.000 only needed for interpolation
041029             0038        include "timer.inc"
041029             0001*   ; Table 32. Timer Control Registers
041029             0002*   TMR0_CTL: equ 80h
041029             0003*   TMR1_CTL: equ 83h
041029             0004*   TMR2_CTL: equ 86h
041029             0005*   TMR3_CTL: equ 89h
041029             0006*   TMR4_CTL: equ 8Ch
041029             0007*   TMR5_CTL: equ 8Fh
041029             0008*   
041029             0009*   ; each timer register takes three bytes:
041029             0010*   ;   0: control register
041029             0011*   ;   1: low byte of timer reset value
041029             0012*   ;   2: high byte of timer reset value
041029             0013*   ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
041029             0014*   ; which correctly force the high and upper bytes of the address bus to zero
041029             0015*   
041029             0016*   TMR_REG_CTL: equ 0
041029             0017*   TMR_RES_LOW: equ 1
041029             0018*   TMR_RES_HIGH: equ 2
041029             0019*   
041029             0020*   ; Timer Control Register Bit Definitions
041029             0021*   PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
041029             0022*                               ; This bit is reset to 0 every time the TMRx_CTL register is read.
041029             0023*   PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
041029             0024*                               ; an interrupt signal is sent to the CPU. This bit remains 1 until
041029             0025*                               ; the TMRx_CTL register is read.
041029             0026*   
041029             0027*   IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
041029             0028*   IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
041029             0029*   
041029             0030*   PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
041029             0031*                               ;  0,and counting stops when the end-of-count value is reached.
041029             0032*   PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
041029             0033*                               ; written to the counter when the end-of-count value is reached.
041029             0034*   
041029             0035*   ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
041029             0036*   CLK_DIV_256:  equ %00001100 ;
041029             0037*   CLK_DIV_64:   equ %00001000 ;
041029             0038*   CLK_DIV_16:   equ %00000100 ;
041029             0039*   CLK_DIV_4:    equ %00000000 ;
041029             0040*   
041029             0041*   RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
041029             0042*   RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
041029             0043*                               ; When a 1 is written to this bit,the values in the reload registers
041029             0044*                               ;  are loaded into the downcounter when the timer restarts. The
041029             0045*                               ; programmer must ensure that this bit is set to 1 each time
041029             0046*                               ; SINGLE-PASS mode is used.
041029             0047*   
041029             0048*   ; disable/enable the programmable reload timer
041029             0049*   PRT_EN_0:     equ %00000000 ;
041029             0050*   PRT_EN_1:     equ %00000001 ;
041029             0051*   
041029             0052*   ; Table 37. Timer Input Source Select Register
041029             0053*   ; Each of the 4 timers are allocated two bits of the 8-bit register
041029             0054*   ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
041029             0055*   ;   00: System clock / CLK_DIV
041029             0056*   ;   01: RTC / CLK_DIV
041029             0057*   ;   NOTE: these are the values given in the manual,but it may be a typo
041029             0058*   ;   10: GPIO port B pin 1.
041029             0059*   ;   11: GPIO port B pin 1.
041029             0060*   TMR_ISS:   equ 92h ; register address
041029             0061*   
041029             0062*   ; Table 51. Real-Time Clock Control Register
041029             0063*   RTC_CTRL: equ EDh ; register address
041029             0064*   
041029             0065*   ; alarm interrupt disable/enable
041029             0066*   RTC_ALARM_0:    equ %00000000
041029             0067*   RTC_ALARM_1:    equ %10000000
041029             0068*   
041029             0069*   ; interrupt on alarm disable/enable
041029             0070*   RTC_INT_ENT_0:  equ %00000000
041029             0071*   RTC_INT_ENT_1:  equ %01000000
041029             0072*   
041029             0073*   RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
041029             0074*   RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
041029             0075*   
041029             0076*   RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
041029             0077*                                   ; On-chip 32768 Hz oscillator is enabled.
041029             0078*   RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
041029             0079*                                   ; On-chip 32768 Hz oscillator is disabled.
041029             0080*   
041029             0081*   RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
041029             0082*   RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
041029             0083*   
041029             0084*   RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
041029             0085*   RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
041029             0086*   
041029             0087*   RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
041029             0088*                                   ; RTC counter is enabled.
041029             0089*   RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
041029             0090*                                   ; RTC counter is disabled.
041029             0091*   
041029             0092*   ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
041029             0093*   
041029             0094*   prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
041029             0095*   prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
041029 00 00 00    0096*   prt_reload: dl 0x000000
04102C             0097*   
04102C             0098*   ; returns: a = 0 if running on hardware,1 if running on emulator
04102C             0099*   ;          de = number PRT interrupts during test interval
04102C             0100*   prt_calibrate:
04102C CD 3B 13 04 0101*       call vdu_vblank
041030             0102*   ; set a MOS timer
041030 21 78 00 00 0103*       ld hl,120*1 ; 1 second
041034 FD 21 B4 11 0104*       ld iy,tmr_test
       04          
041039 CD 92 11 04 0105*       call tmr_set
04103D             0106*   ; set a PRT timer
04103D             0107*       ; ld hl,prt_reload_hardware
04103D             0108*       ; ld hl,prt_reload_emulator
04103D 21 05 2D 00 0109*       ld hl,prt_reload_emulator + prt_reload_hardware / 2
041041 22 29 10 04 0110*       ld (prt_reload),hl
041045 CD CD 10 04 0111*       call prt_set
041049             0112*   @loop:
041049             0113*   ; check time remaining on MOS timer
041049 CD A0 11 04 0114*       call tmr_get
04104D CA 57 10 04 0115*       jp z,@done ; time expired,so quit
041051 FA 57 10 04 0116*       jp m,@done ; time past expiration (negative),so quit
041055 18 F2       0117*       jr @loop
041057             0118*   @done:
041057 ED 5B 1B 11 0119*       ld de,(prt_irq_counter)
       04          
04105C 01 0C 2D 00 0120*       ld bc,prt_reload_hardware ; default value for running on hardware
041060 ED 43 29 10 0121*       ld (prt_reload),bc
       04          
041065 21 64 00 00 0122*       ld hl,100 ; halfway between 101 for real hardware and 99 for emulator
041069 AF          0123*       xor a ; clear carry,zero is default value for running on hardware
04106A 32 8C 10 04 0124*       ld (is_emulator),a
04106E ED 52       0125*       sbc hl,de
041070 21 8D 10 04 0126*       ld hl,on_hardware ; default message for running on hardware
041074 CA 2C 10 04 0127*       jp z,prt_calibrate ; zero result is indeterminate so we try again
041078 F8          0128*       ret m ; negative result means we're on hardware
041079 3C          0129*       inc a ; we're on emulator
04107A 32 8C 10 04 0130*       ld (is_emulator),a
04107E 01 FF 2C 00 0131*       ld bc,prt_reload_emulator
041082 ED 43 29 10 0132*       ld (prt_reload),bc
       04          
041087 21 A3 10 04 0133*       ld hl,on_emulator
04108B C9          0134*       ret
04108C 00          0135*   is_emulator: db 0
04108D 52 75 6E 6E 0136*   on_hardware: defb "Running on hardware\r\n",0
       69 6E 67 20 
       6F 6E 20 68 
       61 72 64 77 
       61 72 65 0D 
       0A 00       
0410A3 52 75 6E 6E 0137*   on_emulator: defb "Running on emulator\r\n",0
       69 6E 67 20 
       6F 6E 20 65 
       6D 75 6C 61 
       74 6F 72 0D 
       0A 00       
0410B9             0138*   
0410B9 43 61 6C 69 0139*   calibrating_timer: defb "Calibrating timer\r\n",0
       62 72 61 74 
       69 6E 67 20 
       74 69 6D 65 
       72 0D 0A 00 
0410CD             0140*   
0410CD             0141*   ; set PRT timer
0410CD             0142*   prt_set:
0410CD 21 00 00 00 0143*       ld hl,0
0410D1 22 1B 11 04 0144*       ld (prt_irq_counter),hl
0410D5 2A 29 10 04 0145*       ld hl,(prt_reload)
0410D9 ED 29 84    0146*       out0 (TMR1_CTL+TMR_RES_LOW),l
0410DC ED 21 85    0147*   	out0 (TMR1_CTL+TMR_RES_HIGH),h
0410DF             0148*   ; disable timer
0410DF 3E 06       0149*       ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
0410E1 ED 39 83    0150*   	out0 (TMR1_CTL+TMR_REG_CTL),a
0410E4             0151*   ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
0410E4 3E 57       0152*       ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
0410E6 ED 39 83    0153*   	out0 (TMR1_CTL+TMR_REG_CTL),a
0410E9 C9          0154*       ret
0410EA             0155*   
0410EA             0156*   ; ===============================================
0410EA             0157*   ; PRT Timer Interrupt Handling
0410EA             0158*   ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.asm
0410EA             0159*   ; -----------------------------------------------
0410EA             0160*   prt_irq_init:
0410EA             0161*       ; set up interrupt vector table 2
0410EA 21 00 00 00 0162*   	ld hl,0
0410EE 3A 0C 01 00 0163*   	ld a,($10c)
0410F2 6F          0164*   	ld l,a
0410F3 3A 0D 01 00 0165*   	ld a,($10d)
0410F7 67          0166*   	ld h,a
0410F8             0167*   
0410F8             0168*   	; skip over CALL ($c3)
0410F8 23          0169*   	inc hl
0410F9             0170*   	; load address of jump into vector table 2 (in ram)
0410F9 ED 27       0171*   	ld hl,(hl)
0410FB             0172*   
0410FB             0173*   	; write CALL prt_irq_handler to vector table 2
0410FB 3E C3       0174*   	ld a,$c3
0410FD 77          0175*   	ld (hl),a
0410FE 23          0176*   	inc hl
0410FF 11 06 11 04 0177*   	ld de,prt_irq_handler
041103 ED 1F       0178*   	ld (hl),de
041105             0179*   
041105 C9          0180*       ret
041106             0181*   
041106             0182*   prt_irq_handler:
041106 F3          0183*   	di
041107 F5          0184*   	push af
041108 E5          0185*       push hl
041109 ED 38 83    0186*   	in0 a,(TMR1_CTL+TMR_REG_CTL)
04110C 2A 1B 11 04 0187*   	ld hl,(prt_irq_counter)
041110 23          0188*   	inc hl
041111 22 1B 11 04 0189*   	ld (prt_irq_counter),hl
041115 E1          0190*       pop hl
041116 F1          0191*   	pop af
041117 FB          0192*   	ei
041118 5B ED 4D    0193*   	reti.l
04111B             0194*   
04111B             0195*   prt_irq_counter:
04111B 00 00 00    0196*   	.dl 0
04111E             0197*   prt_irq_counter_saved:
04111E 00 00 00    0198*       .dl 0
041121             0199*   
041121             0200*   prt_loop_reset:
041121 E5          0201*       push hl
041122 21 00 00 00 0202*   	ld hl,0
041126 22 1B 11 04 0203*   	ld (prt_irq_counter),hl
04112A 22 8C 11 04 0204*       ld (prt_loop_counter),hl
04112E 22 8F 11 04 0205*       ld (prt_loops),hl
041132 CD CD 10 04 0206*       call prt_set
041136 E1          0207*       pop hl
041137 C9          0208*       ret
041138             0209*   
041138             0210*   prt_loop_start:
041138 E5          0211*       push hl
041139 21 00 00 00 0212*   	ld hl,0
04113D 22 1B 11 04 0213*   	ld (prt_irq_counter),hl
041141 E1          0214*       pop hl
041142 C9          0215*       ret
041143             0216*   
041143             0217*   prt_loop_stop:
041143 E5          0218*       push hl
041144 D5          0219*       push de
041145 2A 1B 11 04 0220*       ld hl,(prt_irq_counter)
041149 ED 5B 8C 11 0221*       ld de,(prt_loop_counter)
       04          
04114E 19          0222*       add hl,de
04114F 22 8C 11 04 0223*       ld (prt_loop_counter),hl
041153 21 00 00 00 0224*       ld hl,0
041157 22 1B 11 04 0225*       ld (prt_irq_counter),hl
04115B 2A 8F 11 04 0226*       ld hl,(prt_loops)
04115F 23          0227*       inc hl
041160 22 8F 11 04 0228*       ld (prt_loops),hl
041164 D1          0229*       pop de
041165 E1          0230*       pop hl
041166 C9          0231*       ret
041167             0232*   
041167             0233*   ; inputs: bc = y,x text coordinates to print
041167             0234*   prt_loop_print:
041167 F5          0235*       push af
041168 E5          0236*       push hl
041169 C5          0237*       push bc
04116A D5          0238*       push de
04116B DD E5       0239*       push ix
04116D FD E5       0240*       push iy
04116F CD 9F 12 04 0241*       call vdu_move_cursor
041173             0242*   
041173 2A 8C 11 04 0243*       ld hl,(prt_loop_counter)
041177 CD CC 00 04 0244*       call printDec
04117B             0245*   
04117B 2A 8F 11 04 0246*       ld hl,(prt_loops)
04117F CD CC 00 04 0247*       call printDec
041183             0248*   
041183 FD E1       0249*       pop iy
041185 DD E1       0250*       pop ix
041187 D1          0251*       pop de
041188 C1          0252*       pop bc
041189 E1          0253*       pop hl
04118A F1          0254*       pop af
04118B C9          0255*       ret
04118C             0256*   
04118C             0257*   prt_loop_counter:
04118C 00 00 00    0258*       .dl 0
04118F             0259*   prt_loops:
04118F 00 00 00    0260*       .dl 0
041192             0261*   
041192             0262*   ; ===============================================
041192             0263*   ; Timer functions
041192             0264*   ; -----------------------------------------------
041192             0265*   ; set a countdown timer
041192             0266*   ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
041192             0267*   ; returns: hl = current time
041192             0268*   tmr_set:
041192 FD 2F 03    0269*       ld (iy+3),hl            ; set time remaining
041195             0270*       MOSCALL mos_sysvars     ; ix points to syvars table
                       M1 Args: function=mos_sysvars 
041195 3E 08       0001*M1 			LD	A, function
041197 5B CF       0002*M1 			RST.LIL	08h
041199 DD 27 00    0271*       ld hl,(ix+sysvar_time)  ; get current time
04119C FD 2F 00    0272*       ld (iy+0),hl            ; set start time
04119F C9          0273*       ret
0411A0             0274*   
0411A0             0275*   ; gets time remaining on a countdown timer
0411A0             0276*   ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0411A0             0277*   ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0411A0             0278*   ;          sign flags: pos = time not expired,zero or neg = time expired
0411A0             0279*   tmr_get:
0411A0             0280*       MOSCALL mos_sysvars     ; ix points to syvars table
                       M1 Args: function=mos_sysvars 
0411A0 3E 08       0001*M1 			LD	A, function
0411A2 5B CF       0002*M1 			RST.LIL	08h
0411A4 DD 17 00    0281*       ld de,(ix+sysvar_time)  ; get current time
0411A7 FD 27 00    0282*       ld hl,(iy+0)            ; get start time
0411AA AF          0283*       xor a                   ; clear carry
0411AB ED 52       0284*       sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0411AD FD 17 03    0285*       ld de,(iy+3)            ; get timer set value
0411B0 AF          0286*       xor a                   ; clear carry
0411B1 ED 5A       0287*       adc hl,de               ; hl = time remaining
0411B3             0288*                               ; (we do adc because add hl,rr doesn't set sign or zero flags)
0411B3 C9          0289*       ret
0411B4             0290*   
0411B4             0291*   tmr_test: ds 6 ; example of a buffer to hold timer data
0411BA             0292*   
       FF FF FF FF 
       FF FF 
0411BA 00 00 00    0293*   timestamp_now: dl 0
0411BD 00 00 00    0294*   timestamp_old: dl 0
0411C0 00 00 00    0295*   timestamp_chg: dl 0
0411C3             0296*   
0411C3             0297*   ; update the global timestamp from the system clock
0411C3             0298*   ; inputs: none
0411C3             0299*   ; returns: hl = time elapsed in 1/120ths of a second
0411C3             0300*   ;          de = current time
0411C3             0301*   ;          ix = pointer to syvars table
0411C3             0302*   ; destroys: af,hl,de,ix
0411C3             0303*   timestamp_tick:
0411C3 ED 5B BA 11 0304*       ld de,(timestamp_now)   ; get previous time
       04          
0411C8 ED 53 BD 11 0305*       ld (timestamp_old),de   ; save previous time
       04          
0411CD             0306*       MOSCALL mos_sysvars     ; ix points to syvars table
                       M1 Args: function=mos_sysvars 
0411CD 3E 08       0001*M1 			LD	A, function
0411CF 5B CF       0002*M1 			RST.LIL	08h
0411D1 DD 27 00    0307*       ld hl,(ix+sysvar_time)  ; get current time
0411D4 22 BA 11 04 0308*       ld (timestamp_now),hl   ; save current time
0411D8 AF          0309*       xor a                   ; clear carry
0411D9 ED 52       0310*       sbc hl,de               ; hl = time elapsed
0411DB 22 C0 11 04 0311*       ld (timestamp_chg),hl   ; save elapsed time
0411DF C9          0312*       ret
0411E0             0313*   
0411E0             0314*   ; set a countdown timer
0411E0             0315*   ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0411E0             0316*   ; requires: timestamp_tick to be called at least once before this function
0411E0             0317*   ; returns: hl = current time
0411E0             0318*   ; destroys: hl
0411E0             0319*   timestamp_tmr_set:
0411E0 FD 2F 03    0320*       ld (iy+3),hl            ; set time remaining
0411E3 2A BA 11 04 0321*       ld hl,(timestamp_now)   ; get current timestamp
0411E7 FD 2F 00    0322*       ld (iy+0),hl            ; set start time
0411EA C9          0323*       ret
0411EB             0324*   
0411EB             0325*   ; gets time remaining on a countdown timer following the global timestamp
0411EB             0326*   ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0411EB             0327*   ; requires: timestamp_tick to be called at least once before this function
0411EB             0328*   ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0411EB             0329*   ;          sign flags: pos = time not expired,zero or neg = time expired
0411EB             0330*   ; destroys: af,hl,de
0411EB             0331*   timestamp_tmr_get:
0411EB ED 5B BA 11 0332*       ld de,(timestamp_now)   ; get current timestamp
       04          
0411F0 FD 27 00    0333*       ld hl,(iy+0)            ; get start time
0411F3 AF          0334*       xor a                   ; clear carry
0411F4 ED 52       0335*       sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0411F6 FD 17 03    0336*       ld de,(iy+3)            ; get timer set value
0411F9 AF          0337*       xor a                   ; clear carry
0411FA ED 5A       0338*       adc hl,de               ; hl = time remaining
0411FC             0339*                               ; (we do adc because add hl,rr doesn't set sign or zero flags)
0411FC C9          0340*       ret
0411FD             0341*   
0411FD             0342*   ; set a stopwatch
0411FD             0343*   ; returns: hl = start time
0411FD             0344*   ; destroys: hl,ix
0411FD             0345*   stopwatch_set:
0411FD             0346*       MOSCALL mos_sysvars     ; ix points to syvars table
                       M1 Args: function=mos_sysvars 
0411FD 3E 08       0001*M1 			LD	A, function
0411FF 5B CF       0002*M1 			RST.LIL	08h
041201 DD 27 00    0347*       ld hl,(ix+sysvar_time)  ; get current time
041204 22 19 12 04 0348*       ld (stopwatch_started),hl            ; set start time
041208 C9          0349*       ret
041209             0350*   
041209             0351*   ; gets time elapsed on a stopwatch
041209             0352*   ; returns: hl = time elapsed in 1/120ths of a second
041209             0353*   ; destroys: af,hl,de,ix
041209             0354*   stopwatch_get:
041209             0355*       MOSCALL mos_sysvars     ; ix points to syvars table
                       M1 Args: function=mos_sysvars 
041209 3E 08       0001*M1 			LD	A, function
04120B 5B CF       0002*M1 			RST.LIL	08h
04120D DD 27 00    0356*       ld hl,(ix+sysvar_time)  ; get current time
041210 ED 5B 19 12 0357*       ld de,(stopwatch_started)            ; get start time
       04          
041215 AF          0358*       xor a                   ; clear carry
041216 ED 52       0359*       sbc hl,de               ; hl = time elapsed (will always be zero or positive)
041218 C9          0360*       ret
041219             0361*   
041219             0362*   stopwatch_started: ds 3 ; buffer to hold stopwatch start time
04121C             0363*   
04121C             0364*   ; ------------------
04121C             0365*   ; delay routine
04121C             0366*   ; Author: Richard Turrnidge
04121C             0367*   ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.asm
04121C             0368*   ; routine waits a fixed time,then returns
04121C             0369*   ; arrive with A =  the delay byte. One bit to be set only.
04121C             0370*   ; eg. ld A,00000100b
04121C             0371*   
04121C             0372*   multiPurposeDelay:
       FF FF FF 
04121C F5          0373*       push af
04121D C5          0374*       push bc
04121E DD E5       0375*       push ix
041220 47          0376*       ld b,a
041221 3E 08       0377*       ld a,$08
041223 5B CF       0378*       RST.LIL	08h                 ; get IX pointer to sysvars
041225             0379*   
041225             0380*   waitLoop:
041225             0381*   
041225 DD 7E 00    0382*       ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
041228             0383*   
041228             0384*                                   ;   we check if bit set is same as last time we checked.
041228             0385*                                   ;   bit 0 - don't use
041228             0386*                                   ;   bit 1 - changes 64 times per second
041228             0387*                                   ;   bit 2 - changes 32 times per second
041228             0388*                                   ;   bit 3 - changes 16 times per second
041228             0389*   
041228             0390*                                   ;   bit 4 - changes 8 times per second
041228             0391*                                   ;   bit 5 - changes 4 times per second
041228             0392*                                   ;   bit 6 - changes 2 times per second
041228             0393*                                   ;   bit 7 - changes 1 times per second
041228 A0          0394*       and b
041229 4F          0395*       ld c,a
04122A 3A 3B 12 04 0396*       ld a,(oldTimeStamp)
04122E B9          0397*       cp c                        ; is A same as last value?
04122F 28 F4       0398*       jr z,waitLoop              ; loop here if it is
041231 79          0399*       ld a,c
041232 32 3B 12 04 0400*       ld (oldTimeStamp),a        ; set new value
041236             0401*   
041236 DD E1       0402*       pop ix
041238 C1          0403*       pop bc
041239 F1          0404*       pop af
04123A C9          0405*       ret
04123B             0406*   
04123B 00          0407*   oldTimeStamp:   .db 00h
04123C             0039        include "vdu.inc"
04123C             0001*   ; VDU 30: Home cursor
04123C             0002*   vdu_home_cursor:
04123C 3E 1E       0003*       ld a,30
04123E 5B D7       0004*   	rst.lil $10
041240 C9          0005*   	ret
041241             0006*   
041241             0007*   vdu_cursor_on:
041241 21 4C 12 04 0008*   	ld hl,@cmd
041245 01 03 00 00 0009*   	ld bc,@end-@cmd
041249 5B DF       0010*   	rst.lil $18
04124B C9          0011*   	ret
04124C             0012*   @cmd:
04124C 17 01 01    0013*   	db 23,1,1
04124F             0014*   @end:
04124F             0015*   
04124F             0016*   vdu_cursor_off:
04124F 21 5A 12 04 0017*   	ld hl,@cmd
041253 01 03 00 00 0018*   	ld bc,@end-@cmd
041257 5B DF       0019*   	rst.lil $18
041259 C9          0020*   	ret
04125A             0021*   @cmd:
04125A 17 01 00    0022*   	db 23,1,0
04125D             0023*   @end:
04125D             0024*   
04125D             0025*   ; VDU 4: Write text at text cursor
04125D             0026*   ; This causes text to be written at th current text cursor position. This is the default mode for text display.
04125D             0027*   ; inputs: none
04125D             0028*   ; prerequisites: the text cursor at the intended position on screen
04125D             0029*   ; outputs: none
04125D             0030*   ; destroys: af
04125D             0031*   vdu_text_to_text_cursor:
04125D 3E 04       0032*       ld a,4
04125F 5B D7       0033*       rst.lil $10
041261 C9          0034*       ret
041262             0035*   ; end vdu_text_to_text_cursor
041262             0036*   
041262             0037*   ; set the text cursor to a specified location and print a string there
041262             0038*   ; inputs: hl = address of string to print, c,b = x,y text coordinates
041262             0039*   ; outputs: text
041262             0040*   ; destroys: af, bc, hl
041262             0041*   ; affects: moves text cursor to position after final char printed by default
041262             0042*   ;          unless overridden by VDU 23, 16 cursor control command settings
041262             0043*   ;          all subsequent print commands (rst.lil $10 or $18) will go to the text cursor
041262             0044*   vdu_print_to_text_location:
041262 E5          0045*       push hl ; preserve string pointer
041263 3E 04       0046*       ld a,4 ; VDU 4 char to text cursor
041265 5B D7       0047*       rst.lil $10
041267 CD 9F 12 04 0048*       call vdu_move_cursor
04126B E1          0049*       pop hl ; restore string pointer
04126C CD 67 00 04 0050*       call printString
041270 C9          0051*       ret
041271             0052*   ; end vdu_print_at_text_location
041271             0053*   
041271             0054*   ; VDU 5: Write text at graphics cursor
041271             0055*   ; inputs: none
041271             0056*   ; prerequisites: the graphics cursor at the intended position on screen
041271             0057*   ; outputs: none
041271             0058*   ; destroys: af
041271             0059*   vdu_text_to_gfx_cursor:
041271 3E 05       0060*       ld a,5
041273 5B D7       0061*   	rst.lil $10
041275 C9          0062*   	ret
041276             0063*   ; end vdu_char_to_gfx_cursor
041276             0064*   
041276             0065*   ; set the graphics cursor to a specified location and print a string there
041276             0066*   ; inputs: hl = address of string to print, bc,de = x,y graphics coordinates
041276             0067*   ; outputs: text
041276             0068*   ; destroys: af, bc, de, hl
041276             0069*   ; affects: moves graphics cursor to position after final char printed by default
041276             0070*   ;          unless overridden by setting bit 6 of the cursor control register (VDU 23, 16)
041276             0071*   ;          all subsequent print commands (rst.lil $10 or $18) will go to the graphics cursor
041276             0072*   vdu_print_to_gfx_location:
041276 E5          0073*       push hl ; preserve string pointer
041277 3E 44       0074*       ld a,plot_pt+mv_abs
041279 CD A1 17 04 0075*       call vdu_plot ; moves the graphics cursor to the specified location
04127D 3E 05       0076*       ld a,5 ; VDU 5 char to gfx cursor
04127F 5B D7       0077*       rst.lil $10
041281 E1          0078*       pop hl ; restore string pointer
041282 01 00 00 00 0079*       ld bc,0
041286 3E 00       0080*       ld a,0
041288 5B DF       0081*       rst.lil $18 ; print the string
04128A C9          0082*       ret
04128B             0083*   ; end vdu_print_at_gfx_location
04128B             0084*   
04128B             0085*   ; VDU 8: Move cursor back one character
04128B             0086*   vdu_cursor_back:
04128B 3E 08       0087*       ld a,8
04128D 5B D7       0088*       rst.lil $10
04128F C9          0089*       ret
041290             0090*   ; end vdu_cursor_back
041290             0091*   
041290             0092*   ; VDU 9: Move cursor forward one character
041290             0093*   vdu_cursor_forward:
041290 3E 09       0094*       ld a,9
041292 5B D7       0095*   	rst.lil $10
041294 C9          0096*   	ret
041295             0097*   ; end vdu_cursor_forward
041295             0098*   
041295             0099*   ; VDU 10: Move cursor down one line
041295             0100*   vdu_cursor_down:
041295 3E 0A       0101*       ld a,10
041297 5B D7       0102*       rst.lil $10
041299 C9          0103*       ret
04129A             0104*   ; end vdu_cursor_down
04129A             0105*   
04129A             0106*   ; VDU 11: Move cursor up one line
04129A             0107*   vdu_cursor_up:
04129A 3E 0B       0108*       ld a,11
04129C 5B D7       0109*       rst.lil $10
04129E C9          0110*       ret
04129F             0111*   ; end vdu_cursor_up
04129F             0112*   
04129F             0113*   
04129F             0114*   ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
04129F             0115*   ; inputs: c=x, b=y 8-bit unsigned integers
04129F             0116*   vdu_move_cursor:
04129F ED 43 B0 12 0117*       ld (@x0),bc
       04          
0412A4 21 AF 12 04 0118*   	ld hl,@cmd
0412A8 01 03 00 00 0119*   	ld bc,@end-@cmd
0412AC 5B DF       0120*   	rst.lil $18
0412AE C9          0121*   	ret
0412AF 1F          0122*   @cmd: 	db 31
0412B0 00          0123*   @x0:	db 0
0412B1 00          0124*   @y0: 	db 0
0412B2 00          0125*   @end: 	db 0 ; padding
0412B3             0126*   
0412B3             0127*   ; https://agonconsole8.github.io/agon-docs/vdp/VDU-Commands/#vdu-23-1-n-cursor-control
0412B3             0128*   ; VDU 23, 16, setting, mask: Define cursor movement behaviour
0412B3             0129*   ; inputs: l = setting, h = mask
0412B3             0130*   ; new_setting = (current_setting AND mask) EOR setting
0412B3             0131*   ; in English: mask controls which bit to turn on or off, setting is the value of the bits to set or reset
0412B3             0132*   vdu_cursor_behaviour:
0412B3 22 C4 12 04 0133*       ld (@setting),hl ; little-endian!
0412B7 21 C2 12 04 0134*       ld hl,@cmd
0412BB 01 04 00 00 0135*       ld bc,@end-@cmd
0412BF 5B DF       0136*       rst.lil $18
0412C1 C9          0137*       ret
0412C2 17 10       0138*   @cmd: db 23,16
0412C4 00          0139*   @setting: db 0
0412C5 00          0140*   @mask: db 0
0412C6 00          0141*   @end: db 0 ; padding
0412C7             0142*   
0412C7             0143*   ; VDU 12: Clear text area (CLS)
0412C7             0144*   vdu_cls:
0412C7 3E 0C       0145*       ld a,12
0412C9 5B D7       0146*   	rst.lil $10
0412CB C9          0147*   	ret
0412CC             0148*   
0412CC             0149*   vdu_flip:
0412CC 21 D7 12 04 0150*   	ld hl,@cmd
0412D0 01 03 00 00 0151*   	ld bc,@end-@cmd
0412D4 5B DF       0152*   	rst.lil $18
0412D6 C9          0153*   	ret
0412D7 17 00 C3    0154*   @cmd: db 23,0,0xC3
0412DA             0155*   @end:
0412DA             0156*   
0412DA             0157*   ; VDU 16: Clear graphics area (CLG)
0412DA             0158*   vdu_clg:
0412DA 3E 10       0159*       ld a,16
0412DC 5B D7       0160*   	rst.lil $10
0412DE C9          0161*   	ret
0412DF             0162*   
0412DF             0163*   ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
0412DF             0164*   ; VDU 23, 7: Scrolling
0412DF             0165*   ;     VDU 23, 7, extent, direction, speed: Scroll the screen
0412DF             0166*   ; inputs: a, extent; l, direction; h; speed
0412DF             0167*   vdu_scroll_down:
0412DF 32 F4 12 04 0168*   	ld (@extent),a
0412E3 22 F5 12 04 0169*   	ld (@dir),hl ; implicitly populates @speed
0412E7 21 F2 12 04 0170*   	ld hl,@cmd
0412EB 01 05 00 00 0171*   	ld bc,@end-@cmd
0412EF 5B DF       0172*   	rst.lil $18     ;; Sending command to VDP
0412F1 C9          0173*   	ret
0412F2 17 07       0174*   @cmd:       db 23,7
0412F4 00          0175*   @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
0412F5 00          0176*   @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
0412F6 00          0177*   @speed:     db 0x00 ; pixels
0412F7 00          0178*   @end:		db 0x00 ; padding
0412F8             0179*   
0412F8             0180*   ; COLOUR MODES
0412F8             0181*   ; Mode	Effect
0412F8             0182*   ; 0	Set on-screen pixel to target colour value
0412F8             0183*   ; 1	OR value with the on-screen pixel
0412F8             0184*   ; 2	AND value with the on-screen pixel
0412F8             0185*   ; 3	XOR value with the on-screen pixel
0412F8             0186*   ; 4	Invert the on-screen pixel
0412F8             0187*   ; 5	No operation
0412F8             0188*   ; 6	AND the inverse of the specified colour with the on-screen pixel
0412F8             0189*   ; 7	OR the inverse of the specified colour with the on-screen pixel
0412F8             0190*   
0412F8             0191*   ; VDU 17, colour: Define text colour (COLOUR)
0412F8             0192*   vdu_colour_text:
0412F8 32 08 13 04 0193*   	ld (@arg),a
0412FC 21 07 13 04 0194*   	ld hl,@cmd
041300 01 02 00 00 0195*   	ld bc,@end-@cmd
041304 5B DF       0196*   	rst.lil $18
041306 C9          0197*   	ret
041307 11          0198*   @cmd: db 17
041308 00          0199*   @arg: db 0
041309             0200*   @end:
041309             0201*   
041309             0202*   ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
041309             0203*   ; inputs: a=mode, c=colour (add 128 to set background colour)
041309             0204*   vdu_gcol:
041309 32 1E 13 04 0205*   	ld (@mode),a
04130D 79          0206*       ld a,c
04130E 32 1F 13 04 0207*       ld (@col),a
041312 21 1D 13 04 0208*   	ld hl,@cmd
041316 01 03 00 00 0209*   	ld bc,@end-@cmd
04131A 5B DF       0210*   	rst.lil $18
04131C C9          0211*   	ret
04131D 12          0212*   @cmd:  db 18
04131E 00          0213*   @mode: db 0
04131F 00          0214*   @col:  db 0
041320             0215*   @end:
041320             0216*   
041320             0217*   
041320             0218*   ; VDU 28, left, bottom, right, top: Set text viewport **
041320             0219*   ; MIND THE LITTLE-ENDIANESS
041320             0220*   ; inputs: c=left,b=bottom,e=right,d=top
041320             0221*   ; outputs; nothing
041320             0222*   ; destroys: af, hl, bc, de
041320             0223*   vdu_set_txt_viewport:
041320 ED 43 36 13 0224*       ld (@lb),bc
       04          
041325 ED 53 38 13 0225*   	ld (@rt),de
       04          
04132A 21 35 13 04 0226*   	ld hl,@cmd
04132E 01 05 00 00 0227*   	ld bc,@end-@cmd
041332 5B DF       0228*   	rst.lil $18
041334 C9          0229*   	ret
041335 1C          0230*   @cmd:   db 28 ; set text viewport command
041336 00 00       0231*   @lb: 	dw 0x0000 ; set by bc
041338 00 00       0232*   @rt: 	dw 0x0000 ; set by de
04133A 00          0233*   @end:   db 0x00	  ; padding
04133B             0234*   
04133B             0235*   ; Wait for VBLANK interrupt
04133B             0236*   vdu_vblank:
04133B DD E5       0237*       PUSH 	IX
04133D             0238*   	MOSCALL	mos_sysvars
                       M1 Args: function=mos_sysvars 
04133D 3E 08       0001*M1 			LD	A, function
04133F 5B CF       0002*M1 			RST.LIL	08h
041341 DD 7E 00    0239*   	LD	A, (IX + sysvar_time + 0)
041344             0240*   @wait:
041344 DD BE 00    0241*       CP 	A, (IX + sysvar_time + 0)
041347 28 FB       0242*       JR	Z, @wait
041349 DD E1       0243*       POP	IX
04134B C9          0244*       RET
04134C             0245*   
04134C             0246*   ; VDU 29, x; y;: Set graphics origin
04134C             0247*   ; This command sets the graphics origin.
04134C             0248*   ; The origin is the point on the screen where the coordinates (0,0) are located.
04134C             0249*   ; inputs: bc=x0,de=y0
04134C             0250*   ; outputs; nothing
04134C             0251*   ; destroys: a might make it out alive
04134C             0252*   vdu_set_gfx_origin:
04134C ED 43 62 13 0253*       ld (@x0),bc
       04          
041351 ED 53 64 13 0254*       ld (@y0),de
       04          
041356 21 61 13 04 0255*       ld hl,@cmd
04135A 01 05 00 00 0256*       ld bc,@end-@cmd
04135E 5B DF       0257*       rst.lil $18
041360 C9          0258*       ret
041361 1D          0259*   @cmd:   db 29 ; set graphics origin command
041362 00 00       0260*   @x0: 	dw 0x0000 ; set by bc
041364 00 00       0261*   @y0: 	dw 0x0000 ; set by de
041366 00          0262*   @end:   db 0x00	  ; padding
041367             0263*   
041367             0264*   ; VDU 24, left; bottom; right; top;: Set graphics viewport
041367             0265*   ; NOTE: the order of the y-coordinate parameters are inverted
041367             0266*   ; 	because we have turned off logical screen scaling
041367             0267*   ; NOTE: coordinates are relative to current gfx origin
041367             0268*   ; inputs: bc=x0,de=y0,ix=x1,iy=y1
041367             0269*   ; outputs; nothing
041367             0270*   ; destroys: a might make it out alive
041367             0271*   vdu_set_gfx_viewport:
041367 ED 43 87 13 0272*       ld (@x0),bc
       04          
04136C FD 22 89 13 0273*       ld (@y1),iy
       04          
041371 DD 22 8B 13 0274*   	ld (@x1),ix
       04          
041376 ED 53 8D 13 0275*   	ld (@y0),de
       04          
04137B 21 86 13 04 0276*   	ld hl,@cmd
04137F 01 09 00 00 0277*   	ld bc,@end-@cmd
041383 5B DF       0278*   	rst.lil $18
041385 C9          0279*   	ret
041386 18          0280*   @cmd:   db 24 ; set graphics viewport command
041387 00 00       0281*   @x0: 	dw 0x0000 ; set by bc
041389 00 00       0282*   @y1: 	dw 0x0000 ; set by iy
04138B 00 00       0283*   @x1: 	dw 0x0000 ; set by ix
04138D 00 00       0284*   @y0: 	dw 0x0000 ; set by de
04138F 00          0285*   @end:   db 0x00	  ; padding
041390             0286*   
041390             0287*   ; VDU 26: Reset graphics and text viewports
041390             0288*   vdu_reset_viewports:
041390 3E 1A       0289*       ld a,26
041392 5B D7       0290*       rst.lil $10
041394 C9          0291*       ret
041395             0292*   
041395             0293*   ; SCREEN MODES
041395             0294*   ; ===============================
041395             0295*   ; Mode  Horz  Vert  Cols  Refresh
041395             0296*   ; ---   ----  ----  ----  -------
041395             0297*   ; 11    320   240   2     60hz
041395             0298*   ; 139   320   240   2     60hz
041395             0299*   ; 23    512   384   2     60hz
041395             0300*   ; 151   512   384   2     60hz
041395             0301*   ; 6     640   240   2     60hz
041395             0302*   ; 134   640   240   2     60hz
041395             0303*   ; 2     640   480   2     60hz
041395             0304*   ; 130   640   480   2     60hz
041395             0305*   ; 17    800   600   2     60hz
041395             0306*   ; 145   800   600   2     60hz
041395             0307*   ; 18    1024  768   2     60hz
041395             0308*   ; 146   1024  768   2     60hz
041395             0309*   ; ---   ----  ----  ----  -------
041395             0310*   ; 10    320   240   4     60hz
041395             0311*   ; 138   320   240   4     60hz
041395             0312*   ; 22    512   384   4     60hz
041395             0313*   ; 150   512   384   4     60hz
041395             0314*   ; 5     640   240   4     60hz
041395             0315*   ; 133   640   240   4     60hz
041395             0316*   ; 1     640   480   4     60hz
041395             0317*   ; 129   640   480   4     60hz
041395             0318*   ; 16    800   600   4     60hz
041395             0319*   ; 19    1024  768   4     60hz
041395             0320*   ; ---   ----  ----  ----  -------
041395             0321*   ; 9     320   240   16    60hz
041395             0322*   ; 137   320   240   16    60hz
041395             0323*   ; 21    512   384   16    60hz
041395             0324*   ; 149   512   384   16    60hz
041395             0325*   ; 4     640   240   16    60hz
041395             0326*   ; 132   640   240   16    60hz
041395             0327*   ; 0     640   480   16    60hz
041395             0328*   ; 7     n/a   n/a   16    60hz
041395             0329*   ; ---   ----  ----  ----  -------
041395             0330*   ; 8     320   240   64    60hz
041395             0331*   ; 136   320   240   64    60hz
041395             0332*   ; 20    512   384   64    60hz
041395             0333*   ; 3     640   240   64    60hz
041395             0334*   ; ---   ----  ----  ----  -------
041395             0335*   vdu_set_screen_mode:
041395 32 A5 13 04 0336*   	ld (@arg),a
041399 21 A4 13 04 0337*   	ld hl,@cmd
04139D 01 02 00 00 0338*   	ld bc,@end-@cmd
0413A1 5B DF       0339*   	rst.lil $18
0413A3 C9          0340*   	ret
0413A4 16          0341*   @cmd: db 22 ; set screen mode
0413A5 00          0342*   @arg: db 0  ; screen mode parameter
0413A6             0343*   @end:
0413A6             0344*   
0413A6             0345*   ; get the current screen mode
0413A6             0346*   ; inputs: none
0413A6             0347*   ; outputs: a=screen mode
0413A6             0348*   ; destroys: af, ix
0413A6             0349*   vdu_get_screen_mode:
0413A6             0350*       MOSCALL mos_sysvars
                       M1 Args: function=mos_sysvars 
0413A6 3E 08       0001*M1 			LD	A, function
0413A8 5B CF       0002*M1 			RST.LIL	08h
0413AA DD 7E 27    0351*       ld a,(IX+sysvar_scrMode)
0413AD C9          0352*       ret
0413AE             0353*   ; end vdu_get_screen_mode
0413AE             0354*   
0413AE             0355*   ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
0413AE             0356*   ; inputs: a is scaling mode, 1=on, 0=off
0413AE             0357*   ; note: default setting on boot is scaling ON
0413AE             0358*   vdu_set_scaling:
0413AE 32 C0 13 04 0359*   	ld (@arg),a
0413B2 21 BD 13 04 0360*   	ld hl,@cmd
0413B6 01 04 00 00 0361*   	ld bc,@end-@cmd
0413BA 5B DF       0362*   	rst.lil $18
0413BC C9          0363*   	ret
0413BD 17 00 C0    0364*   @cmd: db 23,0,0xC0
0413C0 00          0365*   @arg: db 0  ; scaling on/off
0413C1             0366*   @end:
0413C1             0367*   
0413C1             0368*   ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
0413C1             0369*   ; inputs: hl=bufferId
0413C1             0370*   vdu_buff_select:
0413C1 22 D3 13 04 0371*   	ld (@bufferId),hl
0413C5 21 D0 13 04 0372*   	ld hl,@cmd
0413C9 01 05 00 00 0373*   	ld bc,@end-@cmd
0413CD 5B DF       0374*   	rst.lil $18
0413CF C9          0375*   	ret
0413D0 17 1B 20    0376*   @cmd: db 23,27,0x20
0413D3 00 00       0377*   @bufferId: dw 0x0000
0413D5 00          0378*   @end: db 0x00 ; padding
0413D6             0379*   
0413D6             0380*   ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
0413D6             0381*   ; inputs: a=format; bc=width; de=height
0413D6             0382*   ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
0413D6             0383*   ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
0413D6             0384*   ; 0 	RGBA8888 (4-bytes per pixel)
0413D6             0385*   ; 1 	RGBA2222 (1-bytes per pixel)
0413D6             0386*   ; 2 	Mono/Mask (1-bit per pixel)
0413D6             0387*   ; 3 	Reserved for internal use by VDP (“native” format)
0413D6             0388*   vdu_bmp_create:
0413D6 ED 43 F2 13 0389*       ld (@width),bc
       04          
0413DB ED 53 F4 13 0390*       ld (@height),de
       04          
0413E0 32 F6 13 04 0391*       ld (@fmt),a
0413E4 21 EF 13 04 0392*   	ld hl,@cmd
0413E8 01 08 00 00 0393*   	ld bc,@end-@cmd
0413EC 5B DF       0394*   	rst.lil $18
0413EE C9          0395*   	ret
0413EF 17 1B 21    0396*   @cmd:       db 23,27,0x21
0413F2 00 00       0397*   @width:     dw 0x0000
0413F4 00 00       0398*   @height:    dw 0x0000
0413F6 00          0399*   @fmt:       db 0x00
0413F7             0400*   @end:
0413F7             0401*   
0413F7             0402*   ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
0413F7             0403*   ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
0413F7             0404*   vdu_load_img_rgba2_to_8:
0413F7             0405*   ; backup the target buffer id and image dimensions
0413F7 E5          0406*       push hl
0413F8 D5          0407*       push de
0413F9 C5          0408*       push bc
0413FA             0409*   ; load the rgba2 image to working buffer 65534
0413FA 21 FE FF 00 0410*       ld hl,65534 ; temporary working buffer id
0413FE CD D5 14 04 0411*   	call vdu_load_buffer_from_file
041402             0412*   ; restore the image dimensions and target buffer id
041402 C1          0413*       pop bc
041403 D1          0414*       pop de
041404 E1          0415*       pop hl
041405             0416*   ; fall through to vdu_rgba2_to_8
041405             0417*   
041405             0418*   ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
041405             0419*   ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
041405             0420*   ; the "expand bitmap" command is:
041405             0421*   ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
041405             0422*   ; and then to reverse the byte order to fix endian-ness:
041405             0423*   ; VDU 23,0,&A0,targetBufferID%;24,4,4;
041405             0424*   ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
041405             0425*   ; VDU 23,27,&20,targetBufferID%;
041405             0426*   ; VDU 23,27,&21,width%;height%;0
041405             0427*   ; -------------------------------------------------------------------
041405             0428*   ; inputs: bc,de image width,height ; hl = targetBufferId
041405             0429*   ; prerequisites: rgba2 image data loaded into workingBufferId 65534
041405             0430*   vdu_rgba2_to_8:
041405             0431*   ; load the image dimensions and buffer id parameters
041405 ED 43 61 14 0432*       ld (@width),bc
       04          
04140A ED 53 63 14 0433*       ld (@height),de
       04          
04140F 22 46 14 04 0434*       ld (@bufferId0),hl
041413 22 53 14 04 0435*       ld (@bufferId2),hl
041417 22 5C 14 04 0436*       ld (@bufferId1),hl
04141B             0437*   ; clean up bytes that got stomped on by the ID loads
04141B 3E 48       0438*       ld a,0x48
04141D 32 48 14 04 0439*       ld (@bufferId0+2),a
041421 3E 17       0440*       ld a,23
041423 32 5E 14 04 0441*       ld (@bufferId1+2),a
041427 3E 18       0442*       ld a,24
041429 32 55 14 04 0443*       ld (@bufferId2+2),a
04142D AF          0444*       xor a
04142E 32 65 14 04 0445*       ld (@height+2),a
041432             0446*   ; send the vdu command strings
041432 21 3D 14 04 0447*       ld hl,@beg
041436 01 29 00 00 0448*       ld bc,@end-@beg
04143A 5B DF       0449*       rst.lil $18
04143C C9          0450*       ret
04143D             0451*   @beg:
04143D             0452*   ; Command 14: Consolidate blocks in a buffer
04143D             0453*   ; VDU 23, 0, &A0, bufferId; 14
04143D 17 00 A0    0454*       db 23,0,0xA0
041440 FE FF       0455*       dw 65534 ; workingBufferId
041442 0E          0456*       db 14 ; consolidate blocks
041443             0457*   ; the "expand bitmap" command is:
041443             0458*   ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
041443 17 00 A0    0459*       db 23,0,0xA0
041446 00 00       0460*   @bufferId0: dw 0x0000 ; targetBufferId
041448 48          0461*       db 0x48 ; given as decimal command 72 in the docs
041449 02          0462*       db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
04144A FE FF       0463*       dw 65534 ; sourceBufferId
04144C 00 7F BF FF 0464*       db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
041450             0465*   ; reverse the byte order to fix endian-ness:
041450             0466*   ; Command 24: Reverse the order of data of blocks within a buffer
041450             0467*   ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
041450             0468*   ; VDU 23,0,&A0,targetBufferID%;24,4,4;
041450 17 00 A0    0469*       db 23,0,0xA0
041453 00 00       0470*   @bufferId2:    dw 0x0000 ; targetBufferId
041455 18          0471*       db 24 ; reverse byte order
041456 04          0472*       db 4 ; option: Reverse data of the value size within chunk of data of the specified size
041457 04 00       0473*       dw 4 ; size (4 bytes)
041459             0474*   ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
041459             0475*   ; VDU 23,27,&20,targetBufferID%;
041459 17 1B 20    0476*       db 23,27,0x20 ; select bitmap
04145C 00 00       0477*   @bufferId1: dw 0x0000 ; targetBufferId
04145E             0478*   ; VDU 23,27,&21,width%;height%;0
04145E 17 1B 21    0479*       db 23,27,0x21 ; create bitmap from buffer
041461 00 00       0480*   @width: dw 0x0000
041463 00 00       0481*   @height: dw 0x0000
041465 00          0482*       db 0x00 ; rgba8888 format
041466             0483*   @end:
041466             0484*   
041466             0485*   ; scratch variables
041466 00 00 00    0486*   bufferId0: dl 0x000000
041469 00 00 00    0487*   bufferId1: dl 0x000000
04146C             0488*   
04146C             0489*   ; load a vdu buffer from local memory
04146C             0490*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
04146C             0491*   vdu_load_buffer:
04146C ED 43 95 14 0492*       ld (@length),bc
       04          
041471 D5          0493*       push de ; save data pointer
041472             0494*   ; send the vdu command string
041472 7D          0495*       ld a,l
041473 32 92 14 04 0496*       ld (@bufferId),a
041477 7C          0497*       ld a,h
041478 32 93 14 04 0498*       ld (@bufferId+1),a
04147C 21 8F 14 04 0499*       ld hl,@cmd
041480 01 08 00 00 0500*       ld bc,@end-@cmd
041484 5B DF       0501*       rst.lil $18
041486             0502*   ; send the buffer data
041486 E1          0503*       pop hl ; pointer to data
041487 ED 4B 95 14 0504*       ld bc,(@length)
       04          
04148C 5B DF       0505*       rst.lil $18 ; send it
04148E C9          0506*       ret
04148F             0507*   ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04148F 17 00 A0    0508*   @cmd:       db 23,0,0xA0
041492 00 00       0509*   @bufferId:	dw 0x0000
041494 00          0510*   		    db 0 ; load buffer
041495 00 00       0511*   @length:	dw 0x0000
041497 00          0512*   @end: db 0 ; padding
041498             0513*   
041498             0514*   ; Command 14: Consolidate blocks in a buffer
041498             0515*   vdu_consolidate_buffer:
041498             0516*   ; set parameters for vdu call
041498 7D          0517*       ld a,l
041499 32 B0 14 04 0518*       ld (@bufferId),a
04149D 7C          0519*       ld a,h
04149E 32 B1 14 04 0520*       ld (@bufferId+1),a
0414A2 21 AD 14 04 0521*       ld hl,@beg
0414A6 01 06 00 00 0522*       ld bc,@end-@beg
0414AA 5B DF       0523*       rst.lil $18
0414AC C9          0524*       ret
0414AD             0525*   ; VDU 23, 0, &A0, bufferId; 14
0414AD 17 00 A0    0526*   @beg: db 23,0,0xA0
0414B0 00 00       0527*   @bufferId: dw 0x0000
0414B2 0E          0528*              db 14
0414B3             0529*   @end:
0414B3             0530*   
0414B3             0531*   ; load an image file to a buffer and make it a bitmap
0414B3             0532*   ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
0414B3             0533*   vdu_load_img:
0414B3             0534*   ; back up image type and dimension parameters
0414B3 22 66 14 04 0535*       ld (bufferId0),hl
0414B7 F5          0536*       push af
0414B8 C5          0537*   	push bc
0414B9 D5          0538*   	push de
0414BA             0539*   ; load the image
0414BA CD D5 14 04 0540*   	call vdu_load_buffer_from_file
0414BE             0541*   ; now make it a bitmap
0414BE 2A 66 14 04 0542*       ld hl,(bufferId0)
0414C2 CD 98 14 04 0543*       call vdu_consolidate_buffer
0414C6 2A 66 14 04 0544*       ld hl,(bufferId0)
0414CA CD C1 13 04 0545*       call vdu_buff_select
0414CE D1          0546*   	pop de ; image height
0414CF C1          0547*   	pop bc ; image width
0414D0 F1          0548*   	pop af ; image type
0414D1 C3 D6 13 04 0549*   	jp vdu_bmp_create ; will return to caller from there
0414D5             0550*   
0414D5             0551*   ; inputs: hl = bufferId; iy = pointer to filename
0414D5             0552*   vdu_load_buffer_from_file:
0414D5 22 66 14 04 0553*       ld (bufferId0),hl
0414D9             0554*   
0414D9             0555*   ; clear target buffer
0414D9 CD 81 16 04 0556*       call vdu_clear_buffer
0414DD             0557*   
0414DD             0558*   ; open the file in read mode
0414DD             0559*   ; Open a file
0414DD             0560*   ; HLU: Filename
0414DD             0561*   ;   C: Mode
0414DD             0562*   ; Returns:
0414DD             0563*   ;   A: Filehandle, or 0 if couldn't open
0414DD FD E5       0564*   	push iy ; pointer to filename
0414DF E1          0565*   	pop hl
0414E0 0E 01       0566*   	ld c,fa_read
0414E2             0567*       MOSCALL mos_fopen
                       M1 Args: function=mos_fopen 
0414E2 3E 0A       0001*M1 			LD	A, function
0414E4 5B CF       0002*M1 			RST.LIL	08h
0414E6 32 21 15 04 0568*       ld (@filehandle),a
0414EA             0569*   
0414EA             0570*   @read_file:
0414EA             0571*   ; Read a block of data from a file
0414EA             0572*   ;   C: Filehandle
0414EA             0573*   ; HLU: Pointer to where to write the data to
0414EA             0574*   ; DEU: Number of bytes to read
0414EA             0575*   ; Returns:
0414EA             0576*   ; DEU: Number of bytes read
0414EA 3A 21 15 04 0577*       ld a,(@filehandle)
0414EE 4F          0578*       ld c,a
0414EF 21 00 E0 B7 0579*       ld hl,filedata
0414F3 11 00 20 00 0580*       ld de,8192 ; max we can read into onboard sram at one time
0414F7             0581*       MOSCALL mos_fread
                       M1 Args: function=mos_fread 
0414F7 3E 1A       0001*M1 			LD	A, function
0414F9 5B CF       0002*M1 			RST.LIL	08h
0414FB             0582*   
0414FB             0583*   ; test de for zero bytes read
0414FB 21 00 00 00 0584*       ld hl,0
0414FF AF          0585*       xor a ; clear carry
041500 ED 52       0586*       sbc hl,de
041502 CA 18 15 04 0587*       jp z,@close_file
041506             0588*   
041506             0589*   ; load a vdu buffer from local memory
041506             0590*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
041506 2A 66 14 04 0591*       ld hl,(bufferId0)
04150A D5          0592*       push de ; chunksize
04150B C1          0593*       pop bc
04150C 11 00 E0 B7 0594*       ld de,filedata
041510 CD 6C 14 04 0595*       call vdu_load_buffer
041514             0596*   
041514             0597*   ; read the next block
041514 C3 EA 14 04 0598*       jp @read_file
041518             0599*   
041518             0600*   ; close the file
041518             0601*   @close_file:
041518 3A 21 15 04 0602*       ld a,(@filehandle)
04151C             0603*       MOSCALL mos_fclose
                       M1 Args: function=mos_fclose 
04151C 3E 0B       0001*M1 			LD	A, function
04151E 5B CF       0002*M1 			RST.LIL	08h
041520 C9          0604*       ret ; vdu_load_buffer_from_file
041521             0605*   
041521 00          0606*   @filehandle: db 0 ; file handle
041522 00 00 00    0607*   @fil: dl 0 ; pointer to FIL struct
041525             0608*   
041525 00 00 00    0609*   @chunkpointer: dl 0 ; pointer to current chunk
041528             0610*   
041528             0611*   ; File information structure (FILINFO)
041528             0612*   @filinfo:
041528 00 00 00 00 0613*   @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
04152C 00 00       0614*   @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
04152E 00 00       0615*   @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
041530 00          0616*   @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
041531 00 00 00 00 0617*   @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
04153E 00 00 00 00 0618*   @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04163E             0040        include "vdu_buffered_api.inc"
04163E             0001*   ; https://agonconsole8.github.io/agon-docs/vdp/Buffered-Commands-API/
04163E             0002*   
04163E             0003*   ; Command 0: Write block to a buffer
04163E             0004*   ; VDU 23, 0, &A0, bufferId; 0, length; <buffer-data>
04163E             0005*   ; inputs: hl = bufferId, bc = length of data, de = pointer to data
04163E             0006*   vdu_write_block_to_buffer:
04163E             0007*   ; back up input parameters
04163E D5          0008*       push de ; pointer to data
04163F C5          0009*       push bc ; length of data
041640             0010*   ; set up the vdu command string
041640 22 60 16 04 0011*       ld (@bufferId),hl
041644 ED 43 63 16 0012*       ld (@length),bc
       04          
041649 AF          0013*       xor a ; load buffer
04164A 32 62 16 04 0014*       ld (@bufferId+2),a
04164E 21 5D 16 04 0015*       ld hl,@cmd0
041652 01 08 00 00 0016*       ld bc,@end0-@cmd0
041656 5B DF       0017*       rst.lil $18
041658             0018*   ; send the buffer data
041658 C1          0019*       pop bc ; length of data
041659 E1          0020*       pop hl ; pointer to data (was de)
04165A 5B DF       0021*       rst.lil $18 ; send it
04165C C9          0022*       ret
04165D             0023*   ; command string data
04165D 17 00 A0    0024*   @cmd0:      db 23,0,0xA0
041660 00 00       0025*   @bufferId:	dw 0x0000
041662 00          0026*               db 0 ; load buffer
041663 00 00       0027*   @length:	dw 0x0000
041665 00          0028*   @end0:      db 0x00 ; padding
041666             0029*   ; end vdu_write_block_to_buffer
041666             0030*   
041666             0031*   ; Command 1: Call a buffer
041666             0032*   ; VDU 23, 0, &A0, bufferId; 1
041666             0033*   ; inputs: hl = bufferId
041666             0034*   vdu_call_buffer:
041666 22 7E 16 04 0035*       ld (@bufferId),hl
04166A 3E 01       0036*       ld a,1 ; call buffer
04166C 32 80 16 04 0037*       ld (@bufferId+2),a
041670 21 7B 16 04 0038*       ld hl,@cmd
041674 01 06 00 00 0039*       ld bc,@end-@cmd
041678 5B DF       0040*       rst.lil $18
04167A C9          0041*       ret
04167B 17 00 A0    0042*   @cmd:     db 23,0,0xA0
04167E 00 00       0043*   @bufferId: dw 0x0000
041680 01          0044*              db 1 ; call buffer
041681             0045*   @end:
041681             0046*   ; end vdu_call_buffer
041681             0047*   
041681             0048*   ; Command 2: Clear a buffer
041681             0049*   ; VDU 23, 0 &A0, bufferId; 2
041681             0050*   ; inputs: hl = bufferId
041681             0051*   vdu_clear_buffer:
041681 22 99 16 04 0052*       ld (@bufferId),hl
041685 3E 02       0053*       ld a,2 ; clear buffer
041687 32 9B 16 04 0054*       ld (@bufferId+2),a
04168B 21 96 16 04 0055*       ld hl,@cmd
04168F 01 06 00 00 0056*       ld bc,@end-@cmd
041693 5B DF       0057*       rst.lil $18
041695 C9          0058*       ret
041696 17 00 A0    0059*   @cmd:     db 23,0,0xA0
041699 00 00       0060*   @bufferId: dw 0x0000
04169B 02          0061*              db 2 ; clear buffer
04169C             0062*   @end:
04169C             0063*   ; end vdu_clear_buffer
04169C             0064*   
04169C             0065*   ; Clear all buffers
04169C             0066*   ; inputs: none
04169C             0067*   vdu_clear_all_buffers:
04169C             0068*   ; clear all buffers
04169C 21 A7 16 04 0069*       ld hl,@beg
0416A0 01 06 00 00 0070*       ld bc,@end-@beg
0416A4 5B DF       0071*       rst.lil $18
0416A6 C9          0072*       ret
0416A7 17 00 A0    0073*   @beg: db 23,0,$A0
0416AA FF FF       0074*         dw -1 ; bufferId -1 (65535) means clear all buffers
0416AC 02          0075*         db 2  ; command 2: clear a buffer
0416AD             0076*   @end:
0416AD             0077*   ; end vdu_clear_all_buffers
0416AD             0078*   
0416AD             0079*   ; Command 3: Create a writeable buffer
0416AD             0080*   ; VDU 23, 0 &A0, bufferId; 3, length;
0416AD             0081*   ; inputs: hl = bufferId, bc = length
0416AD             0082*   vdu_create_writeable_buffer:
0416AD 22 CA 16 04 0083*       ld (@bufferId),hl
0416B1 ED 43 CD 16 0084*       ld (@length),bc
       04          
0416B6 3E 03       0085*       ld a,3 ; create writeable buffer
0416B8 32 CC 16 04 0086*       ld (@bufferId+2),a
0416BC 21 C7 16 04 0087*       ld hl,@cmd
0416C0 01 08 00 00 0088*       ld bc,@end-@cmd
0416C4 5B DF       0089*       rst.lil $18
0416C6 C9          0090*       ret
0416C7 17 00 A0    0091*   @cmd:     db 23,0,0xA0
0416CA 00 00       0092*   @bufferId: dw 0x0000
0416CC 03          0093*              db 3 ; create writeable buffer
0416CD 00 00       0094*   @length: dw 0x0000
0416CF 00          0095*   @end:     db 0x00 ; padding
0416D0             0096*   ; end vdu_create_writeable_buffer
0416D0             0097*   
0416D0             0098*   ; Command 4: Set output stream to a buffer
0416D0             0099*   ; VDU 23, 0 &A0, bufferId; 4
0416D0             0100*   ; inputs: hl = bufferId
0416D0             0101*   vdu_set_output_stream_buffer:
0416D0 22 E8 16 04 0102*       ld (@bufferId),hl
0416D4 3E 04       0103*       ld a,4 ; set output stream to buffer
0416D6 32 EA 16 04 0104*       ld (@bufferId+2),a
0416DA 21 E5 16 04 0105*       ld hl,@cmd
0416DE 01 06 00 00 0106*       ld bc,@end-@cmd
0416E2 5B DF       0107*       rst.lil $18
0416E4 C9          0108*       ret
0416E5 17 00 A0    0109*   @cmd:     db 23,0,0xA0
0416E8 00 00       0110*   @bufferId: dw 0x0000
0416EA 04          0111*              db 4 ; set output stream to buffer
0416EB 00          0112*   @end:     db 0x00 ; padding
0416EC             0113*   ; end vdu_set_output_stream_buffer
0416EC             0114*   
0416EC             0115*   ; Command 5: Adjust buffer contents
0416EC             0116*   ; VDU 23, 0, &A0, bufferId; 5, operation, offset; [count;] <operand>, [arguments]
0416EC             0117*   vdu_adjust_buffer:
0416EC C9          0118*       ret ; TODO: implement
0416ED             0119*   ; end vdu_adjust_buffer
0416ED             0120*   
0416ED             0121*   ; Command 6: Conditionally call a buffer
0416ED             0122*   ; VDU 23, 0, &A0, bufferId; 6, operation, checkBufferId; checkOffset; [arguments]
0416ED             0123*   vdu_call_buffer_conditional:
0416ED C9          0124*       ret ; TODO: implement
0416EE             0125*   ; end vdu_call_buffer_conditional
0416EE             0126*   
0416EE             0127*   ; Command 7: Jump to a buffer
0416EE             0128*   ; VDU 23, 0, &A0, bufferId; 7
0416EE             0129*   ; inputs: hl = bufferId
0416EE             0130*   vdu_jump_to_buffer:
0416EE 22 06 17 04 0131*       ld (@bufferId),hl
0416F2 3E 07       0132*       ld a,7 ; jump to buffer
0416F4 32 08 17 04 0133*       ld (@bufferId+2),a
0416F8 21 03 17 04 0134*       ld hl,@cmd
0416FC 01 06 00 00 0135*       ld bc,@end-@cmd
041700 5B DF       0136*       rst.lil $18
041702 C9          0137*       ret
041703 17 00 A0    0138*   @cmd:     db 23,0,0xA0
041706 00 00       0139*   @bufferId: dw 0x0000
041708 07          0140*              db 7 ; jump to buffer
041709 00          0141*   @end:     db 0x00 ; padding
04170A             0142*   ; end vdu_jump_to_buffer
04170A             0143*   
04170A             0144*   ; Command 8: Conditional Jump to a buffer
04170A             0145*   ; VDU 23, 0, &A0, bufferId; 8, operation, checkBufferId; checkOffset; [arguments]
04170A             0146*   vdu_jump_to_buffer_conditional:
04170A C9          0147*       ret ; TODO: implement
04170B             0148*   ; end vdu_jump_to_buffer_conditional
04170B             0149*   
04170B             0150*   ; Command 9: Jump to an offset in a buffer
04170B             0151*   ; VDU 23, 0, &A0, bufferId; 9, offset; offsetHighByte, [blockNumber;]
04170B             0152*   vdu_jump_to_buffer_offset:
04170B C9          0153*       ret ; TODO: implement
04170C             0154*   ; end vdu_jump_to_buffer_offset
04170C             0155*   
04170C             0156*   ; Command 10: Conditional jump to an offset in a buffer
04170C             0157*   ; VDU 23, 0, &A0, bufferId; 10, offset; offsetHighByte, [blockNumber;] [arguments]
04170C             0158*   vdu_jump_to_buffer_offset_conditional:
04170C C9          0159*       ret ; TODO: implement
04170D             0160*   ; end vdu_jump_to_buffer_offset_conditional
04170D             0161*   
04170D             0162*   ; Command 11: Call buffer with an offset
04170D             0163*   ; VDU 23, 0, &A0, bufferId; 11, offset; offsetHighByte, [blockNumber;]
04170D             0164*   vdu_call_buffer_offset:
04170D C9          0165*       ret ; TODO: implement
04170E             0166*   ; end vdu_call_buffer_offset
04170E             0167*   
04170E             0041        include "vdu_fonts.inc"
04170E             0001*   ; select font
04170E             0002*   ; inputs: hl = bufferId, a = font flags
04170E             0003*   ; Flags:
04170E             0004*   ; Bit	Description
04170E             0005*   ; 0	Adjust cursor position to ensure text baseline is aligned
04170E             0006*   ;   0: Do not adjust cursor position (best for changing font on a new line)
04170E             0007*   ;   1: Adjust cursor position (best for changing font in the middle of a line)
04170E             0008*   ; 1-7	Reserved for future use
04170E             0009*   ; VDU 23, 0, &95, 0, bufferId; flags: Select font
04170E             0010*   vdu_font_select:
04170E 22 25 17 04 0011*       ld (@bufferId),hl
041712 32 27 17 04 0012*       ld (@flags),a
041716 21 21 17 04 0013*       ld hl,@cmd
04171A 01 07 00 00 0014*       ld bc,@end-@cmd
04171E 5B DF       0015*       rst.lil $18
041720 C9          0016*       ret
041721 17 00 95 00 0017*   @cmd: db 23, 0, 0x95, 0
041725 00 00       0018*   @bufferId: dw 0x0000
041727 00          0019*   @flags: db 0x00
041728             0020*   @end:
041728             0021*   
041728             0022*   ; create font from buffer
041728             0023*   ; inputs: hl = bufferId, e = width, d = height, d = ascent, a = flags
041728             0024*   ; VDU 23, 0, &95, 1, bufferId; width, height, ascent, flags: Create font from buffer
041728             0025*   vdu_font_create:
041728 22 4D 17 04 0026*       ld (@bufferId),hl
04172C ED 53 4F 17 0027*       ld (@width),de ; also loads height
       04          
041731 32 52 17 04 0028*       ld (@flags),a
041735 7A          0029*       ld a,d ; height
041736 32 51 17 04 0030*       ld (@ascent),a ; ascent = height
04173A             0031*   ; consolidate buffer
04173A CD 98 14 04 0032*       call vdu_consolidate_buffer
04173E             0033*   ; create font
04173E 21 49 17 04 0034*       ld hl,@cmd
041742 01 0A 00 00 0035*       ld bc,@end-@cmd
041746 5B DF       0036*       rst.lil $18
041748 C9          0037*       ret
041749 17 00 95 01 0038*   @cmd: db 23, 0, 0x95, 1
04174D 00 00       0039*   @bufferId: dw 0x0000
04174F 00          0040*   @width: db 0x00
041750 00          0041*   @height: db 0x00
041751 00          0042*   @ascent: db 0x00
041752 00          0043*   @flags: db 0x00
041753             0044*   @end:
041753             0045*   
041753             0046*   ; set or adjust font property
041753             0047*   ; inputs: hl = bufferId, a = field, de = value
041753             0048*   ; VDU 23, 0, &95, 2, bufferId; field, value;: Set or adjust font property
041753             0049*   vdu_font_property:
041753 22 6F 17 04 0050*       ld (@bufferId),hl
041757 32 71 17 04 0051*       ld (@field),a
04175B ED 53 72 17 0052*       ld (@value),de
       04          
041760 21 6B 17 04 0053*       ld hl,@cmd
041764 01 09 00 00 0054*       ld bc,@end-@cmd
041768 5B DF       0055*       rst.lil $18
04176A C9          0056*       ret
04176B 17 00 95 02 0057*   @cmd: db 23, 0, 0x95, 2
04176F 00 00       0058*   @bufferId: dw 0x0000
041771 00          0059*   @field: db 0x00
041772 00 00       0060*   @value: dw 0x0000
041774 00          0061*   @end: db 0x00 ; padding
041775             0062*   
041775             0063*   ; VDU 23, 0, &95, 3, bufferId; [<args>]: Reserved
041775             0064*   
041775             0065*   ; Clear/Delete font
041775             0066*   ; inputs: hl = bufferId
041775             0067*   ; VDU 23, 0, &95, 4, bufferId;: Clear/Delete font
041775             0068*   vdu_font_clear:
041775 22 88 17 04 0069*       ld (@bufferId),hl
041779 21 84 17 04 0070*       ld hl,@cmd
04177D 01 06 00 00 0071*       ld bc,@end-@cmd
041781 5B DF       0072*       rst.lil $18
041783 C9          0073*       ret
041784 17 00 95 04 0074*   @cmd: db 23, 0, 0x95, 4
041788 00 00       0075*   @bufferId: dw 0x0000
04178A 00          0076*   @end: db 0x00 ; padding
04178B             0077*   
04178B             0078*   ; Copy system font to buffer
04178B             0079*   ; inputs: hl = bufferId
04178B             0080*   ; VDU 23, 0, &95, 5, bufferId;: Copy system font to buffer
04178B             0081*   vdu_font_copy_system:
04178B 22 9E 17 04 0082*       ld (@bufferId),hl
04178F 21 9A 17 04 0083*       ld hl,@cmd
041793 01 06 00 00 0084*       ld bc,@end-@cmd
041797 5B DF       0085*       rst.lil $18
041799 C9          0086*       ret
04179A 17 00 95 05 0087*   @cmd: db 23, 0, 0x95, 5
04179E 00 00       0088*   @bufferId: dw 0x0000
0417A0 00          0089*   @end: db 0x00 ; padding
0417A1             0042        include "vdu_plot.inc"
0417A1             0001*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0417A1             0002*   ; PLOT code 	(Decimal) 	Effect
0417A1             0003*   ; &00-&07 	0-7 	Solid line, includes both ends
0417A1             0004*   plot_sl_both: equ 0x00
0417A1             0005*   
0417A1             0006*   ; &08-&0F 	8-15 	Solid line, final point omitted
0417A1             0007*   plot_sl_first: equ 0x08
0417A1             0008*   
0417A1             0009*   ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
0417A1             0010*   ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
0417A1             0011*   
0417A1             0012*   ; &20-&27 	32-39 	Solid line, first point omitted
0417A1             0013*   plot_sl_last: equ 0x20
0417A1             0014*   
0417A1             0015*   ; &28-&2F 	40-47 	Solid line, both points omitted
0417A1             0016*   plot_sl_none: equ 0x28
0417A1             0017*   
0417A1             0018*   ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
0417A1             0019*   ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
0417A1             0020*   
0417A1             0021*   ; &40-&47 	64-71 	Point plot
0417A1             0022*   plot_pt: equ 0x40
0417A1             0023*   
0417A1             0024*   ; &48-&4F 	72-79 	Line fill left and right to non-background §§
0417A1             0025*   plot_lf_lr_non_bg: equ 0x48
0417A1             0026*   
0417A1             0027*   ; &50-&57 	80-87 	Triangle fill
0417A1             0028*   plot_tf: equ 0x50
0417A1             0029*   
0417A1             0030*   ; &58-&5F 	88-95 	Line fill right to background §§
0417A1             0031*   plot_lf_r_bg: equ 0x58
0417A1             0032*   
0417A1             0033*   ; &60-&67 	96-103 	Rectangle fill
0417A1             0034*   plot_rf: equ 0x60
0417A1             0035*   
0417A1             0036*   ; &68-&6F 	104-111 	Line fill left and right to foreground §§
0417A1             0037*   plot_lf_lr_fg: equ 0x60
0417A1             0038*   
0417A1             0039*   ; &70-&77 	112-119 	Parallelogram fill
0417A1             0040*   plot_pf: equ 0x70
0417A1             0041*   
0417A1             0042*   ; &78-&7F 	120-127 	Line fill right to non-foreground §§
0417A1             0043*   plot_lf_r_non_fg: equ 0x78
0417A1             0044*   
0417A1             0045*   ; &80-&87 	128-135 	Not supported (Flood until non-background)
0417A1             0046*   ; &88-&8F 	136-143 	Not supported (Flood until foreground)
0417A1             0047*   
0417A1             0048*   ; &90-&97 	144-151 	Circle outline
0417A1             0049*   plot_co: equ 0x90
0417A1             0050*   
0417A1             0051*   ; &98-&9F 	152-159 	Circle fill
0417A1             0052*   plot_cf: equ 0x98
0417A1             0053*   
0417A1             0054*   ; &A0-&A7 	160-167 	Not supported (Circular arc)
0417A1             0055*   ; &A8-&AF 	168-175 	Not supported (Circular segment)
0417A1             0056*   ; &B0-&B7 	176-183 	Not supported (Circular sector)
0417A1             0057*   
0417A1             0058*   ; &B8-&BF 	184-191 	Rectangle copy/move
0417A1             0059*   plot_rcm: equ 0xB8
0417A1             0060*   
0417A1             0061*   ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
0417A1             0062*   ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
0417A1             0063*   ; &D0-&D7 	208-215 	Not defined
0417A1             0064*   ; &D8-&DF 	216-223 	Not defined
0417A1             0065*   ; &E0-&E7 	224-231 	Not defined
0417A1             0066*   
0417A1             0067*   ; &E8-&EF 	232-239 	Bitmap plot §
0417A1             0068*   plot_bmp: equ 0xE8
0417A1             0069*   
0417A1             0070*   ; &F0-&F7 	240-247 	Not defined
0417A1             0071*   ; &F8-&FF 	248-255 	Not defined
0417A1             0072*   
0417A1             0073*   ; § Support added in Agon Console8 VDP 2.1.0 §§ Support added in
0417A1             0074*   ; Agon Console8 VDP 2.2.0
0417A1             0075*   
0417A1             0076*   ; Within each group of eight plot codes, the effects are as follows:
0417A1             0077*   ; Plot code 	Effect
0417A1             0078*   ; 0 	Move relative
0417A1             0079*   mv_rel: equ 0
0417A1             0080*   
0417A1             0081*   ; 1 	Plot relative in current foreground colour
0417A1             0082*   dr_rel_fg: equ 1
0417A1             0083*   
0417A1             0084*   ; 2 	Not supported (Plot relative in logical inverse colour)
0417A1             0085*   ; 3 	Plot relative in current background colour
0417A1             0086*   dr_rel_bg: equ 3
0417A1             0087*   
0417A1             0088*   ; 4 	Move absolute
0417A1             0089*   mv_abs: equ 4
0417A1             0090*   
0417A1             0091*   ; 5 	Plot absolute in current foreground colour
0417A1             0092*   dr_abs_fg: equ 5
0417A1             0093*   
0417A1             0094*   ; 6 	Not supported (Plot absolute in logical inverse colour)
0417A1             0095*   ; 7 	Plot absolute in current background colour
0417A1             0096*   dr_abs_bg: equ 7
0417A1             0097*   
0417A1             0098*   ; Codes 0-3 use the position data provided as part of the command
0417A1             0099*   ; as a relative position, adding the position given to the current
0417A1             0100*   ; graphical cursor position. Codes 4-7 use the position data provided
0417A1             0101*   ; as part of the command as an absolute position, setting the current
0417A1             0102*   ; graphical cursor position to the position given.
0417A1             0103*   
0417A1             0104*   ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
0417A1             0105*   ; current pixel colour. These operations cannot currently be supported
0417A1             0106*   ; by the graphics system the Agon VDP uses, so these codes are not
0417A1             0107*   ; supported. Support for these codes may be added in a future version
0417A1             0108*   ; of the VDP firmware.
0417A1             0109*   
0417A1             0110*   ; 16 colour palette constants
0417A1             0111*   c_black: equ 0
0417A1             0112*   c_red_dk: equ 1
0417A1             0113*   c_green_dk: equ 2
0417A1             0114*   c_yellow_dk: equ 3
0417A1             0115*   c_blue_dk: equ 4
0417A1             0116*   c_magenta_dk: equ 5
0417A1             0117*   c_cyan_dk: equ 6
0417A1             0118*   c_grey: equ 7
0417A1             0119*   c_grey_dk: equ 8
0417A1             0120*   c_red: equ 9
0417A1             0121*   c_green: equ 10
0417A1             0122*   c_yellow: equ 11
0417A1             0123*   c_blue: equ 12
0417A1             0124*   c_magenta: equ 13
0417A1             0125*   c_cyan: equ 14
0417A1             0126*   c_white: equ 15
0417A1             0127*   
0417A1             0128*   ; VDU 25, mode, x; y;: PLOT command
0417A1             0129*   ; inputs: a=mode, bc=x0, de=y0
0417A1             0130*   vdu_plot:
0417A1 32 BB 17 04 0131*       ld (@mode),a
0417A5 ED 43 BC 17 0132*       ld (@x0),bc
       04          
0417AA ED 53 BE 17 0133*       ld (@y0),de
       04          
0417AF 21 BA 17 04 0134*   	ld hl,@cmd
0417B3 01 06 00 00 0135*   	ld bc,@end-@cmd
0417B7 5B DF       0136*   	rst.lil $18
0417B9 C9          0137*   	ret
0417BA 19          0138*   @cmd:   db 25
0417BB 00          0139*   @mode:  db 0
0417BC 00 00       0140*   @x0: 	dw 0
0417BE 00 00       0141*   @y0: 	dw 0
0417C0 00          0142*   @end:   db 0 ; extra byte to soak up deu
0417C1             0143*   
0417C1             0144*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0417C1             0145*   ; &E8-&EF 	232-239 	Bitmap plot §
0417C1             0146*   ; VDU 25, mode, x; y;: PLOT command
0417C1             0147*   ; inputs: bc=x0, de=y0
0417C1             0148*   ; prerequisites: vdu_buff_select
0417C1             0149*   vdu_plot_bmp:
0417C1 ED 43 D8 17 0150*       ld (@x0),bc
       04          
0417C6 ED 53 DA 17 0151*       ld (@y0),de
       04          
0417CB 21 D6 17 04 0152*   	ld hl,@cmd
0417CF 01 06 00 00 0153*   	ld bc,@end-@cmd
0417D3 5B DF       0154*   	rst.lil $18
0417D5 C9          0155*   	ret
0417D6 19          0156*   @cmd:   db 25
0417D7 ED          0157*   @mode:  db plot_bmp+dr_abs_fg ; 0xED
0417D8 00 00       0158*   @x0: 	dw 0x0000
0417DA 00 00       0159*   @y0: 	dw 0x0000
0417DC 00          0160*   @end:   db 0x00 ; padding
0417DD             0161*   
0417DD             0162*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0417DD             0163*   ; &E8-&EF 	232-239 	Bitmap plot §
0417DD             0164*   ; VDU 25, mode, x; y;: PLOT command
0417DD             0165*   ; inputs: bc=x0, de=y0
0417DD             0166*   ; USING 16.8 FIXED POINT COORDINATES
0417DD             0167*   ; inputs: ub.c is x coordinate, ud.e is y coordinate
0417DD             0168*   ;   the fractional portiion of the inputs are truncated
0417DD             0169*   ;   leaving only the 16-bit integer portion
0417DD             0170*   ; prerequisites: vdu_buff_select
0417DD             0171*   vdu_plot_bmp168:
0417DD             0172*   ; populate in the reverse of normal to keep the
0417DD             0173*   ; inputs from stomping on each other
0417DD ED 53 FB 17 0174*       ld (@y0-1),de
       04          
0417E2 ED 43 F9 17 0175*       ld (@x0-1),bc
       04          
0417E7 3E ED       0176*       ld a,plot_bmp+dr_abs_fg ; 0xED
0417E9 32 F9 17 04 0177*       ld (@mode),a ; restore the mode byte that got stomped on by bcu
0417ED 21 F8 17 04 0178*   	ld hl,@cmd
0417F1 01 06 00 00 0179*   	ld bc,@end-@cmd
0417F5 5B DF       0180*   	rst.lil $18
0417F7 C9          0181*   	ret
0417F8 19          0182*   @cmd:   db 25
0417F9 ED          0183*   @mode:  db plot_bmp+dr_abs_fg ; 0xED
0417FA 00 00       0184*   @x0: 	dw 0x0000
0417FC 00 00       0185*   @y0: 	dw 0x0000
0417FE             0186*   @end:  ; no padding required b/c we shifted de right
0417FE             0187*   
0417FE             0188*   ; draw a filled rectangle
0417FE             0189*   vdu_plot_rf:
0417FE ED 43 25 18 0190*       ld (@x0),bc
       04          
041803 ED 53 27 18 0191*       ld (@y0),de
       04          
041808 DD 22 2B 18 0192*       ld (@x1),ix
       04          
04180D FD 22 2D 18 0193*       ld (@y1),iy
       04          
041812 3E 19       0194*       ld a,25 ; we have to reload the 2nd plot command
041814 32 29 18 04 0195*       ld (@cmd1),a ; because the 24-bit y0 load stomped on it
041818 21 23 18 04 0196*   	ld hl,@cmd0
04181C 01 0C 00 00 0197*   	ld bc,@end-@cmd0
041820 5B DF       0198*   	rst.lil $18
041822 C9          0199*       ret
041823 19          0200*   @cmd0:  db 25 ; plot
041824 04          0201*   @arg0:  db plot_sl_both+mv_abs
041825 00 00       0202*   @x0:    dw 0x0000
041827 00 00       0203*   @y0:    dw 0x0000
041829 19          0204*   @cmd1:  db 25 ; plot
04182A 65          0205*   @arg1:  db plot_rf+dr_abs_fg
04182B 00 00       0206*   @x1:    dw 0x0000
04182D 00 00       0207*   @y1:    dw 0x0000
04182F 00          0208*   @end:   db 0x00 ; padding
041830             0209*   
041830             0210*   ; draw a filled circle
041830             0211*   vdu_plot_cf:
041830 ED 43 57 18 0212*       ld (@x0),bc
       04          
041835 ED 53 59 18 0213*       ld (@y0),de
       04          
04183A DD 22 5D 18 0214*       ld (@x1),ix
       04          
04183F FD 22 5F 18 0215*       ld (@y1),iy
       04          
041844 3E 19       0216*       ld a,25 ; we have to reload the 2nd plot command
041846 32 5B 18 04 0217*       ld (@cmd1),a ; because the 24-bit y0 load stomped on it
04184A 21 55 18 04 0218*   	ld hl,@cmd0
04184E 01 0C 00 00 0219*   	ld bc,@end-@cmd0
041852 5B DF       0220*   	rst.lil $18
041854 C9          0221*       ret
041855 19          0222*   @cmd0:  db 25 ; plot
041856 04          0223*   @arg0:  db plot_sl_both+mv_abs
041857 00 00       0224*   @x0:    dw 0x0000
041859 00 00       0225*   @y0:    dw 0x0000
04185B 19          0226*   @cmd1:  db 25 ; plot
04185C 9D          0227*   @arg1:  db plot_cf+dr_abs_fg
04185D 00 00       0228*   @x1:    dw 0x0000
04185F 00 00       0229*   @y1:    dw 0x0000
041861 00          0230*   @end:   db 0x00 ; padding
041862             0043        include "vdu_sound.inc"
041862             0001*   ; enable enough additional channels so that total enabled = max_channels
041862             0002*   ; inputs: max_channels set
041862             0003*   ; returns: nothing
041862             0004*   ; destroys: af, bc, hl
041862             0005*   vdu_enable_channels:
041862 3E 01       0006*       ld a,max_channels
041864 D6 03       0007*       sub 3 ; subtract number of default channels already enabled
041866 F2 6D 18 04 0008*       jp p,@loop
04186A C9          0009*       ret
04186B 3E 03       0010*       ld a,3 ; first non-default channel
04186D             0011*   @loop:
04186D 32 88 18 04 0012*       ld (@channel),a
041871 21 85 18 04 0013*       ld hl,@beg
041875 01 05 00 00 0014*       ld bc,@end-@beg
041879 F5          0015*       push af
04187A 5B DF       0016*       rst.lil $18
04187C F1          0017*       pop af
04187D 3C          0018*       inc a
04187E FE 01       0019*       cp max_channels
041880 C2 6D 18 04 0020*       jp nz,@loop
041884 C9          0021*       ret
041885             0022*   @beg:
041885 17 00 85    0023*               db 23, 0, $85
041888 00          0024*   @channel:   db 0
041889 08          0025*               db 8 ; command 8: enable channel
04188A             0026*   @end:
04188A             0027*   
04188A             0028*   ; disable all but the three default sound channels
04188A             0029*   ; inputs: max_channels set
04188A             0030*   ; outputs: none
04188A             0031*   ; destroys: ah,hl,bc
04188A             0032*   vdu_disable_channels:
04188A 3E 01       0033*       ld a,max_channels
04188C D6 03       0034*       sub 3 ; subtract number of default channels already enabled
04188E F2 95 18 04 0035*       jp p,@loop
041892 C9          0036*       ret
041893 3E 03       0037*       ld a,3 ; first non-default channel
041895             0038*   @loop:
041895 32 B0 18 04 0039*       ld (@channel),a
041899 21 AD 18 04 0040*       ld hl,@beg
04189D 01 05 00 00 0041*       ld bc,@end-@beg
0418A1 F5          0042*       push af
0418A2 5B DF       0043*       rst.lil $18
0418A4 F1          0044*       pop af
0418A5 3C          0045*       inc a
0418A6 FE 01       0046*       cp max_channels
0418A8 C2 95 18 04 0047*       jp nz,@loop
0418AC C9          0048*       ret
0418AD             0049*   @beg:
0418AD 17 00 85    0050*       db 23, 0, $85
0418B0 00          0051*   @channel: db 0
0418B1 09          0052*       db 9 ; command 9: disable channel
0418B2             0053*   @end:
0418B2             0054*   
0418B2             0055*   
0418B2             0056*   ; ############################################################
0418B2             0057*   ; VDU SOUND API
0418B2             0058*   ; ############################################################
0418B2             0059*   ; Command 0: Play note
0418B2             0060*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
0418B2             0061*       MACRO PLAY_NOTE channel, volume, frequency, duration
0418B2             0062*       ld hl, @PLAY_NOTE_CMD        ; Start of command block
0418B2             0063*       ld bc, @PLAY_NOTE_END - @PLAY_NOTE_CMD  ; Command block size
0418B2             0064*       rst.lil $18
0418B2             0065*       jr @PLAY_NOTE_END
0418B2             0066*   @PLAY_NOTE_CMD:  db 23, 0, 0x85               ; Command header
0418B2             0067*                    db channel                  ; Channel, 0 (commented out)
0418B2             0068*                    db 0                        ; Play note command
0418B2             0069*                    db volume                   ; Volume
0418B2             0070*                    dw frequency                ; Frequency
0418B2             0071*                    dw duration                 ; Duration
0418B2             0072*   @PLAY_NOTE_END:
0418B2             0073*       ENDMACRO
0418B2             0074*   
0418B2             0075*       MACRO MUTE_CHANNEL channel
0418B2             0076*       ld hl, @MUTE_CHANNEL_CMD     ; Start of command block
0418B2             0077*       ld bc, @MUTE_CHANNEL_END - @MUTE_CHANNEL_CMD  ; Command block size
0418B2             0078*       rst.lil $18
0418B2             0079*       jr @MUTE_CHANNEL_END
0418B2             0080*   @MUTE_CHANNEL_CMD: db 23, 0, 0x85             ; Command header
0418B2             0081*                      db channel                ; Channel, 0 (commented out)
0418B2             0082*                      db 2                      ; Set volume command
0418B2             0083*                      db 0                      ; Volume (mute)
0418B2             0084*   @MUTE_CHANNEL_END:
0418B2             0085*       ENDMACRO
0418B2             0086*   
0418B2             0087*   ; inputs: c = channel, b = volume, hl = frequency; de = duration;
0418B2             0088*   vdu_play_note:
0418B2 79          0089*       ld a,c
0418B3 32 D3 18 04 0090*       ld (@channel),a
0418B7 78          0091*       ld a,b
0418B8 32 D5 18 04 0092*       ld (@volume),a
0418BC 22 D6 18 04 0093*       ld (@frequency),hl
0418C0 ED 53 D8 18 0094*       ld (@duration),de
       04          
0418C5 21 D0 18 04 0095*       ld hl,@cmd
0418C9 01 0A 00 00 0096*       ld bc,@end-@cmd
0418CD 5B DF       0097*       rst.lil $18
0418CF C9          0098*       ret
0418D0 17 00 85    0099*   @cmd:       db 23, 0, 0x85
0418D3 00          0100*   @channel:   db 0x00
0418D4 00          0101*               db 0x00 ; play note command
0418D5 00          0102*   @volume:    db 0x00
0418D6 00 00       0103*   @frequency: dw 0x0000
0418D8 00 00       0104*   @duration:  dw 0x0000
0418DA 00          0105*   @end:       db 0x00 ; padding
0418DB             0106*   
0418DB             0107*   ; Command 1: Status
0418DB             0108*   ; VDU 23, 0, &85, channel, 1
0418DB             0109*   ; inputs: a = channel
0418DB             0110*   ; Returns a bit mask indicating the status of the specified channel, or 255 if the channel is not valid, or has been disabled. The bit mask is as follows:
0418DB             0111*   ; Bit 	Name 	Meaning
0418DB             0112*   ; 0 	Active 	When set this indicates the channel is in use (has an active waveform)
0418DB             0113*   ; 1 	Playing 	Indicates the channel is actively playing a note, and thus will reject calls to play a new note
0418DB             0114*   ; 2 	Indefinite 	Set if the channel is playing an indefinite duration note
0418DB             0115*   ; 3 	Has Volume Envelope 	Set if the channel has a volume envelope
0418DB             0116*   ; 4 	Has Frequency Envelope 	Set if the channel has a frequency envelope
0418DB             0117*   
0418DB             0118*   ; Bits 5-7 are reserved for future use and, for enabled channels, will currently always be zero.
0418DB             0119*   vdu_channel_status:
0418DB 32 ED 18 04 0120*       ld (@channel),a
0418DF 21 EA 18 04 0121*       ld hl,@cmd
0418E3 01 05 00 00 0122*       ld bc,@end-@cmd
0418E7 5B DF       0123*       rst.lil $18
0418E9 C9          0124*       ret
0418EA 17 00 85    0125*   @cmd:       db 23, 0, 0x85
0418ED 00          0126*   @channel:   db 0x00
0418EE 01          0127*               db 0x01 ; get channel status command
0418EF             0128*   @end:
0418EF             0129*   
0418EF             0130*   ; VDU 23, 0, &85, channel, 2, volume
0418EF             0131*   ; inputs: c = channel, b = volume
0418EF             0132*   ; Sets the volume of the specified channel. The volume is a value from 0 to 127, where 0 is silent and 127 is full volume. Values over 127 will be treated as 127 (with one exception described later).
0418EF             0133*   
0418EF             0134*   ; Specifying a channel of -1 (or 255) will set the global sound system volume level. (Requires Console8 VDP 2.5.0 or later.)
0418EF             0135*   
0418EF             0136*   ; Using this command provides more direct control over a channel than the play note command. It can be used to adjust the volume of a channel that is already playing a note.
0418EF             0137*   vdu_channel_volume:
0418EF 79          0138*       ld a,c
0418F0 32 07 19 04 0139*       ld (@channel),a
0418F4 78          0140*       ld a,b
0418F5 32 09 19 04 0141*       ld (@volume),a
0418F9 21 04 19 04 0142*       ld hl,@cmd
0418FD 01 06 00 00 0143*       ld bc,@end-@cmd
041901 5B DF       0144*       rst.lil $18
041903 C9          0145*       ret
041904 17 00 85    0146*   @cmd:       db 23, 0, 0x85
041907 00          0147*   @channel:   db 0x00
041908 02          0148*               db 0x02 ; set volume command
041909 00          0149*   @volume:    db 0x00
04190A             0150*   @end:
04190A             0151*   
04190A             0152*   ; VDU 23, 0, &85, channel, 3, frequency;
04190A             0153*   
04190A             0154*   ; Sets the frequency of the specified channel. The frequency is a 16-bit value specifying in Hz the frequency of the note to be played.
04190A             0155*   
04190A             0156*   ; Using this command provides more direct control over a channel than the play note command. It can be used to adjust the frequency of a channel that is already playing a note.
04190A             0157*   
04190A             0158*   ; Returns 1 on success, 0 for failure.
04190A             0159*   vdu_channel_frequency:
04190A 79          0160*       ld a,c
04190B 32 22 19 04 0161*       ld (@channel),a
04190F ED 53 24 19 0162*       ld (@frequency),de
       04          
041914 21 1F 19 04 0163*       ld hl,@cmd
041918 01 07 00 00 0164*       ld bc,@end-@cmd
04191C 5B DF       0165*       rst.lil $18
04191E C9          0166*       ret
04191F 17 00 85    0167*   @cmd:       db 23, 0, 0x85
041922 00          0168*   @channel:   db 0x00
041923 03          0169*               db 0x03 ; set frequency command
041924 00 00       0170*   @frequency: dw 0x0000
041926 00          0171*   @end:       db 0x00 ; padding
041927             0172*   
041927             0173*   
041927             0174*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
041927             0175*   ; inputs: c = channel, b = waveformOrSample, [hl = bufferId]
041927             0176*   ; Sets the waveform type for a channel to use. The waveformOrSample value is a single byte treated as a signed value.
041927             0177*   
041927             0178*   ; Using a negative value for the waveform indicates that a sample should be used instead. For more information see the documentation for the sample command.
041927             0179*   
041927             0180*   ; By default a channel is set to use waveform 0 (square wave).
041927             0181*   
041927             0182*   ; Valid waveform values are as follows:
041927             0183*   ; Value 	Waveform
041927             0184*   ; 0 	Square wave
041927             0185*   ; 1 	Triangle wave
041927             0186*   ; 2 	Sawtooth wave
041927             0187*   ; 3 	Sine wave
041927             0188*   ; 4 	Noise (simple white noise with no frequency support)
041927             0189*   ; 5 	VIC Noise (emulates a VIC6561; supports frequency)
041927             0190*   ; 8 	Sample (specifying a 16-bit buffer ID for sample data)
041927             0191*   
041927             0192*   vdu_channel_waveform:
041927 79          0193*       ld a,c
041928 32 4D 19 04 0194*       ld (@channel),a
04192C 78          0195*       ld a,b
04192D 32 4F 19 04 0196*       ld (@waveform),a
041931 FE 08       0197*       cp 8 ; check if the waveform is a sample
041933 28 06       0198*       jr z, @sample
041935 01 06 00 00 0199*       ld bc,@bufferId-@cmd
041939 18 08       0200*       jr @sendToVdu
04193B             0201*   @sample:
04193B 22 50 19 04 0202*       ld (@bufferId),hl
04193F 01 08 00 00 0203*       ld bc,@end-@cmd
041943             0204*   @sendToVdu:
041943 21 4A 19 04 0205*       ld hl,@cmd
041947 5B DF       0206*       rst.lil $18
041949 C9          0207*       ret
04194A 17 00 85    0208*   @cmd:       db 23, 0, 0x85
04194D 00          0209*   @channel:   db 0x00
04194E 04          0210*               db 0x04 ; set waveform command
04194F 00          0211*   @waveform:  db 0x00
041950 00 00       0212*   @bufferId:  dw 0x0000
041952 00          0213*   @end:       db 0x00 ; padding
041953             0214*   
041953             0215*   ; VDU 23, 0, &85, channel (ignored), 5, 2, bufferId; format, [sampleRate;]
041953             0216*   ; inputs: hl = bufferId; a = format, de = sample rate in Hz
041953             0217*   ; The format is a single byte giving the format of the sample data. The following formats are supported:
041953             0218*   ; Value	Description
041953             0219*   ; 0	8-bit signed
041953             0220*   ; 1	8-bit unsigned
041953             0221*   ; The format value can also have modifier bits set to modify the behaviour of the sample. The following modifier bits are supported:
041953             0222*   ; Value	Description
041953             0223*   ; 8	sample rate is sent in the next 16-bits
041953             0224*   ; 16	sample is tuneable
041953             0225*   ; The default sample rate for samples on the VDP is 16kHz (actually 16.384kHz to be precise).
041953             0226*   vdu_buffer_to_sound:
041953 22 73 19 04 0227*       ld (@bufferId),hl
041957 C6 08       0228*       add a,8 ; modify format byte to indicate sample rate argument is given
041959 32 75 19 04 0229*       ld (@format),a
04195D ED 53 76 19 0230*       ld (@sampleRate),de
       04          
041962 21 6D 19 04 0231*       ld hl,@cmd
041966 01 0B 00 00 0232*       ld bc,@end-@cmd
04196A 5B DF       0233*       rst.lil $18
04196C C9          0234*       ret
04196D 17 00 85    0235*   @cmd:       db 23, 0, 0x85
041970 00          0236*   @channel:   db 0x00 ; ignored
041971 05          0237*               db 0x05 ; buffer to sound command
041972 02          0238*               db 0x02 ; command 2 create sample
041973 00 00       0239*   @bufferId:  dw 0x0000
041975 00          0240*   @format:    db 0x00
041976 00 00       0241*   @sampleRate: dw 0x0000
041978 00          0242*   @end:       db 0x00 ; padding
041979             0243*   
041979             0244*   ; Command 13: Set sample rate
041979             0245*   ; VDU 23, 0, &85, channel, 13, sampleRate;
041979             0246*   ; inputs: c = channel, hl = sampleRate (Hz)
041979             0247*   vdu_set_sample_rate:
041979 79          0248*       ld a,c
04197A 32 90 19 04 0249*       ld (@channel),a
04197E 22 92 19 04 0250*       ld (@sampleRate),hl
041982 21 8D 19 04 0251*       ld hl,@cmd
041986 01 07 00 00 0252*       ld bc,@end-@cmd
04198A 5B DF       0253*       rst.lil $18
04198C C9          0254*       ret
04198D 17 00 85    0255*   @cmd:       db 23, 0, 0x85
041990 00          0256*   @channel:   db 0x00
041991 0D          0257*               db 13 ; set sample rate command
041992 00 00       0258*   @sampleRate: dw 0x0000
041994 00          0259*   @end:       db 0x00 ; padding
041995             0260*   
041995             0261*   ; load a sound file to a buffer
041995             0262*   ; inputs: hl = bufferId ; de = sampleRate in Hz ; iy = pointer to filename
041995             0263*   vdu_load_sfx:
041995             0264*   ; back up input parameters
041995 E5          0265*       push hl ; bufferId
041996 D5          0266*       push de ; sample rate
041997             0267*   ; load the sound
041997 CD D5 14 04 0268*       call vdu_load_buffer_from_file
04199B             0269*   ; now make the buffer a sound sample
04199B D1          0270*       pop de ; sample rate
04199C E1          0271*       pop hl ; bufferId
04199D AF          0272*       xor a ; zero is the magic number for mono 8-bit signed PCM
04199E CD 53 19 04 0273*       call vdu_buffer_to_sound
0419A2 C9          0274*       ret
0419A3             0275*   
0419A3             0276*   
0419A3 00          0277*   last_channel: db 0
0419A4             0278*   max_channels: equ 1
0419A4             0279*   
0419A4             0280*   ; play a sound effect from an already loaded buffer
0419A4             0281*   ; inputs: hl = bufferId ; bc = duration in milliseconds
0419A4             0282*   vdu_play_sfx:
0419A4 22 DC 19 04 0283*       ld (@bufferId),hl
0419A8 ED 43 E6 19 0284*       ld (@duration),bc
       04          
0419AD 3E 17       0285*       ld a,23
0419AF 32 DE 19 04 0286*       ld (@bufferId+2),a
0419B3 3A A3 19 04 0287*       ld a,(last_channel)
0419B7 3C          0288*       inc a
0419B8             0289*       ; and 31 ; modulo 32
0419B8 FE 01       0290*       cp max_channels
0419BA C2 BF 19 04 0291*       jp nz,@load_channel
0419BE AF          0292*       xor a
0419BF             0293*   @load_channel:
0419BF 32 A3 19 04 0294*       ld (last_channel),a
0419C3 32 D9 19 04 0295*       ld (@channel0),a
0419C7 32 E1 19 04 0296*       ld (@channel1),a
0419CB 21 D6 19 04 0297*       ld hl, @sample
0419CF 01 12 00 00 0298*       ld bc, @sample_end - @sample
0419D3 5B DF       0299*       rst.lil $18
0419D5 C9          0300*       ret
0419D6             0301*   @sample:
0419D6             0302*   ; Command 4: Set waveform
0419D6             0303*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
0419D6 17 00 85    0304*       .db 23,0,$85                        ; do sound
0419D9             0305*   @channel0:
0419D9 00 04 08    0306*       .db 0,4,8 ; channel, command, waveform
0419DC             0307*   @bufferId:
0419DC 00 00       0308*       .dw 0x0000
0419DE             0309*   ; Command 0: Play note
0419DE             0310*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
0419DE 17 00 85    0311*       .db 23,0,$85                        ; do sound
0419E1             0312*   @channel1:
0419E1 00 00 7F    0313*       .db 0,0,127                ; channel, volume
0419E4 00 00       0314*       .dw 0
0419E6             0315*   @duration:                              ; freq (tuneable samples only)
0419E6 00 00       0316*       .dw 0x0000                        ; duration
0419E8             0317*   @sample_end:
0419E8 00          0318*       .db 0x00 ; padding
0419E9             0319*   
0419E9             0320*   ; inputs: c = channel, b = volume, de = sample rate; hl = bufferId;
0419E9             0321*   vdu_play_sample:
0419E9             0322*       ; populate input parameters
0419E9 79          0323*       ld a,c
0419EA 32 1C 1A 04 0324*       ld (@channel0),a
0419EE 32 24 1A 04 0325*       ld (@channel1),a
0419F2 32 2B 1A 04 0326*       ld (@channel2),a
0419F6 78          0327*       ld a,b
0419F7 32 2D 1A 04 0328*       ld (@volume),a
0419FB ED 53 26 1A 0329*       ld (@sampleRate),de
       04          
041A00 22 1F 1A 04 0330*       ld (@bufferId),hl
041A04 3E 17       0331*       ld a,23
041A06 32 21 1A 04 0332*       ld (@cmd1),a
041A0A 32 28 1A 04 0333*       ld (@cmd2),a
041A0E             0334*       ; prep the vdu command string
041A0E 21 19 1A 04 0335*       ld hl, @cmd0
041A12 01 19 00 00 0336*       ld bc, @end - @cmd0
041A16 5B DF       0337*       rst.lil $18
041A18 C9          0338*       ret
041A19             0339*   ; set waveform command
041A19 17 00 85    0340*   @cmd0:       db 23, 0, 0x85
041A1C 00          0341*   @channel0:   db 0x00
041A1D 04          0342*                db 0x04 ; set waveform command
041A1E 08          0343*   @waveform:   db 0x08 ; sample
041A1F 00 00       0344*   @bufferId:   dw 0x0000
041A21             0345*   ; set sample rate command
041A21 17 00 85    0346*   @cmd1:       db 23, 0, 0x85
041A24 00          0347*   @channel1:   db 0x00
041A25 0D          0348*               db 13 ; set sample rate command
041A26 00 00       0349*   @sampleRate: dw 0x0000
041A28             0350*   ; play note command
041A28 17 00 85    0351*   @cmd2:       db 23, 0, 0x85
041A2B 00          0352*   @channel2:   db 0x00
041A2C 00          0353*                db 0x00 ; play note command
041A2D 00          0354*   @volume:     db 0x00
041A2E 00 00       0355*   @frequency:  dw 0x00 ; no effect unless buffer has been set to tuneable sample
041A30 00 00       0356*   @duration:   dw 0x0000 ; milliseconds: set to -1 to loop indefinitely, 0 to play full duration once
041A32 00          0357*   @end:        db 0x00 ; padding
041A33             0044    
041A33             0045    ; APPLICATION INCLUDES
041A33             0046        include "layout.inc"
041A33             0001*   text_top: equ 0
041A33             0002*   text_left: equ 0
041A33             0003*   text_bottom: equ 47      ; 48 rows, zero-based
041A33             0004*   text_right: equ 63       ; 64 columns, zero-based
041A33             0005*   
041A33             0006*   ; set text viewport for current playing song
041A33             0007*   vp_now_playing_left: equ text_left
041A33             0008*   vp_now_playing_top: equ 34
041A33             0009*   vp_now_playing_right: equ text_right
041A33             0010*   vp_now_playing_bottom: equ vp_now_playing_top+1
041A33             0011*   
041A33             0012*   vp_now_playing:
041A33 0E 00       0013*       ld c, vp_now_playing_left
041A35 16 22       0014*       ld d, vp_now_playing_top
041A37 1E 3F       0015*       ld e, vp_now_playing_right
041A39 06 23       0016*       ld b, vp_now_playing_bottom
041A3B CD 20 13 04 0017*       call vdu_set_txt_viewport
041A3F C9          0018*       ret
041A40             0019*   ; end vp_now_playing
041A40             0020*   
041A40             0021*   ; set text viewport for playing breadcrumbs
041A40             0022*   vp_breadcrumbs_left: equ text_left
041A40             0023*   vp_breadcrumbs_top: equ vp_now_playing_bottom
041A40             0024*   vp_breadcrumbs_right: equ text_right
041A40             0025*   vp_breadcrumbs_bottom: equ vp_breadcrumbs_top
041A40             0026*   
041A40             0027*   vp_breadcrumbs:
041A40 0E 00       0028*       ld c, vp_breadcrumbs_left
041A42 16 23       0029*       ld d, vp_breadcrumbs_top
041A44 1E 3F       0030*       ld e, vp_breadcrumbs_right
041A46 06 23       0031*       ld b, vp_breadcrumbs_bottom
041A48 CD 20 13 04 0032*       call vdu_set_txt_viewport
041A4C C9          0033*       ret
041A4D             0034*   ; end vp_breadcrumbs
041A4D             0035*   
041A4D             0036*   vp_dir_hdr_left: equ text_left
041A4D             0037*   vp_dir_hdr_top: equ 19
041A4D             0038*   vp_dir_hdr_right: equ text_right
041A4D             0039*   vp_dir_hdr_bottom: equ vp_dir_hdr_top
041A4D             0040*   vp_dir_hdr:
041A4D 0E 00       0041*       ld c,vp_dir_hdr_left
041A4F 16 13       0042*       ld d,vp_dir_hdr_top
041A51 1E 3F       0043*       ld e,vp_dir_hdr_right
041A53 06 13       0044*       ld b,vp_dir_hdr_bottom
041A55 CD 20 13 04 0045*       call vdu_set_txt_viewport
041A59 C9          0046*       ret
041A5A             0047*   
041A5A             0048*   ; set text viewport for directory listing
041A5A             0049*   vp_dir_left: equ text_left
041A5A             0050*   vp_dir_top: equ vp_dir_hdr_top+4
041A5A             0051*   vp_dir_right: equ text_right
041A5A             0052*   vp_dir_bottom: equ vp_dir_top+11
041A5A             0053*   vp_dir:
041A5A 0E 00       0054*       ld c,vp_dir_left
041A5C 16 17       0055*       ld d,vp_dir_top
041A5E 1E 3F       0056*       ld e,vp_dir_right
041A60 06 22       0057*       ld b,vp_dir_bottom
041A62 CD 20 13 04 0058*       call vdu_set_txt_viewport
041A66 C9          0059*       ret
041A67             0060*   
041A67             0061*   vp_messages_left: equ text_left
041A67             0062*   vp_messages_top: equ vp_dir_bottom+1
041A67             0063*   vp_messages_right: equ text_right
041A67             0064*   vp_messages_bottom: equ text_bottom
041A67             0065*   ; set text viewport for messages
041A67             0066*   vp_messages:
041A67 0E 00       0067*       ld c,vp_messages_left
041A69 16 23       0068*       ld d,vp_messages_top
041A6B 1E 3F       0069*       ld e,vp_messages_right
041A6D 06 2F       0070*       ld b,vp_messages_bottom
041A6F CD 20 13 04 0071*       call vdu_set_txt_viewport
041A73 C9          0072*       ret
041A74             0073*   
041A74             0074*   ui_init:
041A74             0075*   ; reset text viewports and clear the screen
041A74 CD 90 13 04 0076*       call vdu_reset_viewports
041A78 CD C7 12 04 0077*       call vdu_cls
041A7C             0078*   
041A7C             0079*   ; set scroll protection on
041A7C 26 01       0080*       ld h,%00000001 ; mask to change value of bit 0 (scroll protection)
041A7E 2E 01       0081*       ld l,%00000001 ; bit 0 set is scroll protection on
041A80 CD B3 12 04 0082*       call vdu_cursor_behaviour
041A84             0083*   
041A84             0084*   ; tippy top border
041A84 0E 00       0085*       ld c,text_left ; x
041A86 06 00       0086*       ld b,text_top ; y
041A88 CD 9F 12 04 0087*       call vdu_move_cursor
041A8C 21 16 2C 04 0088*       ld hl,str_dashes_thick
041A90 CD 67 00 04 0089*       call printString
041A94             0090*   
041A94             0091*   ; print ascii art splash screen
041A94 0E 00       0092*       ld c,text_left ; x
041A96 06 01       0093*       ld b,text_top+1 ; y
041A98 CD 9F 12 04 0094*       call vdu_move_cursor
041A9C 21 B8 1B 04 0095*       ld hl,agon_jukebox_ascii
041AA0 CD 67 00 04 0096*       call printString
041AA4             0097*   
041AA4             0098*   ; print the directory header
041AA4 0E 00       0099*       ld c,vp_dir_hdr_left ; x
041AA6 06 13       0100*       ld b,vp_dir_hdr_top ; y
041AA8 CD 9F 12 04 0101*       call vdu_move_cursor
041AAC CD 60 00 04 0102*       call printInline
041AB0 50 61 67 65 0103*       asciz "Page 1 of n in directory:"
       20 31 20 6F 
       66 20 6E 20 
       69 6E 20 64 
       69 72 65 63 
       74 6F 72 79 
       3A 00       
041ACA             0104*   
041ACA             0105*   ; print play song instructions
041ACA 0E 00       0106*       ld c,text_left ; x
041ACC 06 15       0107*       ld b,vp_dir_hdr_bottom+2
041ACE CD 9F 12 04 0108*       call vdu_move_cursor
041AD2 CD 60 00 04 0109*       call printInline
041AD6 50 72 65 73 0110*       asciz "Press keys 0-9 to play a song or enter directory:"
       73 20 6B 65 
       79 73 20 30 
       2D 39 20 74 
       6F 20 70 6C 
       61 79 20 61 
       20 73 6F 6E 
       67 20 6F 72 
       20 65 6E 74 
       65 72 20 64 
       69 72 65 63 
       74 6F 72 79 
       3A 00       
041B08             0111*   
041B08             0112*   ; file list top border
041B08 0E 00       0113*       ld c,text_left ; x
041B0A 06 16       0114*       ld b,vp_dir_top-1 ; y
041B0C CD 9F 12 04 0115*       call vdu_move_cursor
041B10 21 D5 2B 04 0116*       ld hl,str_dashes_thin
041B14 CD 67 00 04 0117*       call printString
041B18             0118*   
041B18             0119*   ; below the breadcrumbs border
041B18 0E 00       0120*       ld c,text_left ; x
041B1A 06 24       0121*       ld b,vp_breadcrumbs_bottom+1 ; y
041B1C CD 9F 12 04 0122*       call vdu_move_cursor
041B20 21 D5 2B 04 0123*       ld hl,str_dashes_thin
041B24 CD 67 00 04 0124*       call printString
041B28             0125*   
041B28             0126*   ; print the navigation and song control instructions
041B28 0E 00       0127*       ld c,text_left ; x
041B2A 06 25       0128*       ld b,vp_breadcrumbs_bottom+2 ; y
041B2C CD 9F 12 04 0129*       call vdu_move_cursor
041B30 CD 60 00 04 0130*       call printInline
041B34 53 6F 6E 67 0131*       db "Song \e",24," \e",25," space  | Page [ ]        | (D)ir up\r\n"
       20 1B 18 20 
       1B 19 20 73 
       70 61 63 65 
       20 20 7C 20 
       50 61 67 65 
       20 5B 20 5D 
       20 20 20 20 
       20 20 20 20 
       7C 20 28 44 
       29 69 72 20 
       75 70 0D 0A 
041B64 28 53 29 68 0132*       db "(S)huffle: OFF  | (L)oop: OFF\r\n"
       75 66 66 6C 
       65 3A 20 4F 
       46 46 20 20 
       7C 20 28 4C 
       29 6F 6F 70 
       3A 20 4F 46 
       46 0D 0A    
041B83 28 52 29 61 0133*       db "(R)andom song   | [ESC] or (Q)uit\r\n"
       6E 64 6F 6D 
       20 73 6F 6E 
       67 20 20 20 
       7C 20 5B 45 
       53 43 5D 20 
       6F 72 20 28 
       51 29 75 69 
       74 0D 0A    
041BA6 00          0134*       db 0 ; null terminator
041BA7             0135*   
041BA7             0136*   ; below the detailed instructions / status border
041BA7 0E 00       0137*       ld c,text_left ; x
041BA9 06 28       0138*       ld b,vp_breadcrumbs_bottom+5 ; y
041BAB CD 9F 12 04 0139*       call vdu_move_cursor
041BAF 21 16 2C 04 0140*       ld hl,str_dashes_thick
041BB3 CD 67 00 04 0141*       call printString
041BB7             0142*   
041BB7 C9          0143*       ret
041BB8             0144*   ; end ui_init
041BB8             0047        include "ascii.inc"
041BB8             0001*   agon_jukebox_ascii:
041BB8 20 20 20 5F 0002*       db 32,32,32,95,95,95,95,95,32,32,32,32,95,95,95,95,95,95,95,95,32,95,95,95,95,95,95,95,95,32,32,32,32,95,95,95,95,95,95,95,13,10
       5F 5F 5F 5F 
       20 20 20 20 
       5F 5F 5F 5F 
       5F 5F 5F 5F 
       20 5F 5F 5F 
       5F 5F 5F 5F 
       5F 20 20 20 
       20 5F 5F 5F 
       5F 5F 5F 5F 
       0D 0A       
041BE2 20 20 2F 20 0003*       db 32,32,47,32,32,95,32,32,92,32,32,47,32,32,95,95,95,95,95,47,32,92,95,95,95,95,95,32,32,92,32,32,32,92,32,32,32,32,32,32,92,13,10
       20 5F 20 20 
       5C 20 20 2F 
       20 20 5F 5F 
       5F 5F 5F 2F 
       20 5C 5F 5F 
       5F 5F 5F 20 
       20 5C 20 20 
       20 5C 20 20 
       20 20 20 20 
       5C 0D 0A    
041C0D 20 2F 20 20 0004*       db 32,47,32,32,47,95,92,32,32,92,47,32,32,32,92,32,32,95,95,95,32,32,47,32,32,32,124,32,32,32,92,32,32,47,32,32,32,124,32,32,32,92,13,10
       2F 5F 5C 20 
       20 5C 2F 20 
       20 20 5C 20 
       20 5F 5F 5F 
       20 20 2F 20 
       20 20 7C 20 
       20 20 5C 20 
       20 2F 20 20 
       20 7C 20 20 
       20 5C 0D 0A 
041C39 2F 20 20 20 0005*       db 47,32,32,32,32,124,32,32,32,32,92,32,32,32,32,92,95,92,32,32,92,47,32,32,32,32,124,32,32,32,32,92,47,32,32,32,32,124,32,32,32,32,92,13,10
       20 7C 20 20 
       20 20 5C 20 
       20 20 20 5C 
       5F 5C 20 20 
       5C 2F 20 20 
       20 20 7C 20 
       20 20 20 5C 
       2F 20 20 20 
       20 7C 20 20 
       20 20 5C 0D 
       0A          
041C66 5C 5F 5F 5F 0006*       db 92,95,95,95,95,124,95,95,32,32,47,92,95,95,95,95,95,95,32,32,47,92,95,95,95,95,95,95,95,32,32,47,92,95,95,95,95,124,95,95,32,32,47,13,10
       5F 7C 5F 5F 
       20 20 2F 5C 
       5F 5F 5F 5F 
       5F 5F 20 20 
       2F 5C 5F 5F 
       5F 5F 5F 5F 
       5F 20 20 2F 
       5C 5F 5F 5F 
       5F 7C 5F 5F 
       20 20 2F 0D 
       0A          
041C93 20 20 20 20 0007*       db 32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,32,92,47,13,10
       20 20 20 20 
       5C 2F 20 20 
       20 20 20 20 
       20 20 5C 2F 
       20 20 20 20 
       20 20 20 20 
       20 5C 2F 20 
       20 20 20 20 
       20 20 20 20 
       5C 2F 0D 0A 
041CBF 20 20 20 20 0008*       db 32,32,32,32,32,95,95,95,95,32,95,95,95,95,32,95,95,95,32,95,95,95,95,32,32,95,95,32,95,95,95,95,95,95,95,95,95,95,95,13,10
       20 5F 5F 5F 
       5F 20 5F 5F 
       5F 5F 20 5F 
       5F 5F 20 5F 
       5F 5F 5F 20 
       20 5F 5F 20 
       5F 5F 5F 5F 
       5F 5F 5F 5F 
       5F 5F 5F 0D 
       0A          
041CE8 20 20 20 20 0009*       db 32,32,32,32,124,32,32,32,32,124,32,32,32,32,124,32,32,32,92,32,32,32,32,124,47,32,95,124,92,95,32,32,32,95,95,95,95,95,47,13,10
       7C 20 20 20 
       20 7C 20 20 
       20 20 7C 20 
       20 20 5C 20 
       20 20 20 7C 
       2F 20 5F 7C 
       5C 5F 20 20 
       20 5F 5F 5F 
       5F 5F 2F 0D 
       0A          
041D11 20 20 20 20 0010*       db 32,32,32,32,124,32,32,32,32,124,32,32,32,32,124,32,32,32,47,32,32,32,32,32,32,60,32,32,32,124,32,32,32,32,95,95,41,95,13,10
       7C 20 20 20 
       20 7C 20 20 
       20 20 7C 20 
       20 20 2F 20 
       20 20 20 20 
       20 3C 20 20 
       20 7C 20 20 
       20 20 5F 5F 
       29 5F 0D 0A 
041D39 2F 5C 5F 5F 0011*       db 47,92,95,95,124,32,32,32,32,124,32,32,32,32,124,32,32,47,124,32,32,32,32,124,32,32,92,32,32,124,32,32,32,32,32,32,32,32,92,13,10
       7C 20 20 20 
       20 7C 20 20 
       20 20 7C 20 
       20 2F 7C 20 
       20 20 20 7C 
       20 20 5C 20 
       20 7C 20 20 
       20 20 20 20 
       20 20 5C 0D 
       0A          
041D62 5C 5F 5F 5F 0012*       db 92,95,95,95,95,95,95,95,95,124,95,95,95,95,95,95,47,32,124,95,95,95,95,124,95,95,32,92,47,95,95,95,95,95,95,95,32,32,47,13,10
       5F 5F 5F 5F 
       5F 7C 5F 5F 
       5F 5F 5F 5F 
       2F 20 7C 5F 
       5F 5F 5F 7C 
       5F 5F 20 5C 
       2F 5F 5F 5F 
       5F 5F 5F 5F 
       20 20 2F 0D 
       0A          
041D8B 20 20 20 20 0013*       db 32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,92,47,13,10
       20 20 20 20 
       20 20 20 20 
       20 20 20 20 
       20 20 20 20 
       20 20 20 20 
       20 20 5C 2F 
       20 20 20 20 
       20 20 20 20 
       5C 2F 0D 0A 
041DB3 20 20 20 20 0014*       db 32,32,32,32,95,95,95,95,95,95,95,95,95,95,32,95,95,95,95,95,95,95,95,32,32,95,95,95,95,32,32,95,95,95,13,10
       5F 5F 5F 5F 
       5F 5F 5F 5F 
       5F 5F 20 5F 
       5F 5F 5F 5F 
       5F 5F 5F 20 
       20 5F 5F 5F 
       5F 20 20 5F 
       5F 5F 0D 0A 
041DD7 20 20 20 20 0015*       db 32,32,32,32,92,95,95,95,95,95,95,32,32,32,92,92,95,95,95,95,95,32,32,92,32,92,32,32,32,92,47,32,32,47,13,10
       5C 5F 5F 5F 
       5F 5F 5F 20 
       20 20 5C 5C 
       5F 5F 5F 5F 
       5F 20 20 5C 
       20 5C 20 20 
       20 5C 2F 20 
       20 2F 0D 0A 
041DFB 20 20 20 20 0016*       db 32,32,32,32,32,124,32,32,32,32,124,32,32,95,47,32,47,32,32,32,124,32,32,32,92,32,92,32,32,32,32,32,47,13,10
       20 7C 20 20 
       20 20 7C 20 
       20 5F 2F 20 
       2F 20 20 20 
       7C 20 20 20 
       5C 20 5C 20 
       20 20 20 20 
       2F 0D 0A    
041E1E 20 20 20 20 0017*       db 32,32,32,32,32,124,32,32,32,32,124,32,32,32,92,47,32,32,32,32,124,32,32,32,32,92,47,32,32,32,32,32,92,13,10
       20 7C 20 20 
       20 20 7C 20 
       20 20 5C 2F 
       20 20 20 20 
       7C 20 20 20 
       20 5C 2F 20 
       20 20 20 20 
       5C 0D 0A    
041E41 20 20 20 20 0018*       db 32,32,32,32,32,124,95,95,95,95,95,95,32,32,47,92,95,95,95,95,95,95,95,32,32,47,95,95,95,47,92,32,32,92,13,10
       20 7C 5F 5F 
       5F 5F 5F 5F 
       20 20 2F 5C 
       5F 5F 5F 5F 
       5F 5F 5F 20 
       20 2F 5F 5F 
       5F 2F 5C 20 
       20 5C 0D 0A 
041E65 20 20 20 20 0019*       db 32,32,32,32,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,92,95,47,13,10
       20 20 20 20 
       20 20 20 20 
       5C 2F 20 20 
       20 20 20 20 
       20 20 20 5C 
       2F 20 20 20 
       20 20 20 5C 
       5F 2F 0D 0A 
041E89 00          0020*       db 0 ; list terminator
041E8A             0048        include "input.inc"
041E8A             0001*   get_input:
041E8A             0002*   ; wait for the user to push a button
041E8A FB          0003*       ei ; enable interrupts
041E8B             0004*       MOSCALL mos_getkey ; a = ascii code of key pressed
                       M1 Args: function=mos_getkey 
041E8B 3E 00       0001*M1 			LD	A, function
041E8D 5B CF       0002*M1 			RST.LIL	08h
041E8F F3          0005*       di ; disable interrupts
041E90             0006*       ; rst.lil 10h ; print the key pressed
041E90             0007*   ; app control commands
041E90 FE 1B       0008*       cp '\e' ; escape
041E92 C8          0009*       ret z ; returns to main, which re-enables interrupts and exits app
041E93             0010*   ; DIRECTORY PAGING
041E93 FE 15       0011*       cp 0x15 ; right arrow
041E95 CA B3 25 04 0012*       jp z,ps_dir_next_page
041E99 FE 08       0013*       cp 0x08 ; left arrow
041E9B CA D1 25 04 0014*       jp z,ps_dir_prev_page
041E9F             0015*   ; SONG PLAYING COMMANDS
041E9F             0016*   ; toggle pause playback
041E9F FE 70       0017*       cp 'p'
041EA1 CA E3 1E 04 0018*       jp z,ps_toggle_pause
041EA5             0019*   ; toggle loop play
041EA5 FE 6C       0020*       cp 'l'
041EA7 CA 2B 1F 04 0021*       jp z,ps_toggle_loop
041EAB             0022*   ; toggle shuffle play
041EAB FE 73       0023*       cp 's'
041EAD CA 27 1F 04 0024*       jp z,ps_toggle_shuffle
041EB1             0025*   ; play random song
041EB1 FE 72       0026*       cp 'r'
041EB3 CA 26 26 04 0027*       jp z,ps_play_random
041EB7             0028*   ; 0-9 play song keys
041EB7             0029*   @@:
041EB7 FE 30       0030*       cp '0'
041EB9 DA CD 1E 04 0031*       jp c,@no_cmd ; not a song command
041EBD FE 3A       0032*       cp '9'+1
041EBF D2 CD 1E 04 0033*       jp nc,@no_cmd ; not a song command
041EC3             0034*   ; get pointer to song filename and play it
041EC3 D6 30       0035*       sub '0' ; a = index into filename lut
041EC5 CD F3 25 04 0036*       call ps_get_song_fn_from_pg_idx ; carry set indicates success
041EC9 DA D1 1E 04 0037*       jp c,ps_play_or_chg_dir ; re-enables interrupts and jp's to get_input when finished
041ECD             0038*   @no_cmd: ; no valid commands so loop
041ECD C3 8A 1E 04 0039*       jp get_input
041ED1             0040*   ; end get_input
041ED1             0041*   
041ED1             0042*   ; play or song or change directory when user issues a play song command
041ED1             0043*   ; inputs: hl pointer to the filename, a = file attribute
041ED1             0044*   ps_play_or_chg_dir:
041ED1 FE 10       0045*       cp AM_DIR ; file attribute check for directory
041ED3 C2 0B 23 04 0046*       jp nz,play_song ; not a directory so play the song
041ED7             0047*   ; otherwise change to the directory
041ED7             0048*       MOSCALL mos_cd ; change to the directory
                       M1 Args: function=mos_cd 
041ED7 3E 03       0001*M1 			LD	A, function
041ED9 5B CF       0002*M1 			RST.LIL	08h
041EDB CD D3 23 04 0049*       call ps_get_dir ; get directory listing
041EDF C3 9A 25 04 0050*       jp ps_change_dir ; change to the directory
041EE3             0051*   ; end ps_play_or_chg_dir
041EE3             0052*   
041EE3             0053*   ps_toggle_pause:
041EE3 CD 33 1A 04 0054*       call vp_now_playing
041EE7 CD C7 12 04 0055*       call vdu_cls
041EEB             0056*   
041EEB 21 2F 1F 04 0057*       ld hl,ps_mode
041EEF CB 46       0058*       bit ps_mode_playing,(hl)
041EF1 C2 0A 1F 04 0059*       jp nz,@playing
041EF5             0060*   
041EF5 CB C6       0061*       set ps_mode_playing,(hl)
041EF7 CD 60 00 04 0062*       call printInline
041EFB 28 50 29 6C 0063*       asciz "(P)laying "
       61 79 69 6E 
       67 20 00    
041F06 C3 1B 1F 04 0064*       jp @F
041F0A             0065*   
041F0A             0066*   @playing:
041F0A CB 86       0067*       res ps_mode_playing,(hl)
041F0C CD 60 00 04 0068*       call printInline
041F10 28 50 29 61 0069*       asciz "(P)aused  "
       75 73 65 64 
       20 20 00    
041F1B             0070*   
041F1B             0071*   @@:
041F1B 2A 47 21 04 0072*       ld hl,(ps_song_fn_cur)
041F1F CD 67 00 04 0073*       call printString ; print the song filename
041F23             0074*   
041F23 C3 8A 1E 04 0075*       jp get_input
041F27             0076*   ; end ps_toggle_pause
041F27             0077*   
041F27             0078*   ps_toggle_shuffle:
041F27             0079*   
041F27 C3 8A 1E 04 0080*       jp get_input
041F2B             0081*   ; end ps_toggle_shuffle
041F2B             0082*   
041F2B             0083*   ps_toggle_loop:
041F2B             0084*   
041F2B C3 8A 1E 04 0085*       jp get_input
041F2F             0086*   ; end ps_toggle_loop
041F2F             0049        include "play.inc"
041F2F             0001*   ; stream a song from the SD card
041F2F             0002*   ; inputs: hl = pointer to filename
041F2F             0003*   ; requirements: the file must be 8-bit signed PCM mono
041F2F             0004*   ; uses: sound channels 0 and 1, buffers 0x3000 and 0x3001
041F2F             0005*   ; play_song constants
041F2F             0006*   ch0_buffer: equ 0x3000
041F2F             0007*   ch1_buffer: equ 0x3001
041F2F             0008*   cmd0_buffer: equ 0x3002
041F2F             0009*   cmd1_buffer: equ 0x3003
041F2F             0010*   
041F2F             0011*   ; ps_mode bits
041F2F             0012*   ps_mode_playing: equ 0 ; 0 = paused 1 = playing, p key toggles
041F2F             0013*   ps_mode_loop:    equ 1 ; 0 = no loop 1 = loop (overrides ps_mode_shuffle if on), l key toggles
041F2F             0014*   ps_mode_shuffle: equ 2 ; 0 = shuffle off 1 = on, s key toggles
041F2F             0015*   
041F2F             0016*   ; play_song state variables
041F2F             0017*   ; current active channel and bufferId's
041F2F 00          0018*   ps_mode: db 0 ; playback mode bitmask
041F30 00          0019*   ps_channel: db 0 ; channel number
041F31 00 00 00    0020*   ps_cmdId: dl 0 ; command bufferId
041F34 00 00 00    0021*   ps_sampleId: dl 0 ; sample bufferId
041F37 00 00 00 00 0022*   ps_dir_path:   blkw 256,0 ; path of the current directory
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042137 00 00 00    0023*   ps_dir_num_files: dl 0 ; number of files/directories in the directory (virtually unlimited)
04213A 00 00 00    0024*   ps_dir_num_pages: dl 0 ; number of pages in the directory (virtually unlimited)
04213D 00 00 00    0025*   ps_page_num_files: dl 0 ; number of files/directories in the current directory page (max 10)
042140 00 00 00    0026*   ps_pagelast_num_files: dl 0 ; mod(ps_dir_num_files,10)
042143 00 00 00    0027*   ps_page_cur: dl 0 ; current directory page number
042146 00          0028*   ps_song_idx_cur: db 0 ; current song index in the directory page
042147 00 00 00    0029*   ps_song_fn_cur: dl 0 ; pointer to current song filename
04214A 00 00 00 00 0030*   ps_page_fn_ptrs: blkw 10*3,0 ; list of filename pointers in the current directory page
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042186             0031*   
042186             0032*   ; play_song directory info
042186             0033*   ps_dir_struct:
042186 00 00 00 00 0034*   ps_dptr:       blkb  4,0   ; Current read/write offset
04218A 00 00 00 00 0035*   ps_clust:      blkb  4,0   ; Current cluster
04218E 00 00 00 00 0036*   ps_sect:       blkb  4,0   ; Current sector (0:Read operation has terminated)
042192 00 00 00    0037*   ps_dir:        blkb  3,0   ; Pointer to the directory item in the win[]
042195 00 00 00 00 0038*   ps_fn:         blkb  12,0  ; SFN (in/out) {body[8],ext[3],status[1]}
       00 00 00 00 
       00 00 00 00 
0421A1 00 00 00 00 0039*   ps_blk_ofs:    blkb  4,0   ; Offset of current entry block being processed (0xFFFFFFFF:Invalid)
0421A5             0040*   
0421A5             0041*   ; play_song file info
0421A5 00          0042*   ps_filehandle_cur: db 0 ; file handle
0421A6 00 00 00    0043*   ps_chunkpointer: dl 0 ; pointer to current chunk
0421A9             0044*   ; File information structure (FILINFO)
0421A9             0045*   ps_file_struct:
0421A9 00 00 00 00 0046*   ps_file_fsize:    blkb 4, 0   ; File size (4 bytes)
0421AD 00 00       0047*   ps_file_fdate:    blkb 2, 0   ; Modified date (2 bytes)
0421AF 00 00       0048*   ps_file_ftime:    blkb 2, 0   ; Modified time (2 bytes)
0421B1 00          0049*   ps_file_fattrib:  blkb 1, 0   ; File attribute (1 byte)
0421B2 00 00 00 00 0050*   ps_file_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
0421BF 00 00 00 00 0051*   ps_file_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0422BF             0052*   
0422BF             0053*   ; buffer for play_song sound data
0422BF             0054*   ps_wav_header: ; marker for top of the wav file header and song data
0422BF             0055*   ; (must be last so buffer doesn't overwrite other program code or data)
0422BF             0056*   ; .wav header data
0422BF             0057*   ; WAV File Structure in Memory with LIST Chunk
0422BF 00 00 00 00 0058*   ps_wav_riff:          blkb 4,0   ; 4 bytes: "RIFF" identifier
0422C3 00 00 00 00 0059*   ps_wav_file_size:     blkb 4,0   ; 4 bytes: Total file size minus 8 bytes for RIFF header
0422C7 00 00 00 00 0060*   ps_wav_wave:          blkb 4,0   ; 4 bytes: "WAVE" identifier
0422CB 00 00 00 00 0061*   ps_wav_fmt_marker:    blkb 4,0   ; 4 bytes: "fmt " subchunk marker
0422CF 00 00 00 00 0062*   ps_wav_fmt_size:      blkb 4,0   ; 4 bytes: Format chunk size (16 for PCM)
0422D3 00 00       0063*   ps_wav_audio_format:  blkb 2,0   ; 2 bytes: Audio format (1 = PCM)
0422D5 00 00       0064*   ps_wav_num_channels:  blkb 2,0   ; 2 bytes: Number of channels (1 = mono, 2 = stereo)
0422D7 00 00 00 00 0065*   ps_wav_sample_rate:   blkb 4,0   ; 4 bytes: Sample rate in Hz (e.g., 32768)
0422DB 00 00 00 00 0066*   ps_wav_byte_rate:     blkb 4,0   ; 4 bytes: Bytes per second (SampleRate * NumChannels * BitsPerSample / 8)
0422DF 00 00       0067*   ps_wav_block_align:   blkb 2,0   ; 2 bytes: Bytes per sample block (NumChannels * BitsPerSample / 8)
0422E1 00 00       0068*   ps_wav_bits_per_sample: blkb 2,0 ; 2 bytes: Bits per sample (e.g., 8 or 16)
0422E3             0069*   
0422E3             0070*   ; LIST Chunk (Extra Metadata)
0422E3 00 00 00 00 0071*   ps_wav_list_marker:   blkb 4,0   ; 4 bytes: "LIST" marker
0422E7 00 00 00 00 0072*   ps_wav_list_size:     blkb 4,0   ; 4 bytes: Size of the LIST chunk (e.g., 26)
0422EB 00 00 00 00 0073*   ps_wav_info_marker:   blkb 4,0   ; 4 bytes: "INFO" marker
0422EF 00 00 00 00 0074*   ps_wav_isft_marker:   blkb 4,0   ; 4 bytes: "ISFT" marker (software identifier)
0422F3 00 00 00 00 0075*   ps_wav_isft_data:     blkb 14,0  ; 14 bytes: Software info string (e.g., "Lavf59.27.100")
       00 00 00 00 
       00 00 00 00 
       00 00       
042301 00 00       0076*   ps_wav_isft_padding:  blkb 2,0   ; 2 bytes: Padding/NULL terminator for alignment
042303             0077*   
042303             0078*   ; Data Chunk
042303 00 00 00 00 0079*   ps_wav_data_marker:   blkb 4,0   ; 4 bytes: "data" subchunk marker
042307 00 00 00 00 0080*   ps_wav_data_size:     blkb 4,0   ; 4 bytes: Size of the audio data in bytes
04230B             0081*   ; Total Header Size: 76 bytes
04230B             0082*   play_song:
04230B             0083*   ; save pointer to requested song file
04230B 22 47 21 04 0084*       ld (ps_song_fn_cur),hl
04230F             0085*   ; stop the PRT timer and close any currently playing file
04230F CD C6 23 04 0086*       call ps_close_file
042313 CD 18 27 04 0087*       call ps_prt_stop
042317             0088*   ; open the file in read mode
042317             0089*   ; Open a file
042317             0090*   ; HLU: Filename
042317             0091*   ;   C: Mode
042317             0092*   ; Returns:
042317             0093*   ;   A: Filehandle, or 0 if couldn't open
042317 2A 47 21 04 0094*       ld hl,(ps_song_fn_cur)
04231B 0E 01       0095*   	ld c,fa_read
04231D             0096*       MOSCALL mos_fopen
                       M1 Args: function=mos_fopen 
04231D 3E 0A       0001*M1 			LD	A, function
04231F 5B CF       0002*M1 			RST.LIL	08h
042321 32 A5 21 04 0097*       ld (ps_filehandle_cur),a
042325             0098*   ; read the .wav header data and copy it to the buffer
042325 CD 56 26 04 0099*       call ps_read_wav_header
042329             0100*   ; read the first block of data
042329 CD 5E 23 04 0101*       call ps_read_file
04232D             0102*   ; set ps_mode_playing
04232D 21 2F 1F 04 0103*       ld hl,ps_mode
042331 CB C6       0104*       set ps_mode_playing,(hl)
042333             0105*   ; tell the user what they've won
042333 CD 5C 25 04 0106*       call ps_highlight_song
042337 CD 33 1A 04 0107*       call vp_now_playing
04233B CD C7 12 04 0108*       call vdu_cls
04233F CD 60 00 04 0109*       call printInline
042343 28 50 29 6C 0110*       asciz "(P)laying "
       61 79 69 6E 
       67 20 00    
04234E 2A 47 21 04 0111*       ld hl,(ps_song_fn_cur)
042352 CD 67 00 04 0112*       call printString ; print the song filename
042356             0113*   ; start the PRT timer
042356 CD FB 26 04 0114*       call ps_prt_start
04235A             0115*   ; jump to user input loop:
04235A             0116*   ; the play sample interrupt will return to there
04235A             0117*   ; and exit app will return to main from there as well
04235A C3 8A 1E 04 0118*       jp get_input
04235E             0119*   ; end play_song
04235E             0120*   
04235E             0121*   ; read the next 1-second's worth of sound data from the file
04235E             0122*   ; and upload it to the sample buffer
04235E             0123*   ps_read_file:
04235E             0124*   ; disable interrupts so load is guaranteed to complete
04235E F3          0125*       di
04235F             0126*   ; print a playing breadcrumb
04235F CD 40 1A 04 0127*       call vp_breadcrumbs
042363 3E 2E       0128*       ld a,'.'
042365 5B D7       0129*       rst.lil 10h
042367             0130*   ; Read a block of data from a file
042367             0131*   ;   C: Filehandle
042367             0132*   ; HLU: Pointer to where to write the data to
042367             0133*   ; DEU: Number of bytes to read
042367             0134*   ; Returns:
042367             0135*   ; DEU: Number of bytes read
042367 3A A5 21 04 0136*       ld a,(ps_filehandle_cur)
04236B 4F          0137*       ld c,a
04236C 21 00 00 05 0138*       ld hl,ps_wav_data_start
042370 ED 5B D7 22 0139*       ld de,(ps_wav_sample_rate)
       04          
042375             0140*       MOSCALL mos_fread
                       M1 Args: function=mos_fread 
042375 3E 1A       0001*M1 			LD	A, function
042377 5B CF       0002*M1 			RST.LIL	08h
042379             0141*   ; test de for zero bytes read
042379 21 00 00 00 0142*       ld hl,0
04237D AF          0143*       xor a ; clear carry
04237E ED 52       0144*       sbc hl,de ; hl = 0-chunksize
042380 C2 8C 23 04 0145*       jp nz,@load ; we read some data
042384             0146*   ; no data read so close file and play a random song
042384 CD C6 23 04 0147*       call ps_close_file
042388 C3 26 26 04 0148*       jp ps_play_random
04238C             0149*   ; load a vdu buffer from local memory
04238C             0150*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
04238C             0151*   @load:
04238C 3A 30 1F 04 0152*       ld a,(ps_channel)
042390 3C          0153*       inc a
042391 E6 01       0154*       and 1
042393 32 30 1F 04 0155*       ld (ps_channel),a
042397 21 00 30 00 0156*       ld hl,ch0_buffer
04239B 6F          0157*       ld l,a
04239C 22 34 1F 04 0158*       ld (ps_sampleId),hl
0423A0 CD 81 16 04 0159*       call vdu_clear_buffer
0423A4 2A 34 1F 04 0160*       ld hl,(ps_sampleId)
0423A8 D5          0161*       push de ; chunksize
0423A9 C1          0162*       pop bc ; how much data to load
0423AA 11 00 00 05 0163*       ld de,ps_wav_data_start ; pointer to data
0423AE CD 6C 14 04 0164*       call vdu_load_buffer
0423B2 C9          0165*       ret
0423B3             0166*   ; end ps_read_file
0423B3             0167*   
0423B3             0168*   ; this is called by the PRT timer interrupt
0423B3             0169*   ps_play_sample:
0423B3             0170*   ; call the command buffer to play the sound
0423B3 2A 34 1F 04 0171*       ld hl,(ps_sampleId)
0423B7 2C          0172*       inc l
0423B8 2C          0173*       inc l
0423B9 22 31 1F 04 0174*       ld (ps_cmdId),hl ; TODO: perhaps not needed
0423BD CD 66 16 04 0175*       call vdu_call_buffer
0423C1             0176*   ; load the next chunk of data
0423C1 CD 5E 23 04 0177*       call ps_read_file
0423C5             0178*   ; return to the user input loop
0423C5 C9          0179*       ret
0423C6             0180*   ; end ps_play_sample
0423C6             0181*   
0423C6             0182*   ; close the file
0423C6             0183*   ps_close_file:
0423C6 CD 18 27 04 0184*       call ps_prt_stop ; stop the PRT timer
0423CA 3A A5 21 04 0185*       ld a,(ps_filehandle_cur)
0423CE             0186*       MOSCALL mos_fclose
                       M1 Args: function=mos_fclose 
0423CE 3E 0B       0001*M1 			LD	A, function
0423D0 5B CF       0002*M1 			RST.LIL	08h
0423D2 C9          0187*       ret
0423D3             0188*   ; end ps_close_file
0423D3             0189*   
0423D3             0190*   ps_get_dir:
0423D3             0191*   ; reset filecounter
0423D3 21 00 00 00 0192*       ld hl,0
0423D7 22 37 21 04 0193*       ld (ps_dir_num_files),hl
0423DB             0194*   ; initialize pointers to store directory info
0423DB 21 37 1F 04 0195*       ld hl,ps_dir_path  ; where to store result
0423DF 01 FF 00 00 0196*       ld bc,255          ; max length (final byte is zero terminator)
0423E3             0197*       MOSCALL ffs_getcwd ; MOS api get current working directory
                       M1 Args: function=ffs_getcwd 
0423E3 3E 9E       0001*M1 			LD	A, function
0423E5 5B CF       0002*M1 			RST.LIL	08h
0423E7             0198*   ; now get dir info
0423E7 21 86 21 04 0199*       ld hl,ps_dir_struct ; define where to store directory info
0423EB 11 37 1F 04 0200*       ld de,ps_dir_path   ; this is pointer to the path to the directory
0423EF             0201*       MOSCALL ffs_dopen   ; open dir
                       M1 Args: function=ffs_dopen 
0423EF 3E 91       0001*M1 			LD	A, function
0423F1 5B CF       0002*M1 			RST.LIL	08h
0423F3             0202*   ; set up pointers
0423F3 DD 21 00 00 0203*       ld ix,ps_dir_fil_list ; this is the pointer to the fileinfo table
       06          
0423F8             0204*   @readFileInfo:               ; we will loop here until all files have been processed
0423F8 21 86 21 04 0205*       ld hl,ps_dir_struct      ; HL is where to get directory info
0423FC DD E5       0206*       push ix
0423FE D1          0207*       pop de ; where to store current file info
0423FF             0208*       MOSCALL ffs_dread        ; read next item from dir
                       M1 Args: function=ffs_dread 
0423FF 3E 93       0001*M1 			LD	A, function
042401 5B CF       0002*M1 			RST.LIL	08h
042403             0209*   
042403 DD 7E 16    0210*       ld a,(ix+filinfo_fname)  ; get first char of file name
042406 B7          0211*       or a                     ; if zero then we are at the end of the listing
042407 CA 39 24 04 0212*       jp z,@allDone
04240B             0213*   
04240B DD 7E 08    0214*       ld a,(ix+filinfo_fattrib) ; get the file attribute
04240E CB AF       0215*       res 5,a ; clear bit 5 (archive) see: https://discord.com/channels/1158535358624039014/1158536667670511726/1328466726098309173
042410 B7          0216*       or a ; if zero this is a file
042411 C2 1A 24 04 0217*       jp nz,@F ; not zero so this is some other file type
042415 CB EF       0218*       set 5,a ; set bit 5 (archive) so will be consistent btw emulator and hardware
042417 DD 77 08    0219*       ld (ix+filinfo_fattrib),a ; update so we don't have to do this every time downstream
04241A             0220*   
04241A             0221*   @@: ; skip over writing hidden and system files
04241A E6 02       0222*       and AM_HID ; hidden file
04241C C2 F8 23 04 0223*       jp nz,@readFileInfo
042420 E6 04       0224*       and AM_SYS ; system file
042422 C2 F8 23 04 0225*       jp nz,@readFileInfo
042426             0226*   
042426             0227*   ; valid file or directory
042426 2A 37 21 04 0228*       ld hl,(ps_dir_num_files) ; get the current file counter
04242A 23          0229*       inc hl                  ; increment the counter
04242B 22 37 21 04 0230*       ld (ps_dir_num_files),hl
04242F 11 16 01 00 0231*       ld de,filinfo_struct_size ; length of fileinfo record
042433 DD 19       0232*       add ix,de ; point to next fileinfo record
042435             0233*   
042435 C3 F8 23 04 0234*       jp @readFileInfo         ; loop around to check next entry
042439             0235*   @allDone:
042439             0236*   ; compute page statistics
042439 2A 37 21 04 0237*       ld hl,(ps_dir_num_files) ; get the number of files
04243D 11 0A 00 00 0238*       ld de,10 ; max files per page
042441 CD 80 03 04 0239*       call udiv24 ; de = hl/10, hl = mod(hl,10)
042445             0240*       SIGN_HLU ; check remainder for zero
                       M1 Args: none
042445 19          0001*M1     add hl,de ; 1 cycle
042446 B7          0002*M1     or a ; clear flags ; 1 cycle
042447 ED 52       0003*M1     sbc hl,de ; 2 cycles
042449             0004*M1     ; 4 cycles total
042449 C2 52 24 04 0241*       jp nz,@F
04244D 21 0A 00 00 0242*       ld hl,10 ; if zero then we have exactly 10 files on the last page ...
042451 1B          0243*       dec de ; ... and we don't need an additional page for the remainder
042452             0244*   @@:
042452 22 40 21 04 0245*       ld (ps_pagelast_num_files),hl ; save the number of files on the last page
042456 13          0246*       inc de ; bump the page count
042457 ED 53 3A 21 0247*       ld (ps_dir_num_pages),de ; save the number of pages
       04          
04245C             0248*   ; reset the song index and page to zero and populate the page filename pointers
04245C AF          0249*       xor a
04245D 32 46 21 04 0250*       ld (ps_song_idx_cur),a
042461 21 00 00 00 0251*       ld hl,0
042465 22 43 21 04 0252*       ld (ps_page_cur),hl
042469 CD 76 24 04 0253*       call ps_fill_page_fn_ptrs
04246D             0254*   ; close the directory
04246D 21 86 21 04 0255*       ld hl,ps_dir_struct      ; load H: with address of the DIR struct
042471             0256*       MOSCALL ffs_dclose       ; close dir
                       M1 Args: function=ffs_dclose 
042471 3E 92       0001*M1 			LD	A, function
042473 5B CF       0002*M1 			RST.LIL	08h
042475 C9          0257*       ret
042476             0258*   ; end ps_get_dir
042476             0259*   
042476             0260*   ; populate the page filename pointers for the current directory page
042476             0261*   ; inputs: ps_page_cur
042476             0262*   ; prerequisites: ps_get_dir called on a valid directory
042476             0263*   ; outputs: a populated filename pointer list for the current page
042476             0264*   ; destroys: a, hl, bc, de, ix
042476             0265*   ps_fill_page_fn_ptrs:
042476 2A 43 21 04 0266*       ld hl,(ps_page_cur) ; get the current page number
04247A 11 DC 0A 00 0267*       ld de,10*filinfo_struct_size ; records/page * bytes/record
04247E CD 67 03 04 0268*       call umul24 ; hl = offset into the fileinfo table
042482 11 00 00 06 0269*       ld de,ps_dir_fil_list ; base address of fileinfo table
042486 19          0270*       add hl,de ; add the offset to the base address
042487 DD 21 4A 21 0271*       ld ix,ps_page_fn_ptrs ; get the address of the page fileinfo pointer table
       04          
04248C 11 16 01 00 0272*       ld de,filinfo_struct_size ; bytes per filename record
042490 06 0A       0273*       ld b,10 ; number of files per page
042492             0274*   @loop:
042492 DD 2F 00    0275*       ld (ix),hl ; store the filename pointer
042495 ED 32 03    0276*       lea ix,ix+3 ; bump the index pointer
042498 19          0277*       add hl,de ; add the record size to the filename pointer
042499 10 F7       0278*       djnz @loop
04249B C9          0279*       ret
04249C             0280*   ; end ps_fill_page_fn_ptrs
04249C             0281*   
04249C             0282*   ps_get_page_num_files:
04249C             0283*   ; check whether we're at last page
04249C 2A 43 21 04 0284*       ld hl,(ps_page_cur)
0424A0 ED 5B 3A 21 0285*       ld de,(ps_dir_num_pages)
       04          
0424A5 1B          0286*       dec de ; zero-based
0424A6 B7          0287*       or a ; clear carry
0424A7 ED 52       0288*       sbc hl,de
0424A9 06 0A       0289*       ld b,10 ; b = default number of files per page
0424AB C0          0290*       ret nz ; not the last page
0424AC 3A 40 21 04 0291*       ld a,(ps_pagelast_num_files) ; get the number of files on the last page
0424B0 47          0292*       ld b,a ; b = number of files on the last page
0424B1 C9          0293*       ret
0424B2             0294*   ; end ps_get_page_num_files
0424B2             0295*   
0424B2             0296*   ps_print_dir_page:
0424B2             0297*   ; set text viewport for directory listing
0424B2 CD 5A 1A 04 0298*       call vp_dir
0424B6 CD C7 12 04 0299*       call vdu_cls
0424BA             0300*   ; loop through the fileinfo pointer table and print out the filenames
0424BA CD 9C 24 04 0301*       call ps_get_page_num_files ; b = loop counter
0424BE AF          0302*       xor a ; song index
0424BF DD 21 4A 21 0303*       ld ix,ps_page_fn_ptrs
       04          
0424C4             0304*   @loop:
0424C4 C5          0305*       push bc ; save loop counter
0424C5 F5          0306*       push af ; save song index
0424C6 CD 68 27 04 0307*       call printHexA ; print the song index
0424CA             0308*   ; branch on the file attribute
0424CA DD 27 00    0309*       ld hl,(ix) ; get the filename pointer
0424CD 01 08 00 00 0310*       ld bc,filinfo_fattrib
0424D1 09          0311*       add hl,bc ; hl points to the file attribute
0424D2 7E          0312*       ld a,(hl)
0424D3 FE 10       0313*       cp AM_DIR ; if zero, is directory
0424D5 C2 E6 24 04 0314*       jp nz,@print_file ; not directory so just write filename
0424D9 E5          0315*       push hl
0424DA CD 60 00 04 0316*       call printInline
0424DE 3C 44 49 52 0317*       asciz "<DIR> "
       3E 20 00    
0424E5 E1          0318*       pop hl
0424E6             0319*   @print_file:
0424E6 01 0E 00 00 0320*       ld bc,filinfo_fname-filinfo_fattrib ; offset to the filename
0424EA 09          0321*       add hl,bc ; hl points to the filename
0424EB CD 67 00 04 0322*       call printString ; print the filename
0424EF CD 7C 00 04 0323*       call printNewLine
0424F3             0324*   @bump_counters:
0424F3 ED 32 03    0325*       lea ix,ix+3 ; bump the filename pointer
0424F6 F1          0326*       pop af ; restore song index
0424F7 3C          0327*       inc a ; increment the song index
0424F8 C1          0328*       pop bc ; restore loop counter
0424F9 10 C9       0329*       djnz @loop
0424FB             0330*   ; print the bottom border
0424FB 0E 00       0331*       ld c,text_left ; x
0424FD 06 0A       0332*       ld b,10 ; y
0424FF CD 9F 12 04 0333*       call vdu_move_cursor
042503 21 D5 2B 04 0334*       ld hl,str_dashes_thin
042507 CD 67 00 04 0335*       call printString
04250B C9          0336*       ret
04250C             0337*   ; end ps_print_dir_page
04250C             0338*   
04250C             0339*   ps_print_dir:
04250C             0340*   ; test whether there are any files in the directory
04250C 2A 37 21 04 0341*       ld hl,(ps_dir_num_files)
042510             0342*       SIGN_HLU
                       M1 Args: none
042510 19          0001*M1     add hl,de ; 1 cycle
042511 B7          0002*M1     or a ; clear flags ; 1 cycle
042512 ED 52       0003*M1     sbc hl,de ; 2 cycles
042514             0004*M1     ; 4 cycles total
042514 C8          0343*       ret z ; if zero, no files in the directory
042515             0344*   ; loop through the fileinfo table and print out the filenames
042515 DD 21 00 00 0345*       ld ix,ps_dir_fil_list
       06          
04251A 2A 37 21 04 0346*       ld hl,(ps_dir_num_files)
04251E             0347*   @print_loop:
04251E E5          0348*       push hl ; loop counter
04251F             0349*   ; branch on the file attribute
04251F DD 7E 08    0350*       ld a,(ix+filinfo_fattrib)
042522 FE 10       0351*       cp AM_DIR ; if zero, is directory
042524 C2 33 25 04 0352*       jp nz,@print_file ; not directory so just write filename
042528 CD 60 00 04 0353*       call printInline
04252C 3C 44 49 52 0354*       asciz "<DIR> "
       3E 20 00    
042533             0355*   @print_file:
042533 ED 32 16    0356*       lea ix,ix+filinfo_fname ; point to filinfo_fname
042536 DD E5       0357*       push ix
042538 E1          0358*       pop hl ; get the address of the filename
042539 CD 67 00 04 0359*       call printString
04253D CD 7C 00 04 0360*       call printNewLine
042541 11 00 01 00 0361*       ld de,256 ; length of filename
042545 DD 19       0362*       add ix,de ; bump pointer to next filinfo record
042547             0363*   @dec_loop_counter:
042547 E1          0364*       pop hl
042548 2B          0365*       dec hl ; decrement the loop counter
042549             0366*       SIGN_HLU ; check for zero
                       M1 Args: none
042549 19          0001*M1     add hl,de ; 1 cycle
04254A B7          0002*M1     or a ; clear flags ; 1 cycle
04254B ED 52       0003*M1     sbc hl,de ; 2 cycles
04254D             0004*M1     ; 4 cycles total
04254D C2 1E 25 04 0367*       jp nz,@print_loop
042551 C9          0368*       ret
042552             0369*   @skip_file:
042552 11 16 01 00 0370*       ld de,filinfo_struct_size
042556 DD 19       0371*       add ix,de ; bump pointer to next filinfo record
042558 C3 47 25 04 0372*       jp @dec_loop_counter
04255C             0373*   ; end ps_print_dir
04255C             0374*   
04255C             0375*   ps_highlight_song:
04255C             0376*   ; refresh the directory listing
04255C CD B2 24 04 0377*       call ps_print_dir_page
042560             0378*   ; highlight the song being played in the directory listing
042560 3A 46 21 04 0379*       ld a,(ps_song_idx_cur)
042564 16 17       0380*       ld d,vp_dir_top
042566 82          0381*       add a,d
042567 0E 00       0382*       ld c,vp_dir_left
042569 57          0383*       ld d,a
04256A 1E 3F       0384*       ld e,vp_dir_right
04256C 47          0385*       ld b,a
04256D CD 20 13 04 0386*       call vdu_set_txt_viewport
042571             0387*   ; set text background color
042571 3E 8F       0388*       ld a,c_white+128
042573 CD F8 12 04 0389*       call vdu_colour_text
042577             0390*   ; set text foreground color
042577 3E 04       0391*       ld a,c_blue_dk
042579 CD F8 12 04 0392*       call vdu_colour_text
04257D             0393*   ; print the index and song filename
04257D 3A 46 21 04 0394*       ld a,(ps_song_idx_cur)
042581 CD 68 27 04 0395*       call printHexA
042585 2A 47 21 04 0396*       ld hl,(ps_song_fn_cur)
042589 CD 67 00 04 0397*       call printString
04258D             0398*   ; set text background color
04258D 3E 84       0399*       ld a,c_blue_dk+128
04258F CD F8 12 04 0400*       call vdu_colour_text
042593             0401*   ; set text foreground color
042593 3E 0F       0402*       ld a,c_white
042595 CD F8 12 04 0403*       call vdu_colour_text
042599 C9          0404*       ret
04259A             0405*   ; end ps_highlight_song
04259A             0406*   
04259A             0407*   ps_change_dir:
04259A             0408*   ; reset the song index and page number to 0
04259A AF          0409*       xor a
04259B 32 46 21 04 0410*       ld (ps_song_idx_cur),a
04259F 21 00 00 00 0411*       ld hl,0
0425A3 22 43 21 04 0412*       ld (ps_page_cur),hl
0425A7             0413*   ; populate the page filename pointers
0425A7 CD 76 24 04 0414*       call ps_fill_page_fn_ptrs
0425AB             0415*   ; print the new page
0425AB CD B2 24 04 0416*       call ps_print_dir_page
0425AF             0417*   ; jump back to the user input loop
0425AF C3 8A 1E 04 0418*       jp get_input
0425B3             0419*   ; end ps_change_dir
0425B3             0420*   
0425B3             0421*   ps_dir_next_page:
0425B3             0422*   ; advance the page number
0425B3 2A 43 21 04 0423*       ld hl,(ps_page_cur) ; get the current page number
0425B7 23          0424*       inc hl ; increment the page number
0425B8 ED 5B 3A 21 0425*       ld de,(ps_dir_num_pages) ; get the number of pages
       04          
0425BD CD 80 03 04 0426*       call udiv24 ; hl = mod(ps_page_cur+1,ps_dir_num_pages)
0425C1 22 43 21 04 0427*       ld (ps_page_cur),hl ; save the new page number
0425C5             0428*   ; populate the page filename pointers
0425C5 CD 76 24 04 0429*       call ps_fill_page_fn_ptrs
0425C9             0430*   ; print the new page
0425C9 CD B2 24 04 0431*       call ps_print_dir_page
0425CD             0432*   ; jump back to the user input loop
0425CD C3 8A 1E 04 0433*       jp get_input
0425D1             0434*   ; end ps_dir_next_page
0425D1             0435*   
0425D1             0436*   ps_dir_prev_page:
0425D1             0437*   ; decrement the page number
0425D1 2A 43 21 04 0438*       ld hl,(ps_page_cur) ; get the current page number
0425D5 2B          0439*       dec hl ; decrement the page number
0425D6             0440*       SIGN_HLU ; check for zero
                       M1 Args: none
0425D6 19          0001*M1     add hl,de ; 1 cycle
0425D7 B7          0002*M1     or a ; clear flags ; 1 cycle
0425D8 ED 52       0003*M1     sbc hl,de ; 2 cycles
0425DA             0004*M1     ; 4 cycles total
0425DA F2 E3 25 04 0441*       jp p,@F ; >= 0 so we're good
0425DE 2A 3A 21 04 0442*       ld hl,(ps_dir_num_pages) ; get the number of pages
0425E2 2B          0443*       dec hl ; zero-based
0425E3             0444*   @@:
0425E3 22 43 21 04 0445*       ld (ps_page_cur),hl ; save the new page number
0425E7             0446*   ; populate the page filename pointers
0425E7 CD 76 24 04 0447*       call ps_fill_page_fn_ptrs
0425EB             0448*   ; print the new page
0425EB CD B2 24 04 0449*       call ps_print_dir_page
0425EF             0450*   ; jump back to the user input loop
0425EF C3 8A 1E 04 0451*       jp get_input
0425F3             0452*   ; end ps_dir_prev_page
0425F3             0453*   
0425F3             0454*   ; get the filename of the song at the current index
0425F3             0455*   ; inputs: a = song index
0425F3             0456*   ; returns: carry set if song index in range, new filemame in hl and ps_song_idx_cur, ps_song_fn_cur set to new index, a = file attribute
0425F3             0457*   ;          carry reset if song index out of range, current filename in hl, ps_song_idx_cur, ps_song_fn_cur unchanged, a = requested song index
0425F3             0458*   ; destroys: af, bc, de
0425F3             0459*   ps_get_song_fn_from_pg_idx:
0425F3 F5          0460*       push af ; save song index
0425F4 CD 9C 24 04 0461*       call ps_get_page_num_files ; b = number of files on the page
0425F8 F1          0462*       pop af ; restore song index
0425F9 B8          0463*       cp b ; compare song index to number of files on the page
0425FA 2A 47 21 04 0464*       ld hl,(ps_song_fn_cur) ; get the current song filename
0425FE D0          0465*       ret nc ; requested song index is out of range so return current filename and no carry
0425FF 32 46 21 04 0466*       ld (ps_song_idx_cur),a ; save the song index
042603 DD 21 4A 21 0467*       ld ix,ps_page_fn_ptrs ; get the address of the page fileinfo pointer table
       04          
042608 47          0468*       ld b,a ; song index
042609 0E 03       0469*       ld c,3 ; 3 bytes per filename pointer
04260B ED 4C       0470*       mlt bc ; index into the fileinfo pointer table
04260D DD 09       0471*       add ix,bc ; hl points to the fileinfo pointer
04260F             0472*   
04260F DD 27 00    0473*       ld hl,(ix) ; hl points to the fileinfo
042612 01 08 00 00 0474*       ld bc,filinfo_fattrib ; offset to the file attribute
042616 09          0475*       add hl,bc ; hl points to the file attribute
042617 7E          0476*       ld a,(hl) ; get the file attribute for determining file vs. directory
042618             0477*   
042618 DD 27 00    0478*       ld hl,(ix) ; hl points to the fileinfo
04261B 01 16 00 00 0479*       ld bc,filinfo_fname ; offset to the filename
04261F 09          0480*       add hl,bc ; hl points to the filename
042620 22 47 21 04 0481*       ld (ps_song_fn_cur),hl ; save the new song filename
042624 37          0482*       scf ; set carry to indicate success
042625 C9          0483*       ret
042626             0484*   ; end ps_get_song_fn_from_pg_idx
042626             0485*   
042626             0486*   ; queue a random song on the current page to play next
042626             0487*   ps_play_random:
042626             0488*   ; back up current song index
042626 2A 47 21 04 0489*       ld hl,(ps_song_fn_cur)
04262A 22 53 26 04 0490*       ld (@songFn),hl
04262E             0491*   ; get the number of songs in the current directory
04262E CD 9C 24 04 0492*       call ps_get_page_num_files
042632             0493*   ; get a random song index
042632 CD 38 05 04 0494*       call rand_8 ; a = 0-255
042636 67          0495*       ld h,a
042637 2E 0A       0496*       ld l,10 ; modulo 10
042639 CD 74 05 04 0497*       call udiv8 ; a = mod(a,10)
04263D CD F3 25 04 0498*       call ps_get_song_fn_from_pg_idx
042641 EB          0499*       ex de,hl ; setting up cp hl,de
042642 2A 53 26 04 0500*       ld hl,(@songFn) ; don't play the same song twice in a row
042646 B7          0501*       or a ; clear carry
042647 ED 52       0502*       sbc hl,de
042649 CA 26 26 04 0503*       jp z,ps_play_random ; same song, try again
04264D EB          0504*       ex de,hl ; pointer back to hl
04264E CD 0B 23 04 0505*       call play_song ; hit it
042652 C9          0506*       ret
042653 00 00 00    0507*   @songFn: dl 0
042656             0508*   ; end ps_play_random
042656             0509*   
042656             0510*   ps_read_wav_header:
042656             0511*   ; Read a block of data from a file
042656             0512*   ;   C: Filehandle
042656             0513*   ; HLU: Pointer to where to write the data to
042656             0514*   ; DEU: Number of bytes to read
042656             0515*   ; Returns:
042656             0516*   ; DEU: Number of bytes read
042656 3A A5 21 04 0517*       ld a,(ps_filehandle_cur)
04265A 4F          0518*       ld c,a
04265B 21 BF 22 04 0519*       ld hl,ps_wav_header
04265F 11 4C 00 00 0520*       ld de,wav_header_size
042663             0521*       MOSCALL mos_fread
                       M1 Args: function=mos_fread 
042663 3E 1A       0001*M1 			LD	A, function
042665 5B CF       0002*M1 			RST.LIL	08h
042667             0522*   ; test de for zero bytes read
042667 21 00 00 00 0523*       ld hl,0
04266B AF          0524*       xor a ; clear carry
04266C ED 52       0525*       sbc hl,de ; hl = 0-chunksize
04266E C8          0526*       ret z ; no data read so return zero to caller
04266F             0527*   ; data read so initialize song variables
04266F             0528*   ; load play sample command buffers (namely the sample rate for now)
04266F CD 74 26 04 0529*       call ps_load_command_buffers
042673 C9          0530*       ret
042674             0531*   ; end ps_read_wav_header
042674             0532*   
042674             0533*   ps_load_command_buffers:
042674 21 02 30 00 0534*       ld hl,cmd0_buffer
042678 CD 81 16 04 0535*       call vdu_clear_buffer
04267C 2A D7 22 04 0536*       ld hl,(ps_wav_sample_rate)
042680 22 CA 26 04 0537*       ld (ps_sr0),hl
042684 3E 17       0538*       ld a,23
042686 32 CC 26 04 0539*       ld (ps_sr0+2),a
04268A 21 02 30 00 0540*       ld hl,cmd0_buffer
04268E 01 1D 00 00 0541*       ld bc,ps_cmd0_end-ps_cmd0
042692 11 C1 26 04 0542*       ld de,ps_cmd0
042696 CD 3E 16 04 0543*       call vdu_write_block_to_buffer
04269A             0544*   
04269A 21 03 30 00 0545*       ld hl,cmd1_buffer
04269E CD 81 16 04 0546*       call vdu_clear_buffer
0426A2 2A D7 22 04 0547*       ld hl,(ps_wav_sample_rate)
0426A6 22 E7 26 04 0548*       ld (ps_sr1),hl
0426AA 3E 17       0549*       ld a,23
0426AC 32 E9 26 04 0550*       ld (ps_sr1+2),a
0426B0 21 03 30 00 0551*       ld hl,cmd1_buffer
0426B4 01 1D 00 00 0552*       ld bc,ps_cmd1_end-ps_cmd1
0426B8 11 DE 26 04 0553*       ld de,ps_cmd1
0426BC CD 3E 16 04 0554*       call vdu_write_block_to_buffer
0426C0 C9          0555*       ret
0426C1             0556*   ps_cmd0:
0426C1             0557*   ; vdu_buffer_to_sound command string
0426C1             0558*   ; Command 5: Buffer to sound
0426C1             0559*   ; VDU 23, 0, &85, channel (ignored), 5, 2, bufferId; format, [sampleRate;]
0426C1 17 00 85    0560*       db 23,0,0x85 ; vdu sound command header
0426C4 00          0561*       db 0x00 ; channel (ignored)
0426C5 05          0562*       db 0x05 ; buffer to sound command
0426C6 02          0563*       db 0x02 ; command 2 create sample
0426C7 00 30       0564*       dw ch0_buffer
0426C9 09          0565*       db 1+8 ; 8-bit unsigned PCM mono, 8 = sample rate argument follows
0426CA             0566*   ps_sr0:
0426CA 00 00       0567*       dw 0x0000 ; sample rate Hz
0426CC             0568*   ; vdu_play_sfx command string
0426CC             0569*   ; Command 4: Set waveform
0426CC             0570*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
0426CC 17 00 85    0571*       db 23,0,$85 ; vdu sound command header
0426CF 00          0572*       db 0 ; channel
0426D0 04          0573*       db 4 ; set waveform command
0426D1 08          0574*       db 8 ; waveform 8 = sample
0426D2 00 30       0575*       dw ch0_buffer ; sample bufferId
0426D4             0576*   ; Command 0: Play note
0426D4             0577*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
0426D4 17 00 85    0578*       db 23,0,$85 ; vdu sound command header
0426D7 00          0579*       db 0 ; channel
0426D8 00          0580*       db 0 ; play note command
0426D9 7F          0581*       db 127  ; volume 127 = max
0426DA 00 00       0582*       dw 0 ; frequency (relevant only for tuneable samples)
0426DC 00 00       0583*       dw 0 ; duration (ms), zero means play one time in full
0426DE             0584*   ps_cmd0_end:
0426DE             0585*   
0426DE             0586*   ps_cmd1:
0426DE             0587*   ; vdu_buffer_to_sound command string
0426DE             0588*   ; Command 5: Buffer to sound
0426DE             0589*   ; VDU 23, 0, &85, channel (ignored), 5, 2, bufferId; format, [sampleRate;]
0426DE 17 00 85    0590*       db 23,0,0x85 ; vdu sound command header
0426E1 00          0591*       db 0x00 ; channel (ignored)
0426E2 05          0592*       db 0x05 ; buffer to sound command
0426E3 02          0593*       db 0x02 ; command 2 create sample
0426E4 01 30       0594*       dw ch1_buffer
0426E6 09          0595*       db 1+8 ; 8-bit unsigned PCM mono, 8 = sample rate argument follows
0426E7             0596*   ps_sr1:
0426E7 00 00       0597*       dw 0x0000 ; sample rate Hz
0426E9             0598*   ; vdu_play_sfx command string
0426E9             0599*   ; Command 4: Set waveform
0426E9             0600*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
0426E9 17 00 85    0601*       db 23,0,$85 ; vdu sound command header
0426EC 01          0602*       db 1 ; channel
0426ED 04          0603*       db 4 ; set waveform command
0426EE 08          0604*       db 8 ; waveform 8 = sample
0426EF 01 30       0605*       dw ch1_buffer ; sample bufferId
0426F1             0606*   ; Command 0: Play note
0426F1             0607*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
0426F1 17 00 85    0608*       db 23,0,$85 ; vdu sound command header
0426F4 01          0609*       db 1 ; channel
0426F5 00          0610*       db 0 ; play note command
0426F6 7F          0611*       db 127  ; volume 127 = max
0426F7 00 00       0612*       dw 0 ; frequency (relevant only for tuneable samples)
0426F9 00 00       0613*       dw 0 ; duration (ms), zero means play one time in full
0426FB             0614*   ps_cmd1_end:
0426FB             0615*   ; end ps_load_command_buffers
0426FB             0050        include "timer_jukebox.inc"
0426FB             0001*   ps_prt_reload: equ [72000/2] ; 36000 = 2 ticks per second at 18.432 MHz with a 256 clock divider
0426FB             0002*   
0426FB             0003*   ; start PRT timer
0426FB             0004*   ps_prt_start:
0426FB 21 00 00 00 0005*       ld hl,0
0426FF 22 3A 27 04 0006*       ld (ps_prt_irq_counter),hl
042703 21 A0 8C 00 0007*       ld hl,ps_prt_reload
042707 ED 29 84    0008*       out0 (TMR1_CTL+TMR_RES_LOW),l
04270A ED 21 85    0009*   	out0 (TMR1_CTL+TMR_RES_HIGH),h
04270D             0010*   ; disable timer (in effect, reset it)
04270D 3E 0E       0011*       ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_256 | RST_EN_1 | PRT_EN_0
04270F ED 39 83    0012*   	out0 (TMR1_CTL+TMR_REG_CTL),a
042712             0013*   ; enable timer,with interrupt and CONTINUOUS mode,clock divider 256
042712 3E 5F       0014*       ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_256 | RST_EN_1 | PRT_EN_1
042714 ED 39 83    0015*   	out0 (TMR1_CTL+TMR_REG_CTL),a
042717 C9          0016*       ret
042718             0017*   
042718             0018*   ; stop PRT timer
042718             0019*   ps_prt_stop:
042718 3E 0E       0020*       ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_256 | RST_EN_1 | PRT_EN_0
04271A ED 39 83    0021*   	out0 (TMR1_CTL+TMR_REG_CTL),a
04271D C9          0022*       ret
04271E             0023*   
04271E             0024*   ; ===============================================
04271E             0025*   ; PRT Timer Interrupt Handling
04271E             0026*   ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.asm
04271E             0027*   ; -----------------------------------------------
04271E             0028*   ps_prt_irq_init:
04271E             0029*       ; set up interrupt vector table 2
04271E 21 00 00 00 0030*   	ld hl,0
042722 3A 0C 01 00 0031*   	ld a,($10c)
042726 6F          0032*   	ld l,a
042727 3A 0D 01 00 0033*   	ld a,($10d)
04272B 67          0034*   	ld h,a
04272C             0035*   
04272C             0036*   	; skip over CALL ($c3)
04272C 23          0037*   	inc hl
04272D             0038*   	; load address of jump into vector table 2 (in ram)
04272D ED 27       0039*   	ld hl,(hl)
04272F             0040*   
04272F             0041*   	; write CALL ps_prt_irq_handler to vector table 2
04272F 3E C3       0042*   	ld a,$c3
042731 77          0043*   	ld (hl),a
042732 23          0044*   	inc hl
042733 11 3B 27 04 0045*   	ld de,ps_prt_irq_handler
042737 ED 1F       0046*   	ld (hl),de
042739             0047*   
042739 C9          0048*       ret
04273A             0049*   ; end ps_prt_irq_init
04273A             0050*   
04273A             0051*   ; interrupt routine for playing the next sample
04273A             0052*   ps_prt_irq_counter:
04273A 00          0053*   	db 0
04273B             0054*   ps_prt_irq_handler:
04273B F3          0055*       di
04273C 08          0056*       ex af,af'
04273D D9          0057*       exx
04273E             0058*   ; clear sysvar_keyascii
04273E             0059*   	MOSCALL mos_sysvars
                       M1 Args: function=mos_sysvars 
04273E 3E 08       0001*M1 			LD	A, function
042740 5B CF       0002*M1 			RST.LIL	08h
042742 AF          0060*   	xor a
042743 DD 77 05    0061*   	ld (IX+sysvar_keyascii),a
042746             0062*   ; read the timer interrupt and bump the counter
042746 ED 38 83    0063*       in0 a,(TMR1_CTL+TMR_REG_CTL)
042749 3A 3A 27 04 0064*       ld a,(ps_prt_irq_counter)
04274D 3C          0065*       inc a
04274E E6 01       0066*       and 1 ; modulo 2
042750 32 3A 27 04 0067*       ld (ps_prt_irq_counter),a
042754             0068*   ; if counter zero, play the next sample
042754 C2 62 27 04 0069*       jp nz,@F
042758 21 2F 1F 04 0070*       ld hl,ps_mode
04275C CB 46       0071*       bit ps_mode_playing,(hl)
04275E C4 B3 23 04 0072*       call nz,ps_play_sample
042762             0073*   @@:
042762 D9          0074*       exx
042763 08          0075*       ex af,af'
042764 FB          0076*       ei
042765 5B ED 4D    0077*       reti.l
042768             0078*   ; end ps_prt_irq_handler
042768             0051        include "wav.inc"
042768             0001*   ; WAV File Structure Offsets and Descriptions
042768             0002*   wav_riff:          EQU 0    ; 4 bytes: "RIFF" identifier
042768             0003*   wav_file_size:     EQU 4    ; 4 bytes: Total file size minus 8 bytes for RIFF header
042768             0004*   wav_wave:          EQU 8    ; 4 bytes: "WAVE" identifier
042768             0005*   wav_fmt_marker:    EQU 12   ; 4 bytes: "fmt " subchunk marker
042768             0006*   wav_fmt_size:      EQU 16   ; 4 bytes: Format chunk size (16 for PCM)
042768             0007*   wav_audio_format:  EQU 20   ; 2 bytes: Audio format (1 = PCM)
042768             0008*   wav_num_channels:  EQU 22   ; 2 bytes: Number of channels (1 = mono, 2 = stereo)
042768             0009*   wav_sample_rate:   EQU 24   ; 4 bytes: Sample rate in Hz (e.g., 32768)
042768             0010*   wav_byte_rate:     EQU 28   ; 4 bytes: Bytes per second (SampleRate * NumChannels * BitsPerSample / 8)
042768             0011*   wav_block_align:   EQU 32   ; 2 bytes: Bytes per sample block (NumChannels * BitsPerSample / 8)
042768             0012*   wav_bits_per_sample: EQU 34 ; 2 bytes: Bits per sample (e.g., 8 or 16)
042768             0013*   
042768             0014*   ; LIST Chunk (Extra Metadata)
042768             0015*   wav_list_marker:   EQU 36   ; 4 bytes: "LIST" marker
042768             0016*   wav_list_size:     EQU 40   ; 4 bytes: Size of the LIST chunk (e.g., 26)
042768             0017*   wav_info_marker:   EQU 44   ; 4 bytes: "INFO" marker
042768             0018*   wav_isft_marker:   EQU 48   ; 4 bytes: "ISFT" marker (software identifier)
042768             0019*   wav_isft_data:     EQU 52   ; 14 bytes: Software info string (e.g., "Lavf59.27.100")
042768             0020*   wav_isft_padding:  EQU 66   ; 2 bytes: Padding/NULL terminator for alignment
042768             0021*   
042768             0022*   ; Data Chunk
042768             0023*   wav_data_marker:   EQU 68   ; 4 bytes: "data" subchunk marker
042768             0024*   wav_data_size:     EQU 72   ; 4 bytes: Size of the audio data in bytes
042768             0025*   wav_data_start:    EQU 76   ; Start of audio data
042768             0026*   wav_header_size:   EQU wav_data_start ; Total Header Size: 76 bytes
042768             0052        include "debug.inc"
042768             0001*   printHexA:
042768 F5          0002*       push af
042769 C5          0003*       push bc
04276A CD AE 00 04 0004*       call printHex8
04276E 3E 20       0005*       ld a,' '
042770 5B D7       0006*       rst.lil 10h
042772 C1          0007*       pop bc
042773 F1          0008*       pop af
042774 C9          0009*       ret
042775             0010*   
042775             0011*   printHexHL:
042775 F5          0012*       push af
042776 C5          0013*       push bc
042777 CD A8 00 04 0014*       call printHex16
04277B 3E 20       0015*       ld a,' '
04277D 5B D7       0016*       rst.lil 10h
04277F C1          0017*       pop bc
042780 F1          0018*       pop af
042781 C9          0019*       ret
042782             0020*   
042782             0021*   printHexUHL:
042782 F5          0022*       push af
042783 C5          0023*       push bc
042784 CD A0 00 04 0024*       call printHex24
042788 3E 20       0025*       ld a,' '
04278A 5B D7       0026*       rst.lil 10h
04278C C1          0027*       pop bc
04278D F1          0028*       pop af
04278E C9          0029*       ret
04278F             0030*   
04278F             0031*   printHexAUHL:
04278F F5          0032*       push af
042790 C5          0033*       push bc
042791 CD AE 00 04 0034*       call printHex8
042795 3E 2E       0035*       ld a,'.'
042797 5B D7       0036*       rst.lil 10h
042799 CD A0 00 04 0037*       call printHex24
04279D 3E 20       0038*       ld a,' '
04279F 5B D7       0039*       rst.lil 10h
0427A1 C1          0040*       pop bc
0427A2 F1          0041*       pop af
0427A3 C9          0042*       ret
0427A4             0043*   
0427A4             0044*   printHexABHL:
0427A4             0045*   ; preserve registers
0427A4 C5          0046*       push bc ; b will be ok c will not
0427A5 F5          0047*       push af ; will get totally destroyed
0427A6             0048*   ; print a
0427A6 CD AE 00 04 0049*       call printHex8
0427AA             0050*   ; print b
0427AA 78          0051*       ld a,b
0427AB CD AE 00 04 0052*       call printHex8
0427AF             0053*   ; print hl
0427AF CD A8 00 04 0054*       call printHex16
0427B3             0055*   ; restore registers
0427B3 F1          0056*       pop af
0427B4 C1          0057*       pop bc
0427B5 C9          0058*       ret
0427B6             0059*   
0427B6             0060*   printHexBHL:
0427B6             0061*   ; preserve registers
0427B6 C5          0062*       push bc ; b will be ok c will not
0427B7 F5          0063*       push af ; will get totally destroyed
0427B8             0064*   ; print b
0427B8 78          0065*       ld a,b
0427B9 CD AE 00 04 0066*       call printHex8
0427BD             0067*   ; print hl
0427BD CD A8 00 04 0068*       call printHex16
0427C1             0069*   ; restore registers
0427C1 F1          0070*       pop af
0427C2 C1          0071*       pop bc
0427C3 C9          0072*       ret
0427C4             0073*   
0427C4             0074*   printHexCDE:
0427C4             0075*   ; preserve registers
0427C4 C5          0076*       push bc ; b will be ok c will not
0427C5 F5          0077*       push af ; will get totally destroyed
0427C6             0078*   ; print c
0427C6 79          0079*       ld a,c
0427C7 CD AE 00 04 0080*       call printHex8
0427CB             0081*   ; print de
0427CB EB          0082*       ex de,hl
0427CC CD A8 00 04 0083*       call printHex16
0427D0 EB          0084*       ex de,hl
0427D1             0085*   ; restore registers
0427D1 F1          0086*       pop af
0427D2 C1          0087*       pop bc
0427D3 C9          0088*       ret
0427D4             0089*   
0427D4             0090*   printHexUIX:
0427D4             0091*   ; store everything in scratch
0427D4 22 35 03 04 0092*       ld (uhl),hl
0427D8 ED 43 38 03 0093*       ld (ubc),bc
       04          
0427DD ED 53 3B 03 0094*       ld (ude),de
       04          
0427E2 DD 22 3E 03 0095*       ld (uix),ix
       04          
0427E7 FD 22 41 03 0096*       ld (uiy),iy
       04          
0427EC F5          0097*       push af ; fml
0427ED             0098*   
0427ED 21 CC 02 04 0099*       ld hl,str_ixu
0427F1 CD 67 00 04 0100*       call printString
0427F5 2A 3E 03 04 0101*       ld hl,(uix)
0427F9 CD A0 00 04 0102*       call printHex24
0427FD CD 7C 00 04 0103*       call printNewLine
042801             0104*   
042801             0105*   ; restore everything
042801 2A 35 03 04 0106*       ld hl, (uhl)
042805 ED 4B 38 03 0107*       ld bc, (ubc)
       04          
04280A ED 5B 3B 03 0108*       ld de, (ude)
       04          
04280F DD 2A 3E 03 0109*       ld ix, (uix)
       04          
042814 FD 2A 41 03 0110*       ld iy, (uiy)
       04          
042819 F1          0111*       pop af
04281A             0112*   ; all done
04281A C9          0113*       ret
04281B             0114*   
04281B             0115*   
04281B             0116*   ; print registers to screen in hexidecimal format
04281B             0117*   ; inputs: none
04281B             0118*   ; outputs: values of every register printed to screen
04281B             0119*   ;    values of each register in global scratch memory
04281B             0120*   ; destroys: nothing
04281B             0121*   stepRegistersHex:
04281B             0122*   ; store everything in scratch
04281B 22 35 03 04 0123*       ld (uhl),hl
04281F ED 43 38 03 0124*       ld (ubc),bc
       04          
042824 ED 53 3B 03 0125*       ld (ude),de
       04          
042829 DD 22 3E 03 0126*       ld (uix),ix
       04          
04282E FD 22 41 03 0127*       ld (uiy),iy
       04          
042833 F5          0128*       push af ; fml
042834 E1          0129*       pop hl ; thanks, zilog
042835 22 32 03 04 0130*       ld (uaf),hl
042839 F5          0131*       push af ; dammit
04283A             0132*   
04283A             0133*   ; home the cursor
04283A             0134*       ; call vdu_home_cursor
04283A             0135*   
04283A             0136*   ; print each register
04283A 21 B8 02 04 0137*       ld hl,str_afu
04283E CD 67 00 04 0138*       call printString
042842 2A 32 03 04 0139*       ld hl,(uaf)
042846 CD A0 00 04 0140*       call printHex24
04284A CD 7C 00 04 0141*       call printNewLine
04284E             0142*   
04284E 21 BD 02 04 0143*       ld hl,str_hlu
042852 CD 67 00 04 0144*       call printString
042856 2A 35 03 04 0145*       ld hl,(uhl)
04285A CD A0 00 04 0146*       call printHex24
04285E CD 7C 00 04 0147*       call printNewLine
042862             0148*   
042862 21 C2 02 04 0149*       ld hl,str_bcu
042866 CD 67 00 04 0150*       call printString
04286A 2A 38 03 04 0151*       ld hl,(ubc)
04286E CD A0 00 04 0152*       call printHex24
042872 CD 7C 00 04 0153*       call printNewLine
042876             0154*   
042876 21 C7 02 04 0155*       ld hl,str_deu
04287A CD 67 00 04 0156*       call printString
04287E 2A 3B 03 04 0157*       ld hl,(ude)
042882 CD A0 00 04 0158*       call printHex24
042886 CD 7C 00 04 0159*       call printNewLine
04288A             0160*   
04288A 21 CC 02 04 0161*       ld hl,str_ixu
04288E CD 67 00 04 0162*       call printString
042892 2A 3E 03 04 0163*       ld hl,(uix)
042896 CD A0 00 04 0164*       call printHex24
04289A CD 7C 00 04 0165*       call printNewLine
04289E             0166*   
04289E 21 D1 02 04 0167*       ld hl,str_iyu
0428A2 CD 67 00 04 0168*       call printString
0428A6 2A 41 03 04 0169*       ld hl,(uiy)
0428AA CD A0 00 04 0170*       call printHex24
0428AE CD 7C 00 04 0171*       call printNewLine
0428B2             0172*   
0428B2             0173*       ; call vsync
0428B2             0174*   
0428B2 CD 7C 00 04 0175*       call printNewLine
0428B6             0176*   
0428B6             0177*   ; check for right shift key and quit if pressed
0428B6             0178*       MOSCALL mos_getkbmap
                       M1 Args: function=mos_getkbmap 
0428B6 3E 1E       0001*M1 			LD	A, function
0428B8 5B CF       0002*M1 			RST.LIL	08h
0428BA             0179*   @stayhere:
0428BA             0180*   ; 7 RightShift
0428BA DD CB 00 76 0181*       bit 6,(ix+0)
0428BE 20 02       0182*       jr nz,@RightShift
0428C0 18 F8       0183*       jr @stayhere
0428C2             0184*   @RightShift:
0428C2 DD CB 0E 86 0185*       res 0,(ix+14) ; debounce the key (hopefully)
0428C6 3E 80       0186*       ld a,%10000000
0428C8             0187*       ; call multiPurposeDelay
0428C8             0188*   
0428C8             0189*   ; restore everything
0428C8 2A 35 03 04 0190*       ld hl, (uhl)
0428CC ED 4B 38 03 0191*       ld bc, (ubc)
       04          
0428D1 ED 5B 3B 03 0192*       ld de, (ude)
       04          
0428D6 DD 2A 3E 03 0193*       ld ix, (uix)
       04          
0428DB FD 2A 41 03 0194*       ld iy, (uiy)
       04          
0428E0 F1          0195*       pop af
0428E1             0196*   ; all done
0428E1 C9          0197*       ret
0428E2             0198*   
0428E2             0199*   ; print registers to screen in hexidecimal format
0428E2             0200*   ; inputs: none
0428E2             0201*   ; outputs: values of every register printed to screen
0428E2             0202*   ;    values of each register in global scratch memory
0428E2             0203*   ; destroys: nothing
0428E2             0204*   dumpRegistersHex:
0428E2             0205*   ; store everything in scratch
0428E2 22 35 03 04 0206*       ld (uhl),hl
0428E6 ED 43 38 03 0207*       ld (ubc),bc
       04          
0428EB ED 53 3B 03 0208*       ld (ude),de
       04          
0428F0 DD 22 3E 03 0209*       ld (uix),ix
       04          
0428F5 FD 22 41 03 0210*       ld (uiy),iy
       04          
0428FA F5          0211*       push af ; fml
0428FB E1          0212*       pop hl ; thanks, zilog
0428FC 22 32 03 04 0213*       ld (uaf),hl
042900 F5          0214*       push af ; dammit
042901             0215*   
042901             0216*   ; home the cursor
042901             0217*       ; call vdu_home_cursor
042901             0218*       ; call printNewLine
042901             0219*   
042901             0220*   ; print each register
042901 21 B8 02 04 0221*       ld hl,str_afu
042905 CD 67 00 04 0222*       call printString
042909 2A 32 03 04 0223*       ld hl,(uaf)
04290D CD A0 00 04 0224*       call printHex24
042911 CD 7C 00 04 0225*       call printNewLine
042915             0226*   
042915 21 BD 02 04 0227*       ld hl,str_hlu
042919 CD 67 00 04 0228*       call printString
04291D 2A 35 03 04 0229*       ld hl,(uhl)
042921 CD A0 00 04 0230*       call printHex24
042925 CD 7C 00 04 0231*       call printNewLine
042929             0232*   
042929 21 C2 02 04 0233*       ld hl,str_bcu
04292D CD 67 00 04 0234*       call printString
042931 2A 38 03 04 0235*       ld hl,(ubc)
042935 CD A0 00 04 0236*       call printHex24
042939 CD 7C 00 04 0237*       call printNewLine
04293D             0238*   
04293D 21 C7 02 04 0239*       ld hl,str_deu
042941 CD 67 00 04 0240*       call printString
042945 2A 3B 03 04 0241*       ld hl,(ude)
042949 CD A0 00 04 0242*       call printHex24
04294D CD 7C 00 04 0243*       call printNewLine
042951             0244*   
042951 21 CC 02 04 0245*       ld hl,str_ixu
042955 CD 67 00 04 0246*       call printString
042959 2A 3E 03 04 0247*       ld hl,(uix)
04295D CD A0 00 04 0248*       call printHex24
042961 CD 7C 00 04 0249*       call printNewLine
042965             0250*   
042965 21 D1 02 04 0251*       ld hl,str_iyu
042969 CD 67 00 04 0252*       call printString
04296D 2A 41 03 04 0253*       ld hl,(uiy)
042971 CD A0 00 04 0254*       call printHex24
042975             0255*   
042975 CD 7C 00 04 0256*       call printNewLine
042979 CD 7C 00 04 0257*       call printNewLine
04297D             0258*   ; restore everything
04297D 2A 35 03 04 0259*       ld hl, (uhl)
042981 ED 4B 38 03 0260*       ld bc, (ubc)
       04          
042986 ED 5B 3B 03 0261*       ld de, (ude)
       04          
04298B DD 2A 3E 03 0262*       ld ix, (uix)
       04          
042990 FD 2A 41 03 0263*       ld iy, (uiy)
       04          
042995 F1          0264*       pop af
042996             0265*   ; all done
042996 C9          0266*       ret
042997             0267*   
042997             0268*   dumpRegistersHexPrime:
042997 D9          0269*       exx
042998 08          0270*       ex af,af'
042999 CD E2 28 04 0271*       call dumpRegistersHex
04299D 08          0272*       ex af,af'
04299E D9          0273*       exx
04299F C9          0274*       ret
0429A0             0275*   
0429A0             0276*   ; additionally dump prime registers
0429A0             0277*   ; inputs: none
0429A0             0278*   ; outputs: values of every register printed to screen
0429A0             0279*   ; destroys: nothing
0429A0             0280*   dumpRegistersHexAll:
0429A0 CD E2 28 04 0281*       call dumpRegistersHex
0429A4 08          0282*       ex af,af'
0429A5 D9          0283*       exx
0429A6 CD E2 28 04 0284*       call dumpRegistersHex
0429AA 08          0285*       ex af,af'
0429AB D9          0286*       exx
0429AC C9          0287*       ret
0429AD             0288*   
0429AD             0289*   ; print hlu to screen in hexidecimal format
0429AD             0290*   ; inputs: none
0429AD             0291*   ; destroys: nothing
0429AD             0292*   print_hex_hl:
0429AD F5          0293*       push af
0429AE E5          0294*       push hl
0429AF 21 BD 02 04 0295*       ld hl,str_hlu
0429B3 CD 67 00 04 0296*       call printString
0429B7 E1          0297*       pop hl
0429B8 E5          0298*       push hl
0429B9 CD A0 00 04 0299*       call printHex24
0429BD 3E 20       0300*       ld a,' '
0429BF 5B D7       0301*       rst.lil 10h
0429C1 E1          0302*       pop hl
0429C2 F1          0303*       pop af
0429C3 C9          0304*       ret
0429C4             0305*   
0429C4             0306*   ; print bcu to screen in hexidecimal format
0429C4             0307*   ; inputs: none
0429C4             0308*   ; destroys: nothing
0429C4             0309*   print_hex_bc:
0429C4 F5          0310*       push af
0429C5 E5          0311*       push hl
0429C6 C5          0312*       push bc
0429C7 21 C2 02 04 0313*       ld hl,str_bcu
0429CB CD 67 00 04 0314*       call printString
0429CF E1          0315*       pop hl
0429D0 E5          0316*       push hl
0429D1 CD A0 00 04 0317*       call printHex24
0429D5 3E 20       0318*       ld a,' '
0429D7 5B D7       0319*       rst.lil 10h
0429D9 C1          0320*       pop bc
0429DA E1          0321*       pop hl
0429DB F1          0322*       pop af
0429DC C9          0323*       ret
0429DD             0324*   
0429DD             0325*   ; print deu to screen in hexidecimal format
0429DD             0326*   ; inputs: none
0429DD             0327*   ; destroys: nothing
0429DD             0328*   print_hex_de:
0429DD F5          0329*       push af
0429DE E5          0330*       push hl
0429DF D5          0331*       push de
0429E0 21 C7 02 04 0332*       ld hl,str_deu
0429E4 CD 67 00 04 0333*       call printString
0429E8 E1          0334*       pop hl
0429E9 E5          0335*       push hl
0429EA CD A0 00 04 0336*       call printHex24
0429EE 3E 20       0337*       ld a,' '
0429F0 5B D7       0338*       rst.lil 10h
0429F2 D1          0339*       pop de
0429F3 E1          0340*       pop hl
0429F4 F1          0341*       pop af
0429F5 C9          0342*       ret
0429F6             0343*   
0429F6             0344*   
0429F6             0345*   ; inputs: whatever is in the flags register
0429F6             0346*   ; outputs: binary representation of flags
0429F6             0347*   ;          with a header so we know which is what
0429F6             0348*   ; destroys: nothing
0429F6             0349*   ; preserves: everything
0429F6             0350*   dumpFlags:
0429F6             0351*   ; first we curse zilog for not giving direct access to flags
0429F6 F5          0352*       push af ; this is so we can send it back unharmed
0429F7 F5          0353*       push af ; this is so we can pop it to hl
0429F8             0354*   ; store everything in scratch
0429F8 22 35 03 04 0355*       ld (uhl),hl
0429FC ED 43 38 03 0356*       ld (ubc),bc
       04          
042A01 ED 53 3B 03 0357*       ld (ude),de
       04          
042A06 DD 22 3E 03 0358*       ld (uix),ix
       04          
042A0B FD 22 41 03 0359*       ld (uiy),iy
       04          
042A10             0360*   ; next we print the header
042A10 21 3C 2A 04 0361*       ld hl,@header
042A14 CD 67 00 04 0362*       call printString
042A18 E1          0363*       pop hl ; flags are now in l
042A19 7D          0364*       ld a,l ; flags are now in a
042A1A CD 6E 02 04 0365*       call printBin8
042A1E CD 7C 00 04 0366*       call printNewLine
042A22             0367*   ; restore everything
042A22 2A 35 03 04 0368*       ld hl, (uhl)
042A26 ED 4B 38 03 0369*       ld bc, (ubc)
       04          
042A2B ED 5B 3B 03 0370*       ld de, (ude)
       04          
042A30 DD 2A 3E 03 0371*       ld ix, (uix)
       04          
042A35 FD 2A 41 03 0372*       ld iy, (uiy)
       04          
042A3A F1          0373*       pop af ; send her home the way she came
042A3B C9          0374*       ret
042A3C             0375*   ; Bit 7 (S): Sign flag
042A3C             0376*   ; Bit 6 (Z): Zero flag
042A3C             0377*   ; Bit 5 (5): Reserved (copy of bit 5 of the result)
042A3C             0378*   ; Bit 4 (H): Half Carry flag
042A3C             0379*   ; Bit 3 (3): Reserved (copy of bit 3 of the result)
042A3C             0380*   ; Bit 2 (PV): Parity/Overflow flag
042A3C             0381*   ; Bit 1 (N): Subtract flag
042A3C             0382*   ; Bit 0 (C): Carry flag
042A3C 53 5A 78 48 0383*   @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
042A47             0384*   
042A47             0385*   
042A47             0386*   ; print bytes from an address to the screen in hexidecimal format
042A47             0387*   ; inputs: hl = address of first byte to print, a = number of bytes to print
042A47             0388*   ; outputs: values of each byte printed to screen separated by spaces
042A47             0389*   ; destroys: nothing
042A47             0390*   dumpMemoryHex:
042A47             0391*   ; save registers to the stack
042A47 C5          0392*       push bc
042A48 E5          0393*       push hl
042A49 F5          0394*       push af
042A4A             0395*   
042A4A             0396*   ; print the address and separator
042A4A CD A0 00 04 0397*       call printHex24
042A4E 3E 3A       0398*       ld a,':'
042A50 5B D7       0399*       rst.lil 10h
042A52 3E 20       0400*       ld a,' '
042A54 5B D7       0401*       rst.lil 10h
042A56             0402*   
042A56             0403*   ; set b to be our loop counter
042A56 F1          0404*       pop af
042A57 47          0405*       ld b,a
042A58 E1          0406*       pop hl
042A59 E5          0407*       push hl
042A5A F5          0408*       push af
042A5B             0409*   @loop:
042A5B             0410*   ; print the byte
042A5B 7E          0411*       ld a,(hl)
042A5C CD AE 00 04 0412*       call printHex8
042A60             0413*   ; print a space
042A60 3E 20       0414*       ld a,' '
042A62 5B D7       0415*       rst.lil 10h
042A64 23          0416*       inc hl
042A65 10 F4       0417*       djnz @loop
042A67             0418*       ; call printNewLine
042A67             0419*   
042A67             0420*   ; restore everything
042A67 F1          0421*       pop af
042A68 E1          0422*       pop hl
042A69 C1          0423*       pop bc
042A6A             0424*   
042A6A             0425*   ; all done
042A6A C9          0426*       ret
042A6B             0427*   
042A6B             0428*   
042A6B             0429*   ; print bytes from an address to the screen in binary format
042A6B             0430*   ; inputs: hl = address of first byte to print, a = number of bytes to print
042A6B             0431*   ; outputs: values of each byte printed to screen separated by spaces
042A6B             0432*   ; destroys: nothing
042A6B             0433*   dumpMemoryBin:
042A6B             0434*   ; save all registers to the stack
042A6B F5          0435*       push af
042A6C C5          0436*       push bc
042A6D D5          0437*       push de
042A6E E5          0438*       push hl
042A6F DD E5       0439*       push ix
042A71 FD E5       0440*       push iy
042A73             0441*   
042A73             0442*   ; set b to be our loop counter
042A73 47          0443*       ld b,a
042A74             0444*   @loop:
042A74             0445*   ; print the byte
042A74 7E          0446*       ld a,(hl)
042A75 E5          0447*       push hl
042A76 C5          0448*       push bc
042A77 CD 6E 02 04 0449*       call printBin8
042A7B C1          0450*       pop bc
042A7C             0451*   ; print a space
042A7C 3E 20       0452*       ld a,' '
042A7E 5B D7       0453*       rst.lil 10h
042A80 E1          0454*       pop hl
042A81 23          0455*       inc hl
042A82 10 F0       0456*       djnz @loop
042A84 CD 7C 00 04 0457*       call printNewLine
042A88             0458*   
042A88             0459*   ; restore everything
042A88 FD E1       0460*       pop iy
042A8A DD E1       0461*       pop ix
042A8C E1          0462*       pop hl
042A8D D1          0463*       pop de
042A8E C1          0464*       pop bc
042A8F F1          0465*       pop af
042A90             0466*   ; all done
042A90 C9          0467*       ret
042A91             0468*   
042A91             0469*   ; print bytes from an address to the screen in binary format
042A91             0470*   ; with the bits of each byte in reverse order (lsb first)
042A91             0471*   ; inputs: hl = address of first byte to print, a = number of bytes to print
042A91             0472*   ; outputs: values of each byte printed to screen separated by spaces
042A91             0473*   ; destroys: nothing
042A91             0474*   dumpMemoryBinRev:
042A91             0475*   ; save all registers to the stack
042A91 F5          0476*       push af
042A92 C5          0477*       push bc
042A93 D5          0478*       push de
042A94 E5          0479*       push hl
042A95 DD E5       0480*       push ix
042A97 FD E5       0481*       push iy
042A99             0482*   
042A99             0483*   ; set b to be our loop counter
042A99 47          0484*       ld b,a
042A9A             0485*   @loop:
042A9A             0486*   ; print the byte
042A9A 7E          0487*       ld a,(hl)
042A9B E5          0488*       push hl
042A9C C5          0489*       push bc
042A9D CD 93 02 04 0490*       call printBin8Rev
042AA1 C1          0491*       pop bc
042AA2             0492*   ; print a space
042AA2 3E 20       0493*       ld a,' '
042AA4 5B D7       0494*       rst.lil 10h
042AA6 E1          0495*       pop hl
042AA7 23          0496*       inc hl
042AA8 10 F0       0497*       djnz @loop
042AAA CD 7C 00 04 0498*       call printNewLine
042AAE             0499*   
042AAE             0500*   ; restore everything
042AAE FD E1       0501*       pop iy
042AB0 DD E1       0502*       pop ix
042AB2 E1          0503*       pop hl
042AB3 D1          0504*       pop de
042AB4 C1          0505*       pop bc
042AB5 F1          0506*       pop af
042AB6             0507*   ; all done
042AB6 C9          0508*       ret
042AB7             0509*   
042AB7             0510*   DEBUG_PRINT:
042AB7             0511*       PUSH_ALL
                       M1 Args: none
042AB7 08          0001*M1     ex af,af'
042AB8 D9          0002*M1     exx
042AB9 F5          0003*M1     push af
042ABA E5          0004*M1     push hl
042ABB C5          0005*M1     push bc
042ABC D5          0006*M1     push de
042ABD             0007*M1 
042ABD 08          0008*M1     ex af,af'
042ABE D9          0009*M1     exx
042ABF F5          0010*M1     push af
042AC0 E5          0011*M1     push hl
042AC1 C5          0012*M1     push bc
042AC2 D5          0013*M1     push de
042AC3 DD E5       0014*M1     push ix
042AC5 FD E5       0015*M1     push iy
042AC7             0512*       ; ld c,0 ; X
042AC7             0513*       ; ld b,0 ; Y
042AC7             0514*       ; call vdu_move_cursor
042AC7 CD 7C 00 04 0515*       call printNewLine
042ACB             0516*       POP_ALL
                       M1 Args: none
042ACB FD E1       0001*M1     pop iy
042ACD DD E1       0002*M1     pop ix
042ACF D1          0003*M1     pop de
042AD0 C1          0004*M1     pop bc
042AD1 E1          0005*M1     pop hl
042AD2 F1          0006*M1     pop af
042AD3 08          0007*M1     ex af,af'
042AD4 D9          0008*M1     exx
042AD5             0009*M1 
042AD5 D1          0010*M1     pop de
042AD6 C1          0011*M1     pop bc
042AD7 E1          0012*M1     pop hl
042AD8 F1          0013*M1     pop af
042AD9 08          0014*M1     ex af,af'
042ADA D9          0015*M1     exx
042ADB             0517*       PUSH_ALL
                       M1 Args: none
042ADB 08          0001*M1     ex af,af'
042ADC D9          0002*M1     exx
042ADD F5          0003*M1     push af
042ADE E5          0004*M1     push hl
042ADF C5          0005*M1     push bc
042AE0 D5          0006*M1     push de
042AE1             0007*M1 
042AE1 08          0008*M1     ex af,af'
042AE2 D9          0009*M1     exx
042AE3 F5          0010*M1     push af
042AE4 E5          0011*M1     push hl
042AE5 C5          0012*M1     push bc
042AE6 D5          0013*M1     push de
042AE7 DD E5       0014*M1     push ix
042AE9 FD E5       0015*M1     push iy
042AEB CD F6 29 04 0518*       call dumpFlags
042AEF             0519*       POP_ALL
                       M1 Args: none
042AEF FD E1       0001*M1     pop iy
042AF1 DD E1       0002*M1     pop ix
042AF3 D1          0003*M1     pop de
042AF4 C1          0004*M1     pop bc
042AF5 E1          0005*M1     pop hl
042AF6 F1          0006*M1     pop af
042AF7 08          0007*M1     ex af,af'
042AF8 D9          0008*M1     exx
042AF9             0009*M1 
042AF9 D1          0010*M1     pop de
042AFA C1          0011*M1     pop bc
042AFB E1          0012*M1     pop hl
042AFC F1          0013*M1     pop af
042AFD 08          0014*M1     ex af,af'
042AFE D9          0015*M1     exx
042AFF             0520*       PUSH_ALL
                       M1 Args: none
042AFF 08          0001*M1     ex af,af'
042B00 D9          0002*M1     exx
042B01 F5          0003*M1     push af
042B02 E5          0004*M1     push hl
042B03 C5          0005*M1     push bc
042B04 D5          0006*M1     push de
042B05             0007*M1 
042B05 08          0008*M1     ex af,af'
042B06 D9          0009*M1     exx
042B07 F5          0010*M1     push af
042B08 E5          0011*M1     push hl
042B09 C5          0012*M1     push bc
042B0A D5          0013*M1     push de
042B0B DD E5       0014*M1     push ix
042B0D FD E5       0015*M1     push iy
042B0F CD E2 28 04 0521*       call dumpRegistersHex
042B13             0522*       ; call waitKeypress
042B13 CD 7C 00 04 0523*       call printNewLine
042B17             0524*       POP_ALL
                       M1 Args: none
042B17 FD E1       0001*M1     pop iy
042B19 DD E1       0002*M1     pop ix
042B1B D1          0003*M1     pop de
042B1C C1          0004*M1     pop bc
042B1D E1          0005*M1     pop hl
042B1E F1          0006*M1     pop af
042B1F 08          0007*M1     ex af,af'
042B20 D9          0008*M1     exx
042B21             0009*M1 
042B21 D1          0010*M1     pop de
042B22 C1          0011*M1     pop bc
042B23 E1          0012*M1     pop hl
042B24 F1          0013*M1     pop af
042B25 08          0014*M1     ex af,af'
042B26 D9          0015*M1     exx
042B27 C9          0525*       ret
042B28             0526*   DEBUG_WAITKEYPRESS:
042B28             0527*       PUSH_ALL
                       M1 Args: none
042B28 08          0001*M1     ex af,af'
042B29 D9          0002*M1     exx
042B2A F5          0003*M1     push af
042B2B E5          0004*M1     push hl
042B2C C5          0005*M1     push bc
042B2D D5          0006*M1     push de
042B2E             0007*M1 
042B2E 08          0008*M1     ex af,af'
042B2F D9          0009*M1     exx
042B30 F5          0010*M1     push af
042B31 E5          0011*M1     push hl
042B32 C5          0012*M1     push bc
042B33 D5          0013*M1     push de
042B34 DD E5       0014*M1     push ix
042B36 FD E5       0015*M1     push iy
042B38 CD 5A 03 04 0528*       call waitKeypress
042B3C             0529*       POP_ALL
                       M1 Args: none
042B3C FD E1       0001*M1     pop iy
042B3E DD E1       0002*M1     pop ix
042B40 D1          0003*M1     pop de
042B41 C1          0004*M1     pop bc
042B42 E1          0005*M1     pop hl
042B43 F1          0006*M1     pop af
042B44 08          0007*M1     ex af,af'
042B45 D9          0008*M1     exx
042B46             0009*M1 
042B46 D1          0010*M1     pop de
042B47 C1          0011*M1     pop bc
042B48 E1          0012*M1     pop hl
042B49 F1          0013*M1     pop af
042B4A 08          0014*M1     ex af,af'
042B4B D9          0015*M1     exx
042B4C C9          0530*       RET
042B4D             0531*   
042B4D             0532*   dumpVduCmdStr:
042B4D             0533*       PUSH_ALL
                       M1 Args: none
042B4D 08          0001*M1     ex af,af'
042B4E D9          0002*M1     exx
042B4F F5          0003*M1     push af
042B50 E5          0004*M1     push hl
042B51 C5          0005*M1     push bc
042B52 D5          0006*M1     push de
042B53             0007*M1 
042B53 08          0008*M1     ex af,af'
042B54 D9          0009*M1     exx
042B55 F5          0010*M1     push af
042B56 E5          0011*M1     push hl
042B57 C5          0012*M1     push bc
042B58 D5          0013*M1     push de
042B59 DD E5       0014*M1     push ix
042B5B FD E5       0015*M1     push iy
042B5D 79          0534*       ld a,c
042B5E CD 47 2A 04 0535*       call dumpMemoryHex
042B62 CD 5A 03 04 0536*       call waitKeypress
042B66             0537*       POP_ALL
                       M1 Args: none
042B66 FD E1       0001*M1     pop iy
042B68 DD E1       0002*M1     pop ix
042B6A D1          0003*M1     pop de
042B6B C1          0004*M1     pop bc
042B6C E1          0005*M1     pop hl
042B6D F1          0006*M1     pop af
042B6E 08          0007*M1     ex af,af'
042B6F D9          0008*M1     exx
042B70             0009*M1 
042B70 D1          0010*M1     pop de
042B71 C1          0011*M1     pop bc
042B72 E1          0012*M1     pop hl
042B73 F1          0013*M1     pop af
042B74 08          0014*M1     ex af,af'
042B75 D9          0015*M1     exx
042B76 C9          0538*       ret
042B77             0539*   ; end dumpVduCmdStr
042B77             0053    
042B77             0054    ; --- MAIN PROGRAM FILE ---
042B77 00          0055    original_screen_mode: db 0
042B78             0056    init:
042B78             0057    ; get current screen mode and save it so we can return to it on exit
042B78 CD A6 13 04 0058        call vdu_get_screen_mode
042B7C 32 77 2B 04 0059        ld (original_screen_mode),a
042B80             0060    ; set up display for gameplay
042B80 3E 14       0061        ld a,20
042B82 CD 95 13 04 0062        call vdu_set_screen_mode
042B86 AF          0063        xor a
042B87 CD AE 13 04 0064        call vdu_set_scaling
042B8B             0065    ; set text background color
042B8B 3E 84       0066        ld a,c_blue_dk+128
042B8D CD F8 12 04 0067        call vdu_colour_text
042B91             0068    ; set text foreground color
042B91 3E 0F       0069        ld a,c_white
042B93 CD F8 12 04 0070        call vdu_colour_text
042B97             0071    ; set the cursor off
042B97 CD 4F 12 04 0072        call vdu_cursor_off
042B9B             0073    ; clear the screen
042B9B CD C7 12 04 0074        call vdu_cls
042B9F             0075    ; print loading message
042B9F CD 60 00 04 0076        call printInline
042BA3 4C 6F 61 64 0077        asciz "Loading fonts...\r\n"
       69 6E 67 20 
       66 6F 6E 74 
       73 2E 2E 2E 
       0D 0A 00    
042BB6             0078    ; clear all buffers
042BB6 CD 9C 16 04 0079        call vdu_clear_all_buffers
042BBA             0080    ; load fonts
042BBA CD 82 05 04 0081    	call fonts_load
042BBE             0082    ; select font
042BBE 21 10 FA 00 0083        ld hl,Lat2_VGA8_8x8
042BC2 3E 01       0084        ld a,1 ; flags
042BC4 CD 0E 17 04 0085        call vdu_font_select
042BC8             0086    
042BC8             0087    ; initialize ui
042BC8 CD 74 1A 04 0088        call ui_init
042BCC             0089    
042BCC             0090    ; call directory page listing
042BCC CD D3 23 04 0091        call ps_get_dir
042BD0             0092    
042BD0             0093    ; initialize play sample timer interrupt handler
042BD0 CD 1E 27 04 0094        call ps_prt_irq_init
042BD4 C9          0095        ret
042BD5             0096    ; end init
042BD5             0097    
042BD5 2D 2D 2D 2D 0098    str_dashes_thin: asciz  "----------------------------------------------------------------"
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       00          
042C16 3D 3D 3D 3D 0099    str_dashes_thick: asciz "================================================================"
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       00          
042C57             0100    
042C57             0101    main:
042C57             0102    ; call the change directory routine which jp's to get_input
042C57 CD 9A 25 04 0103        call ps_change_dir
042C5B             0104    ; user pressed ESC to quit so shut down everytyhing and gracefully exit to MOS
042C5B CD 18 27 04 0105        call ps_prt_stop ; stop the PRT timer
042C5F FB          0106        ei ; interrupts were disabled by get_input
042C60             0107    ; restore original screen mode
042C60 3A 77 2B 04 0108        ld a,(original_screen_mode)
042C64 CD 95 13 04 0109        call vdu_set_screen_mode
042C68 CD 90 13 04 0110        call vdu_reset_viewports
042C6C CD C7 12 04 0111        call vdu_cls
042C70             0112    ; print thanks for playing message
042C70 CD 60 00 04 0113        call printInline
042C74 54 68 61 6E 0114        asciz "Thank you for using\r\n"
       6B 20 79 6F 
       75 20 66 6F 
       72 20 75 73 
       69 6E 67 0D 
       0A 00       
042C8A 21 B8 1B 04 0115        ld hl,agon_jukebox_ascii
042C8E CD 67 00 04 0116        call printString
042C92             0117    ; put screen back to regular operation
042C92 26 01       0118        ld h,%00000001 ; mask to change value of bit 0 (scroll protection)
042C94 2E 00       0119        ld l,%00000000 ; bit 0 reset is scroll protection off
042C96 CD B3 12 04 0120        call vdu_cursor_behaviour ; set scroll protection off
042C9A CD 41 12 04 0121        call vdu_cursor_on
042C9E C9          0122        ret ; back to MOS
042C9F             0123    ; end main
042C9F             0124    
042C9F             0125    ; must be final include in program so file data does not stomp on program code or other data
042C9F             0126        include "files.inc"
042C9F             0001*   ; THIS MUST BE LAST INCLUDE SO FILE DATA DOES NOT OVERWRITE OTHER CODE OR DATA
042C9F             0002*   
042C9F             0003*   ; buffer for loading files unrelated to audio
042C9F             0004*   ; e.g.: fonts, sprites, etc. (limited to 8k)
042C9F             0005*   filedata: equ 0xB7E000 ; address of onboard 8k sram
042C9F             0006*   
042C9F             0007*   ;     align 256 ; make things nice for indexing into especially ps_dir_fil_list
042C9F             0008*   ; ; buffer for sound data
042C9F             0009*   ps_wav_data_start: equ 0x050000 ;    equ $   ; (042E00) Start of audio data
042C9F             0010*   
042C9F             0011*   ; this list can grow as large as necessary to hold all the files in the directory
042C9F             0012*   ; each entry will be 278 bytes (filinfo_struct_size)
042C9F             0013*   ps_dir_fil_list: equ 0x060000 ; equ ps_wav_data_start+65536 ; (052E00) max file data we can load in one chunk is 64k
