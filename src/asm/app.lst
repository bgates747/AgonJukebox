PC     Output      Line
040000             0001        assume adl=1
040000             0002        org 0x040000
040000 C3 45 00 04 0003        jp start
040004             0004        align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0005        db "MOS"
040043 00          0006        db 00h
040044 01          0007        db 01h
040045             0008    
040045             0009    start:
040045 F5          0010        push af
040046 C5          0011        push bc
040047 D5          0012        push de
040048 DD E5       0013        push ix
04004A FD E5       0014        push iy
04004C             0015    
04004C CD 84 2D 04 0016        call init
040050 CD 91 2D 04 0017        call main
040054             0018    
040054             0019    exit:
040054 FD E1       0020        pop iy
040056 DD E1       0021        pop ix
040058 D1          0022        pop de
040059 C1          0023        pop bc
04005A F1          0024        pop af
04005B 21 00 00 00 0025        ld hl,0
04005F             0026    
04005F C9          0027        ret
040060             0028    
040060             0029    ; API INCLUDES
040060             0030        include "mos_api.inc"
040060             0001*   ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.inc
040060             0002*   ; Title:	AGON MOS - API for user projects
040060             0003*   ; Author:	Dean Belfield
040060             0004*   ;			Adapted for agon-ez80asm by Jeroen Venema
040060             0005*   ;			Added MOS error codes for return in HL
040060             0006*   ; Created:	03/08/2022
040060             0007*   ; Last Updated:	10/08/2023
040060             0008*   ;
040060             0009*   ; Modinfo:
040060             0010*   ; 05/08/2022:	Added mos_feof
040060             0011*   ; 09/08/2022:	Added system variables: cursorX, cursorY
040060             0012*   ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040060             0013*   ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040060             0014*   ; 24/09/2022:	Added mos_getError, mos_mkdir
040060             0015*   ; 13/10/2022:	Added mos_oscli
040060             0016*   ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040060             0017*   ; 04/03/2023:	Added sysvar_scrpixelIndex
040060             0018*   ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040060             0019*   ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040060             0020*   ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040060             0021*   ; 22/03/2023:	The VDP commands are now indexed from 0x80
040060             0022*   ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040060             0023*   ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040060             0024*   ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040060             0025*   ; 19/05/2023:	Added sysvar_scrMode
040060             0026*   ; 05/06/2023:	Added sysvar_rtcEnable
040060             0027*   ; 03/08/2023:	Added mos_setkbvector
040060             0028*   ; 10/08/2023:	Added mos_getkbmap
040060             0029*   
040060             0030*   ; VDP control (VDU 23, 0, n)
040060             0031*   ;
040060             0032*   vdp_gp:				EQU 80h
040060             0033*   vdp_keycode:		EQU 81h
040060             0034*   vdp_cursor:			EQU	82h
040060             0035*   vdp_scrchar:		EQU	83h
040060             0036*   vdp_scrpixel:		EQU	84h
040060             0037*   vdp_audio:			EQU	85h
040060             0038*   vdp_mode:			EQU	86h
040060             0039*   vdp_rtc:			EQU	87h
040060             0040*   vdp_keystate:		EQU	88h
040060             0041*   vdp_logicalcoords:	EQU	C0h
040060             0042*   vdp_terminalmode:	EQU	FFh
040060             0043*   
040060             0044*   ; MOS high level functions
040060             0045*   ;
040060             0046*   mos_getkey:			EQU	00h
040060             0047*   mos_load:			EQU	01h
040060             0048*   mos_save:			EQU	02h
040060             0049*   mos_cd:				EQU	03h
040060             0050*   mos_dir:			EQU	04h
040060             0051*   mos_del:			EQU	05h
040060             0052*   mos_ren:			EQU	06h
040060             0053*   mos_mkdir:			EQU	07h
040060             0054*   mos_sysvars:		EQU	08h
040060             0055*   mos_editline:		EQU	09h
040060             0056*   mos_fopen:			EQU	0Ah
040060             0057*   mos_fclose:			EQU	0Bh
040060             0058*   mos_fgetc:			EQU	0Ch
040060             0059*   mos_fputc:			EQU	0Dh
040060             0060*   mos_feof:			EQU	0Eh
040060             0061*   mos_getError:		EQU	0Fh
040060             0062*   mos_oscli:			EQU	10h
040060             0063*   mos_copy:			EQU	11h
040060             0064*   mos_getrtc:			EQU	12h
040060             0065*   mos_setrtc:			EQU	13h
040060             0066*   mos_setintvector:	EQU	14h
040060             0067*   mos_uopen:			EQU	15h
040060             0068*   mos_uclose:			EQU	16h
040060             0069*   mos_ugetc:			EQU	17h
040060             0070*   mos_uputc:			EQU	18h
040060             0071*   mos_getfil:			EQU	19h
040060             0072*   mos_fread:			EQU	1Ah
040060             0073*   mos_fwrite:			EQU	1Bh
040060             0074*   mos_flseek:			EQU	1Ch
040060             0075*   mos_setkbvector:	EQU	1Dh
040060             0076*   mos_getkbmap:		EQU	1Eh
040060             0077*   
040060             0078*   ; MOS program exit codes
040060             0079*   ;
040060             0080*   EXIT_OK:				EQU  0;	"OK",
040060             0081*   EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
040060             0082*   EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
040060             0083*   EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
040060             0084*   EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
040060             0085*   EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
040060             0086*   EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
040060             0087*   EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
040060             0088*   EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
040060             0089*   EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
040060             0090*   EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
040060             0091*   EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
040060             0092*   EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
040060             0093*   EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
040060             0094*   EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
040060             0095*   EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
040060             0096*   EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
040060             0097*   EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
040060             0098*   EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
040060             0099*   EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
040060             0100*   EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
040060             0101*   EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
040060             0102*   ; FatFS file access functions
040060             0103*   ;
040060             0104*   ffs_fopen:			EQU	80h
040060             0105*   ffs_fclose:			EQU	81h
040060             0106*   ffs_fread:			EQU	82h
040060             0107*   ffs_fwrite:			EQU	83h
040060             0108*   ffs_flseek:			EQU	84h
040060             0109*   ffs_ftruncate:		EQU	85h
040060             0110*   ffs_fsync:			EQU	86h
040060             0111*   ffs_fforward:		EQU	87h
040060             0112*   ffs_fexpand:		EQU	88h
040060             0113*   ffs_fgets:			EQU	89h
040060             0114*   ffs_fputc:			EQU	8Ah
040060             0115*   ffs_fputs:			EQU	8Bh
040060             0116*   ffs_fprintf:		EQU	8Ch
040060             0117*   ffs_ftell:			EQU	8Dh
040060             0118*   ffs_feof:			EQU	8Eh
040060             0119*   ffs_fsize:			EQU	8Fh
040060             0120*   ffs_ferror:			EQU	90h
040060             0121*   
040060             0122*   ; FatFS directory access functions
040060             0123*   ;
040060             0124*   ffs_dopen:			EQU	91h
040060             0125*   ffs_dclose:			EQU	92h
040060             0126*   ffs_dread:			EQU	93h
040060             0127*   ffs_dfindfirst:		EQU	94h
040060             0128*   ffs_dfindnext:		EQU	95h
040060             0129*   
040060             0130*   ; FatFS file and directory management functions
040060             0131*   ;
040060             0132*   ffs_stat:			EQU	96h
040060             0133*   ffs_unlink:			EQU	97h
040060             0134*   ffs_rename:			EQU	98h
040060             0135*   ffs_chmod:			EQU	99h
040060             0136*   ffs_utime:			EQU	9Ah
040060             0137*   ffs_mkdir:			EQU	9Bh
040060             0138*   ffs_chdir:			EQU	9Ch
040060             0139*   ffs_chdrive:		EQU	9Dh
040060             0140*   ffs_getcwd:			EQU	9Eh
040060             0141*   
040060             0142*   ; FatFS volume management and system configuration functions
040060             0143*   ;
040060             0144*   ffs_mount:			EQU	9Fh
040060             0145*   ffs_mkfs:			EQU	A0h
040060             0146*   ffs_fdisk:			EQU	A1h
040060             0147*   ffs_getfree:		EQU	A2h
040060             0148*   ffs_getlabel:		EQU	A3h
040060             0149*   ffs_setlabel:		EQU	A4h
040060             0150*   ffs_setcp:			EQU	A5h
040060             0151*   
040060             0152*   ; File access modes
040060             0153*   ;
040060             0154*   fa_read:			EQU	01h
040060             0155*   fa_write:			EQU	02h
040060             0156*   fa_open_existing:	EQU	00h
040060             0157*   fa_create_new:		EQU	04h
040060             0158*   fa_create_always:	EQU	08h
040060             0159*   fa_open_always:		EQU	10h
040060             0160*   fa_open_append:		EQU	30h
040060             0161*   
040060             0162*   ; System variable indexes for api_sysvars
040060             0163*   ; Index into _sysvars in globals.inc
040060             0164*   ;
040060             0165*   sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040060             0166*   sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
040060             0167*   sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040060             0168*   sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
040060             0169*   sysvar_cursorX:			EQU	07h	; 1: Cursor X position
040060             0170*   sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
040060             0171*   sysvar_scrchar:			EQU	09h	; 1: Character read from screen
040060             0172*   sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040060             0173*   sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040060             0174*   sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040060             0175*   sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
040060             0176*   sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
040060             0177*   sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
040060             0178*   sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
040060             0179*   sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
040060             0180*   sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040060             0181*   sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
040060             0182*   sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040060             0183*   sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
040060             0184*   sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
040060             0185*   sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
040060             0186*   sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
040060             0187*   sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
040060             0188*   sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
040060             0189*   sysvar_scrMode:			EQU	27h	; 1: Screen mode
040060             0190*   sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040060             0191*   
040060             0192*   ; Flags for the VPD protocol
040060             0193*   ;
040060             0194*   vdp_pflag_cursor:		EQU	00000001b
040060             0195*   vdp_pflag_scrchar:		EQU	00000010b
040060             0196*   vdp_pflag_point:		EQU	00000100b
040060             0197*   vdp_pflag_audio:		EQU	00001000b
040060             0198*   vdp_pflag_mode:			EQU	00010000b
040060             0199*   vdp_pflag_rtc:			EQU	00100000b
040060             0200*   
040060             0201*   ;
040060             0202*   ; FatFS structures
040060             0203*   ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040060             0204*   ;
040060             0205*   ; Object ID and allocation information (FFOBJID)
040060             0206*   ;
040060             0207*   ; Indexes into FFOBJID structure
040060             0208*   ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
040060             0209*   ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
040060             0210*   ffobjid_attr:		EQU	5	; 1: Object attribute
040060             0211*   ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040060             0212*   ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
040060             0213*   ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
040060             0214*   ;
040060             0215*   ; File object structure (FIL)
040060             0216*   ;
040060             0217*   ; Indexes into FIL structure
040060             0218*   fil_obj:		EQU 0	; 15: Object identifier
040060             0219*   fil_flag:		EQU	15 	;  1: File status flags
040060             0220*   fil_err:		EQU	16	;  1: Abort flag (error code)
040060             0221*   fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
040060             0222*   fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
040060             0223*   fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
040060             0224*   fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
040060             0225*   fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
040060             0226*   ;
040060             0227*   ; Directory object structure (DIR)
040060             0228*   ; Indexes into DIR structure
040060             0229*   dir_obj:		EQU  0	; 15: Object identifier
040060             0230*   dir_dptr:		EQU	15	;  4: Current read/write offset
040060             0231*   dir_clust:		EQU	19	;  4: Current cluster
040060             0232*   dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
040060             0233*   dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
040060             0234*   dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
040060             0235*   dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040060             0236*   ;
040060             0237*   ; File information structure (FILINFO)
040060             0238*   ;
040060             0239*   ; Indexes into FILINFO structure
040060             0240*   filinfo_fsize:		EQU 0	;   4: File size
040060             0241*   filinfo_fdate:		EQU	4	;   2: Modified date
040060             0242*   filinfo_ftime:		EQU	6	;   2: Modified time
040060             0243*   filinfo_fattrib:	EQU	8	;   1: File attribute
040060             0244*   filinfo_altname:	EQU	9	;  13: Alternative file name
040060             0245*   filinfo_fname:		EQU	22	; 256: Primary file name
040060             0246*   filinfo_struct_size: EQU filinfo_fname+256 ; size of the FILINFO structure
040060             0247*   
040060             0248*   ; /* File attribute bits for directory entry (FILINFO.fattrib) */
040060             0249*   AM_RDO: equ 0x01 ; Read only
040060             0250*   AM_HID: equ 0x02 ; Hidden
040060             0251*   AM_SYS: equ 0x04 ; System
040060             0252*   AM_DIR: equ 0x10 ; Directory
040060             0253*   AM_ARC: equ 0x20 ; Archive
040060             0254*   ;
040060             0255*   ; Macro for calling the API
040060             0256*   ; Parameters:
040060             0257*   ; - function: One of the function numbers listed above
040060             0258*   ;
040060             0259*   	MACRO	MOSCALL	function
040060             0260*   			LD	A, function
040060             0261*   			RST.LIL	08h
040060             0262*   	ENDMACRO
040060             0031        include "macros.inc"
040060             0001*   
040060             0002*   ; test the sign of HL
040060             0003*   ; inputs: HL obviously
040060             0004*   ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
040060             0005*   ; destroys: flags
040060             0006*       MACRO SIGN_HLU
040060             0007*       add hl,de ; 1 cycle
040060             0008*       or a ; clear flags ; 1 cycle
040060             0009*       sbc hl,de ; 2 cycles
040060             0010*       ; 4 cycles total
040060             0011*       ENDMACRO
040060             0012*   
040060             0013*   ; put the value in A into HLU
040060             0014*   ; affects: HLU
040060             0015*   ; destroys: nothing
040060             0016*   ; note: $ instead of @@ b/c anon labels deprecated in ez80asm
040060             0017*       MACRO A_TO_HLU
040060             0018*       xor a ; 1 cycle
040060             0019*       ld ($+8+1),hl ; 7 cycles
040060             0020*       ld ($+4+3),a ; 5 cycles
040060             0021*       ld hl,0x000000 ; 4 cycles
040060             0022*       ; 17 cycles total
040060             0023*       ENDMACRO
040060             0024*   
040060             0025*   ; alternative: https://discord.com/channels/1158535358624039014/1282290921815408681/1318315567102300220
040060             0026*   ; one cycle less but burns flags
040060             0027*       MACRO A_TO_HLU_ALT
040060             0028*       push hl ; 4 cycles
040060             0029*       ld hl,2 ; 4 cycles
040060             0030*       add hl,sp ; 1 cycle
040060             0031*       ld (hl),a ; 2 cycles
040060             0032*       pop hl ; 4 cycles
040060             0033*       ; 15 cycles total
040060             0034*       ENDMACRO
040060             0035*   
040060             0036*       MACRO hlu_mul256
040060             0037*       add hl,hl ; * 2
040060             0038*       add hl,hl ; * 4
040060             0039*       add hl,hl ; * 8
040060             0040*       add hl,hl ; * 16
040060             0041*       add hl,hl ; * 32
040060             0042*       add hl,hl ; * 64
040060             0043*       add hl,hl ; * 128
040060             0044*       add hl,hl ; * 256
040060             0045*       ENDMACRO
040060             0046*   
040060             0047*   ; https://discord.com/channels/1158535358624039014/1282290921815408681/1317793870070812715
040060             0048*       MACRO SRL_UHL
040060             0049*       dec sp ; 1 cycle
040060             0050*       push hl ; 4 cycles
040060             0051*       inc sp ; 1 cycle
040060             0052*       pop hl ; 4 cycles
040060             0053*       inc hl ; 1 cycle
040060             0054*       dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
040060             0055*       ; 13 cycles total
040060             0056*       ENDMACRO
040060             0057*   
040060             0058*       MACRO printChar char
040060             0059*       LD A, char
040060             0060*       RST.LIL 10h
040060             0061*       ENDMACRO
040060             0062*   
040060             0063*   ; Simulated call to subroutine at HL
040060             0064*   ; inputs: HL pointing to the subroutine address plus whatever the called function expects
040060             0065*   ; outputs: whatever the subroutine does, including HL and BC
040060             0066*   ; destroys: only what the subroutine does, but always BC
040060             0067*       MACRO CALL_HL
040060             0068*       ld bc,$+6 ; Address of first instruction after the jump
040060             0069*       push bc ; which constitutes the return address
040060             0070*       jp (hl) ; Jump to the address in HL
040060             0071*       ENDMACRO
040060             0072*   
040060             0073*   ; Simulated call to subroutine at IX
040060             0074*   ; inputs: IX pointing to the subroutine address plus whatever the called function expects
040060             0075*   ; outputs: whatever the subroutine does, including IX and BC
040060             0076*   ; destroys: only what the subroutine does, but always BC
040060             0077*       MACRO CALL_IX
040060             0078*       ld bc,$+6 ; Address of first instruction after the jump
040060             0079*       push bc ; which constitutes the return address
040060             0080*       jp (ix) ; Jump to the address in IX
040060             0081*       ENDMACRO
040060             0082*   
040060             0083*   ; Simulated call to soubroutinte at IY
040060             0084*   ; inputs: IY pointing to the subroutine address plus whatever the called function expects
040060             0085*   ; outputs: whatever the subroutine does, including IY and BC
040060             0086*   ; destroys: only what the subroutine does, but always BC
040060             0087*       MACRO CALL_IY
040060             0088*       ld bc,$+6 ; Address of first instruction after the jump
040060             0089*       push bc ; which constitutes the return address
040060             0090*       jp (iy) ; Jump to the address in IY
040060             0091*       ENDMACRO
040060             0092*   
040060             0093*   ; put the value in HLU into A
040060             0094*   ; destroys: af
040060             0095*       MACRO HLU_TO_A
040060             0096*       dec sp ; 1 cycle
040060             0097*       push hl ; 4 cycles
040060             0098*       inc sp ; 1 cycle
040060             0099*       pop af ; 4 cycles
040060             0100*       ; 10 cycles total
040060             0101*       ENDMACRO
040060             0102*   
040060             0103*       MACRO PUSH_ALL
040060             0104*       ex af,af'
040060             0105*       exx
040060             0106*       push af
040060             0107*       push hl
040060             0108*       push bc
040060             0109*       push de
040060             0110*   
040060             0111*       ex af,af'
040060             0112*       exx
040060             0113*       push af
040060             0114*       push hl
040060             0115*       push bc
040060             0116*       push de
040060             0117*       push ix
040060             0118*       push iy
040060             0119*       ENDMACRO
040060             0120*   
040060             0121*       MACRO POP_ALL
040060             0122*       pop iy
040060             0123*       pop ix
040060             0124*       pop de
040060             0125*       pop bc
040060             0126*       pop hl
040060             0127*       pop af
040060             0128*       ex af,af'
040060             0129*       exx
040060             0130*   
040060             0131*       pop de
040060             0132*       pop bc
040060             0133*       pop hl
040060             0134*       pop af
040060             0135*       ex af,af'
040060             0136*       exx
040060             0137*       ENDMACRO
040060             0032        include "functions.inc"
040060             0001*   ; Print a zero-terminated string inline with code, e.g.:
040060             0002*   ;
040060             0003*   ;    call printInline
040060             0004*   ;    ASCIZ "Hello, world!\r\n"
040060             0005*   ;
040060             0006*   ; Destroys: HL,AF
040060             0007*   printInline:
040060 E1          0008*       pop hl ; get the return address = pointer to start of string
040061 CD 67 00 04 0009*       call printString ; HL advances to end of string
040065 E5          0010*       push hl ; restore the return address = pointer to end of string
040066 C9          0011*       ret
040067             0012*   
040067             0013*   ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
040067             0014*   ; Print a zero-terminated string
040067             0015*   ; HL: Pointer to string
040067             0016*   ; returns: hl pointed to character after string terminator
040067             0017*   ; destroys: af, hl
040067             0018*   printString:
040067 C5          0019*       PUSH BC
040068 01 00 00 00 0020*       LD BC,0
04006C 3E 00       0021*       LD A,0
04006E 5B DF       0022*       RST.LIL 18h
040070 C1          0023*       POP BC
040071 C9          0024*       RET
040072             0025*   ; print a VDU sequence
040072             0026*   ; HL: Pointer to VDU sequence - <1 byte length> <data>
040072             0027*   sendVDUsequence:
040072 C5          0028*       PUSH BC
040073 01 00 00 00 0029*       LD BC, 0
040077 4E          0030*       LD C, (HL)
040078 5B DF       0031*       RST.LIL 18h
04007A C1          0032*       POP BC
04007B C9          0033*       RET
04007C             0034*   ; Print Newline sequence to VDP
04007C             0035*   ; destroys: nothing
04007C             0036*   printNewLine:
04007C F5          0037*       push af ; for some reason rst.lil 10h sets carry flag
04007D 3E 0D       0038*       LD A, '\r'
04007F 5B D7       0039*       RST.LIL 10h
040081 3E 0A       0040*       LD A, '\n'
040083 5B D7       0041*       RST.LIL 10h
040085 F1          0042*       pop af
040086 C9          0043*       RET
040087             0044*   
040087             0045*   ; print a zero-terminated string at a graphics coordinate
040087             0046*   ; Inputs: HL Pointer to string, BC,DE x,y position (in pixels)
040087             0047*   printStringGfx:
040087 E5          0048*       push hl ; preserve string pointer
040088             0049*   ; move graphics cursor to x,y location
040088 3E 44       0050*       ld a,plot_pt+mv_abs
04008A CD 50 18 04 0051*       call vdu_plot
04008E             0052*   ; print string
04008E E1          0053*       pop hl ; restore string pointer
04008F             0054*   @print_loop:
04008F 7E          0055*       ld a,(hl)
040090 B7          0056*       or a ; check for end of string
040091 C8          0057*       ret z ; if zero, we're done
040092 08          0058*       ex af,af' ; preserve character
040093 3E 05       0059*       ld a,5 ; VDU 5 char to gfx cursor
040095 5B D7       0060*       rst.lil 10h ; send it
040097 08          0061*       ex af,af' ; restore character
040098 5B D7       0062*       rst.lil 10h ; print character
04009A 23          0063*       inc hl
04009B C3 8F 00 04 0064*       jp @print_loop
04009F C9          0065*       ret
0400A0             0066*   ; end printStringGfx
0400A0             0067*   
0400A0             0068*   ; Print a 24-bit HEX number
0400A0             0069*   ; HLU: Number to print
0400A0             0070*   printHex24:
0400A0             0071*       HLU_TO_A
                       M1 Args: none
0400A0 3B          0001*M1     dec sp ; 1 cycle
0400A1 E5          0002*M1     push hl ; 4 cycles
0400A2 33          0003*M1     inc sp ; 1 cycle
0400A3 F1          0004*M1     pop af ; 4 cycles
0400A4             0005*M1     ; 10 cycles total
0400A4 CD AE 00 04 0072*       CALL printHex8
0400A8             0073*   ; Print a 16-bit HEX number
0400A8             0074*   ; HL: Number to print
0400A8             0075*   printHex16:
0400A8 7C          0076*       LD A,H
0400A9 CD AE 00 04 0077*       CALL printHex8
0400AD 7D          0078*       LD A,L
0400AE             0079*   ; Print an 8-bit HEX number
0400AE             0080*   ; A: Number to print
0400AE             0081*   printHex8:
0400AE 4F          0082*       LD C,A
0400AF 1F          0083*       RRA
0400B0 1F          0084*       RRA
0400B1 1F          0085*       RRA
0400B2 1F          0086*       RRA
0400B3 CD B8 00 04 0087*       CALL @F
0400B7 79          0088*       LD A,C
0400B8             0089*   @@:
0400B8 E6 0F       0090*       AND 0Fh
0400BA C6 90       0091*       ADD A,90h
0400BC 27          0092*       DAA
0400BD CE 40       0093*       ADC A,40h
0400BF 27          0094*       DAA
0400C0 5B D7       0095*       RST.LIL 10h
0400C2 C9          0096*       RET
0400C3             0097*   
0400C3             0098*   ; Print a 0x HEX prefix
0400C3             0099*   DisplayHexPrefix:
0400C3 3E 30       0100*       LD A, '0'
0400C5 5B D7       0101*       RST.LIL 10h
0400C7 3E 78       0102*       LD A, 'x'
0400C9 5B D7       0103*       RST.LIL 10h
0400CB C9          0104*       RET
0400CC             0105*   
0400CC             0106*       MACRO printDecBC
0400CC             0107*       push hl
0400CC             0108*       push bc
0400CC             0109*       pop hl
0400CC             0110*       call printDec
0400CC             0111*       pop hl
0400CC             0112*       ENDMACRO
0400CC             0113*   
0400CC             0114*       MACRO printDecDE
0400CC             0115*       push hl
0400CC             0116*       push de
0400CC             0117*       pop hl
0400CC             0118*       call printDec
0400CC             0119*       pop hl
0400CC             0120*       ENDMACRO
0400CC             0121*   
0400CC             0122*       MACRO printDecHL
0400CC             0123*       call printDec
0400CC             0124*       ENDMACRO
0400CC             0125*   
0400CC             0126*       MACRO printDecIX
0400CC             0127*       push hl
0400CC             0128*       push ix
0400CC             0129*       pop hl
0400CC             0130*       call printDec
0400CC             0131*       pop hl
0400CC             0132*       ENDMACRO
0400CC             0133*   
0400CC             0134*       MACRO printDecIY
0400CC             0135*       push hl
0400CC             0136*       push iy
0400CC             0137*       pop hl
0400CC             0138*       call printDec
0400CC             0139*       pop hl
0400CC             0140*       ENDMACRO
0400CC             0141*   
0400CC             0142*   
0400CC             0143*   ; Prints the right justified decimal value in HL without leading zeroes
0400CC             0144*   ; HL : Value to print
0400CC             0145*   ; preserves all registers and flags
0400CC             0146*   printDec:
0400CC             0147*   ; BEGIN MY CODE
0400CC             0148*   ; back up all the things
0400CC F5          0149*       push af
0400CD C5          0150*       push bc
0400CE D5          0151*       push de
0400CF E5          0152*       push hl
0400D0             0153*   ; END MY CODE
0400D0 11 F8 00 04 0154*       LD DE, _printDecBuffer
0400D4 CD 08 01 04 0155*       CALL u24_to_ascii
0400D8             0156*   ; BEGIN MY CODE
0400D8             0157*   ; replace leading zeroes with spaces
0400D8 21 F8 00 04 0158*       LD HL, _printDecBuffer
0400DC 06 07       0159*       ld B, 7 ; if HL was 0, we want to keep the final zero
0400DE             0160*   @loop:
0400DE 7E          0161*       LD A, (HL)
0400DF FE 30       0162*       CP '0'
0400E1 C2 EB 00 04 0163*       JP NZ, @done
0400E5 3E 20       0164*       LD A, ' '
0400E7 77          0165*       LD (HL), A
0400E8 23          0166*       INC HL
0400E9             0167*       ; CALL vdu_cursor_forward
0400E9 10 F3       0168*       DJNZ @loop
0400EB             0169*   @done:
0400EB             0170*   ; END MY CODE
0400EB 21 F8 00 04 0171*       LD HL, _printDecBuffer
0400EF CD 67 00 04 0172*       CALL printString
0400F3             0173*   ; BEGIN MY CODE
0400F3             0174*   ; restore all the things
0400F3 E1          0175*       pop hl
0400F4 D1          0176*       pop de
0400F5 C1          0177*       pop bc
0400F6 F1          0178*       pop af
0400F7             0179*   ; END MY CODE
0400F7 C9          0180*       RET
0400F8 00 00 00 00 0181*   _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040108             0182*   
040108             0183*   ; This routine converts the unsigned 24-bit value in HLU into its ASCII representation,
040108             0184*   ; starting to memory location pointing by DE, in decimal form and with leading zeroes
040108             0185*   ; so it will allways be 8 characters length
040108             0186*   ; HL : Value to convert to string
040108             0187*   ; DE : pointer to buffer, at least 8 byte + 0
040108             0188*   u24_to_ascii:
040108 01 80 69 67 0189*       LD BC,-10000000
04010C CD 3F 01 04 0190*       CALL one_digit
040110 01 C0 BD F0 0191*       LD BC,-1000000
040114 CD 3F 01 04 0192*       CALL one_digit
040118 01 60 79 FE 0193*       LD BC,-100000
04011C CD 3F 01 04 0194*       CALL one_digit
040120 01 F0 D8 FF 0195*       LD BC,-10000
040124 CD 3F 01 04 0196*       CALL one_digit
040128             0197*   u8_to_ascii: ; same arguments but hl <= 255, uhl and h = 0
040128 01 18 FC FF 0198*       LD BC,-1000
04012C CD 3F 01 04 0199*       CALL one_digit
040130 01 9C FF FF 0200*       LD BC,-100
040134 CD 3F 01 04 0201*       CALL one_digit
040138 0E F6       0202*       LD C,-10
04013A CD 3F 01 04 0203*       CALL one_digit
04013E 48          0204*       LD C,B
04013F             0205*   one_digit:
04013F 3E 2F       0206*       LD A,'0'-1
040141             0207*   @divide_me:
040141 3C          0208*       INC A
040142 09          0209*       ADD HL,BC
040143 38 FC       0210*       JR C,@divide_me
040145 ED 42       0211*       SBC HL,BC
040147 12          0212*       LD (DE),A
040148 13          0213*       INC DE
040149 C9          0214*       RET
04014A             0215*   
04014A             0216*   print_u24:
04014A D5          0217*       push de
04014B E5          0218*       push hl
04014C 11 F8 00 04 0219*       ld de,_printDecBuffer
040150 CD 08 01 04 0220*       call u24_to_ascii
040154 21 F8 00 04 0221*       ld hl,_printDecBuffer
040158 CD 67 00 04 0222*       call printString
04015C 3E 20       0223*       ld a,' '
04015E 5B D7       0224*       rst.lil 10h
040160 E1          0225*       pop hl
040161 D1          0226*       pop de
040162 C9          0227*       ret
040163             0228*   
040163             0229*   ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
040163             0230*   ; HL : Value to convert to string (integer part in H, fractional part in L)
040163             0231*   ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
040163             0232*   u168_to_ascii:
040163             0233*   ; add a leading space to make room for sign flag if needed
040163 3E 20       0234*       ld a,' '
040165 12          0235*       ld (de),a
040166 13          0236*       inc de
040167             0237*   ; Convert integer part
040167 E5          0238*       push hl ; Save HL (we’ll need the fractional part later)
040168             0239*       ; call hlu_udiv256 ; Shift to get integer portion in HL
040168             0240*       SRL_UHL ; Shift to get integer portion in HL
                       M1 Args: none
040168 3B          0001*M1     dec sp ; 1 cycle
040169 E5          0002*M1     push hl ; 4 cycles
04016A 33          0003*M1     inc sp ; 1 cycle
04016B E1          0004*M1     pop hl ; 4 cycles
04016C 23          0005*M1     inc hl ; 1 cycle
04016D 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
04016F             0007*M1     ; 13 cycles total
04016F 01 F0 D8 FF 0241*       ld bc, -10000
040173 CD 96 01 04 0242*       call @one_int
040177 01 18 FC FF 0243*       ld bc, -1000
04017B CD 96 01 04 0244*       call @one_int
04017F 01 9C FF FF 0245*       ld bc, -100
040183 CD 96 01 04 0246*       call @one_int
040187 0E F6       0247*       ld c, -10
040189 CD 96 01 04 0248*       call @one_int
04018D 48          0249*       ld c, b
04018E CD 96 01 04 0250*       call @one_int
040192 C3 A1 01 04 0251*       jp @frac ; Jump to fractional part conversion
040196             0252*   @one_int:
040196 3E 2F       0253*       ld a, '0' - 1 ; Start ASCII character at '0'
040198             0254*   @divide_me:
040198 3C          0255*       inc a
040199 09          0256*       add hl, bc ; Accumulate until overflow
04019A 38 FC       0257*       jr c, @divide_me
04019C ED 42       0258*       sbc hl, bc ; Remove excess after overflow
04019E 12          0259*       ld (de), a ; Store ASCII digit
04019F 13          0260*       inc de
0401A0 C9          0261*       ret
0401A1             0262*   ; Convert fractional part
0401A1             0263*   @frac:
0401A1 3E 2E       0264*       ld a, '.' ; Decimal point
0401A3 12          0265*       ld (de), a
0401A4 13          0266*       inc de
0401A5 E1          0267*       pop hl ; Restore HL with original fraction
0401A6 06 03       0268*       ld b, 3 ; Loop counter for 3 fractional digits
0401A8             0269*   @frac_loop:
0401A8 26 0A       0270*       ld h, 10 ; Load multiplier for fractional part
0401AA ED 6C       0271*       mlt hl ; Multiply by 10, result in HL (H holds the integer part)
0401AC 3E 30       0272*       ld a, '0'
0401AE 84          0273*       add a, h ; Convert integer part to ASCII
0401AF 12          0274*       ld (de), a
0401B0 13          0275*       inc de
0401B1 10 F5       0276*       djnz @frac_loop ; Repeat for each fractional digit
0401B3             0277*   ; Add null terminator
0401B3 AF          0278*       xor a ; Null terminator
0401B4 12          0279*       ld (de), a
0401B5 C9          0280*       ret
0401B6             0281*   
0401B6             0282*   print_u168:
0401B6 D5          0283*       push de
0401B7 E5          0284*       push hl
0401B8 11 F8 00 04 0285*       ld de,_printDecBuffer
0401BC CD 63 01 04 0286*       call u168_to_ascii
0401C0 21 F8 00 04 0287*       ld hl,_printDecBuffer
0401C4 CD 67 00 04 0288*       call printString
0401C8 E1          0289*       pop hl
0401C9 D1          0290*       pop de
0401CA C9          0291*       ret
0401CB             0292*   
0401CB             0293*   ; signed version of u168_to_ascii
0401CB             0294*   s168_to_ascii:
0401CB D5          0295*       push de ; save starting address of buffer
0401CC CD 70 04 04 0296*       call hlu_abs
0401D0 F5          0297*       push af ; save sign flag
0401D1 CD 63 01 04 0298*       call u168_to_ascii
0401D5 F1          0299*       pop af ; restore sign flag
0401D6 D1          0300*       pop de ; restore starting address of buffer
0401D7 F0          0301*       ret p ; hlu was positive so nothing to do
0401D8 3E 2D       0302*       ld a,'-'
0401DA 12          0303*       ld (de),a
0401DB C9          0304*       ret
0401DC             0305*   
0401DC             0306*   print_s168:
0401DC D5          0307*       push de
0401DD E5          0308*       push hl
0401DE 11 F8 00 04 0309*       ld de,_printDecBuffer
0401E2 CD CB 01 04 0310*       call s168_to_ascii
0401E6 21 F8 00 04 0311*       ld hl,_printDecBuffer
0401EA CD 67 00 04 0312*       call printString
0401EE E1          0313*       pop hl
0401EF D1          0314*       pop de
0401F0 C9          0315*       ret
0401F1             0316*   
0401F1             0317*   print_s168_hl:
0401F1 F5          0318*       push af
0401F2 E5          0319*       push hl
0401F3 CD DC 01 04 0320*       call print_s168
0401F7 3E 20       0321*       ld a,' '
0401F9 5B D7       0322*       rst.lil 10h
0401FB E1          0323*       pop hl
0401FC F1          0324*       pop af
0401FD C9          0325*       ret
0401FE             0326*   
0401FE             0327*   print_s168_bc:
0401FE F5          0328*       push af
0401FF C5          0329*       push bc
040200 E5          0330*       push hl
040201 C5          0331*       push bc
040202 E1          0332*       pop hl
040203 CD DC 01 04 0333*       call print_s168
040207 3E 20       0334*       ld a,' '
040209 5B D7       0335*       rst.lil 10h
04020B E1          0336*       pop hl
04020C C1          0337*       pop bc
04020D F1          0338*       pop af
04020E C9          0339*       ret
04020F             0340*   
04020F             0341*   print_s168_de:
04020F F5          0342*       push af
040210 D5          0343*       push de
040211 E5          0344*       push hl
040212 EB          0345*       ex de,hl
040213 CD DC 01 04 0346*       call print_s168
040217 3E 20       0347*       ld a,' '
040219 5B D7       0348*       rst.lil 10h
04021B E1          0349*       pop hl
04021C D1          0350*       pop de
04021D F1          0351*       pop af
04021E C9          0352*       ret
04021F             0353*   
04021F             0354*   print_s168_hl_bc_de:
04021F F5          0355*       push af
040220 C5          0356*       push bc
040221 D5          0357*       push de
040222 E5          0358*       push hl
040223 CD DC 01 04 0359*       call print_s168
040227 3E 20       0360*       ld a,' '
040229 5B D7       0361*       rst.lil 10h
04022B C5          0362*       push bc
04022C E1          0363*       pop hl
04022D CD DC 01 04 0364*       call print_s168
040231 3E 20       0365*       ld a,' '
040233 5B D7       0366*       rst.lil 10h
040235 EB          0367*       ex de,hl
040236 CD DC 01 04 0368*       call print_s168
04023A 3E 20       0369*       ld a,' '
04023C 5B D7       0370*       rst.lil 10h
04023E E1          0371*       pop hl
04023F D1          0372*       pop de
040240 C1          0373*       pop bc
040241 F1          0374*       pop af
040242 C9          0375*       ret
040243             0376*   
040243             0377*   print_s168_bc_de:
040243 F5          0378*       push af
040244 C5          0379*       push bc
040245 D5          0380*       push de
040246 C5          0381*       push bc
040247 E1          0382*       pop hl
040248 CD DC 01 04 0383*       call print_s168
04024C 3E 20       0384*       ld a,' '
04024E 5B D7       0385*       rst.lil 10h
040250 EB          0386*       ex de,hl
040251 CD DC 01 04 0387*       call print_s168
040255 3E 20       0388*       ld a,' '
040257 5B D7       0389*       rst.lil 10h
040259 E1          0390*       pop hl
04025A D1          0391*       pop de
04025B C1          0392*       pop bc
04025C F1          0393*       pop af
04025D C9          0394*       ret
04025E             0395*   
04025E             0396*   print_s168_a:
04025E F5          0397*       push af
04025F C5          0398*       push bc
040260 E5          0399*       push hl
040261 21 00 00 00 0400*       ld hl,0
040265 6F          0401*       ld l,a
040266 CD F1 01 04 0402*       call print_s168_hl
04026A E1          0403*       pop hl
04026B C1          0404*       pop bc
04026C F1          0405*       pop af
04026D C9          0406*       ret
04026E             0407*   
04026E             0408*   ; #### new functions added by Brandon R. Gates ####
04026E             0409*   
04026E             0410*   ; print the binary representation of the 8-bit value in a
04026E             0411*   ; destroys a, hl, bc
04026E             0412*   printBin8:
04026E 06 08       0413*       ld b,8 ; loop counter for 8 bits
040270 21 8B 02 04 0414*       ld hl,@cmd ; set hl to the low byte of the output string
040274             0415*       ; (which will be the high bit of the value in a)
040274             0416*   @loop:
040274 07          0417*       rlca ; put the next highest bit into carry
040275 38 04       0418*       jr c,@one
040277 36 30       0419*       ld (hl),'0'
040279 18 02       0420*       jr @next_bit
04027B             0421*   @one:
04027B 36 31       0422*       ld (hl),'1'
04027D             0423*   @next_bit:
04027D 23          0424*       inc hl
04027E 10 F4       0425*       djnz @loop
040280             0426*   ; print it
040280 21 8B 02 04 0427*       ld hl,@cmd
040284 01 08 00 00 0428*       ld bc,@end-@cmd
040288 5B DF       0429*       rst.lil $18
04028A C9          0430*       ret
04028B             0431*   @cmd: ds 8 ; eight bytes for eight bits
040293             0432*   @end:
040293             0433*   
040293             0434*   ; print the binary representation of the 8-bit value in a
040293             0435*   ; in reverse order (lsb first)
040293             0436*   ; destroys a, hl, bc
040293             0437*   printBin8Rev:
       FF FF FF FF 
       FF FF FF FF 
040293 06 08       0438*       ld b,8 ; loop counter for 8 bits
040295 21 B0 02 04 0439*       ld hl,@cmd ; set hl to the low byte of the output string
040299             0440*       ; (which will be the high bit of the value in a)
040299             0441*   @loop:
040299 0F          0442*       rrca ; put the next lowest bit into carry
04029A 38 04       0443*       jr c,@one
04029C 36 30       0444*       ld (hl),'0'
04029E 18 02       0445*       jr @next_bit
0402A0             0446*   @one:
0402A0 36 31       0447*       ld (hl),'1'
0402A2             0448*   @next_bit:
0402A2 23          0449*       inc hl
0402A3 10 F4       0450*       djnz @loop
0402A5             0451*   ; print it
0402A5 21 B0 02 04 0452*       ld hl,@cmd
0402A9 01 08 00 00 0453*       ld bc,@end-@cmd
0402AD 5B DF       0454*       rst.lil $18
0402AF C9          0455*       ret
0402B0             0456*   @cmd: ds 8 ; eight bytes for eight bits
0402B8             0457*   @end:
0402B8             0458*   
       FF FF FF FF 
       FF FF FF FF 
0402B8 20 61 66 3D 0459*   str_afu: db " af=",0
       00          
0402BD 20 68 6C 3D 0460*   str_hlu: db " hl=",0
       00          
0402C2 20 62 63 3D 0461*   str_bcu: db " bc=",0
       00          
0402C7 20 64 65 3D 0462*   str_deu: db " de=",0
       00          
0402CC 20 69 78 3D 0463*   str_ixu: db " ix=",0
       00          
0402D1 20 69 79 3D 0464*   str_iyu: db " iy=",0
       00          
0402D6             0465*   
0402D6             0466*   ; print udeuhl to screen in hexidecimal format
0402D6             0467*   ; inputs: none
0402D6             0468*   ; outputs: concatenated hexidecimal udeuhl
0402D6             0469*   ; destroys: nothing
0402D6             0470*   dumpUDEUHLHex:
0402D6             0471*   ; store everything in scratch
0402D6 22 35 03 04 0472*       ld (uhl),hl
0402DA ED 43 38 03 0473*       ld (ubc),bc
       04          
0402DF ED 53 3B 03 0474*       ld (ude),de
       04          
0402E4 DD 22 3E 03 0475*       ld (uix),ix
       04          
0402E9 FD 22 41 03 0476*       ld (uiy),iy
       04          
0402EE F5          0477*       push af
0402EF             0478*   
0402EF             0479*   ; print each register
0402EF             0480*   
0402EF 21 29 03 04 0481*       ld hl,str_udeuhl
0402F3 CD 67 00 04 0482*       call printString
0402F7 2A 3B 03 04 0483*       ld hl,(ude)
0402FB CD A0 00 04 0484*       call printHex24
0402FF 3E 2E       0485*       ld a,'.' ; print a dot to separate the values
040301 5B D7       0486*       rst.lil 10h
040303 2A 35 03 04 0487*       ld hl,(uhl)
040307 CD A0 00 04 0488*       call printHex24
04030B CD 7C 00 04 0489*       call printNewLine
04030F             0490*   
04030F             0491*   ; restore everything
04030F 2A 35 03 04 0492*       ld hl, (uhl)
040313 ED 4B 38 03 0493*       ld bc, (ubc)
       04          
040318 ED 5B 3B 03 0494*       ld de, (ude)
       04          
04031D DD 2A 3E 03 0495*       ld ix, (uix)
       04          
040322 FD 2A 41 03 0496*       ld iy, (uiy)
       04          
040327 F1          0497*       pop af
040328             0498*   ; all done
040328 C9          0499*       ret
040329             0500*   
040329 75 64 65 2E 0501*   str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
040332             0502*   
040332             0503*   ; global scratch memory for registers
040332 00 00 00    0504*   uaf: dl 0
040335 00 00 00    0505*   uhl: dl 0
040338 00 00 00    0506*   ubc: dl 0
04033B 00 00 00    0507*   ude: dl 0
04033E 00 00 00    0508*   uix: dl 0
040341 00 00 00    0509*   uiy: dl 0
040344 00 00 00    0510*   usp: dl 0
040347 00 00 00    0511*   upc: dl 0
04034A             0512*   
04034A             0513*   
04034A             0514*   ; set all the bits in the flag register
04034A             0515*   ; more of an academic exercise than anything useful
04034A             0516*   ; inputs; none
04034A             0517*   ; outputs; a=0,f=255
04034A             0518*   ; destroys: flags, hl
04034A             0519*   ; preserves: a, because why not
04034A             0520*   setAllFlags:
04034A 21 FF 00 00 0521*       ld hl,255
04034E 67          0522*       ld h,a ; four cycles to preserve a is cheap
04034F E5          0523*       push hl
040350 F1          0524*       pop af
040351 C9          0525*       ret
040352             0526*   
040352             0527*   ; reset all the bits in the flag register
040352             0528*   ; unlike its inverse counterpart, this may actually be useful
040352             0529*   ; inputs; none
040352             0530*   ; outputs; a=0,f=0
040352             0531*   ; destroys: flags, hl
040352             0532*   ; preserves: a, because why not
040352             0533*   resetAllFlags:
040352 21 00 00 00 0534*       ld hl,0
040356 67          0535*       ld h,a ; four cycles to preserve a is cheap
040357 E5          0536*       push hl
040358 F1          0537*       pop af
040359 C9          0538*       ret
04035A             0539*   
04035A             0540*   ; wait until user presses a key
04035A             0541*   ; inputs: none
04035A             0542*   ; outputs: ascii code of key pressed in a
04035A             0543*   ; destroys: af,ix
04035A             0544*   waitKeypress:
04035A             0545*       MOSCALL mos_getkey
                       M1 Args: function=mos_getkey 
04035A 3E 00       0001*M1 			LD	A, function
04035C 5B CF       0002*M1 			RST.LIL	08h
04035E C9          0546*       ret
04035F             0547*   
04035F             0548*   ; clear a block of memory by writing a prescribed value to each byte in the range
04035F             0549*   ; inputs: a = value to write, hl = address of first byte, bc = number of bytes
04035F             0550*   ; outputs: memory block is cleared
04035F             0551*   ; destroys: hl, de
04035F             0552*   clear_mem:
04035F 0B          0553*       dec bc ; we do this because we will increment de before writing the first byte
040360 77          0554*       ld (hl),a
040361 E5          0555*       push hl
040362 D1          0556*       pop de
040363 13          0557*       inc de ; target address
040364 ED B0       0558*       ldir
040366 C9          0559*       ret
040367             0033        include "arith24.inc"
040367             0001*   ;------------------------------------------------------------------------
040367             0002*   ;  arith24.asm
040367             0003*   ;  24-bit ez80 arithmetic routines
040367             0004*   ;  Copyright (c) Shawn Sijnstra 2024
040367             0005*   ;  MIT license
040367             0006*   ;
040367             0007*   ;  This library was created as a tool to help make ez80
040367             0008*   ;  24-bit native assembly routines for simple mathematical problems
040367             0009*   ;  more widely available.
040367             0010*   ;
040367             0011*   ;------------------------------------------------------------------------
040367             0012*   
040367             0013*   ;------------------------------------------------------------------------
040367             0014*   ; umul24:	HL = HL*DE (unsigned)
040367             0015*   ; Preserves AF, BC, DE
040367             0016*   ; Uses a fast multiply routine.
040367             0017*   ;------------------------------------------------------------------------
040367             0018*   umul24:
040367 D5          0019*   	push	DE
040368 C5          0020*   	push	BC
040369 F5          0021*   	push	AF
04036A E5          0022*   	push	HL
04036B C1          0023*   	pop		BC
04036C 3E 18       0024*       ld	 	a, 24 ; No. of bits to process
04036E 21 00 00 00 0025*       ld	 	hl, 0 ; Result
040372             0026*   umul24_lp:
040372 29          0027*   	add	hl,hl
040373 EB          0028*   	ex	de,hl
040374 29          0029*   	add	hl,hl
040375 EB          0030*   	ex	de,hl
040376 30 01       0031*   	jr	nc,umul24_nc
040378 09          0032*   	add	hl,bc
040379             0033*   umul24_nc:
040379 3D          0034*   	dec	a
04037A 20 F6       0035*   	jr	nz,umul24_lp
04037C F1          0036*   	pop	af
04037D C1          0037*   	pop	bc
04037E D1          0038*   	pop	de
04037F C9          0039*   	ret
040380             0040*   
040380             0041*   
040380             0042*   ;------------------------------------------------------------------------
040380             0043*   ; udiv24
040380             0044*   ; Unsigned 24-bit division
040380             0045*   ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
040380             0046*   ;
040380             0047*   ; Uses AF BC DE HL
040380             0048*   ; Uses Restoring Division algorithm
040380             0049*   ;------------------------------------------------------------------------
040380             0050*   
040380             0051*   udiv24:
040380 E5          0052*   	push	hl
040381 C1          0053*   	pop		bc	;move dividend to BCU
040382 21 00 00 00 0054*   	ld		hl,0	;result
040386 A7          0055*   	and		a
040387 ED 52       0056*   	sbc		hl,de	;test for div by 0
040389 C8          0057*   	ret		z		;it's zero, carry flag is clear
04038A 19          0058*   	add		hl,de	;HL is 0 again
04038B 3E 18       0059*   	ld		a,24	;number of loops through.
04038D             0060*   udiv1:
04038D C5          0061*   	push	bc	;complicated way of doing this because of lack of access to top bits
04038E E3          0062*   	ex		(sp),hl
04038F 37          0063*   	scf
040390 ED 6A       0064*   	adc	hl,hl
040392 E3          0065*   	ex	(sp),hl
040393 C1          0066*   	pop	bc		;we now have bc = (bc * 2) + 1
040394             0067*   
040394 ED 6A       0068*   	adc	hl,hl
040396 A7          0069*   	and	a		;is this the bug
040397 ED 52       0070*   	sbc	hl,de
040399 30 02       0071*   	jr	nc,udiv2
04039B 19          0072*   	add	hl,de
04039C             0073*   ;	dec	c
04039C 0B          0074*   	dec	bc
04039D             0075*   udiv2:
04039D 3D          0076*   	dec	a
04039E 20 ED       0077*   	jr	nz,udiv1
0403A0 37          0078*   	scf		;flag used for div0 error
0403A1 C5          0079*   	push	bc
0403A2 D1          0080*   	pop		de	;remainder
0403A3 C9          0081*   	ret
0403A4             0082*   
0403A4             0083*   
0403A4             0084*   
0403A4             0085*   ;------------------------------------------------------------------------
0403A4             0086*   ; neg24
0403A4             0087*   ; Returns: HLU = 0-HLU
0403A4             0088*   ; preserves all other registers
0403A4             0089*   ;------------------------------------------------------------------------
0403A4             0090*   neg24:
0403A4 D5          0091*   	push	de
0403A5 EB          0092*   	ex		de,hl
0403A6 21 00 00 00 0093*   	ld		hl,0
0403AA B7          0094*   	or		a
0403AB ED 52       0095*   	sbc		hl,de
0403AD D1          0096*   	pop		de
0403AE C9          0097*   	ret
0403AF             0098*   
0403AF             0099*   ;------------------------------------------------------------------------
0403AF             0100*   ; or_hlu_deu: 24 bit bitwise OR
0403AF             0101*   ; Returns: hlu = hlu OR deu
0403AF             0102*   ; preserves all other registers
0403AF             0103*   ;------------------------------------------------------------------------
0403AF             0104*   or_hlu_deu:
0403AF 22 38 04 04 0105*   	ld	(bitbuf1),hl
0403B3 ED 53 3B 04 0106*   	ld	(bitbuf2),de
       04          
0403B8 D5          0107*   	push	de	;preserve DEU
0403B9 C5          0108*   	push	bc	;preserve BCU
0403BA 06 03       0109*   	ld		b,3
0403BC 21 38 04 04 0110*   	ld	hl,bitbuf1
0403C0 11 38 04 04 0111*   	ld	de,bitbuf1
0403C4             0112*   orloop_24:
0403C4 1A          0113*   	ld	a,(de)
0403C5 B6          0114*   	or	(hl)
0403C6 12          0115*   	ld	(de),a
0403C7 13          0116*   	inc	de
0403C8 23          0117*   	inc	hl
0403C9 10 F9       0118*   	djnz	orloop_24
0403CB 2A 3B 04 04 0119*   	ld	hl,(bitbuf2)
0403CF C1          0120*   	pop		bc	;restore BC
0403D0 D1          0121*   	pop		de	;restore DE
0403D1             0122*   
0403D1             0123*   ;------------------------------------------------------------------------
0403D1             0124*   ; and_hlu_deu: 24 bit bitwise AND
0403D1             0125*   ; Returns: hlu = hlu AND deu
0403D1             0126*   ; preserves all other registers
0403D1             0127*   ;------------------------------------------------------------------------
0403D1             0128*   and_hlu_deu:
0403D1 22 38 04 04 0129*   	ld	(bitbuf1),hl
0403D5 ED 53 3B 04 0130*   	ld	(bitbuf2),de
       04          
0403DA D5          0131*   	push	de	;preserve DEU
0403DB C5          0132*   	push	bc	;preserve BCU
0403DC 06 03       0133*   	ld		b,3
0403DE 21 38 04 04 0134*   	ld	hl,bitbuf1
0403E2 11 38 04 04 0135*   	ld	de,bitbuf1
0403E6             0136*   andloop_24:
0403E6 1A          0137*   	ld	a,(de)
0403E7 A6          0138*   	and	(hl)
0403E8 12          0139*   	ld	(de),a
0403E9 13          0140*   	inc	de
0403EA 23          0141*   	inc	hl
0403EB 10 F9       0142*   	djnz	andloop_24
0403ED 2A 3B 04 04 0143*   	ld	hl,(bitbuf2)
0403F1 C1          0144*   	pop		bc	;restore BC
0403F2 D1          0145*   	pop		de	;restore DE
0403F3             0146*   
0403F3             0147*   ;------------------------------------------------------------------------
0403F3             0148*   ; xor_hlu_deu: 24 bit bitwise XOR
0403F3             0149*   ; Returns: hlu = hlu XOR deu
0403F3             0150*   ; preserves all other registers
0403F3             0151*   ;------------------------------------------------------------------------
0403F3             0152*   xor_hlu_deu:
0403F3 22 38 04 04 0153*   	ld	(bitbuf1),hl
0403F7 ED 53 3B 04 0154*   	ld	(bitbuf2),de
       04          
0403FC D5          0155*   	push	de	;preserve DEU
0403FD C5          0156*   	push	bc	;preserve BCU
0403FE 06 03       0157*   	ld		b,3
040400 21 38 04 04 0158*   	ld	hl,bitbuf1
040404 11 38 04 04 0159*   	ld	de,bitbuf1
040408             0160*   xorloop_24:
040408 1A          0161*   	ld	a,(de)
040409 AE          0162*   	xor	(hl)
04040A 12          0163*   	ld	(de),a
04040B 13          0164*   	inc	de
04040C 23          0165*   	inc	hl
04040D 10 F9       0166*   	djnz	xorloop_24
04040F 2A 3B 04 04 0167*   	ld	hl,(bitbuf2)
040413 C1          0168*   	pop		bc	;restore BC
040414 D1          0169*   	pop		de	;restore DE
040415             0170*   
040415             0171*   ;------------------------------------------------------------------------
040415             0172*   ; shl_hlu: 24 bit shift left hlu by a positions
040415             0173*   ; Returns: hlu = hlu << a
040415             0174*   ;		   a = 0
040415             0175*   ; NOTE: only considers a up to 16 bits.
040415             0176*   ; preserves all other registers
040415             0177*   ; modified by Brandon R. Gates to use a instead of de
040415             0178*   ;------------------------------------------------------------------------
040415             0179*   shl_hlu:
040415 B7          0180*   	or a
040416 C8          0181*   	ret		z		;we're done
040417 29          0182*   	add		hl,hl	;shift HLU left
040418 3D          0183*   	dec a
040419 18 FA       0184*   	jr		shl_hlu
04041B             0185*   
04041B             0186*   ;------------------------------------------------------------------------
04041B             0187*   ; shr_hlu: 24 bit shift right hlu by a positions
04041B             0188*   ; Returns: hlu = hlu >> a
04041B             0189*   ;		   a = 0
04041B             0190*   ; NOTE: only considers a up to 16 bits.
04041B             0191*   ; preserves all other registers
04041B             0192*   ; modified by Brandon R. Gates to use a instead of de
04041B             0193*   ;------------------------------------------------------------------------
04041B             0194*   shr_hlu:
04041B 22 38 04 04 0195*   	ld		(bitbuf1),hl
04041F 21 3A 04 04 0196*   	ld		hl,bitbuf1+2
040423             0197*   @shr_loop:
040423 B7          0198*   	or a
040424 28 0D       0199*   	jr		z,@shr_done		;we're done
040426             0200*   ;carry is clear from or instruction
040426 CB 1E       0201*   	rr		(hl)
040428 2B          0202*   	dec		hl
040429 CB 1E       0203*   	rr		(hl)
04042B 2B          0204*   	dec		hl
04042C CB 1E       0205*   	rr		(hl)
04042E 23          0206*   	inc		hl
04042F 23          0207*   	inc		hl
040430 3D          0208*   	dec a
040431 18 F0       0209*   	jr		@shr_loop
040433             0210*   @shr_done:
040433 2A 38 04 04 0211*   	ld		hl,(bitbuf1)	;collect result
040437 C9          0212*   	ret
040438             0213*   
040438             0214*   ;------------------------------------------------------------------------
040438             0215*   ; Scratch area for calculations
040438             0216*   ;------------------------------------------------------------------------
040438 00 00 00    0217*   bitbuf1:	dw24	0	;bit manipulation buffer 1
04043B 00 00 00    0218*   bitbuf2:	dw24	0	;bit manipulation buffer 2
04043E             0219*   
04043E             0220*   ; -----------------------------------------------------------------------
04043E             0221*   ; Functions added by Brandon R. Gates
04043E             0222*   ; -----------------------------------------------------------------------
04043E             0223*   
04043E             0224*   ;------------------------------------------------------------------------
04043E             0225*   ; shr_hlu_div: Quick division by powers of two based on log2 of A
04043E             0226*   ;              Determines the LSB of A and shifts HLU accordingly.
04043E             0227*   ;              HLU = HLU >> LSB(A)
04043E             0228*   ; Returns: HLU = HLU >> LSB(A)
04043E             0229*   ; Destroys: af
04043E             0230*   ;------------------------------------------------------------------------
04043E             0231*   shr_hlu_log2a:
04043E B7          0232*   	or a    ; check for zero
04043F C8          0233*   	ret z   ; nothing to shift so we're done
040440 C5          0234*   	push 	bc ; preserve
040441 06 00       0235*   	ld		b,0 ; clear b
040443             0236*   @find_bit:
040443 0F          0237*   	rrca ; bit 0 to carry
040444 DA 4D 04 04 0238*   	jp c,@found_bit
040448 04          0239*   	inc b ; next bit
040449 C3 43 04 04 0240*   	jp @find_bit
04044D             0241*   @found_bit:
04044D 78          0242*   	ld a,b
04044E CD 1B 04 04 0243*   	call shr_hlu
040452 C1          0244*   	pop 	bc ; restore
040453 C9          0245*   	ret
040454             0246*   ; end shr_hlu_log2a
040454             0247*   
040454             0248*   ;------------------------------------------------------------------------
040454             0249*   ; shl_hlu_log2a: Quick multiplication by powers of two based on log2 of A
040454             0250*   ;                Determines the LSB of A and shifts HLU accordingly.
040454             0251*   ;                HLU = HLU << LSB(A)
040454             0252*   ; Returns: HLU = HLU << LSB(A)
040454             0253*   ; Destroys: af
040454             0254*   ;------------------------------------------------------------------------
040454             0255*   shl_hlu_log2a:
040454 B7          0256*   	or a    ; check for zero
040455 C8          0257*   	ret z   ; nothing to shift so we're done
040456 C5          0258*   	push 	bc ; preserve
040457 06 00       0259*   	ld		b,0 ; clear b
040459             0260*   @find_bit:
040459 0F          0261*   	rrca ; bit 0 to carry
04045A DA 63 04 04 0262*   	jp c,@found_bit
04045E 04          0263*   	inc b ; next bit
04045F C3 59 04 04 0264*   	jp @find_bit
040463             0265*   @found_bit:
040463 78          0266*   	ld a,b
040464 CD 15 04 04 0267*   	call shl_hlu
040468 C1          0268*   	pop 	bc ; restore
040469 C9          0269*   	ret
04046A             0270*   ; end shl_hlu_log2a
04046A             0034        include "maths.inc"
04046A             0001*   ;------------------------------------------------------------------------
04046A             0002*   ; Scratch area for calculations
04046A             0003*   ;------------------------------------------------------------------------
04046A 00 00 00    0004*   scratch1: dw24 0 ;bit manipulation buffer 1
04046D 00 00 00    0005*   scratch2: dw24 0 ;bit manipulation buffer 2
040470             0006*   
040470             0007*   ; absolute value of hlu
040470             0008*   ; returns: abs(hlu), flags set according to the incoming sign of hlu:
040470             0009*   ;         s1,z0,pv0,n1,c0 if hlu was negative
040470             0010*   ;         s0,z1,pv0,n1,c0 if hlu was zero
040470             0011*   ;         s0,z0,pv0,n1,c0 if hlu was positive
040470             0012*   ; destroys: a
040470             0013*   hlu_abs:
040470 19          0014*       add hl,de
040471 B7          0015*       or a
040472 ED 52       0016*       sbc hl,de
040474 FA 79 04 04 0017*       jp m,@is_neg
040478 C9          0018*       ret ; hlu is positive or zero so we're done
040479             0019*   @is_neg:
040479 F5          0020*       push af ; otherwise, save current flags for return
04047A CD 80 04 04 0021*       call neg_hlu ; negate hlu
04047E F1          0022*       pop af ; get back flags
04047F C9          0023*       ret
040480             0024*   
040480             0025*   ; flip the sign of hlu
040480             0026*   ; inputs: hlu
040480             0027*   ; returns: 0-hlu, flags set appropriately for the result:
040480             0028*   ;         s1,z0,pv0,n1,c1 if result is negative
040480             0029*   ;         s0,z1,pv0,n1,c0 if result is zero
040480             0030*   ;         s0,z0,pv0,n1,c1 if result is positive
040480             0031*   ; destroys a
040480             0032*   neg_hlu:
040480 D5          0033*       push de ; save de
040481 EB          0034*       ex de,hl ; put hl into de
040482 21 00 00 00 0035*       ld hl,0 ; clear hl
040486 AF          0036*       xor a ; clear carry
040487 ED 52       0037*       sbc hl,de ; 0-hlu = -hlu
040489 D1          0038*       pop de ; get de back
04048A C9          0039*       ret ; easy peasy
04048B             0040*   
04048B             0041*   ;------------------------------------------------------------------------
04048B             0042*   ; divide hlu by 2, inspired by above
04048B             0043*   ;------------------------------------------------------------------------
04048B             0044*   hlu_div2:
04048B 22 6A 04 04 0045*       ld (scratch1),hl
04048F 21 6C 04 04 0046*       ld hl,scratch1+2
040493 CB 1E       0047*       rr (hl)
040495 2B          0048*       dec hl
040496 CB 1E       0049*       rr (hl)
040498 2B          0050*       dec hl
040499 CB 1E       0051*       rr (hl)
04049B 23          0052*       inc hl
04049C 23          0053*       inc hl
04049D 2A 6A 04 04 0054*       ld hl,(scratch1)
0404A1 C9          0055*       ret
0404A2             0056*   
0404A2             0057*   ; this is my little hack to divide by 16
0404A2             0058*   hlu_div16:
0404A2 AF          0059*       xor a
0404A3 29          0060*       add hl,hl
0404A4 17          0061*       rla
0404A5 29          0062*       add hl,hl
0404A6 17          0063*       rla
0404A7 29          0064*       add hl,hl
0404A8 17          0065*       rla
0404A9 29          0066*       add hl,hl
0404AA 17          0067*       rla
0404AB 22 B8 04 04 0068*       ld (@scratch),hl
0404AF 32 BB 04 04 0069*       ld (@scratch+3),a
0404B3 2A B9 04 04 0070*       ld hl,(@scratch+1)
0404B7 C9          0071*       ret
0404B8             0072*   @scratch: ds 4
0404BC             0073*   
0404BC             0074*   ; hlu signed division by 256
0404BC             0075*   ; returns: hlu / 256
0404BC             0076*   ; destroys: af
0404BC             0077*   hlu_sdiv256:
       FF FF FF FF 
0404BC AF          0078*       xor a ; assume hl is positive
0404BD 22 D3 04 04 0079*       ld (@buffer),hl
0404C1             0080*       SIGN_HLU
                       M1 Args: none
0404C1 19          0001*M1     add hl,de ; 1 cycle
0404C2 B7          0002*M1     or a ; clear flags ; 1 cycle
0404C3 ED 52       0003*M1     sbc hl,de ; 2 cycles
0404C5             0004*M1     ; 4 cycles total
0404C5 F2 CA 04 04 0081*       jp p,@hl_pos
0404C9 3D          0082*       dec a
0404CA             0083*   @hl_pos:
0404CA 32 D6 04 04 0084*       ld (@buffer+3),a
0404CE 2A D4 04 04 0085*       ld hl,(@buffer+1)
0404D2 C9          0086*       ret
0404D3             0087*   @buffer: ds 4
0404D7             0088*   
0404D7             0089*   ; hlu 1 byte right shift, unsigned
0404D7             0090*   ; returns: hlu / 256, fractional portion in a
0404D7             0091*   ; destroys: af
0404D7             0092*   hlu_udiv256:
       FF FF FF FF 
0404D7 AF          0093*       xor a
0404D8 32 E9 04 04 0094*       ld (@buffer+3),a
0404DC 7D          0095*       ld a,l ; save the fractional portion
0404DD 22 E6 04 04 0096*       ld (@buffer),hl
0404E1 2A E7 04 04 0097*       ld hl,(@buffer+1)
0404E5 C9          0098*       ret
0404E6             0099*   @buffer: ds 4
0404EA             0100*   
0404EA             0101*   ; floor(value,n)
0404EA             0102*   ; inputs: hl = value to floor, de = n
0404EA             0103*   ; outputs: hl = value floored to n
0404EA             0104*   ; destroys: af, hl, bc, de
0404EA             0105*   hlu_floor:
       FF FF FF FF 
0404EA D5          0106*       push de ; save n
0404EB CD 80 03 04 0107*       call udiv24 ; de = quotient, hl = remainder
0404EF E1          0108*       pop hl ; get n back (was de)
0404F0 CD 67 03 04 0109*       call umul24 ; hl = n * quotient
0404F4 C9          0110*       ret
0404F5             0111*   ; end hlu_floor
0404F5             0112*   
0404F5             0113*   ; ceil(value,n)
0404F5             0114*   ; inputs: hl = value to ceil, de = n
0404F5             0115*   ; outputs: hl = value ceiled to n
0404F5             0116*   ; destroys: af, hl, bc, de
0404F5             0117*   hlu_ceiling:
0404F5 D5          0118*       push de ; save n
0404F6 CD 80 03 04 0119*       call udiv24 ; de = quotient, hl = remainder
0404FA             0120*       SIGN_HLU ; test remaider for zero
                       M1 Args: none
0404FA 19          0001*M1     add hl,de ; 1 cycle
0404FB B7          0002*M1     or a ; clear flags ; 1 cycle
0404FC ED 52       0003*M1     sbc hl,de ; 2 cycles
0404FE             0004*M1     ; 4 cycles total
0404FE CA 03 05 04 0121*       jp z,@F ; if zero, nothing to add
040502 13          0122*       inc de ; add 1 to quotient for the ceiling
040503             0123*   @@:
040503 E1          0124*       pop hl ; get n back (was de)
040504 CD 67 03 04 0125*       call umul24 ; hl = n * quotient
040508 C9          0126*       ret
040509             0127*   ; end hlu_ceiling
040509             0128*   
040509 C9          0129*       ret
04050A             0130*   
04050A 00 00 00 00 0131*   add_bcd_arg1: db #00,#00,#00,#00
04050E 00 00 00 00 0132*   add_bcd_arg2: db #00,#00,#00,#00
040512             0133*   
040512             0134*   ; set bcd values in a scratch memory address from registers bcde
040512             0135*   ; input: hl; scratch address,bcde; 8-place bcd number
040512             0136*   ; destroys ; hl
040512             0137*   set_bcd:
040512 73          0138*       ld (hl),e
040513 23          0139*       inc hl
040514 72          0140*       ld (hl),d
040515 23          0141*       inc hl
040516 71          0142*       ld (hl),c
040517 23          0143*       inc hl
040518 70          0144*       ld (hl),b
040519 C9          0145*       ret
04051A             0146*   
04051A             0147*   ; load bcd values from a scratch memory address to bcde
04051A             0148*   ; input: hl; scratch address
04051A             0149*   ; output: bcde; 8-place bcd number
04051A             0150*   ; destroys: hl
04051A             0151*   get_bcd:
04051A 5E          0152*       ld e,(hl)
04051B 23          0153*       inc hl
04051C 56          0154*       ld d,(hl)
04051D 23          0155*       inc hl
04051E 4E          0156*       ld c,(hl)
04051F 23          0157*       inc hl
040520 46          0158*       ld b,(hl)
040521 C9          0159*       ret
040522             0160*   
040522             0161*   ; BCD addition
040522             0162*   ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
040522             0163*   ;       a is the number of bytes holding each number (number of places/2)
040522             0164*   ; outputs: (hl) + (de) --> (hl)
040522             0165*   ; destroys: a,b,de,hl
040522             0166*   add_bcd:
040522 47          0167*       ld b,a ; loop counter
040523 AF          0168*       xor a ; reset a, clear carry flag
040524             0169*   adcec:
040524 1A          0170*       ld a,(de) ; addend to acc
040525 8E          0171*       adc a,(hl) ; add (hl) to acc
040526 27          0172*       daa ; adjust result to bcd
040527 77          0173*       ld (hl),a ; store result
040528 23          0174*       inc hl ; advance memory pointers
040529 13          0175*       inc de
04052A 10 F8       0176*       djnz adcec ; loop until b == 0
04052C C9          0177*       ret
04052D             0178*   
04052D             0179*   ; BCD subtraction
04052D             0180*   ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
04052D             0181*   ;       a is the number of bytes holding each number (number of places/2)
04052D             0182*   ; outputs: (hl) - (de) --> (hl)
04052D             0183*   ; destroys: a,b,de,hl
04052D             0184*   sub_bcd:
04052D 47          0185*       ld b,a ; loop counter
04052E AF          0186*       xor a ; reset a,clear carry flag
04052F             0187*   subdec:
04052F 1A          0188*       ld a,(de) ; subtrahend to acc
040530 9E          0189*       sbc a,(hl) ; subtract (hl) from acc
040531 27          0190*       daa ; adjust result to bcd
040532 77          0191*       ld (hl),a ; store result
040533 23          0192*       inc hl ; advance memory pointers
040534 13          0193*       inc de
040535 10 F8       0194*       djnz subdec ; loop until b == 0
040537 C9          0195*       ret
040538             0196*   
040538             0197*   ; http://www.z80.info/pseudo-random.txt
040538             0198*   rand_8:
040538 C5          0199*       push bc
040539 3A 4C 05 04 0200*       ld a,(r_seed)
04053D 4F          0201*       ld c,a
04053E             0202*   
04053E 0F          0203*       rrca ; multiply by 32
04053F 0F          0204*       rrca
040540 0F          0205*       rrca
040541 EE 1F       0206*       xor 0x1f
040543             0207*   
040543 81          0208*       add a,c
040544 DE FF       0209*       sbc a,255 ; carry
040546             0210*   
040546 32 4C 05 04 0211*       ld (r_seed),a
04054A C1          0212*       pop bc
04054B C9          0213*       ret
04054C 50          0214*   r_seed: defb $50
04054D             0215*   
04054D             0216*   ; https://www.omnimaga.org/asm-language/ez80-optimized-routines/msg399325/#msg399325
04054D             0217*   prng24:
04054D             0218*   ;;Expects ADL mode.
04054D             0219*   ;;Output: HL
04054D             0220*   ;;50cc
04054D             0221*   ;;33 bytes
04054D             0222*   ;;cycle length: 281,474,959,933,440 (about 2.8 trillion)
04054D ED 5B 6E 05 0223*       ld de,(seed1)
       04          
040552 B7          0224*       or a
040553 ED 62       0225*       sbc hl,hl
040555 19          0226*       add hl,de
040556 29          0227*       add hl,hl
040557 29          0228*       add hl,hl
040558 2C          0229*       inc l
040559 19          0230*       add hl,de
04055A 22 6E 05 04 0231*       ld (seed1),hl
04055E 2A 71 05 04 0232*       ld hl,(seed2)
040562 29          0233*       add hl,hl
040563 9F          0234*       sbc a,a
040564 E6 1B       0235*       and %00011011
040566 AD          0236*       xor l
040567 6F          0237*       ld l,a
040568 22 71 05 04 0238*       ld (seed2),hl
04056C 19          0239*       add hl,de
04056D C9          0240*       ret
04056E 00 00 00    0241*   seed1: dl 0
040571 00 00 00    0242*   seed2: dl 0
040574             0243*   
040574             0244*   
040574             0245*   ; https://map.grauw.nl/sources/external/z80bits.html#2.1
040574             0246*   ; 2.1 Restoring 8-bit / 8-bit Unsigned
040574             0247*   ; Input: H = Dividend, L = Divisor, A = 0
040574             0248*   ; Output: H = Quotient, A = Remainder, L = Divisor (unchanged)
040574             0249*   udiv8:
040574 AF          0250*       xor a
040575 06 08       0251*       ld b,8
040577             0252*   @loop:
040577 CB 24       0253*       sla h
040579 17          0254*       rla
04057A BD          0255*       cp l
04057B 38 02       0256*       jr c,$+4
04057D 95          0257*       sub l
04057E 24          0258*       inc h
04057F 10 F6       0259*       djnz @loop
040581 C9          0260*       ret
040582             0261*   
040582             0262*   ; https://www.omnimaga.org/asm-language/(z80)-32-bit-by-16-bits-division-and-32-bit-square-root/msg406903/#msg406903
040582             0263*   ; This divides HLIX by BC
040582             0264*   ; The result is stored in HLIX, the remainder in DE
040582             0265*   ; BC is unmodified
040582             0266*   ; A is 0
040582             0267*   udiv3216:
040582 11 00 00 00 0268*       ld de,0		; 10
040586 3E 20       0269*       ld a,32		; 7
040588             0270*   @loop:
040588 52 DD 29    0271*       add.s ix,ix		; 15
04058B 52 ED 6A    0272*       adc.s hl,hl		; 15
04058E EB          0273*       ex de,hl		; 4
04058F 52 ED 6A    0274*       adc.s hl,hl		; 15
040592 B7          0275*       or a			; 4
040593 52 ED 42    0276*       sbc.s hl,bc		; 15
040596 52 DD 23    0277*       inc.s ix		; 10
040599 30 05       0278*       jr nc,@cansub		; 12/7
04059B 52 09       0279*       add.s hl,bc		; 11
04059D 52 DD 2B    0280*       dec.s ix		; 10
0405A0             0281*   @cansub:
0405A0 EB          0282*       ex de,hl		; 4
0405A1 3D          0283*       dec a		; 4
0405A2 20 E4       0284*       jr nz,@loop	; 12/7
0405A4 C9          0285*       ret			; 10
0405A5             0286*   ; end udiv3216
0405A5             0287*   
0405A5             0288*   ; https://discord.com/channels/1158535358624039014/1282290921815408681/1329274504022720512
0405A5             0289*   ; calc84maniac's 32-bit by 23-bit division routine
0405A5             0290*   ; This divides AUIX by UDE (maximum 23 bits)
0405A5             0291*   ; The result is stored in AUIX, the remainder in UHL
0405A5             0292*   ; UDE, C are unmodified
0405A5             0293*   ; B is 0
0405A5             0294*   udiv3223:
0405A5 B7          0295*       or a,a         ; 1
0405A6 ED 62       0296*       sbc hl,hl      ; 2
0405A8 06 20       0297*       ld b,32        ; 2
0405AA             0298*   @loop:
0405AA DD 29       0299*       add ix,ix      ; 2
0405AC 8F          0300*       adc a,a        ; 1
0405AD ED 6A       0301*       adc hl,hl      ; 2
0405AF ED 52       0302*       sbc hl,de      ; 2
0405B1 DD 23       0303*       inc ix         ; 2
0405B3 30 03       0304*       jr nc,@cansub  ; 2/4
0405B5 19          0305*       add hl,de      ; 1
0405B6 DD 2B       0306*       dec ix         ; 2
0405B8             0307*   @cansub:
0405B8 10 F0       0308*       djnz @loop     ; 2/4
0405BA C9          0309*       ret            ; 10
0405BB             0310*   ; end udiv3223
0405BB             0035        include "fonts.inc"
0405BB             0001*   fonts_load:
0405BB DD 21 EC 05 0002*       ld ix,font_list ; pointer to font list lookup
       04          
0405C0 06 01       0003*       ld b,num_fonts ; loop counter
0405C2             0004*   
0405C2             0005*   @load_loop:
0405C2 C5          0006*       push bc ; save loop counter
0405C3             0007*   
0405C3             0008*   ; load font into a buffer
0405C3 DD 27 06    0009*       ld hl,(ix+font_list_bufferId)
0405C6 DD 31 09    0010*       ld iy,(ix+font_list_filename)
0405C9 CD 84 15 04 0011*       call vdu_load_buffer_from_file
0405CD             0012*   
0405CD             0013*   ; create font from buffer
0405CD DD 27 06    0014*       ld hl,(ix+font_list_bufferId)
0405D0 DD 5E 00    0015*       ld e,(ix+font_list_width)
0405D3 DD 56 03    0016*       ld d,(ix+font_list_height)
0405D6 3E 00       0017*       ld a,0 ; flags
0405D8 CD D7 17 04 0018*       call vdu_font_create
0405DC             0019*   
0405DC             0020*   ; select font
0405DC DD 27 06    0021*       ld hl,(ix+font_list_bufferId)
0405DF 3E 01       0022*       ld a,1 ; flags
0405E1 CD BD 17 04 0023*       call vdu_font_select
0405E5             0024*   
0405E5             0025*   ; ; debug print filename
0405E5             0026*   ;     call printNewLine
0405E5             0027*   ;     ld hl,(ix+font_list_filename)
0405E5             0028*   ;     call printString
0405E5             0029*   
0405E5             0030*   ; advance font_list pointer to next record
0405E5 ED 32 0C    0031*       lea ix,ix+font_list_record_size
0405E8             0032*   
0405E8             0033*   ; restore loop counter
0405E8 C1          0034*       pop bc
0405E9 10 D7       0035*       djnz @load_loop
0405EB             0036*   
0405EB             0037*   ; all done
0405EB C9          0038*       ret
0405EC             0036        include "fonts_list.inc"
0405EC             0001*   ; Generated by asm_config_editor.py
0405EC             0002*   font_list_record_size: equ 12
0405EC             0003*   font_list_width: equ 0
0405EC             0004*   font_list_height: equ 3
0405EC             0005*   font_list_bufferId: equ 6
0405EC             0006*   font_list_filename: equ 9
0405EC             0007*   
0405EC             0008*   ; num_fonts: equ 28
0405EC             0009*   num_fonts: equ 1
0405EC             0010*   
0405EC             0011*   ; Index list:
0405EC             0012*   ; amiga_forever_16x16: equ 64000
0405EC             0013*   ; amiga_forever_16x24: equ 64001
0405EC             0014*   ; amiga_forever_8x16: equ 64002
0405EC             0015*   ; amiga_forever_8x8: equ 64003
0405EC             0016*   ; computer_pixel_7_10x15: equ 64004
0405EC             0017*   ; computer_pixel_7_10x24: equ 64005
0405EC             0018*   ; computer_pixel_7_8x12: equ 64006
0405EC             0019*   ; computer_pixel_7_8x14: equ 64007
0405EC             0020*   ; computer_pixel_7_8x16: equ 64008
0405EC             0021*   ; dopecre_8x8: equ 64009
0405EC             0022*   ; gamer_2_8x8: equ 64010
0405EC             0023*   ; Lat15_VGA8_8x8: equ 64011
0405EC             0024*   ; Lat2_Terminus12x6_6x12: equ 64012
0405EC             0025*   ; Lat2_TerminusBold14_8x14: equ 64013
0405EC             0026*   ; Lat2_VGA14_8x14: equ 64014
0405EC             0027*   ; Lat2_VGA16_8x16: equ 64015
0405EC             0028*   Lat2_VGA8_8x8: equ 64016
0405EC             0029*   ; Lat38_VGA8_8x8: equ 64017
0405EC             0030*   ; Lat7_Fixed13_8x13: equ 64018
0405EC             0031*   ; Lat7_Terminus12x6_6x12: equ 64019
0405EC             0032*   ; Lat7_TerminusBold16_8x16: equ 64020
0405EC             0033*   ; Lat7_VGA14_8x14: equ 64021
0405EC             0034*   ; Lat7_VGA16_8x16: equ 64022
0405EC             0035*   ; Lat7_VGA8_8x8: equ 64023
0405EC             0036*   ; planetary_contact_8x8: equ 64024
0405EC             0037*   ; scriptorium_12x14: equ 64025
0405EC             0038*   ; Squarewave_Bold_8x12: equ 64026
0405EC             0039*   ; super_mario_bros_2_8x8: equ 64027
0405EC             0040*   ; wendy_neue_6x6: equ 64028
0405EC             0041*   
0405EC             0042*   font_list: ; width; height; bufferId; filename;:
0405EC             0043*   	; dl 16, 16, 64000, fn_amiga_forever_16x16
0405EC             0044*   	; dl 16, 24, 64001, fn_amiga_forever_16x24
0405EC             0045*   	; dl 8, 16, 64002, fn_amiga_forever_8x16
0405EC             0046*   	; dl 8, 8, 64003, fn_amiga_forever_8x8
0405EC             0047*   	; dl 10, 15, 64004, fn_computer_pixel_7_10x15
0405EC             0048*   	; dl 10, 24, 64005, fn_computer_pixel_7_10x24
0405EC             0049*   	; dl 8, 12, 64006, fn_computer_pixel_7_8x12
0405EC             0050*   	; dl 8, 14, 64007, fn_computer_pixel_7_8x14
0405EC             0051*   	; dl 8, 16, 64008, fn_computer_pixel_7_8x16
0405EC             0052*   	; dl 8, 8, 64009, fn_dopecre_8x8
0405EC             0053*   	; dl 8, 8, 64010, fn_gamer_2_8x8
0405EC             0054*   	; dl 8, 8, 64011, fn_Lat15_VGA8_8x8
0405EC             0055*   	; dl 6, 12, 64012, fn_Lat2_Terminus12x6_6x12
0405EC             0056*   	; dl 8, 14, 64013, fn_Lat2_TerminusBold14_8x14
0405EC             0057*   	; dl 8, 14, 64014, fn_Lat2_VGA14_8x14
0405EC             0058*   	; dl 8, 16, 64015, fn_Lat2_VGA16_8x16
0405EC 08 00 00 08 0059*   	dl 8, 8, 64016, fn_Lat2_VGA8_8x8
       00 00 10 FA 
       00 F8 05 04 
0405F8             0060*   	; dl 8, 8, 64017, fn_Lat38_VGA8_8x8
0405F8             0061*   	; dl 8, 13, 64018, fn_Lat7_Fixed13_8x13
0405F8             0062*   	; dl 6, 12, 64019, fn_Lat7_Terminus12x6_6x12
0405F8             0063*   	; dl 8, 16, 64020, fn_Lat7_TerminusBold16_8x16
0405F8             0064*   	; dl 8, 14, 64021, fn_Lat7_VGA14_8x14
0405F8             0065*   	; dl 8, 16, 64022, fn_Lat7_VGA16_8x16
0405F8             0066*   	; dl 8, 8, 64023, fn_Lat7_VGA8_8x8
0405F8             0067*   	; dl 8, 8, 64024, fn_planetary_contact_8x8
0405F8             0068*   	; dl 12, 14, 64025, fn_scriptorium_12x14
0405F8             0069*   	; dl 8, 12, 64026, fn_Squarewave_Bold_8x12
0405F8             0070*   	; dl 8, 8, 64027, fn_super_mario_bros_2_8x8
0405F8             0071*   	; dl 6, 6, 64028, fn_wendy_neue_6x6
0405F8             0072*   
0405F8             0073*   ; files_list: ; filename:
0405F8             0074*   ; fn_amiga_forever_16x16: db "fonts/amiga_forever_16x16.font",0
0405F8             0075*   ; fn_amiga_forever_16x24: db "fonts/amiga_forever_16x24.font",0
0405F8             0076*   ; fn_amiga_forever_8x16: db "fonts/amiga_forever_8x16.font",0
0405F8             0077*   ; fn_amiga_forever_8x8: db "fonts/amiga_forever_8x8.font",0
0405F8             0078*   ; fn_computer_pixel_7_10x15: db "fonts/computer_pixel_7_10x15.font",0
0405F8             0079*   ; fn_computer_pixel_7_10x24: db "fonts/computer_pixel_7_10x24.font",0
0405F8             0080*   ; fn_computer_pixel_7_8x12: db "fonts/computer_pixel_7_8x12.font",0
0405F8             0081*   ; fn_computer_pixel_7_8x14: db "fonts/computer_pixel_7_8x14.font",0
0405F8             0082*   ; fn_computer_pixel_7_8x16: db "fonts/computer_pixel_7_8x16.font",0
0405F8             0083*   ; fn_dopecre_8x8: db "fonts/dopecre_8x8.font",0
0405F8             0084*   ; fn_gamer_2_8x8: db "fonts/gamer_2_8x8.font",0
0405F8             0085*   ; fn_Lat15_VGA8_8x8: db "fonts/Lat15-VGA8_8x8.font",0
0405F8             0086*   ; fn_Lat2_Terminus12x6_6x12: db "fonts/Lat2-Terminus12x6_6x12.font",0
0405F8             0087*   ; fn_Lat2_TerminusBold14_8x14: db "fonts/Lat2-TerminusBold14_8x14.font",0
0405F8             0088*   ; fn_Lat2_VGA14_8x14: db "fonts/Lat2-VGA14_8x14.font",0
0405F8             0089*   ; fn_Lat2_VGA16_8x16: db "fonts/Lat2-VGA16_8x16.font",0
0405F8 66 6F 6E 74 0090*   fn_Lat2_VGA8_8x8: db "fonts/Lat2-VGA8_8x8.font",0
       73 2F 4C 61 
       74 32 2D 56 
       47 41 38 5F 
       38 78 38 2E 
       66 6F 6E 74 
       00          
040611             0091*   ; fn_Lat38_VGA8_8x8: db "fonts/Lat38-VGA8_8x8.font",0
040611             0092*   ; fn_Lat7_Fixed13_8x13: db "fonts/Lat7-Fixed13_8x13.font",0
040611             0093*   ; fn_Lat7_Terminus12x6_6x12: db "fonts/Lat7-Terminus12x6_6x12.font",0
040611             0094*   ; fn_Lat7_TerminusBold16_8x16: db "fonts/Lat7-TerminusBold16_8x16.font",0
040611             0095*   ; fn_Lat7_VGA14_8x14: db "fonts/Lat7-VGA14_8x14.font",0
040611             0096*   ; fn_Lat7_VGA16_8x16: db "fonts/Lat7-VGA16_8x16.font",0
040611             0097*   ; fn_Lat7_VGA8_8x8: db "fonts/Lat7-VGA8_8x8.font",0
040611             0098*   ; fn_planetary_contact_8x8: db "fonts/planetary_contact_8x8.font",0
040611             0099*   ; fn_scriptorium_12x14: db "fonts/scriptorium_12x14.font",0
040611             0100*   ; fn_Squarewave_Bold_8x12: db "fonts/Squarewave_Bold_8x12.font",0
040611             0101*   ; fn_super_mario_bros_2_8x8: db "fonts/super_mario_bros_2_8x8.font",0
040611             0102*   ; fn_wendy_neue_6x6: db "fonts/wendy_neue_6x6.font",0
040611             0037        include "fixed168.inc"
040611             0001*   ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
040611             0002*   ; uses EZ80 MLT instruction for speed
040611             0003*   ; operation: UHL * A --> UHL
040611             0004*   ; destroys: AF, HL
040611             0005*   smul24x8:
040611             0006*   ; make hl positive and store sign flag
040611 CD 70 04 04 0007*       call hlu_abs
040615 F5          0008*       push af
040616             0009*   ; do the division
040616 CD 21 06 04 0010*       call mul24x8 ; hl = product
04061A             0011*   ; adjust sign of result
04061A F1          0012*       pop af ; sign de
04061B F0          0013*       ret p ; hl was positive, nothing to do
04061C CD 80 04 04 0014*       call neg_hlu ; result is negative
040620 C9          0015*       ret
040621             0016*   
040621             0017*   ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
040621             0018*   ; uses EZ80 MLT instruction for speed
040621             0019*   ; operation: UHL * A --> AUHL
040621             0020*   ; destroys: AF, HL
040621             0021*   mul24x8:
040621 D5          0022*       push de ; preserve de
040622             0023*   ; low byte
040622 5D          0024*       ld e,l
040623 57          0025*       ld d,a
040624 ED 5C       0026*       mlt de
040626 6B          0027*       ld l,e ; product low byte
040627 08          0028*       ex af,af' ; save multiplier
040628 7A          0029*       ld a,d ; carry
040629 08          0030*       ex af,af' ; save carry, restore multiplier
04062A             0031*   ; high byte
04062A 5C          0032*       ld e,h
04062B 57          0033*       ld d,a
04062C ED 5C       0034*       mlt de
04062E 08          0035*       ex af,af' ; save multiplier, restore carry
04062F 83          0036*       add a,e ; add carry
040630 67          0037*       ld h,a ; product middle byte
040631 7A          0038*       ld a,d ; carry
040632 08          0039*       ex af,af' ; save carry, restore multiplier
040633             0040*   ; upper byte
040633 22 4E 06 04 0041*       ld (@scratch),hl ; 7 cycles
040637 5F          0042*       ld e,a
040638 3A 50 06 04 0043*       ld a,(@scratch+2)
04063C 57          0044*       ld d,a
04063D ED 5C       0045*       mlt de
04063F 08          0046*       ex af,af' ; restore carry
040640 8B          0047*       adc a,e ; add carry
040641 32 50 06 04 0048*       ld (@scratch+2),a ; 5 cycles
040645 2A 4E 06 04 0049*       ld hl,(@scratch) ; 7 cycles
040649             0050*   ; highest byte
040649 3E 00       0051*       ld a,0 ; preserve carry flag
04064B 8A          0052*       adc a,d ; product highest byte
04064C D1          0053*       pop de ; restore de
04064D C9          0054*       ret
04064E             0055*   @scratch: ds 3
040651             0056*   
       FF FF FF 
040651 00 00 00 00 0057*   mul24out: blkb 6,0
       00 00       
040657             0058*   
040657             0059*   ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
040657             0060*   ; operation: UHL * UDE --> mul24out
040657             0061*   mul24:
040657 DD E5       0062*       push ix ; preserve
040659             0063*   ; point to output buffer and clear it
040659 DD 21 51 06 0064*       ld ix,mul24out
       04          
04065E C5          0065*       push bc
04065F 01 00 00 00 0066*       ld bc,0
040663 DD 0F 00    0067*       ld (ix),bc
040666 DD 0F 03    0068*       ld (ix+3),bc
040669 C1          0069*       pop bc
04066A             0070*   ; STEP 1: UHL * E
04066A 7B          0071*       ld a,e
04066B E5          0072*       push hl
04066C CD 21 06 04 0073*       call mul24x8
040670 DD 2F 00    0074*       ld (ix+0),hl
040673 DD 77 03    0075*       ld (ix+3),a
040676             0076*   ; STEP 2: UHL * D
040676 E1          0077*       pop hl
040677 E5          0078*       push hl
040678 7A          0079*       ld a,d
040679 CD 21 06 04 0080*       call mul24x8
04067D CD 96 06 04 0081*       call @accumulate
040681             0082*   ; STEP 3: UHL * DEU
040681 E1          0083*       pop hl
040682 ED 53 C6 06 0084*       ld (@de),de
       04          
040687 3A C8 06 04 0085*       ld a,(@de+2)
04068B CD 21 06 04 0086*       call mul24x8
04068F CD 96 06 04 0087*       call @accumulate
040693             0088*   ; all done
040693 DD E1       0089*       pop ix ; restore
040695 C9          0090*       ret
040696             0091*   @accumulate:
040696 DD 23       0092*       inc ix
040698             0093*   ; highest byte of product to carry
040698 DD 77 03    0094*       ld (ix+3),a
04069B             0095*   ; low byte of product
04069B 7D          0096*       ld a,l
04069C DD 86 00    0097*       add a,(ix+0)
04069F DD 77 00    0098*       ld (ix+0),a
0406A2             0099*   ; high byte of product
0406A2 7C          0100*       ld a,h
0406A3 DD 8E 01    0101*       adc a,(ix+1)
0406A6 DD 77 01    0102*       ld (ix+1),a
0406A9             0103*   ; uppper byte of product
0406A9 22 C3 06 04 0104*       ld (@hl),hl
0406AD 3A C5 06 04 0105*       ld a,(@hl+2)
0406B1 DD 8E 02    0106*       adc a,(ix+2)
0406B4 DD 77 02    0107*       ld (ix+2),a
0406B7             0108*   ; carry
0406B7 3E 00       0109*       ld a,0 ; preserve flags
0406B9 DD 8E 03    0110*       adc a,(ix+3)
0406BC DD 77 03    0111*       ld (ix+3),a
0406BF C9          0112*       ret
0406C0             0113*   
0406C0 00 00 00    0114*   @ix: dl 0
0406C3 00 00 00    0115*   @hl: dl 0
0406C6 00 00 00    0116*   @de: dl 0
0406C9             0117*   
0406C9             0118*   ; ; UHL * UDE --> UHL (unsigned)
0406C9             0119*   ; umul24:
0406C9             0120*   ;     call mul24
0406C9             0121*   ;     ld hl,(mul24out)
0406C9             0122*   ;     ret
0406C9             0123*   
0406C9             0124*   ; UH.L = UH.L*UD.E (unsigned)
0406C9             0125*   umul168:
0406C9 CD 57 06 04 0126*       call mul24
0406CD 2A 52 06 04 0127*       ld hl,(mul24out+1)
0406D1 C9          0128*       ret
0406D2             0129*   
0406D2             0130*   ; UH.L * UD.E --> UH.L (signed)
0406D2             0131*   smul168:
0406D2             0132*   ; make everything positive and store sign flags
0406D2 CD 70 04 04 0133*       call hlu_abs
0406D6 F5          0134*       push af
0406D7 EB          0135*       ex de,hl
0406D8 CD 70 04 04 0136*       call hlu_abs
0406DC EB          0137*       ex de,hl
0406DD F5          0138*       push af
0406DE             0139*   ; do the division
0406DE CD C9 06 04 0140*       call umul168 ; hl = product
0406E2             0141*   ; adjust sign of result
0406E2 F1          0142*       pop af ; sign de
0406E3 FA EE 06 04 0143*       jp m,@de_neg
0406E7 F1          0144*       pop af ; sign hl
0406E8 F0          0145*       ret p ; both positive, nothing to do
0406E9             0146*   @hl_neg:
0406E9 CD 80 04 04 0147*       call neg_hlu ; de pos, hl neg, result is negative
0406ED C9          0148*       ret
0406EE             0149*   @de_neg:
0406EE F1          0150*       pop af
0406EF F8          0151*       ret m ; both negative, nothing to do
0406F0 CD 80 04 04 0152*       call neg_hlu ; result is negative
0406F4 C9          0153*       ret
0406F5             0154*   
0406F5             0155*   ; UH.L / UD.E --> UD.E rem UHL (unsigned)
0406F5             0156*   ; perform unsigned division of 16.8 fixed place values
0406F5             0157*   ; with an unsigned 16.8 fixed place result and 24-bit remainder
0406F5             0158*   udiv168:
0406F5             0159*   ; back up divisor
0406F5 ED 53 2C 07 0160*       ld (@ude),de
       04          
0406FA             0161*   ; get the 16-bit integer part of the quotient
0406FA CD 80 03 04 0162*       call udiv24 ; de = quotient, hl = remainder
0406FE             0163*   ; load quotient to upper three bytes of output
0406FE ED 53 33 07 0164*       ld (div168_out+1),de
       04          
040703             0165*   @div256:
040703             0166*   ; multiply remainder by 256
040703             0167*       hlu_mul256
                       M1 Args: none
040703 29          0001*M1     add hl,hl ; * 2
040704 29          0002*M1     add hl,hl ; * 4
040705 29          0003*M1     add hl,hl ; * 8
040706 29          0004*M1     add hl,hl ; * 16
040707 29          0005*M1     add hl,hl ; * 32
040708 29          0006*M1     add hl,hl ; * 64
040709 29          0007*M1     add hl,hl ; * 128
04070A 29          0008*M1     add hl,hl ; * 256
04070B             0168*   ; skip fractional computation if remainder is zero
04070B             0169*       SIGN_HLU
                       M1 Args: none
04070B 19          0001*M1     add hl,de ; 1 cycle
04070C B7          0002*M1     or a ; clear flags ; 1 cycle
04070D ED 52       0003*M1     sbc hl,de ; 2 cycles
04070F             0004*M1     ; 4 cycles total
04070F 20 03       0170*       jr nz,@div_frac
040711 AF          0171*       xor a
040712 18 0A       0172*       jr @write_frac
040714             0173*   ; now divide the shifted remainder by the divisor
040714             0174*   @div_frac:
040714 ED 5B 2C 07 0175*       ld de,(@ude) ; get back divisor
       04          
040719 CD 80 03 04 0176*       call udiv24 ; de = quotient, hl = remainder
04071D             0177*   ; load low byte of quotient to low byte of output
04071D 7B          0178*       ld a,e
04071E             0179*   @write_frac:
04071E 32 32 07 04 0180*       ld (div168_out),a
040722             0181*   ; load de with return value
040722 ED 5B 32 07 0182*       ld de,(div168_out)
       04          
040727             0183*   ; load a with any overflow
040727 3A 35 07 04 0184*       ld a,(div168_out+3)
04072B C9          0185*       ret ; ud.e is the 16.8 result
04072C             0186*   @ude: ds 6
040732             0187*   div168_out: ds 4 ; the extra byte is for overflow
040736             0188*   
040736             0189*   ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
040736             0190*   ; perform signed division of 16.8 fixed place values
040736             0191*   ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
040736             0192*   sdiv168:
040736             0193*   ; make everything positive and store sign flags
       FF FF FF FF 
       FF FF FF FF 
       FF FF 
040736 CD 70 04 04 0194*       call hlu_abs
04073A F5          0195*       push af
04073B EB          0196*       ex de,hl
04073C CD 70 04 04 0197*       call hlu_abs
040740 EB          0198*       ex de,hl
040741 F5          0199*       push af
040742             0200*   ; do the division
040742 CD F5 06 04 0201*       call udiv168 ; de = quotient, hl = remainder
040746             0202*   ; adjust sign of result
040746 F1          0203*       pop af ; sign de
040747 FA 54 07 04 0204*       jp m,@de_neg
04074B F1          0205*       pop af ; sign hl
04074C F0          0206*       ret p ; both positive, nothing to do
04074D             0207*   @hl_neg:
04074D EB          0208*       ex de,hl ; hl = quotient, de = remainder
04074E CD 80 04 04 0209*       call neg_hlu ; de pos, hl neg, result is negative
040752 EB          0210*       ex de,hl ; de = negated quotient, hl = remainder
040753 C9          0211*       ret
040754             0212*   @de_neg:
040754 F1          0213*       pop af
040755 F8          0214*       ret m ; both negative, nothing to do
040756 EB          0215*       ex de,hl ; hl = quotient, de = remainder
040757 CD 80 04 04 0216*       call neg_hlu ; result is negative
04075B EB          0217*       ex de,hl ; de = negated quotient, hl = remainder
04075C C9          0218*       ret
04075D             0219*   
04075D             0220*   ; convert signed angles from a 360 to 256 degree circle
04075D             0221*   ; inputs: uh.l is the angle360 in 16.8 fixed format
04075D             0222*   ; outputs: uh.l is the angle256 in 16.8 fixed format
04075D             0223*   ; destroys: TODO
04075D             0224*   deg_360_to_256:
04075D D5          0225*       push de ; preserve de
04075E             0226*   ; make angle positive and store sign flag
04075E CD 70 04 04 0227*       call hlu_abs
040762 F5          0228*       push af
040763             0229*   ; multiply by coversion factor of 256/360
040763 11 B6 00 00 0230*       ld de,0x0000B6 ; 0.711
040767 CD C9 06 04 0231*       call umul168 ; uh.l = uh.l * 0.711
04076B             0232*   ; restore sign flag and adjust output accordingly
04076B F1          0233*       pop af
04076C F2 74 07 04 0234*       jp p,@pos ; positive number
040770 CD 80 04 04 0235*       call neg_hlu
040774             0236*   @pos:
040774             0237*   ; restore de and return uh.l as the result
040774 D1          0238*       pop de
040775 C9          0239*       ret
040776             0240*   
040776             0241*   ; convert signed angles from a 256 to 360 degree circle
040776             0242*   ; inputs: uh.l is the angle256 in 16.8 fixed format
040776             0243*   ; outputs: uh.l is the angle360 in 16.8 fixed format
040776             0244*   ; destroys: TODO
040776             0245*   deg_256_to_360:
040776 D5          0246*       push de ; preserve de
040777             0247*   ; make angle positive and store sign flag
040777 CD 70 04 04 0248*       call hlu_abs
04077B F5          0249*       push af
04077C             0250*   ; multiply by coversion factor of 360/256
04077C 11 68 01 00 0251*       ld de,0x000168 ; 1.406
040780 CD C9 06 04 0252*       call umul168 ; uh.l = uh.l * 1.406
040784             0253*   ; restore sign flag and adjust output accordingly
040784 F1          0254*       pop af
040785 F2 8D 07 04 0255*       jp p,@pos ; positive number
040789 CD 80 04 04 0256*       call neg_hlu
04078D             0257*   @pos:
04078D             0258*   ; restore de and return uh.l as the result
04078D D1          0259*       pop de
04078E C9          0260*       ret
04078F             0261*   
04078F             0262*   ; fixed 16.8 routine
04078F             0263*   ; cos(uh.l) --> uh.l
04078F             0264*   ; destroys: f, hl
04078F             0265*   cos168:
04078F D5          0266*       push de ; preserve de
040790             0267*   ; for cos we simply increment the angle by 90 degrees
040790             0268*   ; or 0x004000 in 16.8 degrees256
040790             0269*   ; which makes it a sin problem
040790 11 00 40 00 0270*       ld de,0x004000
040794 19          0271*       add hl,de ; modulo 256 happens below
040795 D1          0272*       pop de ; restore de
040796             0273*   ; fall through to sin168
040796             0274*   
040796             0275*   ; ---------------------
040796             0276*   ; fixed 16.8 routine
040796             0277*   ; sin(uh.l) --> uh.l
040796             0278*   ; destroys: f, hl
040796             0279*   sin168:
040796 D5          0280*       push de
040797             0281*   ; handle negative angles appropriately
040797 CD 70 04 04 0282*       call hlu_abs
04079B F2 A4 07 04 0283*       jp p,@F
04079F 11 00 00 FF 0284*       ld de,-256*256
0407A3 19          0285*       add hl,de
0407A4             0286*   @@:
0407A4 2E 03       0287*       ld l,3 ; multiply by 3 to get our lookup index
0407A6 ED 6C       0288*       mlt hl
0407A8 11 5C 0A 04 0289*       ld de,sin_lut_168 ; grab the lut address
0407AC 19          0290*       add hl,de ; bump hl by the index
0407AD ED 27       0291*       ld hl,(hl) ; don't try this on a z80!
0407AF D1          0292*       pop de
0407B0 C9          0293*       ret
0407B1             0294*   
0407B1             0295*   ; 16.8 fixed inputs / outputs
0407B1             0296*   ; takes: uh.l as angle in degrees 256
0407B1             0297*   ;        ud.e as radius
0407B1             0298*   ; returns ub.c as dx, ud.e as dy, uh.l as radius
0407B1             0299*   ;        displacements from origin (0,0)
0407B1             0300*   ; destroys: everything except indexes
0407B1             0301*   polar_to_cartesian:
0407B1             0302*   ; back up input parameters
0407B1 22 E0 07 04 0303*       ld (@angle), hl
0407B5 ED 53 E3 07 0304*       ld (@radius), de
       04          
0407BA             0305*   ; compute dx = sin(uh.l) * ud.e
0407BA CD 96 07 04 0306*       call sin168 ; uh.l = sin(uh.l)
0407BE ED 5B E3 07 0307*       ld de,(@radius)
       04          
0407C3 CD D2 06 04 0308*       call smul168 ; uh.l = dx
0407C7 E5          0309*       push hl
0407C8             0310*   ; compute dy = -cos(uh.l) * ud.e
0407C8 2A E0 07 04 0311*       ld hl,(@angle)
0407CC CD 8F 07 04 0312*       call cos168 ; uh.l = cos(uh.l)
0407D0 ED 5B E3 07 0313*       ld de,(@radius)
       04          
0407D5 CD D2 06 04 0314*       call smul168 ; uh.l = dy
0407D9 CD 80 04 04 0315*       call neg_hlu ; invert dy for screen coords convention
0407DD EB          0316*       ex de,hl ; de = dy for output
0407DE C1          0317*       pop bc ; bc = dx for output
0407DF             0318*   ; and out
0407DF C9          0319*       ret
0407E0             0320*   @angle: ds 3
0407E3             0321*   @radius: ds 3
0407E6             0322*   
0407E6             0323*   ; 16.8 fixed inputs / outputs
0407E6             0324*   ; inputs: ub.c as dx, ud.e as dy
0407E6             0325*   ;        displacements from origin (0,0)
0407E6             0326*   ; returns: uh.l as angle in degrees 256
0407E6             0327*   ;        ud.e as radius
0407E6             0328*   ; destroys: everything except indexes
0407E6             0329*   cartesian_to_polar:
       FF FF FF FF 
       FF FF 
0407E6 ED 43 3F 08 0330*       ld (dx168),bc ; dx argument for distance168
       04          
0407EB ED 53 45 08 0331*       ld (dy168),de ; dy argument for distance168
       04          
0407F0             0332*   ; compute radius
0407F0 CD 4B 08 04 0333*       call distance168 ; uh.l = radius
0407F4 E5          0334*       push hl ; save radius
0407F5             0335*   ; compute angle
0407F5 ED 4B 3F 08 0336*       ld bc,(dx168) ; dx argument for atan2_168fast
       04          
0407FA ED 5B 45 08 0337*       ld de,(dy168) ; dy argument for atan2_168fast
       04          
0407FF CD AB 08 04 0338*       call atan2_168fast ; uh.l = angle
040803             0339*   ; return result
040803 D1          0340*       pop de ; de = radius (was hl)
040804 C9          0341*       ret
040805             0342*   ; end cartesian_to_polar
040805             0343*   
040805             0344*   ; 16.8 fixed inputs / outputs
040805             0345*   ; inputs: ub.c as dx, ud.e as dy
040805             0346*   ;        displacements from origin (0,0)
040805             0347*   ; returns: uh.l as angle in degrees 256
040805             0348*   ;        ud.e as radius
040805             0349*   ; destroys: everything except indexes
040805             0350*   ; note: uses distance168sm which is more accurate for small deltas
040805             0351*   cartesian_to_polar_sm:
040805 ED 43 3F 08 0352*       ld (dx168),bc ; dx argument for distance168
       04          
04080A ED 53 45 08 0353*       ld (dy168),de ; dy argument for distance168
       04          
04080F             0354*   ; compute radius
04080F CD 86 08 04 0355*       call distance168sm ; uh.l = radius
040813 E5          0356*       push hl ; save radius
040814             0357*   ; compute angle
040814 ED 4B 3F 08 0358*       ld bc,(dx168) ; dx argument for atan2_168fast
       04          
040819 ED 5B 45 08 0359*       ld de,(dy168) ; dy argument for atan2_168fast
       04          
04081E CD AB 08 04 0360*       call atan2_168fast ; uh.l = angle
040822             0361*   ; return result
040822 D1          0362*       pop de ; de = radius (was hl)
040823 C9          0363*       ret
040824             0364*   ; end cartesian_to_polar
040824             0365*   
040824             0366*   ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
040824             0367*   ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
040824             0368*   ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
040824             0369*   ;         also populates scratch locations dx168 and dy168
040824             0370*   ; destroys: a,hl,bc,de
040824             0371*   dxy168:
040824             0372*   ; compute dx = x1-x0
040824 AF          0373*       xor a ; clear carry
040825 DD E5       0374*       push ix ; move ix to hl via the stack
040827 E1          0375*       pop hl ; hl = x1
040828 ED 42       0376*       sbc hl,bc ; hl = dx
04082A 22 3F 08 04 0377*       ld (dx168),hl ; dx to scratch
04082E             0378*   ; compute dy = y1-y0
04082E AF          0379*       xor a ; clear carry
04082F FD E5       0380*       push iy ; move iy to hl via the stack
040831 E1          0381*       pop hl ; hl = y1
040832 ED 52       0382*       sbc hl,de ; hl = dy
040834 22 45 08 04 0383*       ld (dy168),hl ; dy to scratch
040838             0384*   ; populate output registers and return
040838 EB          0385*       ex de,hl ; ud.e = dy
040839 ED 4B 3F 08 0386*       ld bc,(dx168) ; ub.c = dx
       04          
04083E C9          0387*       ret
04083F 00 00 00 00 0388*   dx168: blkb 6,0
       00 00       
040845 00 00 00 00 0389*   dy168: blkb 6,0
       00 00       
04084B             0390*   
04084B             0391*   ; compute the euclidian distance between two cartesian coordinates
04084B             0392*   ; using the formula d = sqrt(dx^2+dy^2)
04084B             0393*   ; inputs: dx168 and dy168 are dx and dy in 16.8 fixed format
04084B             0394*   ; output; uh.l is the 16.8 fixed format distance
04084B             0395*   ;         also populates scratch locations dx168 and dy168
04084B             0396*   ; destroys: a,hl,bc,de
04084B             0397*   ; NOTE: rounds both deltas down to the nearest integer to avoid overflow when squaring,
04084B             0398*   ;       thus the result will always be an integer, albeit in 16.8 format
04084B             0399*   distance168:
04084B             0400*   ; compute dy^2
04084B 2A 45 08 04 0401*       ld hl,(dy168)
04084F CD 70 04 04 0402*       call hlu_abs
040853             0403*       ; call hlu_udiv256 ; make integer to avoid overflow
040853             0404*       SRL_UHL ; make integer to avoid overflow
                       M1 Args: none
040853 3B          0001*M1     dec sp ; 1 cycle
040854 E5          0002*M1     push hl ; 4 cycles
040855 33          0003*M1     inc sp ; 1 cycle
040856 E1          0004*M1     pop hl ; 4 cycles
040857 23          0005*M1     inc hl ; 1 cycle
040858 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
04085A             0007*M1     ; 13 cycles total
04085A E5          0405*       push hl
04085B D1          0406*       pop de
04085C CD 67 03 04 0407*       call umul24 ; hl = dy^2
040860 E5          0408*       push hl ; save dy^2
040861             0409*   ; compute dx^2
040861 2A 3F 08 04 0410*       ld hl,(dx168)
040865 CD 70 04 04 0411*       call hlu_abs
040869             0412*       ; call hlu_udiv256 ; make integer to avoid overflow
040869             0413*       SRL_UHL ; make integer to avoid overflow
                       M1 Args: none
040869 3B          0001*M1     dec sp ; 1 cycle
04086A E5          0002*M1     push hl ; 4 cycles
04086B 33          0003*M1     inc sp ; 1 cycle
04086C E1          0004*M1     pop hl ; 4 cycles
04086D 23          0005*M1     inc hl ; 1 cycle
04086E 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
040870             0007*M1     ; 13 cycles total
040870 E5          0414*       push hl
040871 D1          0415*       pop de
040872 CD 67 03 04 0416*       call umul24 ; hl = dx^2
040876             0417*   ; add dx^2 and dy^2
040876 D1          0418*       pop de ; de = dy^2 (was hl)
040877 19          0419*       add hl,de ; hl = dx^2 + dy^2
040878             0420*   ; compute the square root
040878 CD 76 09 04 0421*       call sqrt24 ; de = sqrt(dx^2 + dy^2)
04087C EB          0422*       ex de,hl ; hl = distance
04087D             0423*       hlu_mul256 ; convert back to 16.8 fixed
                       M1 Args: none
04087D 29          0001*M1     add hl,hl ; * 2
04087E 29          0002*M1     add hl,hl ; * 4
04087F 29          0003*M1     add hl,hl ; * 8
040880 29          0004*M1     add hl,hl ; * 16
040881 29          0005*M1     add hl,hl ; * 32
040882 29          0006*M1     add hl,hl ; * 64
040883 29          0007*M1     add hl,hl ; * 128
040884 29          0008*M1     add hl,hl ; * 256
040885 C9          0424*       ret
040886             0425*   
040886             0426*   ; compute the euclidian distance between two cartesian coordinates
040886             0427*   ; using the formula d = sqrt(dx^2+dy^2)
040886             0428*   ; inputs: dx168 and dy168 are dx and dy in 16.8 fixed format
040886             0429*   ; output; uh.l is the 16.8 fixed format distance
040886             0430*   ;         also populates scratch locations dx168 and dy168
040886             0431*   ; destroys: a,hl,bc,de
040886             0432*   ; NOTE: sm means 'small' because it doesn't round down the deltas
040886             0433*   ;       making it more accurate for small deltas,
040886             0434*   ;       but will overflow if used for screen-sized deltas
040886             0435*   distance168sm:
040886             0436*   ; compute dy^2
040886 2A 45 08 04 0437*       ld hl,(dy168)
04088A CD 70 04 04 0438*       call hlu_abs
04088E E5          0439*       push hl
04088F D1          0440*       pop de
040890 CD 67 03 04 0441*       call umul24 ; hl = dy^2
040894 E5          0442*       push hl ; save dy^2
040895             0443*   ; compute dx^2
040895 2A 3F 08 04 0444*       ld hl,(dx168)
040899 CD 70 04 04 0445*       call hlu_abs
04089D E5          0446*       push hl
04089E D1          0447*       pop de
04089F CD 67 03 04 0448*       call umul24 ; hl = dx^2
0408A3             0449*   ; add dx^2 and dy^2
0408A3 D1          0450*       pop de ; de = dy^2 (was hl)
0408A4 19          0451*       add hl,de ; hl = dx^2 + dy^2
0408A5             0452*   ; compute the square root
0408A5 CD 76 09 04 0453*       call sqrt24 ; de = sqrt(dx^2 + dy^2)
0408A9 EB          0454*       ex de,hl ; hl = distance
0408AA C9          0455*       ret
0408AB             0456*   
0408AB             0457*   ; atan2_(ub.c,ud.e) --> uh.l
0408AB             0458*   ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0408AB             0459*   ;   whether inputs are integers or fractional doesn't matter
0408AB             0460*   ;   so long as the sign bit of the upper byte is correct
0408AB             0461*   ; output: uh.l is the 16.8 fixed angle in degrees 256
0408AB             0462*   ; angles are COMPASS HEADINGS based on
0408AB             0463*   ; screen coordinate conventions,where the y axis is flipped
0408AB             0464*   ; #E0 224      0       32 #20
0408AB             0465*   ;        -x,-y | +x,-y
0408AB             0466*   ; #C0 192------+------ 64 #40
0408AB             0467*   ;        -x,+y | +x,+y
0408AB             0468*   ; #A0 160   128 #80   96 #60
0408AB             0469*   atan2_168fast:
0408AB             0470*   ; get signs and make everything positive
0408AB             0471*   ; get abs(x) and store its original sign
0408AB C5          0472*       push bc
0408AC E1          0473*       pop hl
0408AD CD 70 04 04 0474*       call hlu_abs ; if x was negative this also sets the sign flag
0408B1 E5          0475*       push hl ; store abs(x)
0408B2 C1          0476*       pop bc ; bc = abs(x)
0408B3 F5          0477*       push af ; store sign of x
0408B4             0478*   ; get abs(y) and store its original sign
0408B4 EB          0479*       ex de,hl ; hl = y
0408B5 CD 70 04 04 0480*       call hlu_abs ; if y was negative this also sets the sign flag
0408B9 EB          0481*       ex de,hl ; de = abs(y)
0408BA F5          0482*       push af ; store sign of y
0408BB             0483*   ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
0408BB             0484*   ; this ensures that our lookup value is between 0 and 1 inclusive
0408BB AF          0485*       xor a ; clear the carry flag
0408BC D5          0486*       push de
0408BD E1          0487*       pop hl
0408BE ED 42       0488*       sbc hl,bc
0408C0 F5          0489*       push af ; save sign of de - bc
0408C1 F2 CA 08 04 0490*       jp p,@1 ; bc <= de, so we skip ahead
0408C5             0491*   ; otherwise we swap bc and de
0408C5 C5          0492*       push bc
0408C6 E1          0493*       pop hl
0408C7 EB          0494*       ex de,hl
0408C8 E5          0495*       push hl
0408C9 C1          0496*       pop bc
0408CA             0497*   @1:
0408CA             0498*   ; now we're ready to snag our preliminary result
0408CA C5          0499*       push bc
0408CB E1          0500*       pop hl
0408CC CD 3A 09 04 0501*       call atan_168fast ; uh.l comes back with prelim result
0408D0             0502*   ; now we adjust uh.l based on sign of de - bc
0408D0 F1          0503*       pop af
0408D1 F2 DD 08 04 0504*       jp p,@2 ; bc <= de,so we skip ahead
0408D5 EB          0505*       ex de,hl
0408D6 21 00 40 00 0506*       ld hl,64*256 ; subtract from 64 (90) degrees
0408DA AF          0507*       xor a ; clear the carry flag
0408DB ED 52       0508*       sbc hl,de
0408DD             0509*   @2:
0408DD             0510*   ; adjust the result based on quadrant
0408DD             0511*   ; #E0 224      0       32 #20
0408DD             0512*   ;        -x,-y | +x,-y
0408DD             0513*   ; #C0 192------+------ 64 #40
0408DD             0514*   ;        -x,+y | +x,+y
0408DD             0515*   ; #A0 160   128 #80   96 #60
0408DD F1          0516*       pop af ; sign of y
0408DE CA 1B 09 04 0517*       jp z,@y_zero
0408E2 F2 FB 08 04 0518*       jp p,@y_pos
0408E6             0519*   ; y neg,check x
0408E6 F1          0520*       pop af ; sign of x
0408E7 CA F5 08 04 0521*       jp z,@y_neg_x_zero
0408EB F2 FA 08 04 0522*       jp p,@y_neg_x_pos
0408EF             0523*   ; y neg,x neg
0408EF             0524*   ; angle is 128 to 256 (270 to 360)
0408EF             0525*   ; negating the intermediate does the trick
0408EF CD 80 04 04 0526*       call neg_hlu
0408F3 18 31       0527*       jr @zero_hlu
0408F5             0528*   
0408F5             0529*   @y_neg_x_zero:
0408F5             0530*   ; y neg,x zero
0408F5             0531*   ; angle is 0
0408F5 21 00 00 00 0532*       ld hl,0
0408F9 C9          0533*       ret
0408FA             0534*   @y_neg_x_pos:
0408FA             0535*   ; y neg,x pos
0408FA             0536*   ; angle is 0 to 64 (0 to 90)
0408FA             0537*   ; so we're good
0408FA C9          0538*       ret
0408FB             0539*   
0408FB             0540*   @y_pos:
0408FB F1          0541*       pop af ; sign of x
0408FC CA 0B 09 04 0542*       jp z,@y_pos_x_zero
040900 F2 10 09 04 0543*       jp p,@y_pos_x_pos
040904             0544*   ; y pos,x neg
040904             0545*   ; angle is 128 to 192 (180-270)
040904             0546*   ; so we add 128 to intermediate
040904 11 00 80 00 0547*       ld de,128*256
040908 19          0548*       add hl,de
040909 18 1B       0549*       jr @zero_hlu
04090B             0550*   @y_pos_x_zero:
04090B             0551*   ; y pos,x zero
04090B             0552*   ; angle is 128 (180)
04090B 21 00 80 00 0553*       ld hl,128*256
04090F C9          0554*       ret
040910             0555*   @y_pos_x_pos:
040910             0556*   ; y pos,x pos
040910             0557*   ; angle is 64 to 128 (90 to 180)
040910             0558*   ; neg the intermediate and add 180 degrees
040910 CD 80 04 04 0559*       call neg_hlu
040914 11 00 80 00 0560*       ld de,128*256
040918 19          0561*       add hl,de
040919 18 0B       0562*       jr @zero_hlu
04091B             0563*   
04091B             0564*   @y_zero:
04091B F1          0565*       pop af ; sign of x
04091C FA 21 09 04 0566*       jp m,@y_zero_x_neg
040920             0567*   ; y zero,x pos
040920             0568*   ; angle is 64 (90),nothing to do
040920 C9          0569*       ret
040921             0570*   @y_zero_x_neg:
040921             0571*   ; y zero ,x neg
040921             0572*   ; angle is 192 (270)
040921 21 00 C0 00 0573*       ld hl,192*256
040925 C9          0574*       ret
040926             0575*   @zero_hlu:
040926 AF          0576*       xor a
040927 22 34 09 04 0577*       ld (@scratch),hl
04092B 32 36 09 04 0578*       ld (@scratch+2),a
04092F 2A 34 09 04 0579*       ld hl,(@scratch)
040933 C9          0580*       ret
040934             0581*   @scratch: ds 6
04093A             0582*   
04093A             0583*   ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
04093A             0584*   ; output: uh.l is the 16.8 fixed format angle in degrees 256
04093A             0585*   ; destroys: a,hl,bc,de
04093A             0586*   ; note: only works for angles from 0 to 32 (45) degrees
04093A             0587*   ;   use atan2_168fast (which calls this proc) to handle the full 256 (360) degrees
04093A             0588*   atan_168fast:
04093A             0589*   ; because we use compass headings instead of geometric angles
04093A             0590*   ; we compute dx/dy which is 1/tan(theta) in the maths world
04093A             0591*   ; we can do faster unsigned division here because we know dx and dy are positive
       FF FF FF FF 
       FF FF 
04093A CD F5 06 04 0592*       call udiv168 ; ud.e = dx/dy
04093E EB          0593*       ex de,hl ; uh.l = dx/dy
04093F             0594*   ; test uh.l for 0
04093F 19          0595*       add hl,de
040940 B7          0596*       or a
040941 ED 52       0597*       sbc hl,de
040943 28 22       0598*       jr z,@is_zero
040945             0599*   ; test uh.l for 1
040945 AF          0600*       xor a ; clear carry
040946 EB          0601*       ex de,hl
040947 21 00 01 00 0602*       ld hl,1*256 ; 1 in 16.8 fixed format
04094B ED 52       0603*       sbc hl,de
04094D 28 13       0604*       jr z,@is_45
04094F EB          0605*       ex de,hl
040950             0606*   ; no special cases so we move on
040950             0607*   ; l contains the fractional portion of tan(uh.l)
040950             0608*   ; we multiply it by three to get our lookup table index
040950 26 03       0609*       ld h,3
040952 ED 6C       0610*       mlt hl ; index into lut
040954 11 00 00 00 0611*       ld de,0 ; clear deu
040958 54          0612*       ld d,h ; copy hl to de
040959 5D          0613*       ld e,l ; de contains our index
04095A 21 5F 0D 04 0614*       ld hl,atan_lut_168 ; grab the lut address
04095E 19          0615*       add hl,de ; bump hl by the index
04095F ED 27       0616*       ld hl,(hl) ; don't try this on a z80!
040961 C9          0617*       ret ; and out
040962             0618*   @is_45:
040962 21 00 20 00 0619*       ld hl,32*256
040966 C9          0620*       ret
040967             0621*   ; for the case tan(0)
040967             0622*   @is_zero:
040967 21 00 00 00 0623*       ld hl,0*256
04096B C9          0624*       ret
04096C             0625*   
04096C             0626*   ; Expects  ADL mode
04096C             0627*   ; Inputs:  UH.L
04096C             0628*   ; Outputs: UH.L is the 16.8 square root
04096C             0629*   ;          UDE is the integer difference inputHL-DE^2
04096C             0630*   sqrt168:
04096C CD 76 09 04 0631*       call sqrt24
040970 EB          0632*       ex de,hl
040971 29          0633*       add hl,hl
040972 29          0634*       add hl,hl
040973 29          0635*       add hl,hl
040974 29          0636*       add hl,hl
040975 C9          0637*       ret
040976             0638*   
040976             0639*   ; credit: xeda112358
040976             0640*   ; https://www.cemetech.net/forum/viewtopic.php?t=11178&postdays=0&postorder=asc&start=0
040976             0641*   sqrt24:
040976             0642*   ; Expects ADL mode
040976             0643*   ; Inputs: HL
040976             0644*   ; Outputs: DE is the integer square root
040976             0645*   ;  HL is the difference inputHL-DE^2
040976             0646*   ;  c flag reset
040976 01 00 00 00 0647*       ld bc,0 ; clear bcu
04097A 11 00 00 00 0648*       ld de,0 ; clear deu
04097E AF          0649*       xor a
04097F 45          0650*       ld b,l
040980 C5          0651*       push bc
040981 47          0652*       ld b,a
040982 6F          0653*       ld l,a
040983             0654*   ; Iteration 1
040983 29          0655*       add hl,hl
040984 CB 11       0656*       rl c
040986 29          0657*       add hl,hl
040987 CB 11       0658*       rl c
040989 91          0659*       sub c
04098A 30 04       0660*       jr nc,$+6
04098C 1C          0661*       inc e
04098D 1C          0662*       inc e
04098E 2F          0663*       cpl
04098F 4F          0664*       ld c,a
040990             0665*   ; Iteration 2
040990 29          0666*       add hl,hl
040991 CB 11       0667*       rl c
040993 29          0668*       add hl,hl
040994 CB 11       0669*       rl c
040996 CB 13       0670*       rl e
040998 7B          0671*       ld a,e
040999 91          0672*       sub c
04099A 30 04       0673*       jr nc,$+6
04099C 1C          0674*       inc e
04099D 1C          0675*       inc e
04099E 2F          0676*       cpl
04099F 4F          0677*       ld c,a
0409A0             0678*   ; Iteration 3
0409A0 29          0679*       add hl,hl
0409A1 CB 11       0680*       rl c
0409A3 29          0681*       add hl,hl
0409A4 CB 11       0682*       rl c
0409A6 CB 13       0683*       rl e
0409A8 7B          0684*       ld a,e
0409A9 91          0685*       sub c
0409AA 30 04       0686*       jr nc,$+6
0409AC 1C          0687*       inc e
0409AD 1C          0688*       inc e
0409AE 2F          0689*       cpl
0409AF 4F          0690*       ld c,a
0409B0             0691*   ; Iteration 4
0409B0 29          0692*       add hl,hl
0409B1 CB 11       0693*       rl c
0409B3 29          0694*       add hl,hl
0409B4 CB 11       0695*       rl c
0409B6 CB 13       0696*       rl e
0409B8 7B          0697*       ld a,e
0409B9 91          0698*       sub c
0409BA 30 04       0699*       jr nc,$+6
0409BC 1C          0700*       inc e
0409BD 1C          0701*       inc e
0409BE 2F          0702*       cpl
0409BF 4F          0703*       ld c,a
0409C0             0704*   ; Iteration 5
0409C0 29          0705*       add hl,hl
0409C1 CB 11       0706*       rl c
0409C3 29          0707*       add hl,hl
0409C4 CB 11       0708*       rl c
0409C6 CB 13       0709*       rl e
0409C8 7B          0710*       ld a,e
0409C9 91          0711*       sub c
0409CA 30 04       0712*       jr nc,$+6
0409CC 1C          0713*       inc e
0409CD 1C          0714*       inc e
0409CE 2F          0715*       cpl
0409CF 4F          0716*       ld c,a
0409D0             0717*   ; Iteration 6
0409D0 29          0718*       add hl,hl
0409D1 CB 11       0719*       rl c
0409D3 29          0720*       add hl,hl
0409D4 CB 11       0721*       rl c
0409D6 CB 13       0722*       rl e
0409D8 7B          0723*       ld a,e
0409D9 91          0724*       sub c
0409DA 30 04       0725*       jr nc,$+6
0409DC 1C          0726*       inc e
0409DD 1C          0727*       inc e
0409DE 2F          0728*       cpl
0409DF 4F          0729*       ld c,a
0409E0             0730*   ; Iteration 7
0409E0 29          0731*       add hl,hl
0409E1 CB 11       0732*       rl c
0409E3 29          0733*       add hl,hl
0409E4 CB 11       0734*       rl c
0409E6 CB 10       0735*       rl b
0409E8 EB          0736*       ex de,hl
0409E9 29          0737*       add hl,hl
0409EA E5          0738*       push hl
0409EB ED 42       0739*       sbc hl,bc
0409ED 30 06       0740*       jr nc,$+8
0409EF 7C          0741*       ld a,h
0409F0 2F          0742*       cpl
0409F1 47          0743*       ld b,a
0409F2 7D          0744*       ld a,l
0409F3 2F          0745*       cpl
0409F4 4F          0746*       ld c,a
0409F5 E1          0747*       pop hl
0409F6 30 02       0748*       jr nc,$+4
0409F8 23          0749*       inc hl
0409F9 23          0750*       inc hl
0409FA EB          0751*       ex de,hl
0409FB             0752*   ; Iteration 8
0409FB 29          0753*       add hl,hl
0409FC 69          0754*       ld l,c
0409FD 60          0755*       ld h,b
0409FE ED 6A       0756*       adc hl,hl
040A00 ED 6A       0757*       adc hl,hl
040A02 EB          0758*       ex de,hl
040A03 29          0759*       add hl,hl
040A04 ED 52       0760*       sbc hl,de
040A06 19          0761*       add hl,de
040A07 EB          0762*       ex de,hl
040A08 30 04       0763*       jr nc,$+6
040A0A ED 52       0764*       sbc hl,de
040A0C 13          0765*       inc de
040A0D 13          0766*       inc de
040A0E             0767*   ; Iteration 9
040A0E F1          0768*       pop af
040A0F 17          0769*       rla
040A10 ED 6A       0770*       adc hl,hl
040A12 17          0771*       rla
040A13 ED 6A       0772*       adc hl,hl
040A15 EB          0773*       ex de,hl
040A16 29          0774*       add hl,hl
040A17 ED 52       0775*       sbc hl,de
040A19 19          0776*       add hl,de
040A1A EB          0777*       ex de,hl
040A1B 30 04       0778*       jr nc,$+6
040A1D ED 52       0779*       sbc hl,de
040A1F 13          0780*       inc de
040A20 13          0781*       inc de
040A21             0782*   ; Iteration 10
040A21 17          0783*       rla
040A22 ED 6A       0784*       adc hl,hl
040A24 17          0785*       rla
040A25 ED 6A       0786*       adc hl,hl
040A27 EB          0787*       ex de,hl
040A28 29          0788*       add hl,hl
040A29 ED 52       0789*       sbc hl,de
040A2B 19          0790*       add hl,de
040A2C EB          0791*       ex de,hl
040A2D 30 04       0792*       jr nc,$+6
040A2F ED 52       0793*       sbc hl,de
040A31 13          0794*       inc de
040A32 13          0795*       inc de
040A33             0796*   ; Iteration 11
040A33 17          0797*       rla
040A34 ED 6A       0798*       adc hl,hl
040A36 17          0799*       rla
040A37 ED 6A       0800*       adc hl,hl
040A39 EB          0801*       ex de,hl
040A3A 29          0802*       add hl,hl
040A3B ED 52       0803*       sbc hl,de
040A3D 19          0804*       add hl,de
040A3E EB          0805*       ex de,hl
040A3F 30 04       0806*       jr nc,$+6
040A41 ED 52       0807*       sbc hl,de
040A43 13          0808*       inc de
040A44 13          0809*       inc de
040A45             0810*   ; Iteration 12
040A45 17          0811*       rla
040A46 ED 6A       0812*       adc hl,hl
040A48 17          0813*       rla
040A49 ED 6A       0814*       adc hl,hl
040A4B EB          0815*       ex de,hl
040A4C 29          0816*       add hl,hl
040A4D ED 52       0817*       sbc hl,de
040A4F 19          0818*       add hl,de
040A50 EB          0819*       ex de,hl
040A51 30 04       0820*       jr nc,$+6
040A53 ED 52       0821*       sbc hl,de
040A55 13          0822*       inc de
040A56 13          0823*       inc de
040A57 CB 1A       0824*       rr d
040A59 CB 1B       0825*       rr e
040A5B C9          0826*       ret
040A5C             0827*   
040A5C             0828*   sin_lut_168:
040A5C 00 00 00    0829*       dl 0x000000 ; 0.000 00, 0.000
040A5F 06 00 00    0830*       dl 0x000006 ; 1.406 01, 0.025
040A62 0C 00 00    0831*       dl 0x00000C ; 2.813 02, 0.049
040A65 12 00 00    0832*       dl 0x000012 ; 4.219 03, 0.074
040A68 19 00 00    0833*       dl 0x000019 ; 5.625 04, 0.098
040A6B 1F 00 00    0834*       dl 0x00001F ; 7.031 05, 0.122
040A6E 25 00 00    0835*       dl 0x000025 ; 8.438 06, 0.147
040A71 2B 00 00    0836*       dl 0x00002B ; 9.844 07, 0.171
040A74 31 00 00    0837*       dl 0x000031 ; 11.250 08, 0.195
040A77 38 00 00    0838*       dl 0x000038 ; 12.656 09, 0.219
040A7A 3E 00 00    0839*       dl 0x00003E ; 14.063 0A, 0.243
040A7D 44 00 00    0840*       dl 0x000044 ; 15.469 0B, 0.267
040A80 4A 00 00    0841*       dl 0x00004A ; 16.875 0C, 0.290
040A83 50 00 00    0842*       dl 0x000050 ; 18.281 0D, 0.314
040A86 56 00 00    0843*       dl 0x000056 ; 19.688 0E, 0.337
040A89 5C 00 00    0844*       dl 0x00005C ; 21.094 0F, 0.360
040A8C 61 00 00    0845*       dl 0x000061 ; 22.500 10, 0.383
040A8F 67 00 00    0846*       dl 0x000067 ; 23.906 11, 0.405
040A92 6D 00 00    0847*       dl 0x00006D ; 25.313 12, 0.428
040A95 73 00 00    0848*       dl 0x000073 ; 26.719 13, 0.450
040A98 78 00 00    0849*       dl 0x000078 ; 28.125 14, 0.471
040A9B 7E 00 00    0850*       dl 0x00007E ; 29.531 15, 0.493
040A9E 83 00 00    0851*       dl 0x000083 ; 30.938 16, 0.514
040AA1 88 00 00    0852*       dl 0x000088 ; 32.344 17, 0.535
040AA4 8E 00 00    0853*       dl 0x00008E ; 33.750 18, 0.556
040AA7 93 00 00    0854*       dl 0x000093 ; 35.156 19, 0.576
040AAA 98 00 00    0855*       dl 0x000098 ; 36.563 1A, 0.596
040AAD 9D 00 00    0856*       dl 0x00009D ; 37.969 1B, 0.615
040AB0 A2 00 00    0857*       dl 0x0000A2 ; 39.375 1C, 0.634
040AB3 A7 00 00    0858*       dl 0x0000A7 ; 40.781 1D, 0.653
040AB6 AB 00 00    0859*       dl 0x0000AB ; 42.188 1E, 0.672
040AB9 B0 00 00    0860*       dl 0x0000B0 ; 43.594 1F, 0.690
040ABC B5 00 00    0861*       dl 0x0000B5 ; 45.000 20, 0.707
040ABF B9 00 00    0862*       dl 0x0000B9 ; 46.406 21, 0.724
040AC2 BD 00 00    0863*       dl 0x0000BD ; 47.813 22, 0.741
040AC5 C1 00 00    0864*       dl 0x0000C1 ; 49.219 23, 0.757
040AC8 C5 00 00    0865*       dl 0x0000C5 ; 50.625 24, 0.773
040ACB C9 00 00    0866*       dl 0x0000C9 ; 52.031 25, 0.788
040ACE CD 00 00    0867*       dl 0x0000CD ; 53.438 26, 0.803
040AD1 D1 00 00    0868*       dl 0x0000D1 ; 54.844 27, 0.818
040AD4 D4 00 00    0869*       dl 0x0000D4 ; 56.250 28, 0.831
040AD7 D8 00 00    0870*       dl 0x0000D8 ; 57.656 29, 0.845
040ADA DB 00 00    0871*       dl 0x0000DB ; 59.063 2A, 0.858
040ADD DE 00 00    0872*       dl 0x0000DE ; 60.469 2B, 0.870
040AE0 E1 00 00    0873*       dl 0x0000E1 ; 61.875 2C, 0.882
040AE3 E4 00 00    0874*       dl 0x0000E4 ; 63.281 2D, 0.893
040AE6 E7 00 00    0875*       dl 0x0000E7 ; 64.688 2E, 0.904
040AE9 EA 00 00    0876*       dl 0x0000EA ; 66.094 2F, 0.914
040AEC EC 00 00    0877*       dl 0x0000EC ; 67.500 30, 0.924
040AEF EE 00 00    0878*       dl 0x0000EE ; 68.906 31, 0.933
040AF2 F1 00 00    0879*       dl 0x0000F1 ; 70.313 32, 0.942
040AF5 F3 00 00    0880*       dl 0x0000F3 ; 71.719 33, 0.950
040AF8 F4 00 00    0881*       dl 0x0000F4 ; 73.125 34, 0.957
040AFB F6 00 00    0882*       dl 0x0000F6 ; 74.531 35, 0.964
040AFE F8 00 00    0883*       dl 0x0000F8 ; 75.938 36, 0.970
040B01 F9 00 00    0884*       dl 0x0000F9 ; 77.344 37, 0.976
040B04 FB 00 00    0885*       dl 0x0000FB ; 78.750 38, 0.981
040B07 FC 00 00    0886*       dl 0x0000FC ; 80.156 39, 0.985
040B0A FD 00 00    0887*       dl 0x0000FD ; 81.563 3A, 0.989
040B0D FE 00 00    0888*       dl 0x0000FE ; 82.969 3B, 0.992
040B10 FE 00 00    0889*       dl 0x0000FE ; 84.375 3C, 0.995
040B13 FF 00 00    0890*       dl 0x0000FF ; 85.781 3D, 0.997
040B16 FF 00 00    0891*       dl 0x0000FF ; 87.188 3E, 0.999
040B19 FF 00 00    0892*       dl 0x0000FF ; 88.594 3F, 1.000
040B1C 00 01 00    0893*       dl 0x000100 ; 90.000 40, 1.000
040B1F FF 00 00    0894*       dl 0x0000FF ; 91.406 41, 1.000
040B22 FF 00 00    0895*       dl 0x0000FF ; 92.813 42, 0.999
040B25 FF 00 00    0896*       dl 0x0000FF ; 94.219 43, 0.997
040B28 FE 00 00    0897*       dl 0x0000FE ; 95.625 44, 0.995
040B2B FE 00 00    0898*       dl 0x0000FE ; 97.031 45, 0.992
040B2E FD 00 00    0899*       dl 0x0000FD ; 98.438 46, 0.989
040B31 FC 00 00    0900*       dl 0x0000FC ; 99.844 47, 0.985
040B34 FB 00 00    0901*       dl 0x0000FB ; 101.250 48, 0.981
040B37 F9 00 00    0902*       dl 0x0000F9 ; 102.656 49, 0.976
040B3A F8 00 00    0903*       dl 0x0000F8 ; 104.063 4A, 0.970
040B3D F6 00 00    0904*       dl 0x0000F6 ; 105.469 4B, 0.964
040B40 F4 00 00    0905*       dl 0x0000F4 ; 106.875 4C, 0.957
040B43 F3 00 00    0906*       dl 0x0000F3 ; 108.281 4D, 0.950
040B46 F1 00 00    0907*       dl 0x0000F1 ; 109.688 4E, 0.942
040B49 EE 00 00    0908*       dl 0x0000EE ; 111.094 4F, 0.933
040B4C EC 00 00    0909*       dl 0x0000EC ; 112.500 50, 0.924
040B4F EA 00 00    0910*       dl 0x0000EA ; 113.906 51, 0.914
040B52 E7 00 00    0911*       dl 0x0000E7 ; 115.313 52, 0.904
040B55 E4 00 00    0912*       dl 0x0000E4 ; 116.719 53, 0.893
040B58 E1 00 00    0913*       dl 0x0000E1 ; 118.125 54, 0.882
040B5B DE 00 00    0914*       dl 0x0000DE ; 119.531 55, 0.870
040B5E DB 00 00    0915*       dl 0x0000DB ; 120.938 56, 0.858
040B61 D8 00 00    0916*       dl 0x0000D8 ; 122.344 57, 0.845
040B64 D4 00 00    0917*       dl 0x0000D4 ; 123.750 58, 0.831
040B67 D1 00 00    0918*       dl 0x0000D1 ; 125.156 59, 0.818
040B6A CD 00 00    0919*       dl 0x0000CD ; 126.563 5A, 0.803
040B6D C9 00 00    0920*       dl 0x0000C9 ; 127.969 5B, 0.788
040B70 C5 00 00    0921*       dl 0x0000C5 ; 129.375 5C, 0.773
040B73 C1 00 00    0922*       dl 0x0000C1 ; 130.781 5D, 0.757
040B76 BD 00 00    0923*       dl 0x0000BD ; 132.188 5E, 0.741
040B79 B9 00 00    0924*       dl 0x0000B9 ; 133.594 5F, 0.724
040B7C B5 00 00    0925*       dl 0x0000B5 ; 135.000 60, 0.707
040B7F B0 00 00    0926*       dl 0x0000B0 ; 136.406 61, 0.690
040B82 AB 00 00    0927*       dl 0x0000AB ; 137.813 62, 0.672
040B85 A7 00 00    0928*       dl 0x0000A7 ; 139.219 63, 0.653
040B88 A2 00 00    0929*       dl 0x0000A2 ; 140.625 64, 0.634
040B8B 9D 00 00    0930*       dl 0x00009D ; 142.031 65, 0.615
040B8E 98 00 00    0931*       dl 0x000098 ; 143.438 66, 0.596
040B91 93 00 00    0932*       dl 0x000093 ; 144.844 67, 0.576
040B94 8E 00 00    0933*       dl 0x00008E ; 146.250 68, 0.556
040B97 88 00 00    0934*       dl 0x000088 ; 147.656 69, 0.535
040B9A 83 00 00    0935*       dl 0x000083 ; 149.063 6A, 0.514
040B9D 7E 00 00    0936*       dl 0x00007E ; 150.469 6B, 0.493
040BA0 78 00 00    0937*       dl 0x000078 ; 151.875 6C, 0.471
040BA3 73 00 00    0938*       dl 0x000073 ; 153.281 6D, 0.450
040BA6 6D 00 00    0939*       dl 0x00006D ; 154.688 6E, 0.428
040BA9 67 00 00    0940*       dl 0x000067 ; 156.094 6F, 0.405
040BAC 61 00 00    0941*       dl 0x000061 ; 157.500 70, 0.383
040BAF 5C 00 00    0942*       dl 0x00005C ; 158.906 71, 0.360
040BB2 56 00 00    0943*       dl 0x000056 ; 160.313 72, 0.337
040BB5 50 00 00    0944*       dl 0x000050 ; 161.719 73, 0.314
040BB8 4A 00 00    0945*       dl 0x00004A ; 163.125 74, 0.290
040BBB 44 00 00    0946*       dl 0x000044 ; 164.531 75, 0.267
040BBE 3E 00 00    0947*       dl 0x00003E ; 165.938 76, 0.243
040BC1 38 00 00    0948*       dl 0x000038 ; 167.344 77, 0.219
040BC4 31 00 00    0949*       dl 0x000031 ; 168.750 78, 0.195
040BC7 2B 00 00    0950*       dl 0x00002B ; 170.156 79, 0.171
040BCA 25 00 00    0951*       dl 0x000025 ; 171.563 7A, 0.147
040BCD 1F 00 00    0952*       dl 0x00001F ; 172.969 7B, 0.122
040BD0 19 00 00    0953*       dl 0x000019 ; 174.375 7C, 0.098
040BD3 12 00 00    0954*       dl 0x000012 ; 175.781 7D, 0.074
040BD6 0C 00 00    0955*       dl 0x00000C ; 177.188 7E, 0.049
040BD9 06 00 00    0956*       dl 0x000006 ; 178.594 7F, 0.025
040BDC 00 00 00    0957*       dl 0x000000 ; 180.000 80, 0.000
040BDF FA FF FF    0958*       dl 0xFFFFFA ; 181.406 81, -0.025
040BE2 F4 FF FF    0959*       dl 0xFFFFF4 ; 182.813 82, -0.049
040BE5 EE FF FF    0960*       dl 0xFFFFEE ; 184.219 83, -0.074
040BE8 E7 FF FF    0961*       dl 0xFFFFE7 ; 185.625 84, -0.098
040BEB E1 FF FF    0962*       dl 0xFFFFE1 ; 187.031 85, -0.122
040BEE DB FF FF    0963*       dl 0xFFFFDB ; 188.438 86, -0.147
040BF1 D5 FF FF    0964*       dl 0xFFFFD5 ; 189.844 87, -0.171
040BF4 CF FF FF    0965*       dl 0xFFFFCF ; 191.250 88, -0.195
040BF7 C8 FF FF    0966*       dl 0xFFFFC8 ; 192.656 89, -0.219
040BFA C2 FF FF    0967*       dl 0xFFFFC2 ; 194.063 8A, -0.243
040BFD BC FF FF    0968*       dl 0xFFFFBC ; 195.469 8B, -0.267
040C00 B6 FF FF    0969*       dl 0xFFFFB6 ; 196.875 8C, -0.290
040C03 B0 FF FF    0970*       dl 0xFFFFB0 ; 198.281 8D, -0.314
040C06 AA FF FF    0971*       dl 0xFFFFAA ; 199.688 8E, -0.337
040C09 A4 FF FF    0972*       dl 0xFFFFA4 ; 201.094 8F, -0.360
040C0C 9F FF FF    0973*       dl 0xFFFF9F ; 202.500 90, -0.383
040C0F 99 FF FF    0974*       dl 0xFFFF99 ; 203.906 91, -0.405
040C12 93 FF FF    0975*       dl 0xFFFF93 ; 205.313 92, -0.428
040C15 8D FF FF    0976*       dl 0xFFFF8D ; 206.719 93, -0.450
040C18 88 FF FF    0977*       dl 0xFFFF88 ; 208.125 94, -0.471
040C1B 82 FF FF    0978*       dl 0xFFFF82 ; 209.531 95, -0.493
040C1E 7D FF FF    0979*       dl 0xFFFF7D ; 210.938 96, -0.514
040C21 78 FF FF    0980*       dl 0xFFFF78 ; 212.344 97, -0.535
040C24 72 FF FF    0981*       dl 0xFFFF72 ; 213.750 98, -0.556
040C27 6D FF FF    0982*       dl 0xFFFF6D ; 215.156 99, -0.576
040C2A 68 FF FF    0983*       dl 0xFFFF68 ; 216.563 9A, -0.596
040C2D 63 FF FF    0984*       dl 0xFFFF63 ; 217.969 9B, -0.615
040C30 5E FF FF    0985*       dl 0xFFFF5E ; 219.375 9C, -0.634
040C33 59 FF FF    0986*       dl 0xFFFF59 ; 220.781 9D, -0.653
040C36 55 FF FF    0987*       dl 0xFFFF55 ; 222.188 9E, -0.672
040C39 50 FF FF    0988*       dl 0xFFFF50 ; 223.594 9F, -0.690
040C3C 4B FF FF    0989*       dl 0xFFFF4B ; 225.000 A0, -0.707
040C3F 47 FF FF    0990*       dl 0xFFFF47 ; 226.406 A1, -0.724
040C42 43 FF FF    0991*       dl 0xFFFF43 ; 227.813 A2, -0.741
040C45 3F FF FF    0992*       dl 0xFFFF3F ; 229.219 A3, -0.757
040C48 3B FF FF    0993*       dl 0xFFFF3B ; 230.625 A4, -0.773
040C4B 37 FF FF    0994*       dl 0xFFFF37 ; 232.031 A5, -0.788
040C4E 33 FF FF    0995*       dl 0xFFFF33 ; 233.438 A6, -0.803
040C51 2F FF FF    0996*       dl 0xFFFF2F ; 234.844 A7, -0.818
040C54 2C FF FF    0997*       dl 0xFFFF2C ; 236.250 A8, -0.831
040C57 28 FF FF    0998*       dl 0xFFFF28 ; 237.656 A9, -0.845
040C5A 25 FF FF    0999*       dl 0xFFFF25 ; 239.063 AA, -0.858
040C5D 22 FF FF    1000*       dl 0xFFFF22 ; 240.469 AB, -0.870
040C60 1F FF FF    1001*       dl 0xFFFF1F ; 241.875 AC, -0.882
040C63 1C FF FF    1002*       dl 0xFFFF1C ; 243.281 AD, -0.893
040C66 19 FF FF    1003*       dl 0xFFFF19 ; 244.688 AE, -0.904
040C69 16 FF FF    1004*       dl 0xFFFF16 ; 246.094 AF, -0.914
040C6C 14 FF FF    1005*       dl 0xFFFF14 ; 247.500 B0, -0.924
040C6F 12 FF FF    1006*       dl 0xFFFF12 ; 248.906 B1, -0.933
040C72 0F FF FF    1007*       dl 0xFFFF0F ; 250.313 B2, -0.942
040C75 0D FF FF    1008*       dl 0xFFFF0D ; 251.719 B3, -0.950
040C78 0C FF FF    1009*       dl 0xFFFF0C ; 253.125 B4, -0.957
040C7B 0A FF FF    1010*       dl 0xFFFF0A ; 254.531 B5, -0.964
040C7E 08 FF FF    1011*       dl 0xFFFF08 ; 255.938 B6, -0.970
040C81 07 FF FF    1012*       dl 0xFFFF07 ; 257.344 B7, -0.976
040C84 05 FF FF    1013*       dl 0xFFFF05 ; 258.750 B8, -0.981
040C87 04 FF FF    1014*       dl 0xFFFF04 ; 260.156 B9, -0.985
040C8A 03 FF FF    1015*       dl 0xFFFF03 ; 261.563 BA, -0.989
040C8D 02 FF FF    1016*       dl 0xFFFF02 ; 262.969 BB, -0.992
040C90 02 FF FF    1017*       dl 0xFFFF02 ; 264.375 BC, -0.995
040C93 01 FF FF    1018*       dl 0xFFFF01 ; 265.781 BD, -0.997
040C96 01 FF FF    1019*       dl 0xFFFF01 ; 267.188 BE, -0.999
040C99 01 FF FF    1020*       dl 0xFFFF01 ; 268.594 BF, -1.000
040C9C 00 FF FF    1021*       dl 0xFFFF00 ; 270.000 C0, -1.000
040C9F 01 FF FF    1022*       dl 0xFFFF01 ; 271.406 C1, -1.000
040CA2 01 FF FF    1023*       dl 0xFFFF01 ; 272.813 C2, -0.999
040CA5 01 FF FF    1024*       dl 0xFFFF01 ; 274.219 C3, -0.997
040CA8 02 FF FF    1025*       dl 0xFFFF02 ; 275.625 C4, -0.995
040CAB 02 FF FF    1026*       dl 0xFFFF02 ; 277.031 C5, -0.992
040CAE 03 FF FF    1027*       dl 0xFFFF03 ; 278.438 C6, -0.989
040CB1 04 FF FF    1028*       dl 0xFFFF04 ; 279.844 C7, -0.985
040CB4 05 FF FF    1029*       dl 0xFFFF05 ; 281.250 C8, -0.981
040CB7 07 FF FF    1030*       dl 0xFFFF07 ; 282.656 C9, -0.976
040CBA 08 FF FF    1031*       dl 0xFFFF08 ; 284.063 CA, -0.970
040CBD 0A FF FF    1032*       dl 0xFFFF0A ; 285.469 CB, -0.964
040CC0 0C FF FF    1033*       dl 0xFFFF0C ; 286.875 CC, -0.957
040CC3 0D FF FF    1034*       dl 0xFFFF0D ; 288.281 CD, -0.950
040CC6 0F FF FF    1035*       dl 0xFFFF0F ; 289.688 CE, -0.942
040CC9 12 FF FF    1036*       dl 0xFFFF12 ; 291.094 CF, -0.933
040CCC 14 FF FF    1037*       dl 0xFFFF14 ; 292.500 D0, -0.924
040CCF 16 FF FF    1038*       dl 0xFFFF16 ; 293.906 D1, -0.914
040CD2 19 FF FF    1039*       dl 0xFFFF19 ; 295.313 D2, -0.904
040CD5 1C FF FF    1040*       dl 0xFFFF1C ; 296.719 D3, -0.893
040CD8 1F FF FF    1041*       dl 0xFFFF1F ; 298.125 D4, -0.882
040CDB 22 FF FF    1042*       dl 0xFFFF22 ; 299.531 D5, -0.870
040CDE 25 FF FF    1043*       dl 0xFFFF25 ; 300.938 D6, -0.858
040CE1 28 FF FF    1044*       dl 0xFFFF28 ; 302.344 D7, -0.845
040CE4 2C FF FF    1045*       dl 0xFFFF2C ; 303.750 D8, -0.831
040CE7 2F FF FF    1046*       dl 0xFFFF2F ; 305.156 D9, -0.818
040CEA 33 FF FF    1047*       dl 0xFFFF33 ; 306.563 DA, -0.803
040CED 37 FF FF    1048*       dl 0xFFFF37 ; 307.969 DB, -0.788
040CF0 3B FF FF    1049*       dl 0xFFFF3B ; 309.375 DC, -0.773
040CF3 3F FF FF    1050*       dl 0xFFFF3F ; 310.781 DD, -0.757
040CF6 43 FF FF    1051*       dl 0xFFFF43 ; 312.188 DE, -0.741
040CF9 47 FF FF    1052*       dl 0xFFFF47 ; 313.594 DF, -0.724
040CFC 4B FF FF    1053*       dl 0xFFFF4B ; 315.000 E0, -0.707
040CFF 50 FF FF    1054*       dl 0xFFFF50 ; 316.406 E1, -0.690
040D02 55 FF FF    1055*       dl 0xFFFF55 ; 317.813 E2, -0.672
040D05 59 FF FF    1056*       dl 0xFFFF59 ; 319.219 E3, -0.653
040D08 5E FF FF    1057*       dl 0xFFFF5E ; 320.625 E4, -0.634
040D0B 63 FF FF    1058*       dl 0xFFFF63 ; 322.031 E5, -0.615
040D0E 68 FF FF    1059*       dl 0xFFFF68 ; 323.438 E6, -0.596
040D11 6D FF FF    1060*       dl 0xFFFF6D ; 324.844 E7, -0.576
040D14 72 FF FF    1061*       dl 0xFFFF72 ; 326.250 E8, -0.556
040D17 78 FF FF    1062*       dl 0xFFFF78 ; 327.656 E9, -0.535
040D1A 7D FF FF    1063*       dl 0xFFFF7D ; 329.063 EA, -0.514
040D1D 82 FF FF    1064*       dl 0xFFFF82 ; 330.469 EB, -0.493
040D20 88 FF FF    1065*       dl 0xFFFF88 ; 331.875 EC, -0.471
040D23 8D FF FF    1066*       dl 0xFFFF8D ; 333.281 ED, -0.450
040D26 93 FF FF    1067*       dl 0xFFFF93 ; 334.688 EE, -0.428
040D29 99 FF FF    1068*       dl 0xFFFF99 ; 336.094 EF, -0.405
040D2C 9F FF FF    1069*       dl 0xFFFF9F ; 337.500 F0, -0.383
040D2F A4 FF FF    1070*       dl 0xFFFFA4 ; 338.906 F1, -0.360
040D32 AA FF FF    1071*       dl 0xFFFFAA ; 340.313 F2, -0.337
040D35 B0 FF FF    1072*       dl 0xFFFFB0 ; 341.719 F3, -0.314
040D38 B6 FF FF    1073*       dl 0xFFFFB6 ; 343.125 F4, -0.290
040D3B BC FF FF    1074*       dl 0xFFFFBC ; 344.531 F5, -0.267
040D3E C2 FF FF    1075*       dl 0xFFFFC2 ; 345.938 F6, -0.243
040D41 C8 FF FF    1076*       dl 0xFFFFC8 ; 347.344 F7, -0.219
040D44 CF FF FF    1077*       dl 0xFFFFCF ; 348.750 F8, -0.195
040D47 D5 FF FF    1078*       dl 0xFFFFD5 ; 350.156 F9, -0.171
040D4A DB FF FF    1079*       dl 0xFFFFDB ; 351.563 FA, -0.147
040D4D E1 FF FF    1080*       dl 0xFFFFE1 ; 352.969 FB, -0.122
040D50 E7 FF FF    1081*       dl 0xFFFFE7 ; 354.375 FC, -0.098
040D53 EE FF FF    1082*       dl 0xFFFFEE ; 355.781 FD, -0.074
040D56 F4 FF FF    1083*       dl 0xFFFFF4 ; 357.188 FE, -0.049
040D59 FA FF FF    1084*       dl 0xFFFFFA ; 358.594 FF, -0.025
040D5C 00 00 00    1085*       dl 0x000000 ; 0.000 00, 0.000 for interpolation
040D5F             1086*   
040D5F             1087*   atan_lut_168:
040D5F 00 00 00    1088*       dl 0x000000 ; 000000, 0.000
040D62 28 00 00    1089*       dl 0x000028 ; 000001, 0.224
040D65 51 00 00    1090*       dl 0x000051 ; 000002, 0.448
040D68 7A 00 00    1091*       dl 0x00007A ; 000003, 0.671
040D6B A2 00 00    1092*       dl 0x0000A2 ; 000004, 0.895
040D6E CB 00 00    1093*       dl 0x0000CB ; 000005, 1.119
040D71 F4 00 00    1094*       dl 0x0000F4 ; 000006, 1.343
040D74 1D 01 00    1095*       dl 0x00011D ; 000007, 1.566
040D77 45 01 00    1096*       dl 0x000145 ; 000008, 1.790
040D7A 6E 01 00    1097*       dl 0x00016E ; 000009, 2.013
040D7D 97 01 00    1098*       dl 0x000197 ; 00000A, 2.237
040D80 BF 01 00    1099*       dl 0x0001BF ; 00000B, 2.460
040D83 E8 01 00    1100*       dl 0x0001E8 ; 00000C, 2.684
040D86 11 02 00    1101*       dl 0x000211 ; 00000D, 2.907
040D89 39 02 00    1102*       dl 0x000239 ; 00000E, 3.130
040D8C 62 02 00    1103*       dl 0x000262 ; 00000F, 3.353
040D8F 8B 02 00    1104*       dl 0x00028B ; 000010, 3.576
040D92 B3 02 00    1105*       dl 0x0002B3 ; 000011, 3.799
040D95 DC 02 00    1106*       dl 0x0002DC ; 000012, 4.022
040D98 04 03 00    1107*       dl 0x000304 ; 000013, 4.245
040D9B 2D 03 00    1108*       dl 0x00032D ; 000014, 4.467
040D9E 55 03 00    1109*       dl 0x000355 ; 000015, 4.690
040DA1 7E 03 00    1110*       dl 0x00037E ; 000016, 4.912
040DA4 A6 03 00    1111*       dl 0x0003A6 ; 000017, 5.134
040DA7 CE 03 00    1112*       dl 0x0003CE ; 000018, 5.356
040DAA F7 03 00    1113*       dl 0x0003F7 ; 000019, 5.578
040DAD 1F 04 00    1114*       dl 0x00041F ; 00001A, 5.799
040DB0 48 04 00    1115*       dl 0x000448 ; 00001B, 6.021
040DB3 70 04 00    1116*       dl 0x000470 ; 00001C, 6.242
040DB6 98 04 00    1117*       dl 0x000498 ; 00001D, 6.463
040DB9 C0 04 00    1118*       dl 0x0004C0 ; 00001E, 6.684
040DBC E8 04 00    1119*       dl 0x0004E8 ; 00001F, 6.905
040DBF 11 05 00    1120*       dl 0x000511 ; 000020, 7.125
040DC2 39 05 00    1121*       dl 0x000539 ; 000021, 7.345
040DC5 61 05 00    1122*       dl 0x000561 ; 000022, 7.565
040DC8 89 05 00    1123*       dl 0x000589 ; 000023, 7.785
040DCB B1 05 00    1124*       dl 0x0005B1 ; 000024, 8.005
040DCE D9 05 00    1125*       dl 0x0005D9 ; 000025, 8.224
040DD1 01 06 00    1126*       dl 0x000601 ; 000026, 8.443
040DD4 28 06 00    1127*       dl 0x000628 ; 000027, 8.662
040DD7 50 06 00    1128*       dl 0x000650 ; 000028, 8.881
040DDA 78 06 00    1129*       dl 0x000678 ; 000029, 9.099
040DDD A0 06 00    1130*       dl 0x0006A0 ; 00002A, 9.317
040DE0 C7 06 00    1131*       dl 0x0006C7 ; 00002B, 9.535
040DE3 EF 06 00    1132*       dl 0x0006EF ; 00002C, 9.752
040DE6 16 07 00    1133*       dl 0x000716 ; 00002D, 9.970
040DE9 3E 07 00    1134*       dl 0x00073E ; 00002E, 10.187
040DEC 65 07 00    1135*       dl 0x000765 ; 00002F, 10.403
040DEF 8D 07 00    1136*       dl 0x00078D ; 000030, 10.620
040DF2 B4 07 00    1137*       dl 0x0007B4 ; 000031, 10.836
040DF5 DB 07 00    1138*       dl 0x0007DB ; 000032, 11.051
040DF8 03 08 00    1139*       dl 0x000803 ; 000033, 11.267
040DFB 2A 08 00    1140*       dl 0x00082A ; 000034, 11.482
040DFE 51 08 00    1141*       dl 0x000851 ; 000035, 11.697
040E01 78 08 00    1142*       dl 0x000878 ; 000036, 11.911
040E04 9F 08 00    1143*       dl 0x00089F ; 000037, 12.125
040E07 C6 08 00    1144*       dl 0x0008C6 ; 000038, 12.339
040E0A ED 08 00    1145*       dl 0x0008ED ; 000039, 12.553
040E0D 13 09 00    1146*       dl 0x000913 ; 00003A, 12.766
040E10 3A 09 00    1147*       dl 0x00093A ; 00003B, 12.978
040E13 61 09 00    1148*       dl 0x000961 ; 00003C, 13.191
040E16 87 09 00    1149*       dl 0x000987 ; 00003D, 13.403
040E19 AE 09 00    1150*       dl 0x0009AE ; 00003E, 13.614
040E1C D4 09 00    1151*       dl 0x0009D4 ; 00003F, 13.825
040E1F FB 09 00    1152*       dl 0x0009FB ; 000040, 14.036
040E22 21 0A 00    1153*       dl 0x000A21 ; 000041, 14.247
040E25 47 0A 00    1154*       dl 0x000A47 ; 000042, 14.457
040E28 6D 0A 00    1155*       dl 0x000A6D ; 000043, 14.666
040E2B 94 0A 00    1156*       dl 0x000A94 ; 000044, 14.876
040E2E BA 0A 00    1157*       dl 0x000ABA ; 000045, 15.085
040E31 E0 0A 00    1158*       dl 0x000AE0 ; 000046, 15.293
040E34 05 0B 00    1159*       dl 0x000B05 ; 000047, 15.501
040E37 2B 0B 00    1160*       dl 0x000B2B ; 000048, 15.709
040E3A 51 0B 00    1161*       dl 0x000B51 ; 000049, 15.916
040E3D 77 0B 00    1162*       dl 0x000B77 ; 00004A, 16.123
040E40 9C 0B 00    1163*       dl 0x000B9C ; 00004B, 16.329
040E43 C2 0B 00    1164*       dl 0x000BC2 ; 00004C, 16.535
040E46 E7 0B 00    1165*       dl 0x000BE7 ; 00004D, 16.740
040E49 0C 0C 00    1166*       dl 0x000C0C ; 00004E, 16.945
040E4C 32 0C 00    1167*       dl 0x000C32 ; 00004F, 17.150
040E4F 57 0C 00    1168*       dl 0x000C57 ; 000050, 17.354
040E52 7C 0C 00    1169*       dl 0x000C7C ; 000051, 17.558
040E55 A1 0C 00    1170*       dl 0x000CA1 ; 000052, 17.761
040E58 C6 0C 00    1171*       dl 0x000CC6 ; 000053, 17.964
040E5B EB 0C 00    1172*       dl 0x000CEB ; 000054, 18.166
040E5E 0F 0D 00    1173*       dl 0x000D0F ; 000055, 18.368
040E61 34 0D 00    1174*       dl 0x000D34 ; 000056, 18.569
040E64 58 0D 00    1175*       dl 0x000D58 ; 000057, 18.770
040E67 7D 0D 00    1176*       dl 0x000D7D ; 000058, 18.970
040E6A A1 0D 00    1177*       dl 0x000DA1 ; 000059, 19.170
040E6D C6 0D 00    1178*       dl 0x000DC6 ; 00005A, 19.370
040E70 EA 0D 00    1179*       dl 0x000DEA ; 00005B, 19.569
040E73 0E 0E 00    1180*       dl 0x000E0E ; 00005C, 19.767
040E76 32 0E 00    1181*       dl 0x000E32 ; 00005D, 19.965
040E79 56 0E 00    1182*       dl 0x000E56 ; 00005E, 20.163
040E7C 7A 0E 00    1183*       dl 0x000E7A ; 00005F, 20.360
040E7F 9E 0E 00    1184*       dl 0x000E9E ; 000060, 20.556
040E82 C1 0E 00    1185*       dl 0x000EC1 ; 000061, 20.752
040E85 E5 0E 00    1186*       dl 0x000EE5 ; 000062, 20.947
040E88 08 0F 00    1187*       dl 0x000F08 ; 000063, 21.142
040E8B 2C 0F 00    1188*       dl 0x000F2C ; 000064, 21.337
040E8E 4F 0F 00    1189*       dl 0x000F4F ; 000065, 21.531
040E91 72 0F 00    1190*       dl 0x000F72 ; 000066, 21.724
040E94 95 0F 00    1191*       dl 0x000F95 ; 000067, 21.917
040E97 B8 0F 00    1192*       dl 0x000FB8 ; 000068, 22.109
040E9A DB 0F 00    1193*       dl 0x000FDB ; 000069, 22.301
040E9D FE 0F 00    1194*       dl 0x000FFE ; 00006A, 22.493
040EA0 21 10 00    1195*       dl 0x001021 ; 00006B, 22.683
040EA3 44 10 00    1196*       dl 0x001044 ; 00006C, 22.874
040EA6 66 10 00    1197*       dl 0x001066 ; 00006D, 23.063
040EA9 89 10 00    1198*       dl 0x001089 ; 00006E, 23.253
040EAC AB 10 00    1199*       dl 0x0010AB ; 00006F, 23.441
040EAF CD 10 00    1200*       dl 0x0010CD ; 000070, 23.629
040EB2 EF 10 00    1201*       dl 0x0010EF ; 000071, 23.817
040EB5 11 11 00    1202*       dl 0x001111 ; 000072, 24.004
040EB8 33 11 00    1203*       dl 0x001133 ; 000073, 24.191
040EBB 55 11 00    1204*       dl 0x001155 ; 000074, 24.376
040EBE 77 11 00    1205*       dl 0x001177 ; 000075, 24.562
040EC1 99 11 00    1206*       dl 0x001199 ; 000076, 24.747
040EC4 BA 11 00    1207*       dl 0x0011BA ; 000077, 24.931
040EC7 DC 11 00    1208*       dl 0x0011DC ; 000078, 25.115
040ECA FD 11 00    1209*       dl 0x0011FD ; 000079, 25.298
040ECD 1E 12 00    1210*       dl 0x00121E ; 00007A, 25.481
040ED0 3F 12 00    1211*       dl 0x00123F ; 00007B, 25.663
040ED3 60 12 00    1212*       dl 0x001260 ; 00007C, 25.844
040ED6 81 12 00    1213*       dl 0x001281 ; 00007D, 26.025
040ED9 A2 12 00    1214*       dl 0x0012A2 ; 00007E, 26.206
040EDC C3 12 00    1215*       dl 0x0012C3 ; 00007F, 26.386
040EDF E4 12 00    1216*       dl 0x0012E4 ; 000080, 26.565
040EE2 04 13 00    1217*       dl 0x001304 ; 000081, 26.744
040EE5 25 13 00    1218*       dl 0x001325 ; 000082, 26.922
040EE8 45 13 00    1219*       dl 0x001345 ; 000083, 27.100
040EEB 65 13 00    1220*       dl 0x001365 ; 000084, 27.277
040EEE 85 13 00    1221*       dl 0x001385 ; 000085, 27.453
040EF1 A5 13 00    1222*       dl 0x0013A5 ; 000086, 27.629
040EF4 C5 13 00    1223*       dl 0x0013C5 ; 000087, 27.805
040EF7 E5 13 00    1224*       dl 0x0013E5 ; 000088, 27.979
040EFA 05 14 00    1225*       dl 0x001405 ; 000089, 28.154
040EFD 24 14 00    1226*       dl 0x001424 ; 00008A, 28.327
040F00 44 14 00    1227*       dl 0x001444 ; 00008B, 28.501
040F03 63 14 00    1228*       dl 0x001463 ; 00008C, 28.673
040F06 83 14 00    1229*       dl 0x001483 ; 00008D, 28.845
040F09 A2 14 00    1230*       dl 0x0014A2 ; 00008E, 29.017
040F0C C1 14 00    1231*       dl 0x0014C1 ; 00008F, 29.187
040F0F E0 14 00    1232*       dl 0x0014E0 ; 000090, 29.358
040F12 FF 14 00    1233*       dl 0x0014FF ; 000091, 29.527
040F15 1E 15 00    1234*       dl 0x00151E ; 000092, 29.697
040F18 3C 15 00    1235*       dl 0x00153C ; 000093, 29.865
040F1B 5B 15 00    1236*       dl 0x00155B ; 000094, 30.033
040F1E 79 15 00    1237*       dl 0x001579 ; 000095, 30.201
040F21 98 15 00    1238*       dl 0x001598 ; 000096, 30.368
040F24 B6 15 00    1239*       dl 0x0015B6 ; 000097, 30.534
040F27 D4 15 00    1240*       dl 0x0015D4 ; 000098, 30.700
040F2A F2 15 00    1241*       dl 0x0015F2 ; 000099, 30.865
040F2D 10 16 00    1242*       dl 0x001610 ; 00009A, 31.030
040F30 2E 16 00    1243*       dl 0x00162E ; 00009B, 31.194
040F33 4C 16 00    1244*       dl 0x00164C ; 00009C, 31.357
040F36 6A 16 00    1245*       dl 0x00166A ; 00009D, 31.520
040F39 87 16 00    1246*       dl 0x001687 ; 00009E, 31.682
040F3C A5 16 00    1247*       dl 0x0016A5 ; 00009F, 31.844
040F3F C2 16 00    1248*       dl 0x0016C2 ; 0000A0, 32.005
040F42 DF 16 00    1249*       dl 0x0016DF ; 0000A1, 32.166
040F45 FC 16 00    1250*       dl 0x0016FC ; 0000A2, 32.326
040F48 19 17 00    1251*       dl 0x001719 ; 0000A3, 32.486
040F4B 36 17 00    1252*       dl 0x001736 ; 0000A4, 32.645
040F4E 53 17 00    1253*       dl 0x001753 ; 0000A5, 32.803
040F51 70 17 00    1254*       dl 0x001770 ; 0000A6, 32.961
040F54 8C 17 00    1255*       dl 0x00178C ; 0000A7, 33.118
040F57 A9 17 00    1256*       dl 0x0017A9 ; 0000A8, 33.275
040F5A C5 17 00    1257*       dl 0x0017C5 ; 0000A9, 33.431
040F5D E2 17 00    1258*       dl 0x0017E2 ; 0000AA, 33.587
040F60 FE 17 00    1259*       dl 0x0017FE ; 0000AB, 33.742
040F63 1A 18 00    1260*       dl 0x00181A ; 0000AC, 33.896
040F66 36 18 00    1261*       dl 0x001836 ; 0000AD, 34.050
040F69 52 18 00    1262*       dl 0x001852 ; 0000AE, 34.203
040F6C 6E 18 00    1263*       dl 0x00186E ; 0000AF, 34.356
040F6F 8A 18 00    1264*       dl 0x00188A ; 0000B0, 34.509
040F72 A5 18 00    1265*       dl 0x0018A5 ; 0000B1, 34.660
040F75 C1 18 00    1266*       dl 0x0018C1 ; 0000B2, 34.811
040F78 DC 18 00    1267*       dl 0x0018DC ; 0000B3, 34.962
040F7B F7 18 00    1268*       dl 0x0018F7 ; 0000B4, 35.112
040F7E 13 19 00    1269*       dl 0x001913 ; 0000B5, 35.262
040F81 2E 19 00    1270*       dl 0x00192E ; 0000B6, 35.410
040F84 49 19 00    1271*       dl 0x001949 ; 0000B7, 35.559
040F87 64 19 00    1272*       dl 0x001964 ; 0000B8, 35.707
040F8A 7F 19 00    1273*       dl 0x00197F ; 0000B9, 35.854
040F8D 99 19 00    1274*       dl 0x001999 ; 0000BA, 36.001
040F90 B4 19 00    1275*       dl 0x0019B4 ; 0000BB, 36.147
040F93 CE 19 00    1276*       dl 0x0019CE ; 0000BC, 36.293
040F96 E9 19 00    1277*       dl 0x0019E9 ; 0000BD, 36.438
040F99 03 1A 00    1278*       dl 0x001A03 ; 0000BE, 36.582
040F9C 1D 1A 00    1279*       dl 0x001A1D ; 0000BF, 36.726
040F9F 37 1A 00    1280*       dl 0x001A37 ; 0000C0, 36.870
040FA2 51 1A 00    1281*       dl 0x001A51 ; 0000C1, 37.013
040FA5 6B 1A 00    1282*       dl 0x001A6B ; 0000C2, 37.155
040FA8 85 1A 00    1283*       dl 0x001A85 ; 0000C3, 37.297
040FAB 9F 1A 00    1284*       dl 0x001A9F ; 0000C4, 37.439
040FAE B9 1A 00    1285*       dl 0x001AB9 ; 0000C5, 37.579
040FB1 D2 1A 00    1286*       dl 0x001AD2 ; 0000C6, 37.720
040FB4 EC 1A 00    1287*       dl 0x001AEC ; 0000C7, 37.859
040FB7 05 1B 00    1288*       dl 0x001B05 ; 0000C8, 37.999
040FBA 1E 1B 00    1289*       dl 0x001B1E ; 0000C9, 38.137
040FBD 37 1B 00    1290*       dl 0x001B37 ; 0000CA, 38.276
040FC0 50 1B 00    1291*       dl 0x001B50 ; 0000CB, 38.413
040FC3 69 1B 00    1292*       dl 0x001B69 ; 0000CC, 38.550
040FC6 82 1B 00    1293*       dl 0x001B82 ; 0000CD, 38.687
040FC9 9B 1B 00    1294*       dl 0x001B9B ; 0000CE, 38.823
040FCC B4 1B 00    1295*       dl 0x001BB4 ; 0000CF, 38.959
040FCF CC 1B 00    1296*       dl 0x001BCC ; 0000D0, 39.094
040FD2 E5 1B 00    1297*       dl 0x001BE5 ; 0000D1, 39.228
040FD5 FD 1B 00    1298*       dl 0x001BFD ; 0000D2, 39.362
040FD8 16 1C 00    1299*       dl 0x001C16 ; 0000D3, 39.496
040FDB 2E 1C 00    1300*       dl 0x001C2E ; 0000D4, 39.629
040FDE 46 1C 00    1301*       dl 0x001C46 ; 0000D5, 39.762
040FE1 5E 1C 00    1302*       dl 0x001C5E ; 0000D6, 39.894
040FE4 76 1C 00    1303*       dl 0x001C76 ; 0000D7, 40.025
040FE7 8E 1C 00    1304*       dl 0x001C8E ; 0000D8, 40.156
040FEA A5 1C 00    1305*       dl 0x001CA5 ; 0000D9, 40.286
040FED BD 1C 00    1306*       dl 0x001CBD ; 0000DA, 40.416
040FF0 D5 1C 00    1307*       dl 0x001CD5 ; 0000DB, 40.546
040FF3 EC 1C 00    1308*       dl 0x001CEC ; 0000DC, 40.675
040FF6 04 1D 00    1309*       dl 0x001D04 ; 0000DD, 40.803
040FF9 1B 1D 00    1310*       dl 0x001D1B ; 0000DE, 40.931
040FFC 32 1D 00    1311*       dl 0x001D32 ; 0000DF, 41.059
040FFF 49 1D 00    1312*       dl 0x001D49 ; 0000E0, 41.186
041002 60 1D 00    1313*       dl 0x001D60 ; 0000E1, 41.312
041005 77 1D 00    1314*       dl 0x001D77 ; 0000E2, 41.438
041008 8E 1D 00    1315*       dl 0x001D8E ; 0000E3, 41.564
04100B A5 1D 00    1316*       dl 0x001DA5 ; 0000E4, 41.689
04100E BB 1D 00    1317*       dl 0x001DBB ; 0000E5, 41.814
041011 D2 1D 00    1318*       dl 0x001DD2 ; 0000E6, 41.938
041014 E9 1D 00    1319*       dl 0x001DE9 ; 0000E7, 42.061
041017 FF 1D 00    1320*       dl 0x001DFF ; 0000E8, 42.184
04101A 15 1E 00    1321*       dl 0x001E15 ; 0000E9, 42.307
04101D 2C 1E 00    1322*       dl 0x001E2C ; 0000EA, 42.429
041020 42 1E 00    1323*       dl 0x001E42 ; 0000EB, 42.551
041023 58 1E 00    1324*       dl 0x001E58 ; 0000EC, 42.672
041026 6E 1E 00    1325*       dl 0x001E6E ; 0000ED, 42.793
041029 84 1E 00    1326*       dl 0x001E84 ; 0000EE, 42.913
04102C 99 1E 00    1327*       dl 0x001E99 ; 0000EF, 43.033
04102F AF 1E 00    1328*       dl 0x001EAF ; 0000F0, 43.152
041032 C5 1E 00    1329*       dl 0x001EC5 ; 0000F1, 43.271
041035 DA 1E 00    1330*       dl 0x001EDA ; 0000F2, 43.390
041038 F0 1E 00    1331*       dl 0x001EF0 ; 0000F3, 43.508
04103B 05 1F 00    1332*       dl 0x001F05 ; 0000F4, 43.625
04103E 1B 1F 00    1333*       dl 0x001F1B ; 0000F5, 43.742
041041 30 1F 00    1334*       dl 0x001F30 ; 0000F6, 43.859
041044 45 1F 00    1335*       dl 0x001F45 ; 0000F7, 43.975
041047 5A 1F 00    1336*       dl 0x001F5A ; 0000F8, 44.091
04104A 6F 1F 00    1337*       dl 0x001F6F ; 0000F9, 44.206
04104D 84 1F 00    1338*       dl 0x001F84 ; 0000FA, 44.321
041050 99 1F 00    1339*       dl 0x001F99 ; 0000FB, 44.435
041053 AD 1F 00    1340*       dl 0x001FAD ; 0000FC, 44.549
041056 C2 1F 00    1341*       dl 0x001FC2 ; 0000FD, 44.662
041059 D7 1F 00    1342*       dl 0x001FD7 ; 0000FE, 44.775
04105C EB 1F 00    1343*       dl 0x001FEB ; 0000FF, 44.888
04105F 00 20 00    1344*       dl 0x002000 ; 000100, 45.000 only needed for interpolation
041062             0038        include "time.inc"
041062             0001*   ; Convert seconds to HH:MM:SS format.
041062             0002*   ; inputs: hl = seconds
041062             0003*   ; outputs: hl = pointer to zero-terminated string representation of HH:MM:SS
041062             0004*   ; destroys: a,bc,de
041062             0005*   seconds_to_hhmmss:
041062             0006*   ; Divide the total seconds into hours, minutes, and seconds.
041062             0007*   ; Hours = Total seconds ÷ 3600.
041062 11 10 0E 00 0008*       ld de,3600
041066 CD 80 03 04 0009*       call udiv24 ; de = hours, hl = remaining seconds
04106A E5          0010*       push hl ; save remainder
04106B EB          0011*       ex de,hl ; hl = hours
04106C 11 C5 10 04 0012*       ld de,@bin2asc
041070 CD 28 01 04 0013*       call u8_to_ascii ; answer in @bin2asc
041074 3A C7 10 04 0014*       ld a,(@bin2asc+2)
041078 32 CF 10 04 0015*       ld (hhmmss+0),a
04107C 3A C8 10 04 0016*       ld a,(@bin2asc+3)
041080 32 D0 10 04 0017*       ld (hhmmss+1),a
041084             0018*   ; Minutes = Remaining seconds ÷ 60.
041084 E1          0019*       pop hl ; restore remainder
041085 11 3C 00 00 0020*       ld de,60
041089 CD 80 03 04 0021*       call udiv24 ; de = minutes, hl = remaining seconds
04108D E5          0022*       push hl ; save remainder
04108E EB          0023*       ex de,hl ; hl = minutes
04108F 11 C5 10 04 0024*       ld de,@bin2asc
041093 CD 28 01 04 0025*       call u8_to_ascii ; answer in @bin2asc
041097 3A C7 10 04 0026*       ld a,(@bin2asc+2)
04109B 32 D2 10 04 0027*       ld (hhmmss+3),a
04109F 3A C8 10 04 0028*       ld a,(@bin2asc+3)
0410A3 32 D3 10 04 0029*       ld (hhmmss+4),a
0410A7             0030*   ; Seconds = Remaining seconds.
0410A7 E1          0031*       pop hl ; restore remainder
0410A8 11 C5 10 04 0032*       ld de,@bin2asc
0410AC CD 28 01 04 0033*       call u8_to_ascii ; answer in @bin2asc
0410B0 3A C7 10 04 0034*       ld a,(@bin2asc+2)
0410B4 32 D5 10 04 0035*       ld (hhmmss+6),a
0410B8 3A C8 10 04 0036*       ld a,(@bin2asc+3)
0410BC 32 D6 10 04 0037*       ld (hhmmss+7),a
0410C0 21 CF 10 04 0038*       ld hl,hhmmss
0410C4 C9          0039*       ret
0410C5 00 00 00 00 0040*   @bin2asc: blkw 5,0 ; scratch space for binary to ascii decimal conversion
       00 00 00 00 
       00 00       
0410CF 30 30 3A 30 0041*   hhmmss: asciz "00:00:00" ; buffer for output string
       30 3A 30 30 
       00          
0410D8             0042*   ; end seconds_to_hhmmss
0410D8             0039        include "timer.inc"
0410D8             0001*   ; Table 32. Timer Control Registers
0410D8             0002*   TMR0_CTL: equ 80h
0410D8             0003*   TMR1_CTL: equ 83h
0410D8             0004*   TMR2_CTL: equ 86h
0410D8             0005*   TMR3_CTL: equ 89h
0410D8             0006*   TMR4_CTL: equ 8Ch
0410D8             0007*   TMR5_CTL: equ 8Fh
0410D8             0008*   
0410D8             0009*   ; each timer register takes three bytes:
0410D8             0010*   ;   0: control register
0410D8             0011*   ;   1: low byte of timer reset value
0410D8             0012*   ;   2: high byte of timer reset value
0410D8             0013*   ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
0410D8             0014*   ; which correctly force the high and upper bytes of the address bus to zero
0410D8             0015*   
0410D8             0016*   TMR_REG_CTL: equ 0
0410D8             0017*   TMR_RES_LOW: equ 1
0410D8             0018*   TMR_RES_HIGH: equ 2
0410D8             0019*   
0410D8             0020*   ; Timer Control Register Bit Definitions
0410D8             0021*   PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
0410D8             0022*                               ; This bit is reset to 0 every time the TMRx_CTL register is read.
0410D8             0023*   PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
0410D8             0024*                               ; an interrupt signal is sent to the CPU. This bit remains 1 until
0410D8             0025*                               ; the TMRx_CTL register is read.
0410D8             0026*   
0410D8             0027*   IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
0410D8             0028*   IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
0410D8             0029*   
0410D8             0030*   PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
0410D8             0031*                               ;  0,and counting stops when the end-of-count value is reached.
0410D8             0032*   PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
0410D8             0033*                               ; written to the counter when the end-of-count value is reached.
0410D8             0034*   
0410D8             0035*   ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
0410D8             0036*   CLK_DIV_256:  equ %00001100 ;
0410D8             0037*   CLK_DIV_64:   equ %00001000 ;
0410D8             0038*   CLK_DIV_16:   equ %00000100 ;
0410D8             0039*   CLK_DIV_4:    equ %00000000 ;
0410D8             0040*   
0410D8             0041*   RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
0410D8             0042*   RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
0410D8             0043*                               ; When a 1 is written to this bit,the values in the reload registers
0410D8             0044*                               ;  are loaded into the downcounter when the timer restarts. The
0410D8             0045*                               ; programmer must ensure that this bit is set to 1 each time
0410D8             0046*                               ; SINGLE-PASS mode is used.
0410D8             0047*   
0410D8             0048*   ; disable/enable the programmable reload timer
0410D8             0049*   PRT_EN_0:     equ %00000000 ;
0410D8             0050*   PRT_EN_1:     equ %00000001 ;
0410D8             0051*   
0410D8             0052*   ; Table 37. Timer Input Source Select Register
0410D8             0053*   ; Each of the 4 timers are allocated two bits of the 8-bit register
0410D8             0054*   ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
0410D8             0055*   ;   00: System clock / CLK_DIV
0410D8             0056*   ;   01: RTC / CLK_DIV
0410D8             0057*   ;   NOTE: these are the values given in the manual,but it may be a typo
0410D8             0058*   ;   10: GPIO port B pin 1.
0410D8             0059*   ;   11: GPIO port B pin 1.
0410D8             0060*   TMR_ISS:   equ 92h ; register address
0410D8             0061*   
0410D8             0062*   ; Table 51. Real-Time Clock Control Register
0410D8             0063*   RTC_CTRL: equ EDh ; register address
0410D8             0064*   
0410D8             0065*   ; alarm interrupt disable/enable
0410D8             0066*   RTC_ALARM_0:    equ %00000000
0410D8             0067*   RTC_ALARM_1:    equ %10000000
0410D8             0068*   
0410D8             0069*   ; interrupt on alarm disable/enable
0410D8             0070*   RTC_INT_ENT_0:  equ %00000000
0410D8             0071*   RTC_INT_ENT_1:  equ %01000000
0410D8             0072*   
0410D8             0073*   RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
0410D8             0074*   RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
0410D8             0075*   
0410D8             0076*   RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
0410D8             0077*                                   ; On-chip 32768 Hz oscillator is enabled.
0410D8             0078*   RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
0410D8             0079*                                   ; On-chip 32768 Hz oscillator is disabled.
0410D8             0080*   
0410D8             0081*   RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
0410D8             0082*   RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
0410D8             0083*   
0410D8             0084*   RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
0410D8             0085*   RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
0410D8             0086*   
0410D8             0087*   RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
0410D8             0088*                                   ; RTC counter is enabled.
0410D8             0089*   RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
0410D8             0090*                                   ; RTC counter is disabled.
0410D8             0091*   
0410D8             0092*   ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
0410D8             0093*   
0410D8             0094*   prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
0410D8             0095*   prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
0410D8 00 00 00    0096*   prt_reload: dl 0x000000
0410DB             0097*   
0410DB             0098*   ; returns: a = 0 if running on hardware,1 if running on emulator
0410DB             0099*   ;          de = number PRT interrupts during test interval
0410DB             0100*   prt_calibrate:
0410DB CD EA 13 04 0101*       call vdu_vblank
0410DF             0102*   ; set a MOS timer
0410DF 21 78 00 00 0103*       ld hl,120*1 ; 1 second
0410E3 FD 21 63 12 0104*       ld iy,tmr_test
       04          
0410E8 CD 41 12 04 0105*       call tmr_set
0410EC             0106*   ; set a PRT timer
0410EC             0107*       ; ld hl,prt_reload_hardware
0410EC             0108*       ; ld hl,prt_reload_emulator
0410EC 21 05 2D 00 0109*       ld hl,prt_reload_emulator + prt_reload_hardware / 2
0410F0 22 D8 10 04 0110*       ld (prt_reload),hl
0410F4 CD 7C 11 04 0111*       call prt_set
0410F8             0112*   @loop:
0410F8             0113*   ; check time remaining on MOS timer
0410F8 CD 4F 12 04 0114*       call tmr_get
0410FC CA 06 11 04 0115*       jp z,@done ; time expired,so quit
041100 FA 06 11 04 0116*       jp m,@done ; time past expiration (negative),so quit
041104 18 F2       0117*       jr @loop
041106             0118*   @done:
041106 ED 5B CA 11 0119*       ld de,(prt_irq_counter)
       04          
04110B 01 0C 2D 00 0120*       ld bc,prt_reload_hardware ; default value for running on hardware
04110F ED 43 D8 10 0121*       ld (prt_reload),bc
       04          
041114 21 64 00 00 0122*       ld hl,100 ; halfway between 101 for real hardware and 99 for emulator
041118 AF          0123*       xor a ; clear carry,zero is default value for running on hardware
041119 32 3B 11 04 0124*       ld (is_emulator),a
04111D ED 52       0125*       sbc hl,de
04111F 21 3C 11 04 0126*       ld hl,on_hardware ; default message for running on hardware
041123 CA DB 10 04 0127*       jp z,prt_calibrate ; zero result is indeterminate so we try again
041127 F8          0128*       ret m ; negative result means we're on hardware
041128 3C          0129*       inc a ; we're on emulator
041129 32 3B 11 04 0130*       ld (is_emulator),a
04112D 01 FF 2C 00 0131*       ld bc,prt_reload_emulator
041131 ED 43 D8 10 0132*       ld (prt_reload),bc
       04          
041136 21 52 11 04 0133*       ld hl,on_emulator
04113A C9          0134*       ret
04113B 00          0135*   is_emulator: db 0
04113C 52 75 6E 6E 0136*   on_hardware: defb "Running on hardware\r\n",0
       69 6E 67 20 
       6F 6E 20 68 
       61 72 64 77 
       61 72 65 0D 
       0A 00       
041152 52 75 6E 6E 0137*   on_emulator: defb "Running on emulator\r\n",0
       69 6E 67 20 
       6F 6E 20 65 
       6D 75 6C 61 
       74 6F 72 0D 
       0A 00       
041168             0138*   
041168 43 61 6C 69 0139*   calibrating_timer: defb "Calibrating timer\r\n",0
       62 72 61 74 
       69 6E 67 20 
       74 69 6D 65 
       72 0D 0A 00 
04117C             0140*   
04117C             0141*   ; set PRT timer
04117C             0142*   prt_set:
04117C 21 00 00 00 0143*       ld hl,0
041180 22 CA 11 04 0144*       ld (prt_irq_counter),hl
041184 2A D8 10 04 0145*       ld hl,(prt_reload)
041188 ED 29 84    0146*       out0 (TMR1_CTL+TMR_RES_LOW),l
04118B ED 21 85    0147*   	out0 (TMR1_CTL+TMR_RES_HIGH),h
04118E             0148*   ; disable timer
04118E 3E 06       0149*       ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
041190 ED 39 83    0150*   	out0 (TMR1_CTL+TMR_REG_CTL),a
041193             0151*   ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
041193 3E 57       0152*       ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
041195 ED 39 83    0153*   	out0 (TMR1_CTL+TMR_REG_CTL),a
041198 C9          0154*       ret
041199             0155*   
041199             0156*   ; ===============================================
041199             0157*   ; PRT Timer Interrupt Handling
041199             0158*   ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.asm
041199             0159*   ; -----------------------------------------------
041199             0160*   prt_irq_init:
041199             0161*       ; set up interrupt vector table 2
041199 21 00 00 00 0162*   	ld hl,0
04119D 3A 0C 01 00 0163*   	ld a,($10c)
0411A1 6F          0164*   	ld l,a
0411A2 3A 0D 01 00 0165*   	ld a,($10d)
0411A6 67          0166*   	ld h,a
0411A7             0167*   
0411A7             0168*   	; skip over CALL ($c3)
0411A7 23          0169*   	inc hl
0411A8             0170*   	; load address of jump into vector table 2 (in ram)
0411A8 ED 27       0171*   	ld hl,(hl)
0411AA             0172*   
0411AA             0173*   	; write CALL prt_irq_handler to vector table 2
0411AA 3E C3       0174*   	ld a,$c3
0411AC 77          0175*   	ld (hl),a
0411AD 23          0176*   	inc hl
0411AE 11 B5 11 04 0177*   	ld de,prt_irq_handler
0411B2 ED 1F       0178*   	ld (hl),de
0411B4             0179*   
0411B4 C9          0180*       ret
0411B5             0181*   
0411B5             0182*   prt_irq_handler:
0411B5 F3          0183*   	di
0411B6 F5          0184*   	push af
0411B7 E5          0185*       push hl
0411B8 ED 38 83    0186*   	in0 a,(TMR1_CTL+TMR_REG_CTL)
0411BB 2A CA 11 04 0187*   	ld hl,(prt_irq_counter)
0411BF 23          0188*   	inc hl
0411C0 22 CA 11 04 0189*   	ld (prt_irq_counter),hl
0411C4 E1          0190*       pop hl
0411C5 F1          0191*   	pop af
0411C6 FB          0192*   	ei
0411C7 5B ED 4D    0193*   	reti.l
0411CA             0194*   
0411CA             0195*   prt_irq_counter:
0411CA 00 00 00    0196*   	.dl 0
0411CD             0197*   prt_irq_counter_saved:
0411CD 00 00 00    0198*       .dl 0
0411D0             0199*   
0411D0             0200*   prt_loop_reset:
0411D0 E5          0201*       push hl
0411D1 21 00 00 00 0202*   	ld hl,0
0411D5 22 CA 11 04 0203*   	ld (prt_irq_counter),hl
0411D9 22 3B 12 04 0204*       ld (prt_loop_counter),hl
0411DD 22 3E 12 04 0205*       ld (prt_loops),hl
0411E1 CD 7C 11 04 0206*       call prt_set
0411E5 E1          0207*       pop hl
0411E6 C9          0208*       ret
0411E7             0209*   
0411E7             0210*   prt_loop_start:
0411E7 E5          0211*       push hl
0411E8 21 00 00 00 0212*   	ld hl,0
0411EC 22 CA 11 04 0213*   	ld (prt_irq_counter),hl
0411F0 E1          0214*       pop hl
0411F1 C9          0215*       ret
0411F2             0216*   
0411F2             0217*   prt_loop_stop:
0411F2 E5          0218*       push hl
0411F3 D5          0219*       push de
0411F4 2A CA 11 04 0220*       ld hl,(prt_irq_counter)
0411F8 ED 5B 3B 12 0221*       ld de,(prt_loop_counter)
       04          
0411FD 19          0222*       add hl,de
0411FE 22 3B 12 04 0223*       ld (prt_loop_counter),hl
041202 21 00 00 00 0224*       ld hl,0
041206 22 CA 11 04 0225*       ld (prt_irq_counter),hl
04120A 2A 3E 12 04 0226*       ld hl,(prt_loops)
04120E 23          0227*       inc hl
04120F 22 3E 12 04 0228*       ld (prt_loops),hl
041213 D1          0229*       pop de
041214 E1          0230*       pop hl
041215 C9          0231*       ret
041216             0232*   
041216             0233*   ; inputs: bc = y,x text coordinates to print
041216             0234*   prt_loop_print:
041216 F5          0235*       push af
041217 E5          0236*       push hl
041218 C5          0237*       push bc
041219 D5          0238*       push de
04121A DD E5       0239*       push ix
04121C FD E5       0240*       push iy
04121E CD 4E 13 04 0241*       call vdu_move_cursor
041222             0242*   
041222 2A 3B 12 04 0243*       ld hl,(prt_loop_counter)
041226 CD CC 00 04 0244*       call printDec
04122A             0245*   
04122A 2A 3E 12 04 0246*       ld hl,(prt_loops)
04122E CD CC 00 04 0247*       call printDec
041232             0248*   
041232 FD E1       0249*       pop iy
041234 DD E1       0250*       pop ix
041236 D1          0251*       pop de
041237 C1          0252*       pop bc
041238 E1          0253*       pop hl
041239 F1          0254*       pop af
04123A C9          0255*       ret
04123B             0256*   
04123B             0257*   prt_loop_counter:
04123B 00 00 00    0258*       .dl 0
04123E             0259*   prt_loops:
04123E 00 00 00    0260*       .dl 0
041241             0261*   
041241             0262*   ; ===============================================
041241             0263*   ; Timer functions
041241             0264*   ; -----------------------------------------------
041241             0265*   ; set a countdown timer
041241             0266*   ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
041241             0267*   ; returns: hl = current time
041241             0268*   tmr_set:
041241 FD 2F 03    0269*       ld (iy+3),hl            ; set time remaining
041244             0270*       MOSCALL mos_sysvars     ; ix points to syvars table
                       M1 Args: function=mos_sysvars 
041244 3E 08       0001*M1 			LD	A, function
041246 5B CF       0002*M1 			RST.LIL	08h
041248 DD 27 00    0271*       ld hl,(ix+sysvar_time)  ; get current time
04124B FD 2F 00    0272*       ld (iy+0),hl            ; set start time
04124E C9          0273*       ret
04124F             0274*   
04124F             0275*   ; gets time remaining on a countdown timer
04124F             0276*   ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
04124F             0277*   ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
04124F             0278*   ;          sign flags: pos = time not expired,zero or neg = time expired
04124F             0279*   tmr_get:
04124F             0280*       MOSCALL mos_sysvars     ; ix points to syvars table
                       M1 Args: function=mos_sysvars 
04124F 3E 08       0001*M1 			LD	A, function
041251 5B CF       0002*M1 			RST.LIL	08h
041253 DD 17 00    0281*       ld de,(ix+sysvar_time)  ; get current time
041256 FD 27 00    0282*       ld hl,(iy+0)            ; get start time
041259 AF          0283*       xor a                   ; clear carry
04125A ED 52       0284*       sbc hl,de               ; hl = time elapsed (will always be zero or negative)
04125C FD 17 03    0285*       ld de,(iy+3)            ; get timer set value
04125F AF          0286*       xor a                   ; clear carry
041260 ED 5A       0287*       adc hl,de               ; hl = time remaining
041262             0288*                               ; (we do adc because add hl,rr doesn't set sign or zero flags)
041262 C9          0289*       ret
041263             0290*   
041263             0291*   tmr_test: ds 6 ; example of a buffer to hold timer data
041269             0292*   
       FF FF FF FF 
       FF FF 
041269 00 00 00    0293*   timestamp_now: dl 0
04126C 00 00 00    0294*   timestamp_old: dl 0
04126F 00 00 00    0295*   timestamp_chg: dl 0
041272             0296*   
041272             0297*   ; update the global timestamp from the system clock
041272             0298*   ; inputs: none
041272             0299*   ; returns: hl = time elapsed in 1/120ths of a second
041272             0300*   ;          de = current time
041272             0301*   ;          ix = pointer to syvars table
041272             0302*   ; destroys: af,hl,de,ix
041272             0303*   timestamp_tick:
041272 ED 5B 69 12 0304*       ld de,(timestamp_now)   ; get previous time
       04          
041277 ED 53 6C 12 0305*       ld (timestamp_old),de   ; save previous time
       04          
04127C             0306*       MOSCALL mos_sysvars     ; ix points to syvars table
                       M1 Args: function=mos_sysvars 
04127C 3E 08       0001*M1 			LD	A, function
04127E 5B CF       0002*M1 			RST.LIL	08h
041280 DD 27 00    0307*       ld hl,(ix+sysvar_time)  ; get current time
041283 22 69 12 04 0308*       ld (timestamp_now),hl   ; save current time
041287 AF          0309*       xor a                   ; clear carry
041288 ED 52       0310*       sbc hl,de               ; hl = time elapsed
04128A 22 6F 12 04 0311*       ld (timestamp_chg),hl   ; save elapsed time
04128E C9          0312*       ret
04128F             0313*   
04128F             0314*   ; set a countdown timer
04128F             0315*   ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
04128F             0316*   ; requires: timestamp_tick to be called at least once before this function
04128F             0317*   ; returns: hl = current time
04128F             0318*   ; destroys: hl
04128F             0319*   timestamp_tmr_set:
04128F FD 2F 03    0320*       ld (iy+3),hl            ; set time remaining
041292 2A 69 12 04 0321*       ld hl,(timestamp_now)   ; get current timestamp
041296 FD 2F 00    0322*       ld (iy+0),hl            ; set start time
041299 C9          0323*       ret
04129A             0324*   
04129A             0325*   ; gets time remaining on a countdown timer following the global timestamp
04129A             0326*   ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
04129A             0327*   ; requires: timestamp_tick to be called at least once before this function
04129A             0328*   ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
04129A             0329*   ;          sign flags: pos = time not expired,zero or neg = time expired
04129A             0330*   ; destroys: af,hl,de
04129A             0331*   timestamp_tmr_get:
04129A ED 5B 69 12 0332*       ld de,(timestamp_now)   ; get current timestamp
       04          
04129F FD 27 00    0333*       ld hl,(iy+0)            ; get start time
0412A2 AF          0334*       xor a                   ; clear carry
0412A3 ED 52       0335*       sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0412A5 FD 17 03    0336*       ld de,(iy+3)            ; get timer set value
0412A8 AF          0337*       xor a                   ; clear carry
0412A9 ED 5A       0338*       adc hl,de               ; hl = time remaining
0412AB             0339*                               ; (we do adc because add hl,rr doesn't set sign or zero flags)
0412AB C9          0340*       ret
0412AC             0341*   
0412AC             0342*   ; set a stopwatch
0412AC             0343*   ; returns: hl = start time
0412AC             0344*   ; destroys: hl,ix
0412AC             0345*   stopwatch_set:
0412AC             0346*       MOSCALL mos_sysvars     ; ix points to syvars table
                       M1 Args: function=mos_sysvars 
0412AC 3E 08       0001*M1 			LD	A, function
0412AE 5B CF       0002*M1 			RST.LIL	08h
0412B0 DD 27 00    0347*       ld hl,(ix+sysvar_time)  ; get current time
0412B3 22 C8 12 04 0348*       ld (stopwatch_started),hl            ; set start time
0412B7 C9          0349*       ret
0412B8             0350*   
0412B8             0351*   ; gets time elapsed on a stopwatch
0412B8             0352*   ; returns: hl = time elapsed in 1/120ths of a second
0412B8             0353*   ; destroys: af,hl,de,ix
0412B8             0354*   stopwatch_get:
0412B8             0355*       MOSCALL mos_sysvars     ; ix points to syvars table
                       M1 Args: function=mos_sysvars 
0412B8 3E 08       0001*M1 			LD	A, function
0412BA 5B CF       0002*M1 			RST.LIL	08h
0412BC DD 27 00    0356*       ld hl,(ix+sysvar_time)  ; get current time
0412BF ED 5B C8 12 0357*       ld de,(stopwatch_started)            ; get start time
       04          
0412C4 AF          0358*       xor a                   ; clear carry
0412C5 ED 52       0359*       sbc hl,de               ; hl = time elapsed (will always be zero or positive)
0412C7 C9          0360*       ret
0412C8             0361*   
0412C8             0362*   stopwatch_started: ds 3 ; buffer to hold stopwatch start time
0412CB             0363*   
0412CB             0364*   ; ------------------
0412CB             0365*   ; delay routine
0412CB             0366*   ; Author: Richard Turrnidge
0412CB             0367*   ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.asm
0412CB             0368*   ; routine waits a fixed time,then returns
0412CB             0369*   ; arrive with A =  the delay byte. One bit to be set only.
0412CB             0370*   ; eg. ld A,00000100b
0412CB             0371*   
0412CB             0372*   multiPurposeDelay:
       FF FF FF 
0412CB F5          0373*       push af
0412CC C5          0374*       push bc
0412CD DD E5       0375*       push ix
0412CF 47          0376*       ld b,a
0412D0 3E 08       0377*       ld a,$08
0412D2 5B CF       0378*       RST.LIL	08h                 ; get IX pointer to sysvars
0412D4             0379*   
0412D4             0380*   waitLoop:
0412D4             0381*   
0412D4 DD 7E 00    0382*       ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
0412D7             0383*   
0412D7             0384*                                   ;   we check if bit set is same as last time we checked.
0412D7             0385*                                   ;   bit 0 - don't use
0412D7             0386*                                   ;   bit 1 - changes 64 times per second
0412D7             0387*                                   ;   bit 2 - changes 32 times per second
0412D7             0388*                                   ;   bit 3 - changes 16 times per second
0412D7             0389*   
0412D7             0390*                                   ;   bit 4 - changes 8 times per second
0412D7             0391*                                   ;   bit 5 - changes 4 times per second
0412D7             0392*                                   ;   bit 6 - changes 2 times per second
0412D7             0393*                                   ;   bit 7 - changes 1 times per second
0412D7 A0          0394*       and b
0412D8 4F          0395*       ld c,a
0412D9 3A EA 12 04 0396*       ld a,(oldTimeStamp)
0412DD B9          0397*       cp c                        ; is A same as last value?
0412DE 28 F4       0398*       jr z,waitLoop              ; loop here if it is
0412E0 79          0399*       ld a,c
0412E1 32 EA 12 04 0400*       ld (oldTimeStamp),a        ; set new value
0412E5             0401*   
0412E5 DD E1       0402*       pop ix
0412E7 C1          0403*       pop bc
0412E8 F1          0404*       pop af
0412E9 C9          0405*       ret
0412EA             0406*   
0412EA 00          0407*   oldTimeStamp:   .db 00h
0412EB             0040        include "vdu.inc"
0412EB             0001*   ; VDU 30: Home cursor
0412EB             0002*   vdu_home_cursor:
0412EB 3E 1E       0003*       ld a,30
0412ED 5B D7       0004*   	rst.lil $10
0412EF C9          0005*   	ret
0412F0             0006*   
0412F0             0007*   vdu_cursor_on:
0412F0 21 FB 12 04 0008*   	ld hl,@cmd
0412F4 01 03 00 00 0009*   	ld bc,@end-@cmd
0412F8 5B DF       0010*   	rst.lil $18
0412FA C9          0011*   	ret
0412FB             0012*   @cmd:
0412FB 17 01 01    0013*   	db 23,1,1
0412FE             0014*   @end:
0412FE             0015*   
0412FE             0016*   vdu_cursor_off:
0412FE 21 09 13 04 0017*   	ld hl,@cmd
041302 01 03 00 00 0018*   	ld bc,@end-@cmd
041306 5B DF       0019*   	rst.lil $18
041308 C9          0020*   	ret
041309             0021*   @cmd:
041309 17 01 00    0022*   	db 23,1,0
04130C             0023*   @end:
04130C             0024*   
04130C             0025*   ; VDU 4: Write text at text cursor
04130C             0026*   ; This causes text to be written at th current text cursor position. This is the default mode for text display.
04130C             0027*   ; inputs: none
04130C             0028*   ; prerequisites: the text cursor at the intended position on screen
04130C             0029*   ; outputs: none
04130C             0030*   ; destroys: af
04130C             0031*   vdu_text_to_text_cursor:
04130C 3E 04       0032*       ld a,4
04130E 5B D7       0033*       rst.lil $10
041310 C9          0034*       ret
041311             0035*   ; end vdu_text_to_text_cursor
041311             0036*   
041311             0037*   ; set the text cursor to a specified location and print a string there
041311             0038*   ; inputs: hl = address of string to print, c,b = x,y text coordinates
041311             0039*   ; outputs: text
041311             0040*   ; destroys: af, bc, hl
041311             0041*   ; affects: moves text cursor to position after final char printed by default
041311             0042*   ;          unless overridden by VDU 23, 16 cursor control command settings
041311             0043*   ;          all subsequent print commands (rst.lil $10 or $18) will go to the text cursor
041311             0044*   vdu_print_to_text_location:
041311 E5          0045*       push hl ; preserve string pointer
041312 3E 04       0046*       ld a,4 ; VDU 4 char to text cursor
041314 5B D7       0047*       rst.lil $10
041316 CD 4E 13 04 0048*       call vdu_move_cursor
04131A E1          0049*       pop hl ; restore string pointer
04131B CD 67 00 04 0050*       call printString
04131F C9          0051*       ret
041320             0052*   ; end vdu_print_at_text_location
041320             0053*   
041320             0054*   ; VDU 5: Write text at graphics cursor
041320             0055*   ; inputs: none
041320             0056*   ; prerequisites: the graphics cursor at the intended position on screen
041320             0057*   ; outputs: none
041320             0058*   ; destroys: af
041320             0059*   vdu_text_to_gfx_cursor:
041320 3E 05       0060*       ld a,5
041322 5B D7       0061*   	rst.lil $10
041324 C9          0062*   	ret
041325             0063*   ; end vdu_char_to_gfx_cursor
041325             0064*   
041325             0065*   ; set the graphics cursor to a specified location and print a string there
041325             0066*   ; inputs: hl = address of string to print, bc,de = x,y graphics coordinates
041325             0067*   ; outputs: text
041325             0068*   ; destroys: af, bc, de, hl
041325             0069*   ; affects: moves graphics cursor to position after final char printed by default
041325             0070*   ;          unless overridden by setting bit 6 of the cursor control register (VDU 23, 16)
041325             0071*   ;          all subsequent print commands (rst.lil $10 or $18) will go to the graphics cursor
041325             0072*   vdu_print_to_gfx_location:
041325 E5          0073*       push hl ; preserve string pointer
041326 3E 44       0074*       ld a,plot_pt+mv_abs
041328 CD 50 18 04 0075*       call vdu_plot ; moves the graphics cursor to the specified location
04132C 3E 05       0076*       ld a,5 ; VDU 5 char to gfx cursor
04132E 5B D7       0077*       rst.lil $10
041330 E1          0078*       pop hl ; restore string pointer
041331 01 00 00 00 0079*       ld bc,0
041335 3E 00       0080*       ld a,0
041337 5B DF       0081*       rst.lil $18 ; print the string
041339 C9          0082*       ret
04133A             0083*   ; end vdu_print_at_gfx_location
04133A             0084*   
04133A             0085*   ; VDU 8: Move cursor back one character
04133A             0086*   vdu_cursor_back:
04133A 3E 08       0087*       ld a,8
04133C 5B D7       0088*       rst.lil $10
04133E C9          0089*       ret
04133F             0090*   ; end vdu_cursor_back
04133F             0091*   
04133F             0092*   ; VDU 9: Move cursor forward one character
04133F             0093*   vdu_cursor_forward:
04133F 3E 09       0094*       ld a,9
041341 5B D7       0095*   	rst.lil $10
041343 C9          0096*   	ret
041344             0097*   ; end vdu_cursor_forward
041344             0098*   
041344             0099*   ; VDU 10: Move cursor down one line
041344             0100*   vdu_cursor_down:
041344 3E 0A       0101*       ld a,10
041346 5B D7       0102*       rst.lil $10
041348 C9          0103*       ret
041349             0104*   ; end vdu_cursor_down
041349             0105*   
041349             0106*   ; VDU 11: Move cursor up one line
041349             0107*   vdu_cursor_up:
041349 3E 0B       0108*       ld a,11
04134B 5B D7       0109*       rst.lil $10
04134D C9          0110*       ret
04134E             0111*   ; end vdu_cursor_up
04134E             0112*   
04134E             0113*   
04134E             0114*   ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
04134E             0115*   ; inputs: c=x, b=y 8-bit unsigned integers
04134E             0116*   vdu_move_cursor:
04134E ED 43 5F 13 0117*       ld (@x0),bc
       04          
041353 21 5E 13 04 0118*   	ld hl,@cmd
041357 01 03 00 00 0119*   	ld bc,@end-@cmd
04135B 5B DF       0120*   	rst.lil $18
04135D C9          0121*   	ret
04135E 1F          0122*   @cmd: 	db 31
04135F 00          0123*   @x0:	db 0
041360 00          0124*   @y0: 	db 0
041361 00          0125*   @end: 	db 0 ; padding
041362             0126*   
041362             0127*   ; https://agonconsole8.github.io/agon-docs/vdp/VDU-Commands/#vdu-23-1-n-cursor-control
041362             0128*   ; VDU 23, 16, setting, mask: Define cursor movement behaviour
041362             0129*   ; inputs: l = setting, h = mask
041362             0130*   ; new_setting = (current_setting AND mask) EOR setting
041362             0131*   ; in English: mask controls which bit to turn on or off, setting is the value of the bits to set or reset
041362             0132*   vdu_cursor_behaviour:
041362 22 73 13 04 0133*       ld (@setting),hl ; little-endian!
041366 21 71 13 04 0134*       ld hl,@cmd
04136A 01 04 00 00 0135*       ld bc,@end-@cmd
04136E 5B DF       0136*       rst.lil $18
041370 C9          0137*       ret
041371 17 10       0138*   @cmd: db 23,16
041373 00          0139*   @setting: db 0
041374 00          0140*   @mask: db 0
041375 00          0141*   @end: db 0 ; padding
041376             0142*   
041376             0143*   ; VDU 12: Clear text area (CLS)
041376             0144*   vdu_cls:
041376 3E 0C       0145*       ld a,12
041378 5B D7       0146*   	rst.lil $10
04137A C9          0147*   	ret
04137B             0148*   
04137B             0149*   vdu_flip:
04137B 21 86 13 04 0150*   	ld hl,@cmd
04137F 01 03 00 00 0151*   	ld bc,@end-@cmd
041383 5B DF       0152*   	rst.lil $18
041385 C9          0153*   	ret
041386 17 00 C3    0154*   @cmd: db 23,0,0xC3
041389             0155*   @end:
041389             0156*   
041389             0157*   ; VDU 16: Clear graphics area (CLG)
041389             0158*   vdu_clg:
041389 3E 10       0159*       ld a,16
04138B 5B D7       0160*   	rst.lil $10
04138D C9          0161*   	ret
04138E             0162*   
04138E             0163*   ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
04138E             0164*   ; VDU 23, 7: Scrolling
04138E             0165*   ;     VDU 23, 7, extent, direction, speed: Scroll the screen
04138E             0166*   ; inputs: a, extent; l, direction; h; speed
04138E             0167*   vdu_scroll_down:
04138E 32 A3 13 04 0168*   	ld (@extent),a
041392 22 A4 13 04 0169*   	ld (@dir),hl ; implicitly populates @speed
041396 21 A1 13 04 0170*   	ld hl,@cmd
04139A 01 05 00 00 0171*   	ld bc,@end-@cmd
04139E 5B DF       0172*   	rst.lil $18     ;; Sending command to VDP
0413A0 C9          0173*   	ret
0413A1 17 07       0174*   @cmd:       db 23,7
0413A3 00          0175*   @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
0413A4 00          0176*   @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
0413A5 00          0177*   @speed:     db 0x00 ; pixels
0413A6 00          0178*   @end:		db 0x00 ; padding
0413A7             0179*   
0413A7             0180*   ; COLOUR MODES
0413A7             0181*   ; Mode	Effect
0413A7             0182*   ; 0	Set on-screen pixel to target colour value
0413A7             0183*   ; 1	OR value with the on-screen pixel
0413A7             0184*   ; 2	AND value with the on-screen pixel
0413A7             0185*   ; 3	XOR value with the on-screen pixel
0413A7             0186*   ; 4	Invert the on-screen pixel
0413A7             0187*   ; 5	No operation
0413A7             0188*   ; 6	AND the inverse of the specified colour with the on-screen pixel
0413A7             0189*   ; 7	OR the inverse of the specified colour with the on-screen pixel
0413A7             0190*   
0413A7             0191*   ; VDU 17, colour: Define text colour (COLOUR)
0413A7             0192*   vdu_colour_text:
0413A7 32 B7 13 04 0193*   	ld (@arg),a
0413AB 21 B6 13 04 0194*   	ld hl,@cmd
0413AF 01 02 00 00 0195*   	ld bc,@end-@cmd
0413B3 5B DF       0196*   	rst.lil $18
0413B5 C9          0197*   	ret
0413B6 11          0198*   @cmd: db 17
0413B7 00          0199*   @arg: db 0
0413B8             0200*   @end:
0413B8             0201*   
0413B8             0202*   ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
0413B8             0203*   ; inputs: a=mode, c=colour (add 128 to set background colour)
0413B8             0204*   vdu_gcol:
0413B8 32 CD 13 04 0205*   	ld (@mode),a
0413BC 79          0206*       ld a,c
0413BD 32 CE 13 04 0207*       ld (@col),a
0413C1 21 CC 13 04 0208*   	ld hl,@cmd
0413C5 01 03 00 00 0209*   	ld bc,@end-@cmd
0413C9 5B DF       0210*   	rst.lil $18
0413CB C9          0211*   	ret
0413CC 12          0212*   @cmd:  db 18
0413CD 00          0213*   @mode: db 0
0413CE 00          0214*   @col:  db 0
0413CF             0215*   @end:
0413CF             0216*   
0413CF             0217*   
0413CF             0218*   ; VDU 28, left, bottom, right, top: Set text viewport **
0413CF             0219*   ; MIND THE LITTLE-ENDIANESS
0413CF             0220*   ; inputs: c=left,b=bottom,e=right,d=top
0413CF             0221*   ; outputs; nothing
0413CF             0222*   ; destroys: af, hl, bc, de
0413CF             0223*   vdu_set_txt_viewport:
0413CF ED 43 E5 13 0224*       ld (@lb),bc
       04          
0413D4 ED 53 E7 13 0225*   	ld (@rt),de
       04          
0413D9 21 E4 13 04 0226*   	ld hl,@cmd
0413DD 01 05 00 00 0227*   	ld bc,@end-@cmd
0413E1 5B DF       0228*   	rst.lil $18
0413E3 C9          0229*   	ret
0413E4 1C          0230*   @cmd:   db 28 ; set text viewport command
0413E5 00 00       0231*   @lb: 	dw 0x0000 ; set by bc
0413E7 00 00       0232*   @rt: 	dw 0x0000 ; set by de
0413E9 00          0233*   @end:   db 0x00	  ; padding
0413EA             0234*   
0413EA             0235*   ; Wait for VBLANK interrupt
0413EA             0236*   vdu_vblank:
0413EA DD E5       0237*       PUSH 	IX
0413EC             0238*   	MOSCALL	mos_sysvars
                       M1 Args: function=mos_sysvars 
0413EC 3E 08       0001*M1 			LD	A, function
0413EE 5B CF       0002*M1 			RST.LIL	08h
0413F0 DD 7E 00    0239*   	LD	A, (IX + sysvar_time + 0)
0413F3             0240*   @wait:
0413F3 DD BE 00    0241*       CP 	A, (IX + sysvar_time + 0)
0413F6 28 FB       0242*       JR	Z, @wait
0413F8 DD E1       0243*       POP	IX
0413FA C9          0244*       RET
0413FB             0245*   
0413FB             0246*   ; VDU 29, x; y;: Set graphics origin
0413FB             0247*   ; This command sets the graphics origin.
0413FB             0248*   ; The origin is the point on the screen where the coordinates (0,0) are located.
0413FB             0249*   ; inputs: bc=x0,de=y0
0413FB             0250*   ; outputs; nothing
0413FB             0251*   ; destroys: a might make it out alive
0413FB             0252*   vdu_set_gfx_origin:
0413FB ED 43 11 14 0253*       ld (@x0),bc
       04          
041400 ED 53 13 14 0254*       ld (@y0),de
       04          
041405 21 10 14 04 0255*       ld hl,@cmd
041409 01 05 00 00 0256*       ld bc,@end-@cmd
04140D 5B DF       0257*       rst.lil $18
04140F C9          0258*       ret
041410 1D          0259*   @cmd:   db 29 ; set graphics origin command
041411 00 00       0260*   @x0: 	dw 0x0000 ; set by bc
041413 00 00       0261*   @y0: 	dw 0x0000 ; set by de
041415 00          0262*   @end:   db 0x00	  ; padding
041416             0263*   
041416             0264*   ; VDU 24, left; bottom; right; top;: Set graphics viewport
041416             0265*   ; NOTE: the order of the y-coordinate parameters are inverted
041416             0266*   ; 	because we have turned off logical screen scaling
041416             0267*   ; NOTE: coordinates are relative to current gfx origin
041416             0268*   ; inputs: bc=x0,de=y0,ix=x1,iy=y1
041416             0269*   ; outputs; nothing
041416             0270*   ; destroys: a might make it out alive
041416             0271*   vdu_set_gfx_viewport:
041416 ED 43 36 14 0272*       ld (@x0),bc
       04          
04141B FD 22 38 14 0273*       ld (@y1),iy
       04          
041420 DD 22 3A 14 0274*   	ld (@x1),ix
       04          
041425 ED 53 3C 14 0275*   	ld (@y0),de
       04          
04142A 21 35 14 04 0276*   	ld hl,@cmd
04142E 01 09 00 00 0277*   	ld bc,@end-@cmd
041432 5B DF       0278*   	rst.lil $18
041434 C9          0279*   	ret
041435 18          0280*   @cmd:   db 24 ; set graphics viewport command
041436 00 00       0281*   @x0: 	dw 0x0000 ; set by bc
041438 00 00       0282*   @y1: 	dw 0x0000 ; set by iy
04143A 00 00       0283*   @x1: 	dw 0x0000 ; set by ix
04143C 00 00       0284*   @y0: 	dw 0x0000 ; set by de
04143E 00          0285*   @end:   db 0x00	  ; padding
04143F             0286*   
04143F             0287*   ; VDU 26: Reset graphics and text viewports
04143F             0288*   vdu_reset_viewports:
04143F 3E 1A       0289*       ld a,26
041441 5B D7       0290*       rst.lil $10
041443 C9          0291*       ret
041444             0292*   
041444             0293*   ; SCREEN MODES
041444             0294*   ; ===============================
041444             0295*   ; Mode  Horz  Vert  Cols  Refresh
041444             0296*   ; ---   ----  ----  ----  -------
041444             0297*   ; 11    320   240   2     60hz
041444             0298*   ; 139   320   240   2     60hz
041444             0299*   ; 23    512   384   2     60hz
041444             0300*   ; 151   512   384   2     60hz
041444             0301*   ; 6     640   240   2     60hz
041444             0302*   ; 134   640   240   2     60hz
041444             0303*   ; 2     640   480   2     60hz
041444             0304*   ; 130   640   480   2     60hz
041444             0305*   ; 17    800   600   2     60hz
041444             0306*   ; 145   800   600   2     60hz
041444             0307*   ; 18    1024  768   2     60hz
041444             0308*   ; 146   1024  768   2     60hz
041444             0309*   ; ---   ----  ----  ----  -------
041444             0310*   ; 10    320   240   4     60hz
041444             0311*   ; 138   320   240   4     60hz
041444             0312*   ; 22    512   384   4     60hz
041444             0313*   ; 150   512   384   4     60hz
041444             0314*   ; 5     640   240   4     60hz
041444             0315*   ; 133   640   240   4     60hz
041444             0316*   ; 1     640   480   4     60hz
041444             0317*   ; 129   640   480   4     60hz
041444             0318*   ; 16    800   600   4     60hz
041444             0319*   ; 19    1024  768   4     60hz
041444             0320*   ; ---   ----  ----  ----  -------
041444             0321*   ; 9     320   240   16    60hz
041444             0322*   ; 137   320   240   16    60hz
041444             0323*   ; 21    512   384   16    60hz
041444             0324*   ; 149   512   384   16    60hz
041444             0325*   ; 4     640   240   16    60hz
041444             0326*   ; 132   640   240   16    60hz
041444             0327*   ; 0     640   480   16    60hz
041444             0328*   ; 7     n/a   n/a   16    60hz
041444             0329*   ; ---   ----  ----  ----  -------
041444             0330*   ; 8     320   240   64    60hz
041444             0331*   ; 136   320   240   64    60hz
041444             0332*   ; 20    512   384   64    60hz
041444             0333*   ; 3     640   240   64    60hz
041444             0334*   ; ---   ----  ----  ----  -------
041444             0335*   vdu_set_screen_mode:
041444 32 54 14 04 0336*   	ld (@arg),a
041448 21 53 14 04 0337*   	ld hl,@cmd
04144C 01 02 00 00 0338*   	ld bc,@end-@cmd
041450 5B DF       0339*   	rst.lil $18
041452 C9          0340*   	ret
041453 16          0341*   @cmd: db 22 ; set screen mode
041454 00          0342*   @arg: db 0  ; screen mode parameter
041455             0343*   @end:
041455             0344*   
041455             0345*   ; get the current screen mode
041455             0346*   ; inputs: none
041455             0347*   ; outputs: a=screen mode
041455             0348*   ; destroys: af, ix
041455             0349*   vdu_get_screen_mode:
041455             0350*       MOSCALL mos_sysvars
                       M1 Args: function=mos_sysvars 
041455 3E 08       0001*M1 			LD	A, function
041457 5B CF       0002*M1 			RST.LIL	08h
041459 DD 7E 27    0351*       ld a,(IX+sysvar_scrMode)
04145C C9          0352*       ret
04145D             0353*   ; end vdu_get_screen_mode
04145D             0354*   
04145D             0355*   ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
04145D             0356*   ; inputs: a is scaling mode, 1=on, 0=off
04145D             0357*   ; note: default setting on boot is scaling ON
04145D             0358*   vdu_set_scaling:
04145D 32 6F 14 04 0359*   	ld (@arg),a
041461 21 6C 14 04 0360*   	ld hl,@cmd
041465 01 04 00 00 0361*   	ld bc,@end-@cmd
041469 5B DF       0362*   	rst.lil $18
04146B C9          0363*   	ret
04146C 17 00 C0    0364*   @cmd: db 23,0,0xC0
04146F 00          0365*   @arg: db 0  ; scaling on/off
041470             0366*   @end:
041470             0367*   
041470             0368*   ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
041470             0369*   ; inputs: hl=bufferId
041470             0370*   vdu_buff_select:
041470 22 82 14 04 0371*   	ld (@bufferId),hl
041474 21 7F 14 04 0372*   	ld hl,@cmd
041478 01 05 00 00 0373*   	ld bc,@end-@cmd
04147C 5B DF       0374*   	rst.lil $18
04147E C9          0375*   	ret
04147F 17 1B 20    0376*   @cmd: db 23,27,0x20
041482 00 00       0377*   @bufferId: dw 0x0000
041484 00          0378*   @end: db 0x00 ; padding
041485             0379*   
041485             0380*   ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
041485             0381*   ; inputs: a=format; bc=width; de=height
041485             0382*   ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
041485             0383*   ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
041485             0384*   ; 0 	RGBA8888 (4-bytes per pixel)
041485             0385*   ; 1 	RGBA2222 (1-bytes per pixel)
041485             0386*   ; 2 	Mono/Mask (1-bit per pixel)
041485             0387*   ; 3 	Reserved for internal use by VDP (“native” format)
041485             0388*   vdu_bmp_create:
041485 ED 43 A1 14 0389*       ld (@width),bc
       04          
04148A ED 53 A3 14 0390*       ld (@height),de
       04          
04148F 32 A5 14 04 0391*       ld (@fmt),a
041493 21 9E 14 04 0392*   	ld hl,@cmd
041497 01 08 00 00 0393*   	ld bc,@end-@cmd
04149B 5B DF       0394*   	rst.lil $18
04149D C9          0395*   	ret
04149E 17 1B 21    0396*   @cmd:       db 23,27,0x21
0414A1 00 00       0397*   @width:     dw 0x0000
0414A3 00 00       0398*   @height:    dw 0x0000
0414A5 00          0399*   @fmt:       db 0x00
0414A6             0400*   @end:
0414A6             0401*   
0414A6             0402*   ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
0414A6             0403*   ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
0414A6             0404*   vdu_load_img_rgba2_to_8:
0414A6             0405*   ; backup the target buffer id and image dimensions
0414A6 E5          0406*       push hl
0414A7 D5          0407*       push de
0414A8 C5          0408*       push bc
0414A9             0409*   ; load the rgba2 image to working buffer 65534
0414A9 21 FE FF 00 0410*       ld hl,65534 ; temporary working buffer id
0414AD CD 84 15 04 0411*   	call vdu_load_buffer_from_file
0414B1             0412*   ; restore the image dimensions and target buffer id
0414B1 C1          0413*       pop bc
0414B2 D1          0414*       pop de
0414B3 E1          0415*       pop hl
0414B4             0416*   ; fall through to vdu_rgba2_to_8
0414B4             0417*   
0414B4             0418*   ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
0414B4             0419*   ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
0414B4             0420*   ; the "expand bitmap" command is:
0414B4             0421*   ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0414B4             0422*   ; and then to reverse the byte order to fix endian-ness:
0414B4             0423*   ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0414B4             0424*   ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0414B4             0425*   ; VDU 23,27,&20,targetBufferID%;
0414B4             0426*   ; VDU 23,27,&21,width%;height%;0
0414B4             0427*   ; -------------------------------------------------------------------
0414B4             0428*   ; inputs: bc,de image width,height ; hl = targetBufferId
0414B4             0429*   ; prerequisites: rgba2 image data loaded into workingBufferId 65534
0414B4             0430*   vdu_rgba2_to_8:
0414B4             0431*   ; load the image dimensions and buffer id parameters
0414B4 ED 43 10 15 0432*       ld (@width),bc
       04          
0414B9 ED 53 12 15 0433*       ld (@height),de
       04          
0414BE 22 F5 14 04 0434*       ld (@bufferId0),hl
0414C2 22 02 15 04 0435*       ld (@bufferId2),hl
0414C6 22 0B 15 04 0436*       ld (@bufferId1),hl
0414CA             0437*   ; clean up bytes that got stomped on by the ID loads
0414CA 3E 48       0438*       ld a,0x48
0414CC 32 F7 14 04 0439*       ld (@bufferId0+2),a
0414D0 3E 17       0440*       ld a,23
0414D2 32 0D 15 04 0441*       ld (@bufferId1+2),a
0414D6 3E 18       0442*       ld a,24
0414D8 32 04 15 04 0443*       ld (@bufferId2+2),a
0414DC AF          0444*       xor a
0414DD 32 14 15 04 0445*       ld (@height+2),a
0414E1             0446*   ; send the vdu command strings
0414E1 21 EC 14 04 0447*       ld hl,@beg
0414E5 01 29 00 00 0448*       ld bc,@end-@beg
0414E9 5B DF       0449*       rst.lil $18
0414EB C9          0450*       ret
0414EC             0451*   @beg:
0414EC             0452*   ; Command 14: Consolidate blocks in a buffer
0414EC             0453*   ; VDU 23, 0, &A0, bufferId; 14
0414EC 17 00 A0    0454*       db 23,0,0xA0
0414EF FE FF       0455*       dw 65534 ; workingBufferId
0414F1 0E          0456*       db 14 ; consolidate blocks
0414F2             0457*   ; the "expand bitmap" command is:
0414F2             0458*   ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0414F2 17 00 A0    0459*       db 23,0,0xA0
0414F5 00 00       0460*   @bufferId0: dw 0x0000 ; targetBufferId
0414F7 48          0461*       db 0x48 ; given as decimal command 72 in the docs
0414F8 02          0462*       db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
0414F9 FE FF       0463*       dw 65534 ; sourceBufferId
0414FB 00 7F BF FF 0464*       db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
0414FF             0465*   ; reverse the byte order to fix endian-ness:
0414FF             0466*   ; Command 24: Reverse the order of data of blocks within a buffer
0414FF             0467*   ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
0414FF             0468*   ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0414FF 17 00 A0    0469*       db 23,0,0xA0
041502 00 00       0470*   @bufferId2:    dw 0x0000 ; targetBufferId
041504 18          0471*       db 24 ; reverse byte order
041505 04          0472*       db 4 ; option: Reverse data of the value size within chunk of data of the specified size
041506 04 00       0473*       dw 4 ; size (4 bytes)
041508             0474*   ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
041508             0475*   ; VDU 23,27,&20,targetBufferID%;
041508 17 1B 20    0476*       db 23,27,0x20 ; select bitmap
04150B 00 00       0477*   @bufferId1: dw 0x0000 ; targetBufferId
04150D             0478*   ; VDU 23,27,&21,width%;height%;0
04150D 17 1B 21    0479*       db 23,27,0x21 ; create bitmap from buffer
041510 00 00       0480*   @width: dw 0x0000
041512 00 00       0481*   @height: dw 0x0000
041514 00          0482*       db 0x00 ; rgba8888 format
041515             0483*   @end:
041515             0484*   
041515             0485*   ; scratch variables
041515 00 00 00    0486*   bufferId0: dl 0x000000
041518 00 00 00    0487*   bufferId1: dl 0x000000
04151B             0488*   
04151B             0489*   ; load a vdu buffer from local memory
04151B             0490*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
04151B             0491*   vdu_load_buffer:
04151B ED 43 44 15 0492*       ld (@length),bc
       04          
041520 D5          0493*       push de ; save data pointer
041521             0494*   ; send the vdu command string
041521 7D          0495*       ld a,l
041522 32 41 15 04 0496*       ld (@bufferId),a
041526 7C          0497*       ld a,h
041527 32 42 15 04 0498*       ld (@bufferId+1),a
04152B 21 3E 15 04 0499*       ld hl,@cmd
04152F 01 08 00 00 0500*       ld bc,@end-@cmd
041533 5B DF       0501*       rst.lil $18
041535             0502*   ; send the buffer data
041535 E1          0503*       pop hl ; pointer to data
041536 ED 4B 44 15 0504*       ld bc,(@length)
       04          
04153B 5B DF       0505*       rst.lil $18 ; send it
04153D C9          0506*       ret
04153E             0507*   ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04153E 17 00 A0    0508*   @cmd:       db 23,0,0xA0
041541 00 00       0509*   @bufferId:	dw 0x0000
041543 00          0510*   		    db 0 ; load buffer
041544 00 00       0511*   @length:	dw 0x0000
041546 00          0512*   @end: db 0 ; padding
041547             0513*   
041547             0514*   ; Command 14: Consolidate blocks in a buffer
041547             0515*   vdu_consolidate_buffer:
041547             0516*   ; set parameters for vdu call
041547 7D          0517*       ld a,l
041548 32 5F 15 04 0518*       ld (@bufferId),a
04154C 7C          0519*       ld a,h
04154D 32 60 15 04 0520*       ld (@bufferId+1),a
041551 21 5C 15 04 0521*       ld hl,@beg
041555 01 06 00 00 0522*       ld bc,@end-@beg
041559 5B DF       0523*       rst.lil $18
04155B C9          0524*       ret
04155C             0525*   ; VDU 23, 0, &A0, bufferId; 14
04155C 17 00 A0    0526*   @beg: db 23,0,0xA0
04155F 00 00       0527*   @bufferId: dw 0x0000
041561 0E          0528*              db 14
041562             0529*   @end:
041562             0530*   
041562             0531*   ; load an image file to a buffer and make it a bitmap
041562             0532*   ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
041562             0533*   vdu_load_img:
041562             0534*   ; back up image type and dimension parameters
041562 22 15 15 04 0535*       ld (bufferId0),hl
041566 F5          0536*       push af
041567 C5          0537*   	push bc
041568 D5          0538*   	push de
041569             0539*   ; load the image
041569 CD 84 15 04 0540*   	call vdu_load_buffer_from_file
04156D             0541*   ; now make it a bitmap
04156D 2A 15 15 04 0542*       ld hl,(bufferId0)
041571 CD 47 15 04 0543*       call vdu_consolidate_buffer
041575 2A 15 15 04 0544*       ld hl,(bufferId0)
041579 CD 70 14 04 0545*       call vdu_buff_select
04157D D1          0546*   	pop de ; image height
04157E C1          0547*   	pop bc ; image width
04157F F1          0548*   	pop af ; image type
041580 C3 85 14 04 0549*   	jp vdu_bmp_create ; will return to caller from there
041584             0550*   
041584             0551*   ; inputs: hl = bufferId; iy = pointer to filename
041584             0552*   vdu_load_buffer_from_file:
041584 22 15 15 04 0553*       ld (bufferId0),hl
041588             0554*   
041588             0555*   ; clear target buffer
041588 CD 30 17 04 0556*       call vdu_clear_buffer
04158C             0557*   
04158C             0558*   ; open the file in read mode
04158C             0559*   ; Open a file
04158C             0560*   ; HLU: Filename
04158C             0561*   ;   C: Mode
04158C             0562*   ; Returns:
04158C             0563*   ;   A: Filehandle, or 0 if couldn't open
04158C FD E5       0564*   	push iy ; pointer to filename
04158E E1          0565*   	pop hl
04158F 0E 01       0566*   	ld c,fa_read
041591             0567*       MOSCALL mos_fopen
                       M1 Args: function=mos_fopen 
041591 3E 0A       0001*M1 			LD	A, function
041593 5B CF       0002*M1 			RST.LIL	08h
041595 32 D0 15 04 0568*       ld (@filehandle),a
041599             0569*   
041599             0570*   @read_file:
041599             0571*   ; Read a block of data from a file
041599             0572*   ;   C: Filehandle
041599             0573*   ; HLU: Pointer to where to write the data to
041599             0574*   ; DEU: Number of bytes to read
041599             0575*   ; Returns:
041599             0576*   ; DEU: Number of bytes read
041599 3A D0 15 04 0577*       ld a,(@filehandle)
04159D 4F          0578*       ld c,a
04159E 21 00 E0 B7 0579*       ld hl,filedata
0415A2 11 00 20 00 0580*       ld de,8192 ; max we can read into onboard sram at one time
0415A6             0581*       MOSCALL mos_fread
                       M1 Args: function=mos_fread 
0415A6 3E 1A       0001*M1 			LD	A, function
0415A8 5B CF       0002*M1 			RST.LIL	08h
0415AA             0582*   
0415AA             0583*   ; test de for zero bytes read
0415AA 21 00 00 00 0584*       ld hl,0
0415AE AF          0585*       xor a ; clear carry
0415AF ED 52       0586*       sbc hl,de
0415B1 CA C7 15 04 0587*       jp z,@close_file
0415B5             0588*   
0415B5             0589*   ; load a vdu buffer from local memory
0415B5             0590*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0415B5 2A 15 15 04 0591*       ld hl,(bufferId0)
0415B9 D5          0592*       push de ; chunksize
0415BA C1          0593*       pop bc
0415BB 11 00 E0 B7 0594*       ld de,filedata
0415BF CD 1B 15 04 0595*       call vdu_load_buffer
0415C3             0596*   
0415C3             0597*   ; read the next block
0415C3 C3 99 15 04 0598*       jp @read_file
0415C7             0599*   
0415C7             0600*   ; close the file
0415C7             0601*   @close_file:
0415C7 3A D0 15 04 0602*       ld a,(@filehandle)
0415CB             0603*       MOSCALL mos_fclose
                       M1 Args: function=mos_fclose 
0415CB 3E 0B       0001*M1 			LD	A, function
0415CD 5B CF       0002*M1 			RST.LIL	08h
0415CF C9          0604*       ret ; vdu_load_buffer_from_file
0415D0             0605*   
0415D0 00          0606*   @filehandle: db 0 ; file handle
0415D1 00 00 00    0607*   @fil: dl 0 ; pointer to FIL struct
0415D4             0608*   
0415D4 00 00 00    0609*   @chunkpointer: dl 0 ; pointer to current chunk
0415D7             0610*   
0415D7             0611*   ; File information structure (FILINFO)
0415D7             0612*   @filinfo:
0415D7 00 00 00 00 0613*   @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
0415DB 00 00       0614*   @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
0415DD 00 00       0615*   @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
0415DF 00          0616*   @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
0415E0 00 00 00 00 0617*   @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
0415ED 00 00 00 00 0618*   @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0416ED             0041        include "vdu_buffered_api.inc"
0416ED             0001*   ; https://agonconsole8.github.io/agon-docs/vdp/Buffered-Commands-API/
0416ED             0002*   
0416ED             0003*   ; Command 0: Write block to a buffer
0416ED             0004*   ; VDU 23, 0, &A0, bufferId; 0, length; <buffer-data>
0416ED             0005*   ; inputs: hl = bufferId, bc = length of data, de = pointer to data
0416ED             0006*   vdu_write_block_to_buffer:
0416ED             0007*   ; back up input parameters
0416ED D5          0008*       push de ; pointer to data
0416EE C5          0009*       push bc ; length of data
0416EF             0010*   ; set up the vdu command string
0416EF 22 0F 17 04 0011*       ld (@bufferId),hl
0416F3 ED 43 12 17 0012*       ld (@length),bc
       04          
0416F8 AF          0013*       xor a ; load buffer
0416F9 32 11 17 04 0014*       ld (@bufferId+2),a
0416FD 21 0C 17 04 0015*       ld hl,@cmd0
041701 01 08 00 00 0016*       ld bc,@end0-@cmd0
041705 5B DF       0017*       rst.lil $18
041707             0018*   ; send the buffer data
041707 C1          0019*       pop bc ; length of data
041708 E1          0020*       pop hl ; pointer to data (was de)
041709 5B DF       0021*       rst.lil $18 ; send it
04170B C9          0022*       ret
04170C             0023*   ; command string data
04170C 17 00 A0    0024*   @cmd0:      db 23,0,0xA0
04170F 00 00       0025*   @bufferId:	dw 0x0000
041711 00          0026*               db 0 ; load buffer
041712 00 00       0027*   @length:	dw 0x0000
041714 00          0028*   @end0:      db 0x00 ; padding
041715             0029*   ; end vdu_write_block_to_buffer
041715             0030*   
041715             0031*   ; Command 1: Call a buffer
041715             0032*   ; VDU 23, 0, &A0, bufferId; 1
041715             0033*   ; inputs: hl = bufferId
041715             0034*   vdu_call_buffer:
041715 22 2D 17 04 0035*       ld (@bufferId),hl
041719 3E 01       0036*       ld a,1 ; call buffer
04171B 32 2F 17 04 0037*       ld (@bufferId+2),a
04171F 21 2A 17 04 0038*       ld hl,@cmd
041723 01 06 00 00 0039*       ld bc,@end-@cmd
041727 5B DF       0040*       rst.lil $18
041729 C9          0041*       ret
04172A 17 00 A0    0042*   @cmd:     db 23,0,0xA0
04172D 00 00       0043*   @bufferId: dw 0x0000
04172F 01          0044*              db 1 ; call buffer
041730             0045*   @end:
041730             0046*   ; end vdu_call_buffer
041730             0047*   
041730             0048*   ; Command 2: Clear a buffer
041730             0049*   ; VDU 23, 0 &A0, bufferId; 2
041730             0050*   ; inputs: hl = bufferId
041730             0051*   vdu_clear_buffer:
041730 22 48 17 04 0052*       ld (@bufferId),hl
041734 3E 02       0053*       ld a,2 ; clear buffer
041736 32 4A 17 04 0054*       ld (@bufferId+2),a
04173A 21 45 17 04 0055*       ld hl,@cmd
04173E 01 06 00 00 0056*       ld bc,@end-@cmd
041742 5B DF       0057*       rst.lil $18
041744 C9          0058*       ret
041745 17 00 A0    0059*   @cmd:     db 23,0,0xA0
041748 00 00       0060*   @bufferId: dw 0x0000
04174A 02          0061*              db 2 ; clear buffer
04174B             0062*   @end:
04174B             0063*   ; end vdu_clear_buffer
04174B             0064*   
04174B             0065*   ; Clear all buffers
04174B             0066*   ; inputs: none
04174B             0067*   vdu_clear_all_buffers:
04174B             0068*   ; clear all buffers
04174B 21 56 17 04 0069*       ld hl,@beg
04174F 01 06 00 00 0070*       ld bc,@end-@beg
041753 5B DF       0071*       rst.lil $18
041755 C9          0072*       ret
041756 17 00 A0    0073*   @beg: db 23,0,$A0
041759 FF FF       0074*         dw -1 ; bufferId -1 (65535) means clear all buffers
04175B 02          0075*         db 2  ; command 2: clear a buffer
04175C             0076*   @end:
04175C             0077*   ; end vdu_clear_all_buffers
04175C             0078*   
04175C             0079*   ; Command 3: Create a writeable buffer
04175C             0080*   ; VDU 23, 0 &A0, bufferId; 3, length;
04175C             0081*   ; inputs: hl = bufferId, bc = length
04175C             0082*   vdu_create_writeable_buffer:
04175C 22 79 17 04 0083*       ld (@bufferId),hl
041760 ED 43 7C 17 0084*       ld (@length),bc
       04          
041765 3E 03       0085*       ld a,3 ; create writeable buffer
041767 32 7B 17 04 0086*       ld (@bufferId+2),a
04176B 21 76 17 04 0087*       ld hl,@cmd
04176F 01 08 00 00 0088*       ld bc,@end-@cmd
041773 5B DF       0089*       rst.lil $18
041775 C9          0090*       ret
041776 17 00 A0    0091*   @cmd:     db 23,0,0xA0
041779 00 00       0092*   @bufferId: dw 0x0000
04177B 03          0093*              db 3 ; create writeable buffer
04177C 00 00       0094*   @length: dw 0x0000
04177E 00          0095*   @end:     db 0x00 ; padding
04177F             0096*   ; end vdu_create_writeable_buffer
04177F             0097*   
04177F             0098*   ; Command 4: Set output stream to a buffer
04177F             0099*   ; VDU 23, 0 &A0, bufferId; 4
04177F             0100*   ; inputs: hl = bufferId
04177F             0101*   vdu_set_output_stream_buffer:
04177F 22 97 17 04 0102*       ld (@bufferId),hl
041783 3E 04       0103*       ld a,4 ; set output stream to buffer
041785 32 99 17 04 0104*       ld (@bufferId+2),a
041789 21 94 17 04 0105*       ld hl,@cmd
04178D 01 06 00 00 0106*       ld bc,@end-@cmd
041791 5B DF       0107*       rst.lil $18
041793 C9          0108*       ret
041794 17 00 A0    0109*   @cmd:     db 23,0,0xA0
041797 00 00       0110*   @bufferId: dw 0x0000
041799 04          0111*              db 4 ; set output stream to buffer
04179A 00          0112*   @end:     db 0x00 ; padding
04179B             0113*   ; end vdu_set_output_stream_buffer
04179B             0114*   
04179B             0115*   ; Command 5: Adjust buffer contents
04179B             0116*   ; VDU 23, 0, &A0, bufferId; 5, operation, offset; [count;] <operand>, [arguments]
04179B             0117*   vdu_adjust_buffer:
04179B C9          0118*       ret ; TODO: implement
04179C             0119*   ; end vdu_adjust_buffer
04179C             0120*   
04179C             0121*   ; Command 6: Conditionally call a buffer
04179C             0122*   ; VDU 23, 0, &A0, bufferId; 6, operation, checkBufferId; checkOffset; [arguments]
04179C             0123*   vdu_call_buffer_conditional:
04179C C9          0124*       ret ; TODO: implement
04179D             0125*   ; end vdu_call_buffer_conditional
04179D             0126*   
04179D             0127*   ; Command 7: Jump to a buffer
04179D             0128*   ; VDU 23, 0, &A0, bufferId; 7
04179D             0129*   ; inputs: hl = bufferId
04179D             0130*   vdu_jump_to_buffer:
04179D 22 B5 17 04 0131*       ld (@bufferId),hl
0417A1 3E 07       0132*       ld a,7 ; jump to buffer
0417A3 32 B7 17 04 0133*       ld (@bufferId+2),a
0417A7 21 B2 17 04 0134*       ld hl,@cmd
0417AB 01 06 00 00 0135*       ld bc,@end-@cmd
0417AF 5B DF       0136*       rst.lil $18
0417B1 C9          0137*       ret
0417B2 17 00 A0    0138*   @cmd:     db 23,0,0xA0
0417B5 00 00       0139*   @bufferId: dw 0x0000
0417B7 07          0140*              db 7 ; jump to buffer
0417B8 00          0141*   @end:     db 0x00 ; padding
0417B9             0142*   ; end vdu_jump_to_buffer
0417B9             0143*   
0417B9             0144*   ; Command 8: Conditional Jump to a buffer
0417B9             0145*   ; VDU 23, 0, &A0, bufferId; 8, operation, checkBufferId; checkOffset; [arguments]
0417B9             0146*   vdu_jump_to_buffer_conditional:
0417B9 C9          0147*       ret ; TODO: implement
0417BA             0148*   ; end vdu_jump_to_buffer_conditional
0417BA             0149*   
0417BA             0150*   ; Command 9: Jump to an offset in a buffer
0417BA             0151*   ; VDU 23, 0, &A0, bufferId; 9, offset; offsetHighByte, [blockNumber;]
0417BA             0152*   vdu_jump_to_buffer_offset:
0417BA C9          0153*       ret ; TODO: implement
0417BB             0154*   ; end vdu_jump_to_buffer_offset
0417BB             0155*   
0417BB             0156*   ; Command 10: Conditional jump to an offset in a buffer
0417BB             0157*   ; VDU 23, 0, &A0, bufferId; 10, offset; offsetHighByte, [blockNumber;] [arguments]
0417BB             0158*   vdu_jump_to_buffer_offset_conditional:
0417BB C9          0159*       ret ; TODO: implement
0417BC             0160*   ; end vdu_jump_to_buffer_offset_conditional
0417BC             0161*   
0417BC             0162*   ; Command 11: Call buffer with an offset
0417BC             0163*   ; VDU 23, 0, &A0, bufferId; 11, offset; offsetHighByte, [blockNumber;]
0417BC             0164*   vdu_call_buffer_offset:
0417BC C9          0165*       ret ; TODO: implement
0417BD             0166*   ; end vdu_call_buffer_offset
0417BD             0167*   
0417BD             0042        include "vdu_fonts.inc"
0417BD             0001*   ; select font
0417BD             0002*   ; inputs: hl = bufferId, a = font flags
0417BD             0003*   ; Flags:
0417BD             0004*   ; Bit	Description
0417BD             0005*   ; 0	Adjust cursor position to ensure text baseline is aligned
0417BD             0006*   ;   0: Do not adjust cursor position (best for changing font on a new line)
0417BD             0007*   ;   1: Adjust cursor position (best for changing font in the middle of a line)
0417BD             0008*   ; 1-7	Reserved for future use
0417BD             0009*   ; VDU 23, 0, &95, 0, bufferId; flags: Select font
0417BD             0010*   vdu_font_select:
0417BD 22 D4 17 04 0011*       ld (@bufferId),hl
0417C1 32 D6 17 04 0012*       ld (@flags),a
0417C5 21 D0 17 04 0013*       ld hl,@cmd
0417C9 01 07 00 00 0014*       ld bc,@end-@cmd
0417CD 5B DF       0015*       rst.lil $18
0417CF C9          0016*       ret
0417D0 17 00 95 00 0017*   @cmd: db 23, 0, 0x95, 0
0417D4 00 00       0018*   @bufferId: dw 0x0000
0417D6 00          0019*   @flags: db 0x00
0417D7             0020*   @end:
0417D7             0021*   
0417D7             0022*   ; create font from buffer
0417D7             0023*   ; inputs: hl = bufferId, e = width, d = height, d = ascent, a = flags
0417D7             0024*   ; VDU 23, 0, &95, 1, bufferId; width, height, ascent, flags: Create font from buffer
0417D7             0025*   vdu_font_create:
0417D7 22 FC 17 04 0026*       ld (@bufferId),hl
0417DB ED 53 FE 17 0027*       ld (@width),de ; also loads height
       04          
0417E0 32 01 18 04 0028*       ld (@flags),a
0417E4 7A          0029*       ld a,d ; height
0417E5 32 00 18 04 0030*       ld (@ascent),a ; ascent = height
0417E9             0031*   ; consolidate buffer
0417E9 CD 47 15 04 0032*       call vdu_consolidate_buffer
0417ED             0033*   ; create font
0417ED 21 F8 17 04 0034*       ld hl,@cmd
0417F1 01 0A 00 00 0035*       ld bc,@end-@cmd
0417F5 5B DF       0036*       rst.lil $18
0417F7 C9          0037*       ret
0417F8 17 00 95 01 0038*   @cmd: db 23, 0, 0x95, 1
0417FC 00 00       0039*   @bufferId: dw 0x0000
0417FE 00          0040*   @width: db 0x00
0417FF 00          0041*   @height: db 0x00
041800 00          0042*   @ascent: db 0x00
041801 00          0043*   @flags: db 0x00
041802             0044*   @end:
041802             0045*   
041802             0046*   ; set or adjust font property
041802             0047*   ; inputs: hl = bufferId, a = field, de = value
041802             0048*   ; VDU 23, 0, &95, 2, bufferId; field, value;: Set or adjust font property
041802             0049*   vdu_font_property:
041802 22 1E 18 04 0050*       ld (@bufferId),hl
041806 32 20 18 04 0051*       ld (@field),a
04180A ED 53 21 18 0052*       ld (@value),de
       04          
04180F 21 1A 18 04 0053*       ld hl,@cmd
041813 01 09 00 00 0054*       ld bc,@end-@cmd
041817 5B DF       0055*       rst.lil $18
041819 C9          0056*       ret
04181A 17 00 95 02 0057*   @cmd: db 23, 0, 0x95, 2
04181E 00 00       0058*   @bufferId: dw 0x0000
041820 00          0059*   @field: db 0x00
041821 00 00       0060*   @value: dw 0x0000
041823 00          0061*   @end: db 0x00 ; padding
041824             0062*   
041824             0063*   ; VDU 23, 0, &95, 3, bufferId; [<args>]: Reserved
041824             0064*   
041824             0065*   ; Clear/Delete font
041824             0066*   ; inputs: hl = bufferId
041824             0067*   ; VDU 23, 0, &95, 4, bufferId;: Clear/Delete font
041824             0068*   vdu_font_clear:
041824 22 37 18 04 0069*       ld (@bufferId),hl
041828 21 33 18 04 0070*       ld hl,@cmd
04182C 01 06 00 00 0071*       ld bc,@end-@cmd
041830 5B DF       0072*       rst.lil $18
041832 C9          0073*       ret
041833 17 00 95 04 0074*   @cmd: db 23, 0, 0x95, 4
041837 00 00       0075*   @bufferId: dw 0x0000
041839 00          0076*   @end: db 0x00 ; padding
04183A             0077*   
04183A             0078*   ; Copy system font to buffer
04183A             0079*   ; inputs: hl = bufferId
04183A             0080*   ; VDU 23, 0, &95, 5, bufferId;: Copy system font to buffer
04183A             0081*   vdu_font_copy_system:
04183A 22 4D 18 04 0082*       ld (@bufferId),hl
04183E 21 49 18 04 0083*       ld hl,@cmd
041842 01 06 00 00 0084*       ld bc,@end-@cmd
041846 5B DF       0085*       rst.lil $18
041848 C9          0086*       ret
041849 17 00 95 05 0087*   @cmd: db 23, 0, 0x95, 5
04184D 00 00       0088*   @bufferId: dw 0x0000
04184F 00          0089*   @end: db 0x00 ; padding
041850             0043        include "vdu_plot.inc"
041850             0001*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
041850             0002*   ; PLOT code 	(Decimal) 	Effect
041850             0003*   ; &00-&07 	0-7 	Solid line, includes both ends
041850             0004*   plot_sl_both: equ 0x00
041850             0005*   
041850             0006*   ; &08-&0F 	8-15 	Solid line, final point omitted
041850             0007*   plot_sl_first: equ 0x08
041850             0008*   
041850             0009*   ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
041850             0010*   ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
041850             0011*   
041850             0012*   ; &20-&27 	32-39 	Solid line, first point omitted
041850             0013*   plot_sl_last: equ 0x20
041850             0014*   
041850             0015*   ; &28-&2F 	40-47 	Solid line, both points omitted
041850             0016*   plot_sl_none: equ 0x28
041850             0017*   
041850             0018*   ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
041850             0019*   ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
041850             0020*   
041850             0021*   ; &40-&47 	64-71 	Point plot
041850             0022*   plot_pt: equ 0x40
041850             0023*   
041850             0024*   ; &48-&4F 	72-79 	Line fill left and right to non-background §§
041850             0025*   plot_lf_lr_non_bg: equ 0x48
041850             0026*   
041850             0027*   ; &50-&57 	80-87 	Triangle fill
041850             0028*   plot_tf: equ 0x50
041850             0029*   
041850             0030*   ; &58-&5F 	88-95 	Line fill right to background §§
041850             0031*   plot_lf_r_bg: equ 0x58
041850             0032*   
041850             0033*   ; &60-&67 	96-103 	Rectangle fill
041850             0034*   plot_rf: equ 0x60
041850             0035*   
041850             0036*   ; &68-&6F 	104-111 	Line fill left and right to foreground §§
041850             0037*   plot_lf_lr_fg: equ 0x60
041850             0038*   
041850             0039*   ; &70-&77 	112-119 	Parallelogram fill
041850             0040*   plot_pf: equ 0x70
041850             0041*   
041850             0042*   ; &78-&7F 	120-127 	Line fill right to non-foreground §§
041850             0043*   plot_lf_r_non_fg: equ 0x78
041850             0044*   
041850             0045*   ; &80-&87 	128-135 	Not supported (Flood until non-background)
041850             0046*   ; &88-&8F 	136-143 	Not supported (Flood until foreground)
041850             0047*   
041850             0048*   ; &90-&97 	144-151 	Circle outline
041850             0049*   plot_co: equ 0x90
041850             0050*   
041850             0051*   ; &98-&9F 	152-159 	Circle fill
041850             0052*   plot_cf: equ 0x98
041850             0053*   
041850             0054*   ; &A0-&A7 	160-167 	Not supported (Circular arc)
041850             0055*   ; &A8-&AF 	168-175 	Not supported (Circular segment)
041850             0056*   ; &B0-&B7 	176-183 	Not supported (Circular sector)
041850             0057*   
041850             0058*   ; &B8-&BF 	184-191 	Rectangle copy/move
041850             0059*   plot_rcm: equ 0xB8
041850             0060*   
041850             0061*   ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
041850             0062*   ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
041850             0063*   ; &D0-&D7 	208-215 	Not defined
041850             0064*   ; &D8-&DF 	216-223 	Not defined
041850             0065*   ; &E0-&E7 	224-231 	Not defined
041850             0066*   
041850             0067*   ; &E8-&EF 	232-239 	Bitmap plot §
041850             0068*   plot_bmp: equ 0xE8
041850             0069*   
041850             0070*   ; &F0-&F7 	240-247 	Not defined
041850             0071*   ; &F8-&FF 	248-255 	Not defined
041850             0072*   
041850             0073*   ; § Support added in Agon Console8 VDP 2.1.0 §§ Support added in
041850             0074*   ; Agon Console8 VDP 2.2.0
041850             0075*   
041850             0076*   ; Within each group of eight plot codes, the effects are as follows:
041850             0077*   ; Plot code 	Effect
041850             0078*   ; 0 	Move relative
041850             0079*   mv_rel: equ 0
041850             0080*   
041850             0081*   ; 1 	Plot relative in current foreground colour
041850             0082*   dr_rel_fg: equ 1
041850             0083*   
041850             0084*   ; 2 	Not supported (Plot relative in logical inverse colour)
041850             0085*   ; 3 	Plot relative in current background colour
041850             0086*   dr_rel_bg: equ 3
041850             0087*   
041850             0088*   ; 4 	Move absolute
041850             0089*   mv_abs: equ 4
041850             0090*   
041850             0091*   ; 5 	Plot absolute in current foreground colour
041850             0092*   dr_abs_fg: equ 5
041850             0093*   
041850             0094*   ; 6 	Not supported (Plot absolute in logical inverse colour)
041850             0095*   ; 7 	Plot absolute in current background colour
041850             0096*   dr_abs_bg: equ 7
041850             0097*   
041850             0098*   ; Codes 0-3 use the position data provided as part of the command
041850             0099*   ; as a relative position, adding the position given to the current
041850             0100*   ; graphical cursor position. Codes 4-7 use the position data provided
041850             0101*   ; as part of the command as an absolute position, setting the current
041850             0102*   ; graphical cursor position to the position given.
041850             0103*   
041850             0104*   ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
041850             0105*   ; current pixel colour. These operations cannot currently be supported
041850             0106*   ; by the graphics system the Agon VDP uses, so these codes are not
041850             0107*   ; supported. Support for these codes may be added in a future version
041850             0108*   ; of the VDP firmware.
041850             0109*   
041850             0110*   ; 16 colour palette constants
041850             0111*   c_black: equ 0
041850             0112*   c_red_dk: equ 1
041850             0113*   c_green_dk: equ 2
041850             0114*   c_yellow_dk: equ 3
041850             0115*   c_blue_dk: equ 4
041850             0116*   c_magenta_dk: equ 5
041850             0117*   c_cyan_dk: equ 6
041850             0118*   c_grey: equ 7
041850             0119*   c_grey_dk: equ 8
041850             0120*   c_red: equ 9
041850             0121*   c_green: equ 10
041850             0122*   c_yellow: equ 11
041850             0123*   c_blue: equ 12
041850             0124*   c_magenta: equ 13
041850             0125*   c_cyan: equ 14
041850             0126*   c_white: equ 15
041850             0127*   
041850             0128*   ; VDU 25, mode, x; y;: PLOT command
041850             0129*   ; inputs: a=mode, bc=x0, de=y0
041850             0130*   vdu_plot:
041850 32 6A 18 04 0131*       ld (@mode),a
041854 ED 43 6B 18 0132*       ld (@x0),bc
       04          
041859 ED 53 6D 18 0133*       ld (@y0),de
       04          
04185E 21 69 18 04 0134*   	ld hl,@cmd
041862 01 06 00 00 0135*   	ld bc,@end-@cmd
041866 5B DF       0136*   	rst.lil $18
041868 C9          0137*   	ret
041869 19          0138*   @cmd:   db 25
04186A 00          0139*   @mode:  db 0
04186B 00 00       0140*   @x0: 	dw 0
04186D 00 00       0141*   @y0: 	dw 0
04186F 00          0142*   @end:   db 0 ; extra byte to soak up deu
041870             0143*   
041870             0144*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
041870             0145*   ; &E8-&EF 	232-239 	Bitmap plot §
041870             0146*   ; VDU 25, mode, x; y;: PLOT command
041870             0147*   ; inputs: bc=x0, de=y0
041870             0148*   ; prerequisites: vdu_buff_select
041870             0149*   vdu_plot_bmp:
041870 ED 43 87 18 0150*       ld (@x0),bc
       04          
041875 ED 53 89 18 0151*       ld (@y0),de
       04          
04187A 21 85 18 04 0152*   	ld hl,@cmd
04187E 01 06 00 00 0153*   	ld bc,@end-@cmd
041882 5B DF       0154*   	rst.lil $18
041884 C9          0155*   	ret
041885 19          0156*   @cmd:   db 25
041886 ED          0157*   @mode:  db plot_bmp+dr_abs_fg ; 0xED
041887 00 00       0158*   @x0: 	dw 0x0000
041889 00 00       0159*   @y0: 	dw 0x0000
04188B 00          0160*   @end:   db 0x00 ; padding
04188C             0161*   
04188C             0162*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
04188C             0163*   ; &E8-&EF 	232-239 	Bitmap plot §
04188C             0164*   ; VDU 25, mode, x; y;: PLOT command
04188C             0165*   ; inputs: bc=x0, de=y0
04188C             0166*   ; USING 16.8 FIXED POINT COORDINATES
04188C             0167*   ; inputs: ub.c is x coordinate, ud.e is y coordinate
04188C             0168*   ;   the fractional portiion of the inputs are truncated
04188C             0169*   ;   leaving only the 16-bit integer portion
04188C             0170*   ; prerequisites: vdu_buff_select
04188C             0171*   vdu_plot_bmp168:
04188C             0172*   ; populate in the reverse of normal to keep the
04188C             0173*   ; inputs from stomping on each other
04188C ED 53 AA 18 0174*       ld (@y0-1),de
       04          
041891 ED 43 A8 18 0175*       ld (@x0-1),bc
       04          
041896 3E ED       0176*       ld a,plot_bmp+dr_abs_fg ; 0xED
041898 32 A8 18 04 0177*       ld (@mode),a ; restore the mode byte that got stomped on by bcu
04189C 21 A7 18 04 0178*   	ld hl,@cmd
0418A0 01 06 00 00 0179*   	ld bc,@end-@cmd
0418A4 5B DF       0180*   	rst.lil $18
0418A6 C9          0181*   	ret
0418A7 19          0182*   @cmd:   db 25
0418A8 ED          0183*   @mode:  db plot_bmp+dr_abs_fg ; 0xED
0418A9 00 00       0184*   @x0: 	dw 0x0000
0418AB 00 00       0185*   @y0: 	dw 0x0000
0418AD             0186*   @end:  ; no padding required b/c we shifted de right
0418AD             0187*   
0418AD             0188*   ; draw a filled rectangle
0418AD             0189*   vdu_plot_rf:
0418AD ED 43 D4 18 0190*       ld (@x0),bc
       04          
0418B2 ED 53 D6 18 0191*       ld (@y0),de
       04          
0418B7 DD 22 DA 18 0192*       ld (@x1),ix
       04          
0418BC FD 22 DC 18 0193*       ld (@y1),iy
       04          
0418C1 3E 19       0194*       ld a,25 ; we have to reload the 2nd plot command
0418C3 32 D8 18 04 0195*       ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0418C7 21 D2 18 04 0196*   	ld hl,@cmd0
0418CB 01 0C 00 00 0197*   	ld bc,@end-@cmd0
0418CF 5B DF       0198*   	rst.lil $18
0418D1 C9          0199*       ret
0418D2 19          0200*   @cmd0:  db 25 ; plot
0418D3 04          0201*   @arg0:  db plot_sl_both+mv_abs
0418D4 00 00       0202*   @x0:    dw 0x0000
0418D6 00 00       0203*   @y0:    dw 0x0000
0418D8 19          0204*   @cmd1:  db 25 ; plot
0418D9 65          0205*   @arg1:  db plot_rf+dr_abs_fg
0418DA 00 00       0206*   @x1:    dw 0x0000
0418DC 00 00       0207*   @y1:    dw 0x0000
0418DE 00          0208*   @end:   db 0x00 ; padding
0418DF             0209*   
0418DF             0210*   ; draw a filled circle
0418DF             0211*   vdu_plot_cf:
0418DF ED 43 06 19 0212*       ld (@x0),bc
       04          
0418E4 ED 53 08 19 0213*       ld (@y0),de
       04          
0418E9 DD 22 0C 19 0214*       ld (@x1),ix
       04          
0418EE FD 22 0E 19 0215*       ld (@y1),iy
       04          
0418F3 3E 19       0216*       ld a,25 ; we have to reload the 2nd plot command
0418F5 32 0A 19 04 0217*       ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0418F9 21 04 19 04 0218*   	ld hl,@cmd0
0418FD 01 0C 00 00 0219*   	ld bc,@end-@cmd0
041901 5B DF       0220*   	rst.lil $18
041903 C9          0221*       ret
041904 19          0222*   @cmd0:  db 25 ; plot
041905 04          0223*   @arg0:  db plot_sl_both+mv_abs
041906 00 00       0224*   @x0:    dw 0x0000
041908 00 00       0225*   @y0:    dw 0x0000
04190A 19          0226*   @cmd1:  db 25 ; plot
04190B 9D          0227*   @arg1:  db plot_cf+dr_abs_fg
04190C 00 00       0228*   @x1:    dw 0x0000
04190E 00 00       0229*   @y1:    dw 0x0000
041910 00          0230*   @end:   db 0x00 ; padding
041911             0044        include "vdu_sound.inc"
041911             0001*   ; enable enough additional channels so that total enabled = max_channels
041911             0002*   ; inputs: max_channels set
041911             0003*   ; returns: nothing
041911             0004*   ; destroys: af, bc, hl
041911             0005*   vdu_enable_channels:
041911 3E 01       0006*       ld a,max_channels
041913 D6 03       0007*       sub 3 ; subtract number of default channels already enabled
041915 F2 1C 19 04 0008*       jp p,@loop
041919 C9          0009*       ret
04191A 3E 03       0010*       ld a,3 ; first non-default channel
04191C             0011*   @loop:
04191C 32 37 19 04 0012*       ld (@channel),a
041920 21 34 19 04 0013*       ld hl,@beg
041924 01 05 00 00 0014*       ld bc,@end-@beg
041928 F5          0015*       push af
041929 5B DF       0016*       rst.lil $18
04192B F1          0017*       pop af
04192C 3C          0018*       inc a
04192D FE 01       0019*       cp max_channels
04192F C2 1C 19 04 0020*       jp nz,@loop
041933 C9          0021*       ret
041934             0022*   @beg:
041934 17 00 85    0023*               db 23, 0, $85
041937 00          0024*   @channel:   db 0
041938 08          0025*               db 8 ; command 8: enable channel
041939             0026*   @end:
041939             0027*   
041939             0028*   ; disable all but the three default sound channels
041939             0029*   ; inputs: max_channels set
041939             0030*   ; outputs: none
041939             0031*   ; destroys: ah,hl,bc
041939             0032*   vdu_disable_channels:
041939 3E 01       0033*       ld a,max_channels
04193B D6 03       0034*       sub 3 ; subtract number of default channels already enabled
04193D F2 44 19 04 0035*       jp p,@loop
041941 C9          0036*       ret
041942 3E 03       0037*       ld a,3 ; first non-default channel
041944             0038*   @loop:
041944 32 5F 19 04 0039*       ld (@channel),a
041948 21 5C 19 04 0040*       ld hl,@beg
04194C 01 05 00 00 0041*       ld bc,@end-@beg
041950 F5          0042*       push af
041951 5B DF       0043*       rst.lil $18
041953 F1          0044*       pop af
041954 3C          0045*       inc a
041955 FE 01       0046*       cp max_channels
041957 C2 44 19 04 0047*       jp nz,@loop
04195B C9          0048*       ret
04195C             0049*   @beg:
04195C 17 00 85    0050*       db 23, 0, $85
04195F 00          0051*   @channel: db 0
041960 09          0052*       db 9 ; command 9: disable channel
041961             0053*   @end:
041961             0054*   
041961             0055*   
041961             0056*   ; ############################################################
041961             0057*   ; VDU SOUND API
041961             0058*   ; ############################################################
041961             0059*   ; Command 0: Play note
041961             0060*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
041961             0061*       MACRO PLAY_NOTE channel, volume, frequency, duration
041961             0062*       ld hl, @PLAY_NOTE_CMD        ; Start of command block
041961             0063*       ld bc, @PLAY_NOTE_END - @PLAY_NOTE_CMD  ; Command block size
041961             0064*       rst.lil $18
041961             0065*       jr @PLAY_NOTE_END
041961             0066*   @PLAY_NOTE_CMD:  db 23, 0, 0x85               ; Command header
041961             0067*                    db channel                  ; Channel, 0 (commented out)
041961             0068*                    db 0                        ; Play note command
041961             0069*                    db volume                   ; Volume
041961             0070*                    dw frequency                ; Frequency
041961             0071*                    dw duration                 ; Duration
041961             0072*   @PLAY_NOTE_END:
041961             0073*       ENDMACRO
041961             0074*   
041961             0075*       MACRO MUTE_CHANNEL channel
041961             0076*       ld hl, @MUTE_CHANNEL_CMD     ; Start of command block
041961             0077*       ld bc, @MUTE_CHANNEL_END - @MUTE_CHANNEL_CMD  ; Command block size
041961             0078*       rst.lil $18
041961             0079*       jr @MUTE_CHANNEL_END
041961             0080*   @MUTE_CHANNEL_CMD: db 23, 0, 0x85             ; Command header
041961             0081*                      db channel                ; Channel, 0 (commented out)
041961             0082*                      db 2                      ; Set volume command
041961             0083*                      db 0                      ; Volume (mute)
041961             0084*   @MUTE_CHANNEL_END:
041961             0085*       ENDMACRO
041961             0086*   
041961             0087*   ; inputs: c = channel, b = volume, hl = frequency; de = duration;
041961             0088*   vdu_play_note:
041961 79          0089*       ld a,c
041962 32 82 19 04 0090*       ld (@channel),a
041966 78          0091*       ld a,b
041967 32 84 19 04 0092*       ld (@volume),a
04196B 22 85 19 04 0093*       ld (@frequency),hl
04196F ED 53 87 19 0094*       ld (@duration),de
       04          
041974 21 7F 19 04 0095*       ld hl,@cmd
041978 01 0A 00 00 0096*       ld bc,@end-@cmd
04197C 5B DF       0097*       rst.lil $18
04197E C9          0098*       ret
04197F 17 00 85    0099*   @cmd:       db 23, 0, 0x85
041982 00          0100*   @channel:   db 0x00
041983 00          0101*               db 0x00 ; play note command
041984 00          0102*   @volume:    db 0x00
041985 00 00       0103*   @frequency: dw 0x0000
041987 00 00       0104*   @duration:  dw 0x0000
041989 00          0105*   @end:       db 0x00 ; padding
04198A             0106*   
04198A             0107*   ; Command 1: Status
04198A             0108*   ; VDU 23, 0, &85, channel, 1
04198A             0109*   ; inputs: a = channel
04198A             0110*   ; Returns a bit mask indicating the status of the specified channel, or 255 if the channel is not valid, or has been disabled. The bit mask is as follows:
04198A             0111*   ; Bit 	Name 	Meaning
04198A             0112*   ; 0 	Active 	When set this indicates the channel is in use (has an active waveform)
04198A             0113*   ; 1 	Playing 	Indicates the channel is actively playing a note, and thus will reject calls to play a new note
04198A             0114*   ; 2 	Indefinite 	Set if the channel is playing an indefinite duration note
04198A             0115*   ; 3 	Has Volume Envelope 	Set if the channel has a volume envelope
04198A             0116*   ; 4 	Has Frequency Envelope 	Set if the channel has a frequency envelope
04198A             0117*   
04198A             0118*   ; Bits 5-7 are reserved for future use and, for enabled channels, will currently always be zero.
04198A             0119*   vdu_channel_status:
04198A 32 9C 19 04 0120*       ld (@channel),a
04198E 21 99 19 04 0121*       ld hl,@cmd
041992 01 05 00 00 0122*       ld bc,@end-@cmd
041996 5B DF       0123*       rst.lil $18
041998 C9          0124*       ret
041999 17 00 85    0125*   @cmd:       db 23, 0, 0x85
04199C 00          0126*   @channel:   db 0x00
04199D 01          0127*               db 0x01 ; get channel status command
04199E             0128*   @end:
04199E             0129*   
04199E             0130*   ; VDU 23, 0, &85, channel, 2, volume
04199E             0131*   ; inputs: c = channel, b = volume
04199E             0132*   ; Sets the volume of the specified channel. The volume is a value from 0 to 127, where 0 is silent and 127 is full volume. Values over 127 will be treated as 127 (with one exception described later).
04199E             0133*   
04199E             0134*   ; Specifying a channel of -1 (or 255) will set the global sound system volume level. (Requires Console8 VDP 2.5.0 or later.)
04199E             0135*   
04199E             0136*   ; Using this command provides more direct control over a channel than the play note command. It can be used to adjust the volume of a channel that is already playing a note.
04199E             0137*   vdu_channel_volume:
04199E 79          0138*       ld a,c
04199F 32 B6 19 04 0139*       ld (@channel),a
0419A3 78          0140*       ld a,b
0419A4 32 B8 19 04 0141*       ld (@volume),a
0419A8 21 B3 19 04 0142*       ld hl,@cmd
0419AC 01 06 00 00 0143*       ld bc,@end-@cmd
0419B0 5B DF       0144*       rst.lil $18
0419B2 C9          0145*       ret
0419B3 17 00 85    0146*   @cmd:       db 23, 0, 0x85
0419B6 00          0147*   @channel:   db 0x00
0419B7 02          0148*               db 0x02 ; set volume command
0419B8 00          0149*   @volume:    db 0x00
0419B9             0150*   @end:
0419B9             0151*   
0419B9             0152*   ; VDU 23, 0, &85, channel, 3, frequency;
0419B9             0153*   
0419B9             0154*   ; Sets the frequency of the specified channel. The frequency is a 16-bit value specifying in Hz the frequency of the note to be played.
0419B9             0155*   
0419B9             0156*   ; Using this command provides more direct control over a channel than the play note command. It can be used to adjust the frequency of a channel that is already playing a note.
0419B9             0157*   
0419B9             0158*   ; Returns 1 on success, 0 for failure.
0419B9             0159*   vdu_channel_frequency:
0419B9 79          0160*       ld a,c
0419BA 32 D1 19 04 0161*       ld (@channel),a
0419BE ED 53 D3 19 0162*       ld (@frequency),de
       04          
0419C3 21 CE 19 04 0163*       ld hl,@cmd
0419C7 01 07 00 00 0164*       ld bc,@end-@cmd
0419CB 5B DF       0165*       rst.lil $18
0419CD C9          0166*       ret
0419CE 17 00 85    0167*   @cmd:       db 23, 0, 0x85
0419D1 00          0168*   @channel:   db 0x00
0419D2 03          0169*               db 0x03 ; set frequency command
0419D3 00 00       0170*   @frequency: dw 0x0000
0419D5 00          0171*   @end:       db 0x00 ; padding
0419D6             0172*   
0419D6             0173*   
0419D6             0174*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
0419D6             0175*   ; inputs: c = channel, b = waveformOrSample, [hl = bufferId]
0419D6             0176*   ; Sets the waveform type for a channel to use. The waveformOrSample value is a single byte treated as a signed value.
0419D6             0177*   
0419D6             0178*   ; Using a negative value for the waveform indicates that a sample should be used instead. For more information see the documentation for the sample command.
0419D6             0179*   
0419D6             0180*   ; By default a channel is set to use waveform 0 (square wave).
0419D6             0181*   
0419D6             0182*   ; Valid waveform values are as follows:
0419D6             0183*   ; Value 	Waveform
0419D6             0184*   ; 0 	Square wave
0419D6             0185*   ; 1 	Triangle wave
0419D6             0186*   ; 2 	Sawtooth wave
0419D6             0187*   ; 3 	Sine wave
0419D6             0188*   ; 4 	Noise (simple white noise with no frequency support)
0419D6             0189*   ; 5 	VIC Noise (emulates a VIC6561; supports frequency)
0419D6             0190*   ; 8 	Sample (specifying a 16-bit buffer ID for sample data)
0419D6             0191*   
0419D6             0192*   vdu_channel_waveform:
0419D6 79          0193*       ld a,c
0419D7 32 FC 19 04 0194*       ld (@channel),a
0419DB 78          0195*       ld a,b
0419DC 32 FE 19 04 0196*       ld (@waveform),a
0419E0 FE 08       0197*       cp 8 ; check if the waveform is a sample
0419E2 28 06       0198*       jr z, @sample
0419E4 01 06 00 00 0199*       ld bc,@bufferId-@cmd
0419E8 18 08       0200*       jr @sendToVdu
0419EA             0201*   @sample:
0419EA 22 FF 19 04 0202*       ld (@bufferId),hl
0419EE 01 08 00 00 0203*       ld bc,@end-@cmd
0419F2             0204*   @sendToVdu:
0419F2 21 F9 19 04 0205*       ld hl,@cmd
0419F6 5B DF       0206*       rst.lil $18
0419F8 C9          0207*       ret
0419F9 17 00 85    0208*   @cmd:       db 23, 0, 0x85
0419FC 00          0209*   @channel:   db 0x00
0419FD 04          0210*               db 0x04 ; set waveform command
0419FE 00          0211*   @waveform:  db 0x00
0419FF 00 00       0212*   @bufferId:  dw 0x0000
041A01 00          0213*   @end:       db 0x00 ; padding
041A02             0214*   
041A02             0215*   ; VDU 23, 0, &85, channel (ignored), 5, 2, bufferId; format, [sampleRate;]
041A02             0216*   ; inputs: hl = bufferId; a = format, de = sample rate in Hz
041A02             0217*   ; The format is a single byte giving the format of the sample data. The following formats are supported:
041A02             0218*   ; Value	Description
041A02             0219*   ; 0	8-bit signed
041A02             0220*   ; 1	8-bit unsigned
041A02             0221*   ; The format value can also have modifier bits set to modify the behaviour of the sample. The following modifier bits are supported:
041A02             0222*   ; Value	Description
041A02             0223*   ; 8	sample rate is sent in the next 16-bits
041A02             0224*   ; 16	sample is tuneable
041A02             0225*   ; The default sample rate for samples on the VDP is 16kHz (actually 16.384kHz to be precise).
041A02             0226*   vdu_buffer_to_sound:
041A02 22 22 1A 04 0227*       ld (@bufferId),hl
041A06 C6 08       0228*       add a,8 ; modify format byte to indicate sample rate argument is given
041A08 32 24 1A 04 0229*       ld (@format),a
041A0C ED 53 25 1A 0230*       ld (@sampleRate),de
       04          
041A11 21 1C 1A 04 0231*       ld hl,@cmd
041A15 01 0B 00 00 0232*       ld bc,@end-@cmd
041A19 5B DF       0233*       rst.lil $18
041A1B C9          0234*       ret
041A1C 17 00 85    0235*   @cmd:       db 23, 0, 0x85
041A1F 00          0236*   @channel:   db 0x00 ; ignored
041A20 05          0237*               db 0x05 ; buffer to sound command
041A21 02          0238*               db 0x02 ; command 2 create sample
041A22 00 00       0239*   @bufferId:  dw 0x0000
041A24 00          0240*   @format:    db 0x00
041A25 00 00       0241*   @sampleRate: dw 0x0000
041A27 00          0242*   @end:       db 0x00 ; padding
041A28             0243*   
041A28             0244*   ; Command 13: Set sample rate
041A28             0245*   ; VDU 23, 0, &85, channel, 13, sampleRate;
041A28             0246*   ; inputs: c = channel, hl = sampleRate (Hz)
041A28             0247*   vdu_set_sample_rate:
041A28 79          0248*       ld a,c
041A29 32 3F 1A 04 0249*       ld (@channel),a
041A2D 22 41 1A 04 0250*       ld (@sampleRate),hl
041A31 21 3C 1A 04 0251*       ld hl,@cmd
041A35 01 07 00 00 0252*       ld bc,@end-@cmd
041A39 5B DF       0253*       rst.lil $18
041A3B C9          0254*       ret
041A3C 17 00 85    0255*   @cmd:       db 23, 0, 0x85
041A3F 00          0256*   @channel:   db 0x00
041A40 0D          0257*               db 13 ; set sample rate command
041A41 00 00       0258*   @sampleRate: dw 0x0000
041A43 00          0259*   @end:       db 0x00 ; padding
041A44             0260*   
041A44             0261*   ; load a sound file to a buffer
041A44             0262*   ; inputs: hl = bufferId ; de = sampleRate in Hz ; iy = pointer to filename
041A44             0263*   vdu_load_sfx:
041A44             0264*   ; back up input parameters
041A44 E5          0265*       push hl ; bufferId
041A45 D5          0266*       push de ; sample rate
041A46             0267*   ; load the sound
041A46 CD 84 15 04 0268*       call vdu_load_buffer_from_file
041A4A             0269*   ; now make the buffer a sound sample
041A4A D1          0270*       pop de ; sample rate
041A4B E1          0271*       pop hl ; bufferId
041A4C AF          0272*       xor a ; zero is the magic number for mono 8-bit signed PCM
041A4D CD 02 1A 04 0273*       call vdu_buffer_to_sound
041A51 C9          0274*       ret
041A52             0275*   
041A52             0276*   
041A52 00          0277*   last_channel: db 0
041A53             0278*   max_channels: equ 1
041A53             0279*   
041A53             0280*   ; play a sound effect from an already loaded buffer
041A53             0281*   ; inputs: hl = bufferId ; bc = duration in milliseconds
041A53             0282*   vdu_play_sfx:
041A53 22 8B 1A 04 0283*       ld (@bufferId),hl
041A57 ED 43 95 1A 0284*       ld (@duration),bc
       04          
041A5C 3E 17       0285*       ld a,23
041A5E 32 8D 1A 04 0286*       ld (@bufferId+2),a
041A62 3A 52 1A 04 0287*       ld a,(last_channel)
041A66 3C          0288*       inc a
041A67             0289*       ; and 31 ; modulo 32
041A67 FE 01       0290*       cp max_channels
041A69 C2 6E 1A 04 0291*       jp nz,@load_channel
041A6D AF          0292*       xor a
041A6E             0293*   @load_channel:
041A6E 32 52 1A 04 0294*       ld (last_channel),a
041A72 32 88 1A 04 0295*       ld (@channel0),a
041A76 32 90 1A 04 0296*       ld (@channel1),a
041A7A 21 85 1A 04 0297*       ld hl, @sample
041A7E 01 12 00 00 0298*       ld bc, @sample_end - @sample
041A82 5B DF       0299*       rst.lil $18
041A84 C9          0300*       ret
041A85             0301*   @sample:
041A85             0302*   ; Command 4: Set waveform
041A85             0303*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
041A85 17 00 85    0304*       .db 23,0,$85                        ; do sound
041A88             0305*   @channel0:
041A88 00 04 08    0306*       .db 0,4,8 ; channel, command, waveform
041A8B             0307*   @bufferId:
041A8B 00 00       0308*       .dw 0x0000
041A8D             0309*   ; Command 0: Play note
041A8D             0310*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
041A8D 17 00 85    0311*       .db 23,0,$85                        ; do sound
041A90             0312*   @channel1:
041A90 00 00 7F    0313*       .db 0,0,127                ; channel, volume
041A93 00 00       0314*       .dw 0
041A95             0315*   @duration:                              ; freq (tuneable samples only)
041A95 00 00       0316*       .dw 0x0000                        ; duration
041A97             0317*   @sample_end:
041A97 00          0318*       .db 0x00 ; padding
041A98             0319*   
041A98             0320*   ; inputs: c = channel, b = volume, de = sample rate; hl = bufferId;
041A98             0321*   vdu_play_sample:
041A98             0322*       ; populate input parameters
041A98 79          0323*       ld a,c
041A99 32 CB 1A 04 0324*       ld (@channel0),a
041A9D 32 D3 1A 04 0325*       ld (@channel1),a
041AA1 32 DA 1A 04 0326*       ld (@channel2),a
041AA5 78          0327*       ld a,b
041AA6 32 DC 1A 04 0328*       ld (@volume),a
041AAA ED 53 D5 1A 0329*       ld (@sampleRate),de
       04          
041AAF 22 CE 1A 04 0330*       ld (@bufferId),hl
041AB3 3E 17       0331*       ld a,23
041AB5 32 D0 1A 04 0332*       ld (@cmd1),a
041AB9 32 D7 1A 04 0333*       ld (@cmd2),a
041ABD             0334*       ; prep the vdu command string
041ABD 21 C8 1A 04 0335*       ld hl, @cmd0
041AC1 01 19 00 00 0336*       ld bc, @end - @cmd0
041AC5 5B DF       0337*       rst.lil $18
041AC7 C9          0338*       ret
041AC8             0339*   ; set waveform command
041AC8 17 00 85    0340*   @cmd0:       db 23, 0, 0x85
041ACB 00          0341*   @channel0:   db 0x00
041ACC 04          0342*                db 0x04 ; set waveform command
041ACD 08          0343*   @waveform:   db 0x08 ; sample
041ACE 00 00       0344*   @bufferId:   dw 0x0000
041AD0             0345*   ; set sample rate command
041AD0 17 00 85    0346*   @cmd1:       db 23, 0, 0x85
041AD3 00          0347*   @channel1:   db 0x00
041AD4 0D          0348*               db 13 ; set sample rate command
041AD5 00 00       0349*   @sampleRate: dw 0x0000
041AD7             0350*   ; play note command
041AD7 17 00 85    0351*   @cmd2:       db 23, 0, 0x85
041ADA 00          0352*   @channel2:   db 0x00
041ADB 00          0353*                db 0x00 ; play note command
041ADC 00          0354*   @volume:     db 0x00
041ADD 00 00       0355*   @frequency:  dw 0x00 ; no effect unless buffer has been set to tuneable sample
041ADF 00 00       0356*   @duration:   dw 0x0000 ; milliseconds: set to -1 to loop indefinitely, 0 to play full duration once
041AE1 00          0357*   @end:        db 0x00 ; padding
041AE2             0045    
041AE2             0046    ; APPLICATION INCLUDES
041AE2             0047        include "layout.inc"
041AE2             0001*   text_top: equ 0
041AE2             0002*   text_left: equ 0
041AE2             0003*   text_bottom: equ 47      ; 48 rows, zero-based
041AE2             0004*   text_right: equ 63       ; 64 columns, zero-based
041AE2             0005*   
041AE2 00          0006*   original_screen_mode: db 0 ; screen mode when app started so we can return to it on exit
041AE3             0007*   
041AE3 2D 2D 2D 2D 0008*   str_dashes_thin: asciz  "----------------------------------------------------------------"
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       00          
041B24 3D 3D 3D 3D 0009*   str_dashes_thick: asciz "================================================================"
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       00          
041B65             0010*   
041B65             0011*   ; set text viewport for current playing song
041B65             0012*   vp_now_playing_top: equ 34
041B65             0013*   vp_now_playing:
041B65 0E 00       0014*       ld c, text_left
041B67 16 22       0015*       ld d, vp_now_playing_top
041B69 1E 3F       0016*       ld e, text_right
041B6B 06 22       0017*       ld b, vp_now_playing_top
041B6D CD CF 13 04 0018*       call vdu_set_txt_viewport
041B71 C9          0019*       ret
041B72             0020*   ; end vp_now_playing
041B72             0021*   
041B72             0022*   ; set text viewport for elapsed time
041B72             0023*   vp_elapsed_top: equ vp_now_playing_top+1
041B72             0024*   vp_elapsed_right: equ text_left+7 ; 8 chars for HH:MM:SS
041B72             0025*   vp_elapsed:
041B72 0E 00       0026*       ld c, text_left
041B74 16 23       0027*       ld d, vp_elapsed_top
041B76 1E 07       0028*       ld e, vp_elapsed_right
041B78 06 23       0029*       ld b, vp_elapsed_top
041B7A CD CF 13 04 0030*       call vdu_set_txt_viewport
041B7E C9          0031*       ret
041B7F             0032*   ; end vp_elapsed
041B7F             0033*   
041B7F             0034*   ; set text viewport for song duration
041B7F             0035*   vp_duration_left: equ text_right-7 ; 8 chars for HH:MM:SS
041B7F             0036*   vp_duration_top: equ vp_now_playing_top+1
041B7F             0037*   vp_duration:
041B7F 0E 38       0038*       ld c, vp_duration_left
041B81 16 23       0039*       ld d, vp_duration_top
041B83 1E 3F       0040*       ld e, text_right
041B85 06 23       0041*       ld b, vp_duration_top
041B87 CD CF 13 04 0042*       call vdu_set_txt_viewport
041B8B C9          0043*       ret
041B8C             0044*   ; end vp_duration
041B8C             0045*   
041B8C             0046*   ; set text viewport for playing breadcrumbs
041B8C             0047*   vp_playhead_left: equ vp_elapsed_right+1 ; leave room for left arrow
041B8C             0048*   vp_playhead_top: equ vp_now_playing_top+1
041B8C             0049*   vp_playhead_right: equ vp_duration_left-1 ; leave room for right arrow
041B8C             0050*   vp_playhead:
041B8C 0E 08       0051*       ld c, vp_playhead_left
041B8E 16 23       0052*       ld d, vp_playhead_top
041B90 1E 37       0053*       ld e, vp_playhead_right
041B92 06 23       0054*       ld b, vp_playhead_top
041B94 CD CF 13 04 0055*       call vdu_set_txt_viewport
041B98 C9          0056*       ret
041B99             0057*   ; end vp_playhead
041B99             0058*   
041B99             0059*   vp_dir_hdr_top: equ 20
041B99             0060*   vp_dir_hdr:
041B99 0E 00       0061*       ld c,text_left
041B9B 16 14       0062*       ld d,vp_dir_hdr_top
041B9D 1E 3F       0063*       ld e,text_right
041B9F 06 14       0064*       ld b,vp_dir_hdr_top
041BA1 CD CF 13 04 0065*       call vdu_set_txt_viewport
041BA5 C9          0066*       ret
041BA6             0067*   
041BA6             0068*   vp_dir_name_top: equ vp_dir_hdr_top+1
041BA6             0069*   vp_dir_name:
041BA6 0E 00       0070*       ld c,text_left
041BA8 16 15       0071*       ld d,vp_dir_name_top
041BAA 1E 3F       0072*       ld e,text_right
041BAC 06 15       0073*       ld b,vp_dir_name_top
041BAE CD CF 13 04 0074*       call vdu_set_txt_viewport
041BB2 C9          0075*       ret
041BB3             0076*   
041BB3             0077*   ; set text viewport for directory listing
041BB3             0078*   vp_dir_top: equ vp_dir_hdr_top+3
041BB3             0079*   vp_dir_bottom: equ vp_dir_top+9
041BB3             0080*   vp_dir:
041BB3 0E 00       0081*       ld c,text_left
041BB5 16 17       0082*       ld d,vp_dir_top
041BB7 1E 3F       0083*       ld e,text_right
041BB9 06 20       0084*       ld b,vp_dir_bottom
041BBB CD CF 13 04 0085*       call vdu_set_txt_viewport
041BBF C9          0086*       ret
041BC0             0087*   
041BC0             0088*   vp_legend_top: equ vp_playhead_top+2
041BC0             0089*   vp_legend:
041BC0 0E 00       0090*       ld c,text_left
041BC2 16 25       0091*       ld d,vp_legend_top
041BC4 1E 3F       0092*       ld e,text_right
041BC6 06 27       0093*       ld b,vp_legend_top+2
041BC8 CD CF 13 04 0094*       call vdu_set_txt_viewport
041BCC C9          0095*       ret
041BCD             0096*   
041BCD             0097*   vp_legend_shuffle_top: equ vp_legend_top+1
041BCD             0098*   vp_legend_shuffle_left: equ text_left+33
041BCD             0099*   vp_legend_shuffle:
041BCD 0E 21       0100*       ld c,vp_legend_shuffle_left
041BCF 16 26       0101*       ld d,vp_legend_shuffle_top
041BD1 1E 23       0102*       ld e,vp_legend_shuffle_left+2
041BD3 06 26       0103*       ld b,vp_legend_shuffle_top
041BD5 CD CF 13 04 0104*       call vdu_set_txt_viewport
041BD9 C9          0105*       ret
041BDA             0106*   
041BDA             0107*   vp_legend_loop_top: equ vp_legend_top+1
041BDA             0108*   vp_legend_loop_left: equ text_left+51
041BDA             0109*   vp_legend_loop:
041BDA 0E 33       0110*       ld c,vp_legend_loop_left
041BDC 16 26       0111*       ld d,vp_legend_loop_top
041BDE 1E 35       0112*       ld e,vp_legend_loop_left+2
041BE0 06 26       0113*       ld b,vp_legend_loop_top
041BE2 CD CF 13 04 0114*       call vdu_set_txt_viewport
041BE6 C9          0115*       ret
041BE7             0116*   
041BE7             0117*   vp_messages_top: equ vp_playhead_top+6
041BE7             0118*   vp_messages_bottom: equ text_bottom
041BE7             0119*   ; set text viewport for messages
041BE7             0120*   vp_messages:
041BE7 0E 00       0121*       ld c,text_left
041BE9 16 29       0122*       ld d,vp_messages_top
041BEB 1E 3F       0123*       ld e,text_right
041BED 06 2F       0124*       ld b,vp_messages_bottom
041BEF CD CF 13 04 0125*       call vdu_set_txt_viewport
041BF3 C9          0126*       ret
041BF4             0127*   
041BF4             0128*   set_text_colours_normal:
041BF4             0129*   ; set text background color
041BF4 3E 84       0130*       ld a,c_blue_dk+128
041BF6 CD A7 13 04 0131*       call vdu_colour_text
041BFA             0132*   ; set text foreground color
041BFA 3E 0F       0133*       ld a,c_white
041BFC CD A7 13 04 0134*       call vdu_colour_text
041C00 C9          0135*       ret
041C01             0136*   ; end set_text_colours_normal
041C01             0137*   
041C01             0138*   set_text_colours_inverse:
041C01             0139*   ; set text background color
041C01 3E 8F       0140*       ld a,c_white+128
041C03 CD A7 13 04 0141*       call vdu_colour_text
041C07             0142*   ; set text foreground color
041C07 3E 04       0143*       ld a,c_blue_dk
041C09 CD A7 13 04 0144*       call vdu_colour_text
041C0D C9          0145*       ret
041C0E             0146*   ; end set_text_colours_inverse
041C0E             0147*   
041C0E             0148*   ui_init:
041C0E             0149*   ; get current screen mode and save it so we can return to it on exit
041C0E CD 55 14 04 0150*       call vdu_get_screen_mode
041C12 32 E2 1A 04 0151*       ld (original_screen_mode),a
041C16             0152*   ; set up display
041C16 3E 14       0153*       ld a,20 ; 512x384x64 single-buffered
041C18 CD 44 14 04 0154*       call vdu_set_screen_mode
041C1C AF          0155*       xor a
041C1D CD 5D 14 04 0156*       call vdu_set_scaling
041C21             0157*   ; load fonts and select one
041C21 CD 4B 17 04 0158*       call vdu_clear_all_buffers
041C25 CD BB 05 04 0159*   	call fonts_load
041C29 21 10 FA 00 0160*       ld hl,Lat2_VGA8_8x8
041C2D 3E 01       0161*       ld a,1
041C2F CD BD 17 04 0162*       call vdu_font_select
041C33             0163*   ; set text fg and bg colours to normal
041C33 CD F4 1B 04 0164*       call set_text_colours_normal
041C37             0165*   ; set cursor behaviuor
041C37 CD FE 12 04 0166*       call vdu_cursor_off
041C3B 26 10       0167*       ld h,%00010000 ; bit 4 controls cursor scroll at bottom of screen
041C3D 2E 10       0168*       ld l,%00010000 ; bit 4 set means cursor wraps to top of screen
041C3F CD 62 13 04 0169*       call vdu_cursor_behaviour
041C43             0170*   ; reset text viewports and clear the screen
041C43 CD 3F 14 04 0171*       call vdu_reset_viewports
041C47 CD 76 13 04 0172*       call vdu_cls
041C4B             0173*   
041C4B             0174*   ; tippy top border
041C4B 0E 00       0175*       ld c,text_left ; x
041C4D 06 00       0176*       ld b,text_top ; y
041C4F CD 4E 13 04 0177*       call vdu_move_cursor
041C53 21 24 1B 04 0178*       ld hl,str_dashes_thick
041C57 CD 67 00 04 0179*       call printString
041C5B             0180*   
041C5B             0181*   ; print ascii art splash screen
041C5B 0E 00       0182*       ld c,text_left ; x
041C5D 06 01       0183*       ld b,text_top+1 ; y
041C5F CD 4E 13 04 0184*       call vdu_move_cursor
041C63 21 92 1D 04 0185*       ld hl,agon_jukebox_ascii
041C67 CD 67 00 04 0186*       call printString
041C6B             0187*   
041C6B             0188*   ; below logo border
041C6B 0E 00       0189*       ld c,text_left ; x
041C6D 06 13       0190*       ld b,vp_dir_hdr_top-1 ; y
041C6F CD 4E 13 04 0191*       call vdu_move_cursor
041C73 21 24 1B 04 0192*       ld hl,str_dashes_thick
041C77 CD 67 00 04 0193*       call printString
041C7B             0194*   
041C7B             0195*   ; print the directory header
041C7B 0E 00       0196*       ld c,text_left ; x
041C7D 06 14       0197*       ld b,vp_dir_hdr_top ; y
041C7F CD 4E 13 04 0198*       call vdu_move_cursor
041C83 CD 60 00 04 0199*       call printInline
041C87 4F 75 72 20 0200*       asciz "Our current directory is:"
       63 75 72 72 
       65 6E 74 20 
       64 69 72 65 
       63 74 6F 72 
       79 20 69 73 
       3A 00       
041CA1             0201*   
041CA1             0202*   ; file list top border
041CA1 0E 00       0203*       ld c,text_left ; x
041CA3 06 16       0204*       ld b,vp_dir_top-1 ; y
041CA5 CD 4E 13 04 0205*       call vdu_move_cursor
041CA9 21 E3 1A 04 0206*       ld hl,str_dashes_thin
041CAD CD 67 00 04 0207*       call printString
041CB1             0208*   
041CB1             0209*   ; file list bottom border
041CB1 0E 00       0210*       ld c,text_left ; x
041CB3 06 21       0211*       ld b,vp_dir_bottom+1 ; y
041CB5 CD 4E 13 04 0212*       call vdu_move_cursor
041CB9 21 E3 1A 04 0213*       ld hl,str_dashes_thin
041CBD CD 67 00 04 0214*       call printString
041CC1             0215*   
041CC1             0216*   ; below the breadcrumbs border
041CC1 0E 00       0217*       ld c,text_left ; x
041CC3 06 24       0218*       ld b,vp_playhead_top+1 ; y
041CC5 CD 4E 13 04 0219*       call vdu_move_cursor
041CC9 21 24 1B 04 0220*       ld hl,str_dashes_thick
041CCD CD 67 00 04 0221*       call printString
041CD1             0222*   
041CD1             0223*   ; print the navigation and song control instructions
041CD1 0E 00       0224*       ld c,text_left ; x
041CD3 06 25       0225*       ld b,vp_playhead_top+2 ; y
041CD5 CD 4E 13 04 0226*       call vdu_move_cursor
041CD9 CD 60 00 04 0227*       call printInline
041CDD 20 53 6F 6E 0228*       db " Song \e",24," \e",25," or 0-9    | Page \e",27," \e",26,"           | [U]p directory\r\n"
       67 20 1B 18 
       20 1B 19 20 
       6F 72 20 30 
       2D 39 20 20 
       20 20 7C 20 
       50 61 67 65 
       20 1B 1B 20 
       1B 1A 20 20 
       20 20 20 20 
       20 20 20 20 
       20 7C 20 5B 
       55 5D 70 20 
       64 69 72 65 
       63 74 6F 72 
       79 0D 0A    
041D1C 20 5B 52 5D 0229*       db " [R]andom song      | [S]huffle: OFF     | [L]oop: OFF\r\n"
       61 6E 64 6F 
       6D 20 73 6F 
       6E 67 20 20 
       20 20 20 20 
       7C 20 5B 53 
       5D 68 75 66 
       66 6C 65 3A 
       20 4F 46 46 
       20 20 20 20 
       20 7C 20 5B 
       4C 5D 6F 6F 
       70 3A 20 4F 
       46 46 0D 0A 
041D54 20 5B 45 53 0230*       db " [ESC] or [Q]uit    |                    |\r\n"
       43 5D 20 6F 
       72 20 5B 51 
       5D 75 69 74 
       20 20 20 20 
       7C 20 20 20 
       20 20 20 20 
       20 20 20 20 
       20 20 20 20 
       20 20 20 20 
       20 7C 0D 0A 
041D80 00          0231*       db 0 ; null terminator
041D81             0232*   
041D81             0233*   ; below the detailed instructions / status border
041D81 0E 00       0234*       ld c,text_left ; x
041D83 06 28       0235*       ld b,vp_playhead_top+5 ; y
041D85 CD 4E 13 04 0236*       call vdu_move_cursor
041D89 21 24 1B 04 0237*       ld hl,str_dashes_thick
041D8D CD 67 00 04 0238*       call printString
041D91             0239*   
041D91 C9          0240*       ret
041D92             0241*   ; end ui_init
041D92             0048        include "ascii.inc"
041D92             0001*   agon_jukebox_ascii:
041D92 20 20 20 5F 0002*       db 32,32,32,95,95,95,95,95,32,32,32,32,95,95,95,95,95,95,95,95,32,95,95,95,95,95,95,95,95,32,32,32,32,95,95,95,95,95,95,95,13,10
       5F 5F 5F 5F 
       20 20 20 20 
       5F 5F 5F 5F 
       5F 5F 5F 5F 
       20 5F 5F 5F 
       5F 5F 5F 5F 
       5F 20 20 20 
       20 5F 5F 5F 
       5F 5F 5F 5F 
       0D 0A       
041DBC 20 20 2F 20 0003*       db 32,32,47,32,32,95,32,32,92,32,32,47,32,32,95,95,95,95,95,47,32,92,95,95,95,95,95,32,32,92,32,32,32,92,32,32,32,32,32,32,92,13,10
       20 5F 20 20 
       5C 20 20 2F 
       20 20 5F 5F 
       5F 5F 5F 2F 
       20 5C 5F 5F 
       5F 5F 5F 20 
       20 5C 20 20 
       20 5C 20 20 
       20 20 20 20 
       5C 0D 0A    
041DE7 20 2F 20 20 0004*       db 32,47,32,32,47,95,92,32,32,92,47,32,32,32,92,32,32,95,95,95,32,32,47,32,32,32,124,32,32,32,92,32,32,47,32,32,32,124,32,32,32,92,13,10
       2F 5F 5C 20 
       20 5C 2F 20 
       20 20 5C 20 
       20 5F 5F 5F 
       20 20 2F 20 
       20 20 7C 20 
       20 20 5C 20 
       20 2F 20 20 
       20 7C 20 20 
       20 5C 0D 0A 
041E13 2F 20 20 20 0005*       db 47,32,32,32,32,124,32,32,32,32,92,32,32,32,32,92,95,92,32,32,92,47,32,32,32,32,124,32,32,32,32,92,47,32,32,32,32,124,32,32,32,32,92,13,10
       20 7C 20 20 
       20 20 5C 20 
       20 20 20 5C 
       5F 5C 20 20 
       5C 2F 20 20 
       20 20 7C 20 
       20 20 20 5C 
       2F 20 20 20 
       20 7C 20 20 
       20 20 5C 0D 
       0A          
041E40 5C 5F 5F 5F 0006*       db 92,95,95,95,95,124,95,95,32,32,47,92,95,95,95,95,95,95,32,32,47,92,95,95,95,95,95,95,95,32,32,47,92,95,95,95,95,124,95,95,32,32,47,13,10
       5F 7C 5F 5F 
       20 20 2F 5C 
       5F 5F 5F 5F 
       5F 5F 20 20 
       2F 5C 5F 5F 
       5F 5F 5F 5F 
       5F 20 20 2F 
       5C 5F 5F 5F 
       5F 7C 5F 5F 
       20 20 2F 0D 
       0A          
041E6D 20 20 20 20 0007*       db 32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,32,92,47,13,10
       20 20 20 20 
       5C 2F 20 20 
       20 20 20 20 
       20 20 5C 2F 
       20 20 20 20 
       20 20 20 20 
       20 5C 2F 20 
       20 20 20 20 
       20 20 20 20 
       5C 2F 0D 0A 
041E99 20 20 20 20 0008*       db 32,32,32,32,32,95,95,95,95,32,95,95,95,95,32,95,95,95,32,95,95,95,95,32,32,95,95,32,95,95,95,95,95,95,95,95,95,95,95,13,10
       20 5F 5F 5F 
       5F 20 5F 5F 
       5F 5F 20 5F 
       5F 5F 20 5F 
       5F 5F 5F 20 
       20 5F 5F 20 
       5F 5F 5F 5F 
       5F 5F 5F 5F 
       5F 5F 5F 0D 
       0A          
041EC2 20 20 20 20 0009*       db 32,32,32,32,124,32,32,32,32,124,32,32,32,32,124,32,32,32,92,32,32,32,32,124,47,32,95,124,92,95,32,32,32,95,95,95,95,95,47,13,10
       7C 20 20 20 
       20 7C 20 20 
       20 20 7C 20 
       20 20 5C 20 
       20 20 20 7C 
       2F 20 5F 7C 
       5C 5F 20 20 
       20 5F 5F 5F 
       5F 5F 2F 0D 
       0A          
041EEB 20 20 20 20 0010*       db 32,32,32,32,124,32,32,32,32,124,32,32,32,32,124,32,32,32,47,32,32,32,32,32,32,60,32,32,32,124,32,32,32,32,95,95,41,95,13,10
       7C 20 20 20 
       20 7C 20 20 
       20 20 7C 20 
       20 20 2F 20 
       20 20 20 20 
       20 3C 20 20 
       20 7C 20 20 
       20 20 5F 5F 
       29 5F 0D 0A 
041F13 2F 5C 5F 5F 0011*       db 47,92,95,95,124,32,32,32,32,124,32,32,32,32,124,32,32,47,124,32,32,32,32,124,32,32,92,32,32,124,32,32,32,32,32,32,32,32,92,13,10
       7C 20 20 20 
       20 7C 20 20 
       20 20 7C 20 
       20 2F 7C 20 
       20 20 20 7C 
       20 20 5C 20 
       20 7C 20 20 
       20 20 20 20 
       20 20 5C 0D 
       0A          
041F3C 5C 5F 5F 5F 0012*       db 92,95,95,95,95,95,95,95,95,124,95,95,95,95,95,95,47,32,124,95,95,95,95,124,95,95,32,92,47,95,95,95,95,95,95,95,32,32,47,13,10
       5F 5F 5F 5F 
       5F 7C 5F 5F 
       5F 5F 5F 5F 
       2F 20 7C 5F 
       5F 5F 5F 7C 
       5F 5F 20 5C 
       2F 5F 5F 5F 
       5F 5F 5F 5F 
       20 20 2F 0D 
       0A          
041F65 20 20 20 20 0013*       db 32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,92,47,13,10
       20 20 20 20 
       20 20 20 20 
       20 20 20 20 
       20 20 20 20 
       20 20 20 20 
       20 20 5C 2F 
       20 20 20 20 
       20 20 20 20 
       5C 2F 0D 0A 
041F8D 20 20 20 20 0014*       db 32,32,32,32,95,95,95,95,95,95,95,95,95,95,32,95,95,95,95,95,95,95,95,32,32,95,95,95,95,32,32,95,95,95,13,10
       5F 5F 5F 5F 
       5F 5F 5F 5F 
       5F 5F 20 5F 
       5F 5F 5F 5F 
       5F 5F 5F 20 
       20 5F 5F 5F 
       5F 20 20 5F 
       5F 5F 0D 0A 
041FB1 20 20 20 20 0015*       db 32,32,32,32,92,95,95,95,95,95,95,32,32,32,92,92,95,95,95,95,95,32,32,92,32,92,32,32,32,92,47,32,32,47,13,10
       5C 5F 5F 5F 
       5F 5F 5F 20 
       20 20 5C 5C 
       5F 5F 5F 5F 
       5F 20 20 5C 
       20 5C 20 20 
       20 5C 2F 20 
       20 2F 0D 0A 
041FD5 20 20 20 20 0016*       db 32,32,32,32,32,124,32,32,32,32,124,32,32,95,47,32,47,32,32,32,124,32,32,32,92,32,92,32,32,32,32,32,47,13,10
       20 7C 20 20 
       20 20 7C 20 
       20 5F 2F 20 
       2F 20 20 20 
       7C 20 20 20 
       5C 20 5C 20 
       20 20 20 20 
       2F 0D 0A    
041FF8 20 20 20 20 0017*       db 32,32,32,32,32,124,32,32,32,32,124,32,32,32,92,47,32,32,32,32,124,32,32,32,32,92,47,32,32,32,32,32,92,13,10
       20 7C 20 20 
       20 20 7C 20 
       20 20 5C 2F 
       20 20 20 20 
       7C 20 20 20 
       20 5C 2F 20 
       20 20 20 20 
       5C 0D 0A    
04201B 20 20 20 20 0018*       db 32,32,32,32,32,124,95,95,95,95,95,95,32,32,47,92,95,95,95,95,95,95,95,32,32,47,95,95,95,47,92,32,32,92,13,10
       20 7C 5F 5F 
       5F 5F 5F 5F 
       20 20 2F 5C 
       5F 5F 5F 5F 
       5F 5F 5F 20 
       20 2F 5F 5F 
       5F 2F 5C 20 
       20 5C 0D 0A 
04203F 20 20 20 20 0019*       db 32,32,32,32,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,92,95,47,13,10
       20 20 20 20 
       20 20 20 20 
       5C 2F 20 20 
       20 20 20 20 
       20 20 20 5C 
       2F 20 20 20 
       20 20 20 5C 
       5F 2F 0D 0A 
042063 00          0020*       db 0 ; list terminator
042064             0049        include "input.inc"
042064             0001*   get_input:
042064             0002*   ; wait for the user to push a button
042064 FB          0003*       ei ; enable interrupts
042065             0004*       MOSCALL mos_getkey ; a = ascii code of key pressed
                       M1 Args: function=mos_getkey 
042065 3E 00       0001*M1 			LD	A, function
042067 5B CF       0002*M1 			RST.LIL	08h
042069 F3          0005*       di ; disable interrupts
04206A             0006*   
04206A             0007*   ; DEBUG
04206A             0008*   ; clear sysvar_keyascii
04206A 6F          0009*       ld l,a ; store for a sec
04206B             0010*   	MOSCALL mos_sysvars
                       M1 Args: function=mos_sysvars 
04206B 3E 08       0001*M1 			LD	A, function
04206D 5B CF       0002*M1 			RST.LIL	08h
04206F AF          0011*   	xor a
042070 DD 77 05    0012*   	ld (IX+sysvar_keyascii),a
042073 7D          0013*       ld a,l ; restore a
042074             0014*   ; DEBUG
042074             0015*   
042074             0016*   ; app control commands
042074             0017*   
042074             0018*   ; RETURN TO MAIN, which re-enables interrupts and exits app
042074 FE 1B       0019*       cp '\e' ; escape
042076 C8          0020*       ret z
042077 FE 71       0021*       cp 'q' ; quit
042079 C8          0022*       ret z
04207A             0023*   
04207A             0024*   ; DIRECTORY PAGING
04207A FE 15       0025*       cp 0x15 ; right arrow
04207C CA BE 27 04 0026*       jp z,ps_dir_next_page
042080 FE 08       0027*       cp 0x08 ; left arrow
042082 CA DD 27 04 0028*       jp z,ps_dir_prev_page
042086             0029*   
042086             0030*   ; SONG PLAYING COMMANDS
042086             0031*   ; toggle play / pause
042086 FE 70       0032*       cp 'p'
042088 CA 3C 21 04 0033*       jp z,ps_toggle_pause
04208C             0034*   ; toggle loop
04208C FE 6C       0035*       cp 'l'
04208E CA B9 21 04 0036*       jp z,ps_toggle_loop
042092             0037*   ; toggle shuffle
042092 FE 73       0038*       cp 's'
042094 CA 80 21 04 0039*       jp z,ps_toggle_shuffle
042098             0040*   ; play random song
042098 FE 72       0041*       cp 'r'
04209A CA 33 28 04 0042*       jp z,ps_play_random
04209E             0043*   ; go up one directory
04209E FE 75       0044*       cp 'u'
0420A0 CA D4 20 04 0045*       jp z,ps_up_dir
0420A4             0046*   ; 0-9 play song keys
0420A4             0047*   @@:
0420A4 FE 30       0048*       cp '0'
0420A6 DA BA 20 04 0049*       jp c,@no_cmd ; not a song command
0420AA FE 3A       0050*       cp '9'+1
0420AC D2 BA 20 04 0051*       jp nc,@no_cmd ; not a song command
0420B0             0052*   ; get pointer to song filename and play it
0420B0 D6 30       0053*       sub '0' ; a = index into filename lut
0420B2 CD 00 28 04 0054*       call ps_get_song_fn_from_pg_idx ; carry set indicates success
0420B6 DA BE 20 04 0055*       jp c,ps_play_or_chg_dir ; re-enables interrupts and jp's to get_input when finished
0420BA             0056*   @no_cmd: ; no valid commands so loop
0420BA C3 64 20 04 0057*       jp get_input
0420BE             0058*   ; end get_input
0420BE             0059*   
0420BE             0060*   ; play or song or change directory when user issues a play song command
0420BE             0061*   ; inputs: hl pointer to the filename, a = file attribute
0420BE             0062*   ps_play_or_chg_dir:
0420BE FE 10       0063*       cp AM_DIR ; file attribute check for directory
0420C0 C2 DB 24 04 0064*       jp nz,play_song ; not a directory so play the song
0420C4             0065*   ; otherwise change to the directory
0420C4             0066*       MOSCALL mos_cd ; change to the directory
                       M1 Args: function=mos_cd 
0420C4 3E 03       0001*M1 			LD	A, function
0420C6 5B CF       0002*M1 			RST.LIL	08h
0420C8 CD F1 25 04 0067*       call ps_get_dir ; get directory listing
0420CC CD EB 20 04 0068*       call ps_stop ; TEMPORARY until we have separate buffers for playback and browsing
0420D0 C3 64 20 04 0069*       jp get_input ; back to main loop
0420D4             0070*   ; end ps_play_or_chg_dir
0420D4             0071*   
0420D4             0072*   ; change directory one level up
0420D4             0073*   ; inputs: none
0420D4             0074*   ps_up_dir:
0420D4 CD EB 20 04 0075*       call ps_stop ; TEMPORARY until we have separate buffers for playback and browsing
0420D8 21 E8 20 04 0076*       ld hl,@str_up_dir
0420DC             0077*       MOSCALL mos_cd ; change to the directory
                       M1 Args: function=mos_cd 
0420DC 3E 03       0001*M1 			LD	A, function
0420DE 5B CF       0002*M1 			RST.LIL	08h
0420E0 CD F1 25 04 0078*       call ps_get_dir ; get directory listing
0420E4 C3 64 20 04 0079*       jp get_input ; back to main loop
0420E8 2E 2E 00    0080*   @str_up_dir: asciz ".."
0420EB             0081*   ; end ps_up_dir
0420EB             0082*   
0420EB             0083*   ; TEMPORARY until we have separate buffers for playback and browsing
0420EB             0084*   ps_stop:
0420EB 21 F2 21 04 0085*       ld hl,ps_mode
0420EF CB 86       0086*       res ps_mode_playing,(hl)
0420F1 CD 65 1B 04 0087*       call vp_now_playing
0420F5 CD 76 13 04 0088*       call vdu_cls
0420F9 CD 60 00 04 0089*       call printInline
0420FD 53 74 6F 70 0090*       asciz "Stopped due to directory change. Select a new song to resume."
       70 65 64 20 
       64 75 65 20 
       74 6F 20 64 
       69 72 65 63 
       74 6F 72 79 
       20 63 68 61 
       6E 67 65 2E 
       20 53 65 6C 
       65 63 74 20 
       61 20 6E 65 
       77 20 73 6F 
       6E 67 20 74 
       6F 20 72 65 
       73 75 6D 65 
       2E 00       
04213B C9          0091*       ret
04213C             0092*   ; end ps_stop
04213C             0093*   
04213C             0094*   ps_toggle_pause:
04213C CD 65 1B 04 0095*       call vp_now_playing
042140 CD 76 13 04 0096*       call vdu_cls
042144             0097*   
042144 21 F2 21 04 0098*       ld hl,ps_mode
042148 CB 46       0099*       bit ps_mode_playing,(hl)
04214A C2 63 21 04 0100*       jp nz,@playing
04214E             0101*   
04214E CB C6       0102*       set ps_mode_playing,(hl)
042150 CD 60 00 04 0103*       call printInline
042154 28 50 29 6C 0104*       asciz "(P)laying "
       61 79 69 6E 
       67 20 00    
04215F C3 74 21 04 0105*       jp @F
042163             0106*   
042163             0107*   @playing:
042163 CB 86       0108*       res ps_mode_playing,(hl)
042165 CD 60 00 04 0109*       call printInline
042169 28 50 29 61 0110*       asciz "(P)aused  "
       75 73 65 64 
       20 20 00    
042174             0111*   
042174             0112*   @@:
042174 2A 0A 23 04 0113*       ld hl,(ps_song_fn_cur)
042178 CD 67 00 04 0114*       call printString ; print the song filename
04217C             0115*   
04217C C3 64 20 04 0116*       jp get_input
042180             0117*   ; end ps_toggle_pause
042180             0118*   
042180             0119*   ps_toggle_shuffle:
042180 CD CD 1B 04 0120*       call vp_legend_shuffle
042184 CD 76 13 04 0121*       call vdu_cls
042188             0122*   
042188 21 F2 21 04 0123*       ld hl,ps_mode
04218C CB 56       0124*       bit ps_mode_shuffle,(hl)
04218E C2 AB 21 04 0125*       jp nz,@shuffling
042192             0126*   
042192 CD 01 1C 04 0127*       call set_text_colours_inverse
042196 21 F2 21 04 0128*       ld hl,ps_mode
04219A CB D6       0129*       set ps_mode_shuffle,(hl)
04219C CD 60 00 04 0130*       call printInline
0421A0 4F 4E 00    0131*       asciz "ON"
0421A3 CD F4 1B 04 0132*       call set_text_colours_normal
0421A7 C3 64 20 04 0133*       jp get_input
0421AB             0134*   
0421AB             0135*   @shuffling:
0421AB CB 96       0136*       res ps_mode_shuffle,(hl)
0421AD CD 60 00 04 0137*       call printInline
0421B1 4F 46 46 00 0138*       asciz "OFF"
0421B5 C3 64 20 04 0139*       jp get_input
0421B9             0140*   ; end ps_toggle_shuffle
0421B9             0141*   
0421B9             0142*   ps_toggle_loop:
0421B9 CD DA 1B 04 0143*       call vp_legend_loop
0421BD CD 76 13 04 0144*       call vdu_cls
0421C1             0145*   
0421C1 21 F2 21 04 0146*       ld hl,ps_mode
0421C5 CB 4E       0147*       bit ps_mode_loop,(hl)
0421C7 C2 E4 21 04 0148*       jp nz,@looping
0421CB             0149*   
0421CB CD 01 1C 04 0150*       call set_text_colours_inverse
0421CF 21 F2 21 04 0151*       ld hl,ps_mode
0421D3 CB CE       0152*       set ps_mode_loop,(hl)
0421D5 CD 60 00 04 0153*       call printInline
0421D9 4F 4E 00    0154*       asciz "ON"
0421DC CD F4 1B 04 0155*       call set_text_colours_normal
0421E0 C3 64 20 04 0156*       jp get_input
0421E4             0157*   
0421E4             0158*   @looping:
0421E4 CB 8E       0159*       res ps_mode_loop,(hl)
0421E6 CD 60 00 04 0160*       call printInline
0421EA 4F 46 46 00 0161*       asciz "OFF"
0421EE C3 64 20 04 0162*       jp get_input
0421F2             0163*   ; end ps_toggle_loop
0421F2             0050        include "play.inc"
0421F2             0001*   ; stream a song from the SD card
0421F2             0002*   ; inputs: hl = pointer to filename
0421F2             0003*   ; requirements: the file must be 8-bit signed PCM mono
0421F2             0004*   ; uses: sound channels 0 and 1, buffers 0x3000 and 0x3001
0421F2             0005*   ; play_song constants
0421F2             0006*   ch0_buffer: equ 0x3000
0421F2             0007*   ch1_buffer: equ 0x3001
0421F2             0008*   cmd0_buffer: equ 0x3002
0421F2             0009*   cmd1_buffer: equ 0x3003
0421F2             0010*   
0421F2             0011*   ; ps_mode bits
0421F2             0012*   ps_mode_playing: equ 0 ; 0 = paused 1 = playing, p key toggles
0421F2             0013*   ps_mode_loop:    equ 1 ; 0 = no loop 1 = loop (overrides ps_mode_shuffle if on), l key toggles
0421F2             0014*   ps_mode_shuffle: equ 2 ; 0 = shuffle off 1 = on, s key toggles
0421F2             0015*   
0421F2             0016*   ; play_song state variables
0421F2             0017*   ; current active channel and bufferId's
0421F2 00          0018*   ps_mode: db 0 ; playback mode bitmask
0421F3 00          0019*   ps_channel: db 0 ; channel number
0421F4 00 00 00    0020*   ps_cmdId: dl 0 ; command bufferId
0421F7 00 00 00    0021*   ps_sampleId: dl 0 ; sample bufferId
0421FA 00 00 00 00 0022*   ps_dir_path:   blkb 256,0 ; path of the current directory
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0422FA 00 00 00    0023*   ps_dir_num_files: dl 0 ; number of files/directories in the directory (virtually unlimited)
0422FD 00 00 00    0024*   ps_dir_num_pages: dl 0 ; number of pages in the directory (virtually unlimited)
042300 00 00 00    0025*   ps_page_num_files: dl 0 ; number of files/directories in the current directory page (max 10)
042303 00 00 00    0026*   ps_pagelast_num_files: dl 0 ; mod(ps_dir_num_files,10)
042306 00 00 00    0027*   ps_page_cur: dl 0 ; current directory page number
042309 00          0028*   ps_song_idx_cur: db 0 ; current song index in the directory page
04230A 00 00 00    0029*   ps_song_fn_cur: dl 0 ; pointer to current song filename
04230D 00 00 00 00 0030*   ps_song_duration: blkw 5,0 ; duration of the current song in seconds (32-bit word plus a padding byte)
       00 00 00 00 
       00 00       
042317 00 00 00    0031*   ps_playhead: dl 0 ; current playhead position in the song in seconds from the start
04231A 00 00 00 00 0032*   ps_page_fn_ptrs: blkw 10*3,0 ; list of filename pointers in the current directory page
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042356             0033*   
042356             0034*   ; play_song directory info
042356             0035*   ps_dir_struct:
042356 00 00 00 00 0036*   ps_dptr:       blkb  4,0   ; Current read/write offset
04235A 00 00 00 00 0037*   ps_clust:      blkb  4,0   ; Current cluster
04235E 00 00 00 00 0038*   ps_sect:       blkb  4,0   ; Current sector (0:Read operation has terminated)
042362 00 00 00    0039*   ps_dir:        blkb  3,0   ; Pointer to the directory item in the win[]
042365 00 00 00 00 0040*   ps_fn:         blkb  12,0  ; SFN (in/out) {body[8],ext[3],status[1]}
       00 00 00 00 
       00 00 00 00 
042371 00 00 00 00 0041*   ps_blk_ofs:    blkb  4,0   ; Offset of current entry block being processed (0xFFFFFFFF:Invalid)
042375             0042*   
042375             0043*   ; play_song file info
042375 00          0044*   ps_filehandle_cur: db 0 ; file handle
042376 00 00 00    0045*   ps_chunkpointer: dl 0 ; pointer to current chunk
042379             0046*   ; File information structure (FILINFO)
042379             0047*   ps_file_struct:
042379 00 00 00 00 0048*   ps_file_fsize:    blkb 4, 0   ; File size (4 bytes)
04237D 00 00       0049*   ps_file_fdate:    blkb 2, 0   ; Modified date (2 bytes)
04237F 00 00       0050*   ps_file_ftime:    blkb 2, 0   ; Modified time (2 bytes)
042381 00          0051*   ps_file_fattrib:  blkb 1, 0   ; File attribute (1 byte)
042382 00 00 00 00 0052*   ps_file_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
04238F 00 00 00 00 0053*   ps_file_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04248F             0054*   
04248F             0055*   ; buffer for play_song sound data
04248F             0056*   ps_wav_header: ; marker for top of the wav file header and song data
04248F             0057*   ; (must be last so buffer doesn't overwrite other program code or data)
04248F             0058*   ; .wav header data
04248F             0059*   ; WAV File Structure in Memory with LIST Chunk
04248F 00 00 00 00 0060*   ps_wav_riff:          blkb 4,0   ; 4 bytes: "RIFF" identifier
042493 00 00 00 00 0061*   ps_wav_file_size:     blkb 4,0   ; 4 bytes: Total file size minus 8 bytes for RIFF header
042497 00 00 00 00 0062*   ps_wav_wave:          blkb 4,0   ; 4 bytes: "WAVE" identifier
04249B 00 00 00 00 0063*   ps_wav_fmt_marker:    blkb 4,0   ; 4 bytes: "fmt " subchunk marker
04249F 00 00 00 00 0064*   ps_wav_fmt_size:      blkb 4,0   ; 4 bytes: Format chunk size (16 for PCM)
0424A3 00 00       0065*   ps_wav_audio_format:  blkb 2,0   ; 2 bytes: Audio format (1 = PCM)
0424A5 00 00       0066*   ps_wav_num_channels:  blkb 2,0   ; 2 bytes: Number of channels (1 = mono, 2 = stereo)
0424A7 00 00 00 00 0067*   ps_wav_sample_rate:   blkb 4,0   ; 4 bytes: Sample rate in Hz (e.g., 32768)
0424AB 00 00 00 00 0068*   ps_wav_byte_rate:     blkb 4,0   ; 4 bytes: Bytes per second (SampleRate * NumChannels * BitsPerSample / 8)
0424AF 00 00       0069*   ps_wav_block_align:   blkb 2,0   ; 2 bytes: Bytes per sample block (NumChannels * BitsPerSample / 8)
0424B1 00 00       0070*   ps_wav_bits_per_sample: blkb 2,0 ; 2 bytes: Bits per sample (e.g., 8 or 16)
0424B3             0071*   
0424B3             0072*   ; LIST Chunk (Extra Metadata)
0424B3 00 00 00 00 0073*   ps_wav_list_marker:   blkb 4,0   ; 4 bytes: "LIST" marker
0424B7 00 00 00 00 0074*   ps_wav_list_size:     blkb 4,0   ; 4 bytes: Size of the LIST chunk (e.g., 26)
0424BB 00 00 00 00 0075*   ps_wav_info_marker:   blkb 4,0   ; 4 bytes: "INFO" marker
0424BF 00 00 00 00 0076*   ps_wav_isft_marker:   blkb 4,0   ; 4 bytes: "ISFT" marker (software identifier)
0424C3 00 00 00 00 0077*   ps_wav_isft_data:     blkb 14,0  ; 14 bytes: Software info string (e.g., "Lavf59.27.100")
       00 00 00 00 
       00 00 00 00 
       00 00       
0424D1 00 00       0078*   ps_wav_isft_padding:  blkb 2,0   ; 2 bytes: Padding/NULL terminator for alignment
0424D3             0079*   
0424D3             0080*   ; Data Chunk
0424D3 00 00 00 00 0081*   ps_wav_data_marker:   blkb 4,0   ; 4 bytes: "data" subchunk marker
0424D7 00 00 00 00 0082*   ps_wav_data_size:     blkb 4,0   ; 4 bytes: Size of the audio data in bytes
0424DB             0083*   ; Total Header Size: 76 bytes
0424DB             0084*   play_song:
0424DB             0085*   ; save pointer to requested song file
0424DB 22 0A 23 04 0086*       ld (ps_song_fn_cur),hl
0424DF             0087*   ; stop the PRT timer and close any currently playing file
0424DF CD E4 25 04 0088*       call ps_close_file
0424E3 CD 25 29 04 0089*       call ps_prt_stop
0424E7             0090*   ; tell the user what they've won
0424E7 CD 65 1B 04 0091*       call vp_now_playing
0424EB CD 76 13 04 0092*       call vdu_cls
0424EF 2A 0A 23 04 0093*       ld hl,(ps_song_fn_cur)
0424F3 CD 60 00 04 0094*       call printInline
0424F7 28 50 29 6C 0095*       asciz "(P)laying "
       61 79 69 6E 
       67 20 00    
042502 2A 0A 23 04 0096*       ld hl,(ps_song_fn_cur)
042506 CD 67 00 04 0097*       call printString ; print the song filename
04250A             0098*   ; highlight the song being played
04250A CD 8C 27 04 0099*       call ps_highlight_song
04250E             0100*   ; open the file in read mode
04250E             0101*   ; Open a file
04250E             0102*   ; HLU: Filename
04250E             0103*   ;   C: Mode
04250E             0104*   ; Returns:
04250E             0105*   ;   A: Filehandle, or 0 if couldn't open
04250E 2A 0A 23 04 0106*       ld hl,(ps_song_fn_cur)
042512 0E 01       0107*   	ld c,fa_read
042514             0108*       MOSCALL mos_fopen
                       M1 Args: function=mos_fopen 
042514 3E 0A       0001*M1 			LD	A, function
042516 5B CF       0002*M1 			RST.LIL	08h
042518 32 75 23 04 0109*       ld (ps_filehandle_cur),a
04251C             0110*   ; read the .wav header data and copy it to the buffer
04251C CD 63 28 04 0111*       call ps_read_wav_header
042520             0112*   ; compute the song duration from the file size and sample rate and print it
042520             0113*   ; technically we should account for the .wav header, but at 76 bytes it's negligible
042520 CD 7F 1B 04 0114*       call vp_duration ; set viewport to duration window
042524 3A 96 24 04 0115*       ld a,(ps_wav_file_size+3) ; upper byte
042528 DD 2A 93 24 0116*       ld ix,(ps_wav_file_size+0) ; lower word
       04          
04252D ED 5B A7 24 0117*       ld de,(ps_wav_sample_rate)
       04          
042532 CD A5 05 04 0118*       call udiv3223 ; auix = duration in seconds
042536 DD 22 0D 23 0119*       ld (ps_song_duration),ix ; duration low word
       04          
04253B 32 10 23 04 0120*       ld (ps_song_duration+3),a ; duration high word
04253F 2A 0D 23 04 0121*       ld hl,(ps_song_duration) ; ls 24 bits of duration is sufficient and all we're prepared for
042543 CD 62 10 04 0122*       call seconds_to_hhmmss ; hl pointer to string representation of HH:MM:SS
042547 CD 67 00 04 0123*       call printString ; print the duration
04254B             0124*   ; reset the playhead counter to zer0
04254B 21 00 00 00 0125*       ld hl,0
04254F 22 17 23 04 0126*       ld (ps_playhead),hl
042553             0127*   ; read the first block of data
042553 CD 66 25 04 0128*       call ps_read_file
042557             0129*   ; set ps_mode_playing
042557 21 F2 21 04 0130*       ld hl,ps_mode
04255B CB C6       0131*       set ps_mode_playing,(hl)
04255D             0132*   ; enable interrupts and start the PRT timer
04255D FB          0133*       ei
04255E CD 08 29 04 0134*       call ps_prt_start
042562             0135*   ; jump to user input loop:
042562             0136*   ; the play sample interrupt will return to there
042562             0137*   ; and exit app will return to main from there as well
042562 C3 64 20 04 0138*       jp get_input
042566             0139*   ; end play_song
042566             0140*   
042566             0141*   ; read the next 1-second's worth of sound data from the file
042566             0142*   ; and upload it to the sample buffer
042566             0143*   ps_read_file:
042566             0144*   ; disable interrupts so load is guaranteed to complete
042566 F3          0145*       di
042567             0146*   ; Read a block of data from a file
042567             0147*   ;   C: Filehandle
042567             0148*   ; HLU: Pointer to where to write the data to
042567             0149*   ; DEU: Number of bytes to read
042567             0150*   ; Returns:
042567             0151*   ; DEU: Number of bytes read
042567 3A 75 23 04 0152*       ld a,(ps_filehandle_cur)
04256B 4F          0153*       ld c,a
04256C 21 00 00 05 0154*       ld hl,ps_wav_data_start
042570 ED 5B A7 24 0155*       ld de,(ps_wav_sample_rate)
       04          
042575             0156*       MOSCALL mos_fread
                       M1 Args: function=mos_fread 
042575 3E 1A       0001*M1 			LD	A, function
042577 5B CF       0002*M1 			RST.LIL	08h
042579             0157*   ; test de for zero bytes read
042579 21 00 00 00 0158*       ld hl,0
04257D AF          0159*       xor a ; clear carry
04257E ED 52       0160*       sbc hl,de ; hl = 0-chunksize
042580 C2 8C 25 04 0161*       jp nz,@load ; we read some data
042584             0162*   ; no data read so close file and play a random song
042584 CD E4 25 04 0163*       call ps_close_file
042588 C3 33 28 04 0164*       jp ps_play_random
04258C             0165*   ; load a vdu buffer from local memory
04258C             0166*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
04258C             0167*   @load:
04258C 3A F3 21 04 0168*       ld a,(ps_channel)
042590 3C          0169*       inc a
042591 E6 01       0170*       and 1
042593 32 F3 21 04 0171*       ld (ps_channel),a
042597 21 00 30 00 0172*       ld hl,ch0_buffer
04259B 6F          0173*       ld l,a
04259C 22 F7 21 04 0174*       ld (ps_sampleId),hl
0425A0 CD 30 17 04 0175*       call vdu_clear_buffer
0425A4 2A F7 21 04 0176*       ld hl,(ps_sampleId)
0425A8 D5          0177*       push de ; chunksize
0425A9 C1          0178*       pop bc ; how much data to load
0425AA 11 00 00 05 0179*       ld de,ps_wav_data_start ; pointer to data
0425AE CD 1B 15 04 0180*       call vdu_load_buffer
0425B2             0181*   ; update the playhead counter and display the time elapsed
0425B2 CD 72 1B 04 0182*       call vp_elapsed
0425B6 2A 17 23 04 0183*       ld hl,(ps_playhead)
0425BA 23          0184*       inc hl
0425BB 22 17 23 04 0185*       ld (ps_playhead),hl
0425BF CD 62 10 04 0186*       call seconds_to_hhmmss ; hl pointer to string representation of HH:MM:SS
0425C3 CD 67 00 04 0187*       call printString ; print the playhead position
0425C7             0188*   ; print a playing breadcrumb
0425C7 CD 8C 1B 04 0189*       call vp_playhead
0425CB 3E 2E       0190*       ld a,'.'
0425CD 5B D7       0191*       rst.lil 10h
0425CF C9          0192*       ret
0425D0             0193*   ; end ps_read_file
0425D0             0194*   
0425D0             0195*   ; this is called by the PRT timer interrupt
0425D0             0196*   ps_play_sample:
0425D0             0197*   ; call the command buffer to play the sound
0425D0 2A F7 21 04 0198*       ld hl,(ps_sampleId)
0425D4 2C          0199*       inc l
0425D5 2C          0200*       inc l
0425D6 22 F4 21 04 0201*       ld (ps_cmdId),hl ; TODO: perhaps not needed
0425DA CD 15 17 04 0202*       call vdu_call_buffer
0425DE             0203*   ; load the next chunk of data
0425DE CD 66 25 04 0204*       call ps_read_file
0425E2             0205*   ; reenable interrupts and return to the user input loop
0425E2 FB          0206*       ei
0425E3 C9          0207*       ret
0425E4             0208*   ; end ps_play_sample
0425E4             0209*   
0425E4             0210*   ; close the file
0425E4             0211*   ps_close_file:
0425E4 CD 25 29 04 0212*       call ps_prt_stop ; stop the PRT timer
0425E8 3A 75 23 04 0213*       ld a,(ps_filehandle_cur)
0425EC             0214*       MOSCALL mos_fclose
                       M1 Args: function=mos_fclose 
0425EC 3E 0B       0001*M1 			LD	A, function
0425EE 5B CF       0002*M1 			RST.LIL	08h
0425F0 C9          0215*       ret
0425F1             0216*   ; end ps_close_file
0425F1             0217*   
0425F1             0218*   ps_get_dir:
0425F1             0219*   ; set text viewport to directory name and clear it
0425F1 CD A6 1B 04 0220*       call vp_dir_name
0425F5 CD 76 13 04 0221*       call vdu_cls
0425F9             0222*   ; reset filecounter
0425F9 21 00 00 00 0223*       ld hl,0
0425FD 22 FA 22 04 0224*       ld (ps_dir_num_files),hl
042601             0225*   ; reset the song index and page number to 0
042601 AF          0226*       xor a
042602 32 09 23 04 0227*       ld (ps_song_idx_cur),a
042606 21 00 00 00 0228*       ld hl,0
04260A 22 06 23 04 0229*       ld (ps_page_cur),hl
04260E             0230*   ; initialize pointers to store directory info and print directory name
04260E 21 FA 21 04 0231*       ld hl,ps_dir_path  ; where to store result
042612             0232*   ; note: setting bc has no apparent effect, but we leave it for consistency with docs
042612             0233*   ; https://agonconsole8.github.io/agon-docs/MOS-API/#0x9e-ffs_getcwd
042612 01 FF 00 00 0234*       ld bc,255          ; max length (final byte is zero terminator)
042616             0235*       MOSCALL ffs_getcwd ; MOS api get current working directory
                       M1 Args: function=ffs_getcwd 
042616 3E 9E       0001*M1 			LD	A, function
042618 5B CF       0002*M1 			RST.LIL	08h
04261A             0236*   ; print the directory path (ffs_getcwd preserves hl)
04261A CD 67 00 04 0237*       call printString
04261E             0238*   ; now get dir info
04261E 21 56 23 04 0239*       ld hl,ps_dir_struct ; define where to store directory info
042622 11 FA 21 04 0240*       ld de,ps_dir_path   ; this is pointer to the path to the directory
042626 AF          0241*       xor a               ; tell MOS to expect zero-terminated string
042627             0242*       MOSCALL ffs_dopen   ; open dir
                       M1 Args: function=ffs_dopen 
042627 3E 91       0001*M1 			LD	A, function
042629 5B CF       0002*M1 			RST.LIL	08h
04262B             0243*   ; set up pointers
04262B DD 21 00 00 0244*       ld ix,ps_dir_fil_list ; this is the pointer to the fileinfo table
       06          
042630             0245*   @readFileInfo:               ; we will loop here until all files have been processed
042630 21 56 23 04 0246*       ld hl,ps_dir_struct      ; HL is where to get directory info
042634 DD E5       0247*       push ix
042636 D1          0248*       pop de ; where to store current file info
042637             0249*       MOSCALL ffs_dread        ; read next item from dir
                       M1 Args: function=ffs_dread 
042637 3E 93       0001*M1 			LD	A, function
042639 5B CF       0002*M1 			RST.LIL	08h
04263B             0250*   
04263B DD 7E 16    0251*       ld a,(ix+filinfo_fname)  ; get first char of file name
04263E B7          0252*       or a                     ; if zero then we are at the end of the listing
04263F CA 71 26 04 0253*       jp z,@allDone
042643             0254*   
042643 DD 7E 08    0255*       ld a,(ix+filinfo_fattrib) ; get the file attribute
042646 CB AF       0256*       res 5,a ; clear bit 5 (archive) see: https://discord.com/channels/1158535358624039014/1158536667670511726/1328466726098309173
042648 B7          0257*       or a ; if zero this is a file
042649 C2 52 26 04 0258*       jp nz,@F ; not zero so this is some other file type
04264D CB EF       0259*       set 5,a ; set bit 5 (archive) so will be consistent btw emulator and hardware
04264F DD 77 08    0260*       ld (ix+filinfo_fattrib),a ; update so we don't have to do this every time downstream
042652             0261*   
042652             0262*   @@: ; skip over writing hidden and system files
042652 E6 02       0263*       and AM_HID ; hidden file
042654 C2 30 26 04 0264*       jp nz,@readFileInfo
042658 E6 04       0265*       and AM_SYS ; system file
04265A C2 30 26 04 0266*       jp nz,@readFileInfo
04265E             0267*   
04265E             0268*   ; valid file or directory
04265E 2A FA 22 04 0269*       ld hl,(ps_dir_num_files) ; get the current file counter
042662 23          0270*       inc hl                  ; increment the counter
042663 22 FA 22 04 0271*       ld (ps_dir_num_files),hl
042667 11 16 01 00 0272*       ld de,filinfo_struct_size ; length of fileinfo record
04266B DD 19       0273*       add ix,de ; point to next fileinfo record
04266D             0274*   
04266D C3 30 26 04 0275*       jp @readFileInfo         ; loop around to check next entry
042671             0276*   @allDone:
042671             0277*   ; compute page statistics
042671 2A FA 22 04 0278*       ld hl,(ps_dir_num_files) ; get the number of files
042675 11 0A 00 00 0279*       ld de,10 ; max files per page
042679 CD 80 03 04 0280*       call udiv24 ; de = hl/10, hl = mod(hl,10)
04267D             0281*       SIGN_HLU ; check remainder for zero
                       M1 Args: none
04267D 19          0001*M1     add hl,de ; 1 cycle
04267E B7          0002*M1     or a ; clear flags ; 1 cycle
04267F ED 52       0003*M1     sbc hl,de ; 2 cycles
042681             0004*M1     ; 4 cycles total
042681 C2 8A 26 04 0282*       jp nz,@F
042685 21 0A 00 00 0283*       ld hl,10 ; if zero then we have exactly 10 files on the last page ...
042689 1B          0284*       dec de ; ... and we don't need an additional page for the remainder
04268A             0285*   @@:
04268A 22 03 23 04 0286*       ld (ps_pagelast_num_files),hl ; save the number of files on the last page
04268E 13          0287*       inc de ; bump the page count
04268F ED 53 FD 22 0288*       ld (ps_dir_num_pages),de ; save the number of pages
       04          
042694             0289*   ; reset the song index and page to zero
042694 AF          0290*       xor a
042695 32 09 23 04 0291*       ld (ps_song_idx_cur),a
042699 21 00 00 00 0292*       ld hl,0
04269D 22 06 23 04 0293*       ld (ps_page_cur),hl
0426A1             0294*   ; and populate the page filename pointers and print the page
0426A1 CD B2 26 04 0295*       call ps_fill_page_fn_ptrs
0426A5 CD EE 26 04 0296*       call ps_print_dir_page
0426A9             0297*   ; close the directory
0426A9 21 56 23 04 0298*       ld hl,ps_dir_struct      ; load H: with address of the DIR struct
0426AD             0299*       MOSCALL ffs_dclose       ; close dir
                       M1 Args: function=ffs_dclose 
0426AD 3E 92       0001*M1 			LD	A, function
0426AF 5B CF       0002*M1 			RST.LIL	08h
0426B1 C9          0300*       ret
0426B2             0301*   ; end ps_get_dir
0426B2             0302*   
0426B2             0303*   ; populate the page filename pointers for the current directory page
0426B2             0304*   ; inputs: ps_page_cur
0426B2             0305*   ; prerequisites: ps_get_dir called on a valid directory
0426B2             0306*   ; outputs: a populated filename pointer list for the current page
0426B2             0307*   ; destroys: a, hl, bc, de, ix
0426B2             0308*   ps_fill_page_fn_ptrs:
0426B2 2A 06 23 04 0309*       ld hl,(ps_page_cur) ; get the current page number
0426B6 11 DC 0A 00 0310*       ld de,10*filinfo_struct_size ; records/page * bytes/record
0426BA CD 67 03 04 0311*       call umul24 ; hl = offset into the fileinfo table
0426BE 11 00 00 06 0312*       ld de,ps_dir_fil_list ; base address of fileinfo table
0426C2 19          0313*       add hl,de ; add the offset to the base address
0426C3 DD 21 1A 23 0314*       ld ix,ps_page_fn_ptrs ; get the address of the page fileinfo pointer table
       04          
0426C8 11 16 01 00 0315*       ld de,filinfo_struct_size ; bytes per filename record
0426CC 06 0A       0316*       ld b,10 ; number of files per page
0426CE             0317*   @loop:
0426CE DD 2F 00    0318*       ld (ix),hl ; store the filename pointer
0426D1 ED 32 03    0319*       lea ix,ix+3 ; bump the index pointer
0426D4 19          0320*       add hl,de ; add the record size to the filename pointer
0426D5 10 F7       0321*       djnz @loop
0426D7 C9          0322*       ret
0426D8             0323*   ; end ps_fill_page_fn_ptrs
0426D8             0324*   
0426D8             0325*   ps_get_page_num_files:
0426D8             0326*   ; check whether we're at last page
0426D8 2A 06 23 04 0327*       ld hl,(ps_page_cur)
0426DC ED 5B FD 22 0328*       ld de,(ps_dir_num_pages)
       04          
0426E1 1B          0329*       dec de ; zero-based
0426E2 B7          0330*       or a ; clear carry
0426E3 ED 52       0331*       sbc hl,de
0426E5 06 0A       0332*       ld b,10 ; b = default number of files per page
0426E7 C0          0333*       ret nz ; not the last page
0426E8 3A 03 23 04 0334*       ld a,(ps_pagelast_num_files) ; get the number of files on the last page
0426EC 47          0335*       ld b,a ; b = number of files on the last page
0426ED C9          0336*       ret
0426EE             0337*   ; end ps_get_page_num_files
0426EE             0338*   
0426EE             0339*   ps_print_dir_page:
0426EE             0340*   ; set text viewport for directory listing
0426EE CD B3 1B 04 0341*       call vp_dir
0426F2 CD 76 13 04 0342*       call vdu_cls
0426F6             0343*   ; loop through the fileinfo pointer table and print out the filenames
0426F6 CD D8 26 04 0344*       call ps_get_page_num_files ; b = loop counter
0426FA AF          0345*       xor a ; song index
0426FB DD 21 1A 23 0346*       ld ix,ps_page_fn_ptrs
       04          
042700             0347*   @loop:
042700 C5          0348*       push bc ; save loop counter
042701 F5          0349*       push af ; save song index
042702 CD 75 29 04 0350*       call printHexA ; print the song index
042706             0351*   ; branch on the file attribute
042706 DD 27 00    0352*       ld hl,(ix) ; get the filename pointer
042709 01 08 00 00 0353*       ld bc,filinfo_fattrib
04270D 09          0354*       add hl,bc ; hl points to the file attribute
04270E 7E          0355*       ld a,(hl)
04270F FE 10       0356*       cp AM_DIR ; if zero, is directory
042711 C2 22 27 04 0357*       jp nz,@print_file ; not directory so just write filename
042715 E5          0358*       push hl
042716 CD 60 00 04 0359*       call printInline
04271A 3C 44 49 52 0360*       asciz "<DIR> "
       3E 20 00    
042721 E1          0361*       pop hl
042722             0362*   @print_file:
042722 01 0E 00 00 0363*       ld bc,filinfo_fname-filinfo_fattrib ; offset to the filename
042726 09          0364*       add hl,bc ; hl points to the filename
042727 CD 67 00 04 0365*       call printString ; print the filename
04272B             0366*   @bump_counters:
04272B ED 32 03    0367*       lea ix,ix+3 ; bump the filename pointer
04272E F1          0368*       pop af ; restore song index
04272F 3C          0369*       inc a ; increment the song index
042730 C1          0370*       pop bc ; restore loop counter
042731 05          0371*       dec b
042732 C8          0372*       ret z ; if zero, we're done
042733 CD 7C 00 04 0373*       call printNewLine
042737 C3 00 27 04 0374*       jp @loop
04273B C9          0375*       ret
04273C             0376*   ; end ps_print_dir_page
04273C             0377*   
04273C             0378*   ps_print_dir:
04273C             0379*   ; test whether there are any files in the directory
04273C 2A FA 22 04 0380*       ld hl,(ps_dir_num_files)
042740             0381*       SIGN_HLU
                       M1 Args: none
042740 19          0001*M1     add hl,de ; 1 cycle
042741 B7          0002*M1     or a ; clear flags ; 1 cycle
042742 ED 52       0003*M1     sbc hl,de ; 2 cycles
042744             0004*M1     ; 4 cycles total
042744 C8          0382*       ret z ; if zero, no files in the directory
042745             0383*   ; loop through the fileinfo table and print out the filenames
042745 DD 21 00 00 0384*       ld ix,ps_dir_fil_list
       06          
04274A 2A FA 22 04 0385*       ld hl,(ps_dir_num_files)
04274E             0386*   @print_loop:
04274E E5          0387*       push hl ; loop counter
04274F             0388*   ; branch on the file attribute
04274F DD 7E 08    0389*       ld a,(ix+filinfo_fattrib)
042752 FE 10       0390*       cp AM_DIR ; if zero, is directory
042754 C2 63 27 04 0391*       jp nz,@print_file ; not directory so just write filename
042758 CD 60 00 04 0392*       call printInline
04275C 3C 44 49 52 0393*       asciz "<DIR> "
       3E 20 00    
042763             0394*   @print_file:
042763 ED 32 16    0395*       lea ix,ix+filinfo_fname ; point to filinfo_fname
042766 DD E5       0396*       push ix
042768 E1          0397*       pop hl ; get the address of the filename
042769 CD 67 00 04 0398*       call printString
04276D CD 7C 00 04 0399*       call printNewLine
042771 11 00 01 00 0400*       ld de,256 ; length of filename
042775 DD 19       0401*       add ix,de ; bump pointer to next filinfo record
042777             0402*   @dec_loop_counter:
042777 E1          0403*       pop hl
042778 2B          0404*       dec hl ; decrement the loop counter
042779             0405*       SIGN_HLU ; check for zero
                       M1 Args: none
042779 19          0001*M1     add hl,de ; 1 cycle
04277A B7          0002*M1     or a ; clear flags ; 1 cycle
04277B ED 52       0003*M1     sbc hl,de ; 2 cycles
04277D             0004*M1     ; 4 cycles total
04277D C2 4E 27 04 0406*       jp nz,@print_loop
042781 C9          0407*       ret
042782             0408*   @skip_file:
042782 11 16 01 00 0409*       ld de,filinfo_struct_size
042786 DD 19       0410*       add ix,de ; bump pointer to next filinfo record
042788 C3 77 27 04 0411*       jp @dec_loop_counter
04278C             0412*   ; end ps_print_dir
04278C             0413*   
04278C             0414*   ps_highlight_song:
04278C             0415*   ; refresh the directory listing
04278C CD EE 26 04 0416*       call ps_print_dir_page
042790             0417*   ; highlight the song being played in the directory listing
042790 3A 09 23 04 0418*       ld a,(ps_song_idx_cur)
042794 16 17       0419*       ld d,vp_dir_top
042796 82          0420*       add a,d
042797 0E 00       0421*       ld c,text_left
042799 57          0422*       ld d,a
04279A 1E 3F       0423*       ld e,text_right
04279C 47          0424*       ld b,a
04279D CD CF 13 04 0425*       call vdu_set_txt_viewport
0427A1 CD EB 12 04 0426*       call vdu_home_cursor
0427A5             0427*   ; set text colours to inverse
0427A5 CD 01 1C 04 0428*       call set_text_colours_inverse
0427A9             0429*   ; print the index and song filename
0427A9 3A 09 23 04 0430*       ld a,(ps_song_idx_cur)
0427AD CD 75 29 04 0431*       call printHexA
0427B1 2A 0A 23 04 0432*       ld hl,(ps_song_fn_cur)
0427B5 CD 67 00 04 0433*       call printString
0427B9             0434*   ; set text colours to normal
0427B9 CD F4 1B 04 0435*       call set_text_colours_normal
0427BD C9          0436*       ret
0427BE             0437*   ; end ps_highlight_song
0427BE             0438*   
0427BE             0439*   ps_dir_next_page:
0427BE             0440*   ; advance the page number
0427BE 2A 06 23 04 0441*       ld hl,(ps_page_cur) ; get the current page number
0427C2 23          0442*       inc hl ; increment the page number
0427C3 ED 5B FD 22 0443*       ld de,(ps_dir_num_pages) ; get the number of pages
       04          
0427C8 CD 80 03 04 0444*       call udiv24 ; hl = mod(ps_page_cur+1,ps_dir_num_pages)
0427CC 22 06 23 04 0445*       ld (ps_page_cur),hl ; save the new page number
0427D0             0446*   ; populate the page filename pointers
0427D0 CD B2 26 04 0447*       call ps_fill_page_fn_ptrs
0427D4             0448*   ; print the new page
0427D4 CD EE 26 04 0449*       call ps_print_dir_page
0427D8             0450*   ; enable interrupts and jump back to the user input loop
0427D8 FB          0451*       ei
0427D9 C3 64 20 04 0452*       jp get_input
0427DD             0453*   ; end ps_dir_next_page
0427DD             0454*   
0427DD             0455*   ps_dir_prev_page:
0427DD             0456*   ; decrement the page number
0427DD 2A 06 23 04 0457*       ld hl,(ps_page_cur) ; get the current page number
0427E1 2B          0458*       dec hl ; decrement the page number
0427E2             0459*       SIGN_HLU ; check for zero
                       M1 Args: none
0427E2 19          0001*M1     add hl,de ; 1 cycle
0427E3 B7          0002*M1     or a ; clear flags ; 1 cycle
0427E4 ED 52       0003*M1     sbc hl,de ; 2 cycles
0427E6             0004*M1     ; 4 cycles total
0427E6 F2 EF 27 04 0460*       jp p,@F ; >= 0 so we're good
0427EA 2A FD 22 04 0461*       ld hl,(ps_dir_num_pages) ; get the number of pages
0427EE 2B          0462*       dec hl ; zero-based
0427EF             0463*   @@:
0427EF 22 06 23 04 0464*       ld (ps_page_cur),hl ; save the new page number
0427F3             0465*   ; populate the page filename pointers
0427F3 CD B2 26 04 0466*       call ps_fill_page_fn_ptrs
0427F7             0467*   ; print the new page and
0427F7 CD EE 26 04 0468*       call ps_print_dir_page
0427FB             0469*   ; enable interrupts and jump back to the user input loop
0427FB FB          0470*       ei
0427FC C3 64 20 04 0471*       jp get_input
042800             0472*   ; end ps_dir_prev_page
042800             0473*   
042800             0474*   ; get the filename of the song at the current index
042800             0475*   ; inputs: a = song index
042800             0476*   ; returns: carry set if song index in range, new filemame in hl and ps_song_idx_cur, ps_song_fn_cur set to new index, a = file attribute
042800             0477*   ;          carry reset if song index out of range, current filename in hl, ps_song_idx_cur, ps_song_fn_cur unchanged, a = requested song index
042800             0478*   ; destroys: af, bc, de
042800             0479*   ps_get_song_fn_from_pg_idx:
042800 F5          0480*       push af ; save song index
042801 CD D8 26 04 0481*       call ps_get_page_num_files ; b = number of files on the page
042805 F1          0482*       pop af ; restore song index
042806 B8          0483*       cp b ; compare song index to number of files on the page
042807 2A 0A 23 04 0484*       ld hl,(ps_song_fn_cur) ; get the current song filename
04280B D0          0485*       ret nc ; requested song index is out of range so return current filename and no carry
04280C 32 09 23 04 0486*       ld (ps_song_idx_cur),a ; save the song index
042810 DD 21 1A 23 0487*       ld ix,ps_page_fn_ptrs ; get the address of the page fileinfo pointer table
       04          
042815 47          0488*       ld b,a ; song index
042816 0E 03       0489*       ld c,3 ; 3 bytes per filename pointer
042818 ED 4C       0490*       mlt bc ; index into the fileinfo pointer table
04281A DD 09       0491*       add ix,bc ; hl points to the fileinfo pointer
04281C             0492*   
04281C DD 27 00    0493*       ld hl,(ix) ; hl points to the fileinfo
04281F 01 08 00 00 0494*       ld bc,filinfo_fattrib ; offset to the file attribute
042823 09          0495*       add hl,bc ; hl points to the file attribute
042824 7E          0496*       ld a,(hl) ; get the file attribute for determining file vs. directory
042825             0497*   
042825 DD 27 00    0498*       ld hl,(ix) ; hl points to the fileinfo
042828 01 16 00 00 0499*       ld bc,filinfo_fname ; offset to the filename
04282C 09          0500*       add hl,bc ; hl points to the filename
04282D 22 0A 23 04 0501*       ld (ps_song_fn_cur),hl ; save the new song filename
042831 37          0502*       scf ; set carry to indicate success
042832 C9          0503*       ret
042833             0504*   ; end ps_get_song_fn_from_pg_idx
042833             0505*   
042833             0506*   ; queue a random song on the current page to play next
042833             0507*   ps_play_random:
042833             0508*   ; back up current song index
042833 2A 0A 23 04 0509*       ld hl,(ps_song_fn_cur)
042837 22 60 28 04 0510*       ld (@songFn),hl
04283B             0511*   ; get the number of songs in the current directory
04283B CD D8 26 04 0512*       call ps_get_page_num_files
04283F             0513*   ; get a random song index
04283F CD 38 05 04 0514*       call rand_8 ; a = 0-255
042843 67          0515*       ld h,a
042844 2E 0A       0516*       ld l,10 ; modulo 10
042846 CD 74 05 04 0517*       call udiv8 ; a = mod(a,10)
04284A CD 00 28 04 0518*       call ps_get_song_fn_from_pg_idx
04284E EB          0519*       ex de,hl ; setting up cp hl,de
04284F 2A 60 28 04 0520*       ld hl,(@songFn) ; don't play the same song twice in a row
042853 B7          0521*       or a ; clear carry
042854 ED 52       0522*       sbc hl,de
042856 CA 33 28 04 0523*       jp z,ps_play_random ; same song, try again
04285A EB          0524*       ex de,hl ; pointer back to hl
04285B CD DB 24 04 0525*       call play_song ; hit it
04285F C9          0526*       ret
042860 00 00 00    0527*   @songFn: dl 0
042863             0528*   ; end ps_play_random
042863             0529*   
042863             0530*   ps_read_wav_header:
042863             0531*   ; Read a block of data from a file
042863             0532*   ;   C: Filehandle
042863             0533*   ; HLU: Pointer to where to write the data to
042863             0534*   ; DEU: Number of bytes to read
042863             0535*   ; Returns:
042863             0536*   ; DEU: Number of bytes read
042863 3A 75 23 04 0537*       ld a,(ps_filehandle_cur)
042867 4F          0538*       ld c,a
042868 21 8F 24 04 0539*       ld hl,ps_wav_header
04286C 11 4C 00 00 0540*       ld de,wav_header_size
042870             0541*       MOSCALL mos_fread
                       M1 Args: function=mos_fread 
042870 3E 1A       0001*M1 			LD	A, function
042872 5B CF       0002*M1 			RST.LIL	08h
042874             0542*   ; test de for zero bytes read
042874 21 00 00 00 0543*       ld hl,0
042878 AF          0544*       xor a ; clear carry
042879 ED 52       0545*       sbc hl,de ; hl = 0-chunksize
04287B C8          0546*       ret z ; no data read so return zero to caller
04287C             0547*   ; data read so initialize song variables
04287C             0548*   ; load play sample command buffers (namely the sample rate for now)
04287C CD 81 28 04 0549*       call ps_load_command_buffers
042880 C9          0550*       ret
042881             0551*   ; end ps_read_wav_header
042881             0552*   
042881             0553*   ps_load_command_buffers:
042881 21 02 30 00 0554*       ld hl,cmd0_buffer
042885 CD 30 17 04 0555*       call vdu_clear_buffer
042889 2A A7 24 04 0556*       ld hl,(ps_wav_sample_rate)
04288D 22 D7 28 04 0557*       ld (ps_sr0),hl
042891 3E 17       0558*       ld a,23
042893 32 D9 28 04 0559*       ld (ps_sr0+2),a
042897 21 02 30 00 0560*       ld hl,cmd0_buffer
04289B 01 1D 00 00 0561*       ld bc,ps_cmd0_end-ps_cmd0
04289F 11 CE 28 04 0562*       ld de,ps_cmd0
0428A3 CD ED 16 04 0563*       call vdu_write_block_to_buffer
0428A7             0564*   
0428A7 21 03 30 00 0565*       ld hl,cmd1_buffer
0428AB CD 30 17 04 0566*       call vdu_clear_buffer
0428AF 2A A7 24 04 0567*       ld hl,(ps_wav_sample_rate)
0428B3 22 F4 28 04 0568*       ld (ps_sr1),hl
0428B7 3E 17       0569*       ld a,23
0428B9 32 F6 28 04 0570*       ld (ps_sr1+2),a
0428BD 21 03 30 00 0571*       ld hl,cmd1_buffer
0428C1 01 1D 00 00 0572*       ld bc,ps_cmd1_end-ps_cmd1
0428C5 11 EB 28 04 0573*       ld de,ps_cmd1
0428C9 CD ED 16 04 0574*       call vdu_write_block_to_buffer
0428CD C9          0575*       ret
0428CE             0576*   ps_cmd0:
0428CE             0577*   ; vdu_buffer_to_sound command string
0428CE             0578*   ; Command 5: Buffer to sound
0428CE             0579*   ; VDU 23, 0, &85, channel (ignored), 5, 2, bufferId; format, [sampleRate;]
0428CE 17 00 85    0580*       db 23,0,0x85 ; vdu sound command header
0428D1 00          0581*       db 0x00 ; channel (ignored)
0428D2 05          0582*       db 0x05 ; buffer to sound command
0428D3 02          0583*       db 0x02 ; command 2 create sample
0428D4 00 30       0584*       dw ch0_buffer
0428D6 09          0585*       db 1+8 ; 8-bit unsigned PCM mono, 8 = sample rate argument follows
0428D7             0586*   ps_sr0:
0428D7 00 00       0587*       dw 0x0000 ; sample rate Hz
0428D9             0588*   ; vdu_play_sfx command string
0428D9             0589*   ; Command 4: Set waveform
0428D9             0590*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
0428D9 17 00 85    0591*       db 23,0,$85 ; vdu sound command header
0428DC 00          0592*       db 0 ; channel
0428DD 04          0593*       db 4 ; set waveform command
0428DE 08          0594*       db 8 ; waveform 8 = sample
0428DF 00 30       0595*       dw ch0_buffer ; sample bufferId
0428E1             0596*   ; Command 0: Play note
0428E1             0597*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
0428E1 17 00 85    0598*       db 23,0,$85 ; vdu sound command header
0428E4 00          0599*       db 0 ; channel
0428E5 00          0600*       db 0 ; play note command
0428E6 7F          0601*       db 127  ; volume 127 = max
0428E7 00 00       0602*       dw 0 ; frequency (relevant only for tuneable samples)
0428E9 00 00       0603*       dw 0 ; duration (ms), zero means play one time in full
0428EB             0604*   ps_cmd0_end:
0428EB             0605*   
0428EB             0606*   ps_cmd1:
0428EB             0607*   ; vdu_buffer_to_sound command string
0428EB             0608*   ; Command 5: Buffer to sound
0428EB             0609*   ; VDU 23, 0, &85, channel (ignored), 5, 2, bufferId; format, [sampleRate;]
0428EB 17 00 85    0610*       db 23,0,0x85 ; vdu sound command header
0428EE 00          0611*       db 0x00 ; channel (ignored)
0428EF 05          0612*       db 0x05 ; buffer to sound command
0428F0 02          0613*       db 0x02 ; command 2 create sample
0428F1 01 30       0614*       dw ch1_buffer
0428F3 09          0615*       db 1+8 ; 8-bit unsigned PCM mono, 8 = sample rate argument follows
0428F4             0616*   ps_sr1:
0428F4 00 00       0617*       dw 0x0000 ; sample rate Hz
0428F6             0618*   ; vdu_play_sfx command string
0428F6             0619*   ; Command 4: Set waveform
0428F6             0620*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
0428F6 17 00 85    0621*       db 23,0,$85 ; vdu sound command header
0428F9 01          0622*       db 1 ; channel
0428FA 04          0623*       db 4 ; set waveform command
0428FB 08          0624*       db 8 ; waveform 8 = sample
0428FC 01 30       0625*       dw ch1_buffer ; sample bufferId
0428FE             0626*   ; Command 0: Play note
0428FE             0627*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
0428FE 17 00 85    0628*       db 23,0,$85 ; vdu sound command header
042901 01          0629*       db 1 ; channel
042902 00          0630*       db 0 ; play note command
042903 7F          0631*       db 127  ; volume 127 = max
042904 00 00       0632*       dw 0 ; frequency (relevant only for tuneable samples)
042906 00 00       0633*       dw 0 ; duration (ms), zero means play one time in full
042908             0634*   ps_cmd1_end:
042908             0635*   ; end ps_load_command_buffers
042908             0051        include "timer_jukebox.inc"
042908             0001*   ps_prt_reload: equ [72000/2] ; 36000 = 2 ticks per second at 18.432 MHz with a 256 clock divider
042908             0002*   
042908             0003*   ; start PRT timer
042908             0004*   ps_prt_start:
042908 21 00 00 00 0005*       ld hl,0
04290C 22 47 29 04 0006*       ld (ps_prt_irq_counter),hl
042910 21 A0 8C 00 0007*       ld hl,ps_prt_reload
042914 ED 29 84    0008*       out0 (TMR1_CTL+TMR_RES_LOW),l
042917 ED 21 85    0009*   	out0 (TMR1_CTL+TMR_RES_HIGH),h
04291A             0010*   ; disable timer (in effect, reset it)
04291A 3E 0E       0011*       ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_256 | RST_EN_1 | PRT_EN_0
04291C ED 39 83    0012*   	out0 (TMR1_CTL+TMR_REG_CTL),a
04291F             0013*   ; enable timer,with interrupt and CONTINUOUS mode,clock divider 256
04291F 3E 5F       0014*       ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_256 | RST_EN_1 | PRT_EN_1
042921 ED 39 83    0015*   	out0 (TMR1_CTL+TMR_REG_CTL),a
042924 C9          0016*       ret
042925             0017*   
042925             0018*   ; stop PRT timer
042925             0019*   ps_prt_stop:
042925 3E 0E       0020*       ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_256 | RST_EN_1 | PRT_EN_0
042927 ED 39 83    0021*   	out0 (TMR1_CTL+TMR_REG_CTL),a
04292A C9          0022*       ret
04292B             0023*   
04292B             0024*   ; ===============================================
04292B             0025*   ; PRT Timer Interrupt Handling
04292B             0026*   ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.asm
04292B             0027*   ; -----------------------------------------------
04292B             0028*   ps_prt_irq_init:
04292B             0029*       ; set up interrupt vector table 2
04292B 21 00 00 00 0030*   	ld hl,0
04292F 3A 0C 01 00 0031*   	ld a,($10c)
042933 6F          0032*   	ld l,a
042934 3A 0D 01 00 0033*   	ld a,($10d)
042938 67          0034*   	ld h,a
042939             0035*   
042939             0036*   	; skip over CALL ($c3)
042939 23          0037*   	inc hl
04293A             0038*   	; load address of jump into vector table 2 (in ram)
04293A ED 27       0039*   	ld hl,(hl)
04293C             0040*   
04293C             0041*   	; write CALL ps_prt_irq_handler to vector table 2
04293C 3E C3       0042*   	ld a,$c3
04293E 77          0043*   	ld (hl),a
04293F 23          0044*   	inc hl
042940 11 48 29 04 0045*   	ld de,ps_prt_irq_handler
042944 ED 1F       0046*   	ld (hl),de
042946             0047*   
042946 C9          0048*       ret
042947             0049*   ; end ps_prt_irq_init
042947             0050*   
042947             0051*   ; interrupt routine for playing the next sample
042947             0052*   ps_prt_irq_counter:
042947 00          0053*   	db 0
042948             0054*   ps_prt_irq_handler:
042948 F3          0055*       di
042949 08          0056*       ex af,af'
04294A D9          0057*       exx
04294B             0058*   ; clear sysvar_keyascii
04294B             0059*   	MOSCALL mos_sysvars
                       M1 Args: function=mos_sysvars 
04294B 3E 08       0001*M1 			LD	A, function
04294D 5B CF       0002*M1 			RST.LIL	08h
04294F AF          0060*   	xor a
042950 DD 77 05    0061*   	ld (IX+sysvar_keyascii),a
042953             0062*   ; read the timer interrupt and bump the counter
042953 ED 38 83    0063*       in0 a,(TMR1_CTL+TMR_REG_CTL)
042956 3A 47 29 04 0064*       ld a,(ps_prt_irq_counter)
04295A 3C          0065*       inc a
04295B E6 01       0066*       and 1 ; modulo 2
04295D 32 47 29 04 0067*       ld (ps_prt_irq_counter),a
042961             0068*   ; if counter zero, play the next sample
042961 C2 6F 29 04 0069*       jp nz,@F
042965 21 F2 21 04 0070*       ld hl,ps_mode
042969 CB 46       0071*       bit ps_mode_playing,(hl)
04296B C4 D0 25 04 0072*       call nz,ps_play_sample
04296F             0073*   @@:
04296F D9          0074*       exx
042970 08          0075*       ex af,af'
042971 FB          0076*       ei
042972 5B ED 4D    0077*       reti.l
042975             0078*   ; end ps_prt_irq_handler
042975             0052        include "wav.inc"
042975             0001*   ; WAV File Structure Offsets and Descriptions
042975             0002*   wav_riff:          EQU 0    ; 4 bytes: "RIFF" identifier
042975             0003*   wav_file_size:     EQU 4    ; 4 bytes: Total file size minus 8 bytes for RIFF header
042975             0004*   wav_wave:          EQU 8    ; 4 bytes: "WAVE" identifier
042975             0005*   wav_fmt_marker:    EQU 12   ; 4 bytes: "fmt " subchunk marker
042975             0006*   wav_fmt_size:      EQU 16   ; 4 bytes: Format chunk size (16 for PCM)
042975             0007*   wav_audio_format:  EQU 20   ; 2 bytes: Audio format (1 = PCM)
042975             0008*   wav_num_channels:  EQU 22   ; 2 bytes: Number of channels (1 = mono, 2 = stereo)
042975             0009*   wav_sample_rate:   EQU 24   ; 4 bytes: Sample rate in Hz (e.g., 32768)
042975             0010*   wav_byte_rate:     EQU 28   ; 4 bytes: Bytes per second (SampleRate * NumChannels * BitsPerSample / 8)
042975             0011*   wav_block_align:   EQU 32   ; 2 bytes: Bytes per sample block (NumChannels * BitsPerSample / 8)
042975             0012*   wav_bits_per_sample: EQU 34 ; 2 bytes: Bits per sample (e.g., 8 or 16)
042975             0013*   
042975             0014*   ; LIST Chunk (Extra Metadata)
042975             0015*   wav_list_marker:   EQU 36   ; 4 bytes: "LIST" marker
042975             0016*   wav_list_size:     EQU 40   ; 4 bytes: Size of the LIST chunk (e.g., 26)
042975             0017*   wav_info_marker:   EQU 44   ; 4 bytes: "INFO" marker
042975             0018*   wav_isft_marker:   EQU 48   ; 4 bytes: "ISFT" marker (software identifier)
042975             0019*   wav_isft_data:     EQU 52   ; 14 bytes: Software info string (e.g., "Lavf59.27.100")
042975             0020*   wav_isft_padding:  EQU 66   ; 2 bytes: Padding/NULL terminator for alignment
042975             0021*   
042975             0022*   ; Data Chunk
042975             0023*   wav_data_marker:   EQU 68   ; 4 bytes: "data" subchunk marker
042975             0024*   wav_data_size:     EQU 72   ; 4 bytes: Size of the audio data in bytes
042975             0025*   wav_data_start:    EQU 76   ; Start of audio data
042975             0026*   wav_header_size:   EQU wav_data_start ; Total Header Size: 76 bytes
042975             0053        include "debug.inc"
042975             0001*   printHexA:
042975 F5          0002*       push af
042976 C5          0003*       push bc
042977 CD AE 00 04 0004*       call printHex8
04297B 3E 20       0005*       ld a,' '
04297D 5B D7       0006*       rst.lil 10h
04297F C1          0007*       pop bc
042980 F1          0008*       pop af
042981 C9          0009*       ret
042982             0010*   
042982             0011*   printHexHL:
042982 F5          0012*       push af
042983 C5          0013*       push bc
042984 CD A8 00 04 0014*       call printHex16
042988 3E 20       0015*       ld a,' '
04298A 5B D7       0016*       rst.lil 10h
04298C C1          0017*       pop bc
04298D F1          0018*       pop af
04298E C9          0019*       ret
04298F             0020*   
04298F             0021*   printHexUHL:
04298F F5          0022*       push af
042990 C5          0023*       push bc
042991 CD A0 00 04 0024*       call printHex24
042995 3E 20       0025*       ld a,' '
042997 5B D7       0026*       rst.lil 10h
042999 C1          0027*       pop bc
04299A F1          0028*       pop af
04299B C9          0029*       ret
04299C             0030*   
04299C             0031*   printHexAUHL:
04299C F5          0032*       push af
04299D C5          0033*       push bc
04299E CD AE 00 04 0034*       call printHex8
0429A2 3E 2E       0035*       ld a,'.'
0429A4 5B D7       0036*       rst.lil 10h
0429A6 CD A0 00 04 0037*       call printHex24
0429AA 3E 20       0038*       ld a,' '
0429AC 5B D7       0039*       rst.lil 10h
0429AE C1          0040*       pop bc
0429AF F1          0041*       pop af
0429B0 C9          0042*       ret
0429B1             0043*   
0429B1             0044*   printHexABHL:
0429B1             0045*   ; preserve registers
0429B1 C5          0046*       push bc ; b will be ok c will not
0429B2 F5          0047*       push af ; will get totally destroyed
0429B3             0048*   ; print a
0429B3 CD AE 00 04 0049*       call printHex8
0429B7             0050*   ; print b
0429B7 78          0051*       ld a,b
0429B8 CD AE 00 04 0052*       call printHex8
0429BC             0053*   ; print hl
0429BC CD A8 00 04 0054*       call printHex16
0429C0             0055*   ; restore registers
0429C0 F1          0056*       pop af
0429C1 C1          0057*       pop bc
0429C2 C9          0058*       ret
0429C3             0059*   
0429C3             0060*   printHexBHL:
0429C3             0061*   ; preserve registers
0429C3 C5          0062*       push bc ; b will be ok c will not
0429C4 F5          0063*       push af ; will get totally destroyed
0429C5             0064*   ; print b
0429C5 78          0065*       ld a,b
0429C6 CD AE 00 04 0066*       call printHex8
0429CA             0067*   ; print hl
0429CA CD A8 00 04 0068*       call printHex16
0429CE             0069*   ; restore registers
0429CE F1          0070*       pop af
0429CF C1          0071*       pop bc
0429D0 C9          0072*       ret
0429D1             0073*   
0429D1             0074*   printHexCDE:
0429D1             0075*   ; preserve registers
0429D1 C5          0076*       push bc ; b will be ok c will not
0429D2 F5          0077*       push af ; will get totally destroyed
0429D3             0078*   ; print c
0429D3 79          0079*       ld a,c
0429D4 CD AE 00 04 0080*       call printHex8
0429D8             0081*   ; print de
0429D8 EB          0082*       ex de,hl
0429D9 CD A8 00 04 0083*       call printHex16
0429DD EB          0084*       ex de,hl
0429DE             0085*   ; restore registers
0429DE F1          0086*       pop af
0429DF C1          0087*       pop bc
0429E0 C9          0088*       ret
0429E1             0089*   
0429E1             0090*   printHexUIX:
0429E1             0091*   ; store everything in scratch
0429E1 22 35 03 04 0092*       ld (uhl),hl
0429E5 ED 43 38 03 0093*       ld (ubc),bc
       04          
0429EA ED 53 3B 03 0094*       ld (ude),de
       04          
0429EF DD 22 3E 03 0095*       ld (uix),ix
       04          
0429F4 FD 22 41 03 0096*       ld (uiy),iy
       04          
0429F9 F5          0097*       push af ; fml
0429FA             0098*   
0429FA 21 CC 02 04 0099*       ld hl,str_ixu
0429FE CD 67 00 04 0100*       call printString
042A02 2A 3E 03 04 0101*       ld hl,(uix)
042A06 CD A0 00 04 0102*       call printHex24
042A0A CD 7C 00 04 0103*       call printNewLine
042A0E             0104*   
042A0E             0105*   ; restore everything
042A0E 2A 35 03 04 0106*       ld hl, (uhl)
042A12 ED 4B 38 03 0107*       ld bc, (ubc)
       04          
042A17 ED 5B 3B 03 0108*       ld de, (ude)
       04          
042A1C DD 2A 3E 03 0109*       ld ix, (uix)
       04          
042A21 FD 2A 41 03 0110*       ld iy, (uiy)
       04          
042A26 F1          0111*       pop af
042A27             0112*   ; all done
042A27 C9          0113*       ret
042A28             0114*   
042A28             0115*   
042A28             0116*   ; print registers to screen in hexidecimal format
042A28             0117*   ; inputs: none
042A28             0118*   ; outputs: values of every register printed to screen
042A28             0119*   ;    values of each register in global scratch memory
042A28             0120*   ; destroys: nothing
042A28             0121*   stepRegistersHex:
042A28             0122*   ; store everything in scratch
042A28 22 35 03 04 0123*       ld (uhl),hl
042A2C ED 43 38 03 0124*       ld (ubc),bc
       04          
042A31 ED 53 3B 03 0125*       ld (ude),de
       04          
042A36 DD 22 3E 03 0126*       ld (uix),ix
       04          
042A3B FD 22 41 03 0127*       ld (uiy),iy
       04          
042A40 F5          0128*       push af ; fml
042A41 E1          0129*       pop hl ; thanks, zilog
042A42 22 32 03 04 0130*       ld (uaf),hl
042A46 F5          0131*       push af ; dammit
042A47             0132*   
042A47             0133*   ; home the cursor
042A47             0134*       ; call vdu_home_cursor
042A47             0135*   
042A47             0136*   ; print each register
042A47 21 B8 02 04 0137*       ld hl,str_afu
042A4B CD 67 00 04 0138*       call printString
042A4F 2A 32 03 04 0139*       ld hl,(uaf)
042A53 CD A0 00 04 0140*       call printHex24
042A57 CD 7C 00 04 0141*       call printNewLine
042A5B             0142*   
042A5B 21 BD 02 04 0143*       ld hl,str_hlu
042A5F CD 67 00 04 0144*       call printString
042A63 2A 35 03 04 0145*       ld hl,(uhl)
042A67 CD A0 00 04 0146*       call printHex24
042A6B CD 7C 00 04 0147*       call printNewLine
042A6F             0148*   
042A6F 21 C2 02 04 0149*       ld hl,str_bcu
042A73 CD 67 00 04 0150*       call printString
042A77 2A 38 03 04 0151*       ld hl,(ubc)
042A7B CD A0 00 04 0152*       call printHex24
042A7F CD 7C 00 04 0153*       call printNewLine
042A83             0154*   
042A83 21 C7 02 04 0155*       ld hl,str_deu
042A87 CD 67 00 04 0156*       call printString
042A8B 2A 3B 03 04 0157*       ld hl,(ude)
042A8F CD A0 00 04 0158*       call printHex24
042A93 CD 7C 00 04 0159*       call printNewLine
042A97             0160*   
042A97 21 CC 02 04 0161*       ld hl,str_ixu
042A9B CD 67 00 04 0162*       call printString
042A9F 2A 3E 03 04 0163*       ld hl,(uix)
042AA3 CD A0 00 04 0164*       call printHex24
042AA7 CD 7C 00 04 0165*       call printNewLine
042AAB             0166*   
042AAB 21 D1 02 04 0167*       ld hl,str_iyu
042AAF CD 67 00 04 0168*       call printString
042AB3 2A 41 03 04 0169*       ld hl,(uiy)
042AB7 CD A0 00 04 0170*       call printHex24
042ABB CD 7C 00 04 0171*       call printNewLine
042ABF             0172*   
042ABF             0173*       ; call vsync
042ABF             0174*   
042ABF CD 7C 00 04 0175*       call printNewLine
042AC3             0176*   
042AC3             0177*   ; check for right shift key and quit if pressed
042AC3             0178*       MOSCALL mos_getkbmap
                       M1 Args: function=mos_getkbmap 
042AC3 3E 1E       0001*M1 			LD	A, function
042AC5 5B CF       0002*M1 			RST.LIL	08h
042AC7             0179*   @stayhere:
042AC7             0180*   ; 7 RightShift
042AC7 DD CB 00 76 0181*       bit 6,(ix+0)
042ACB 20 02       0182*       jr nz,@RightShift
042ACD 18 F8       0183*       jr @stayhere
042ACF             0184*   @RightShift:
042ACF DD CB 0E 86 0185*       res 0,(ix+14) ; debounce the key (hopefully)
042AD3 3E 80       0186*       ld a,%10000000
042AD5             0187*       ; call multiPurposeDelay
042AD5             0188*   
042AD5             0189*   ; restore everything
042AD5 2A 35 03 04 0190*       ld hl, (uhl)
042AD9 ED 4B 38 03 0191*       ld bc, (ubc)
       04          
042ADE ED 5B 3B 03 0192*       ld de, (ude)
       04          
042AE3 DD 2A 3E 03 0193*       ld ix, (uix)
       04          
042AE8 FD 2A 41 03 0194*       ld iy, (uiy)
       04          
042AED F1          0195*       pop af
042AEE             0196*   ; all done
042AEE C9          0197*       ret
042AEF             0198*   
042AEF             0199*   ; print registers to screen in hexidecimal format
042AEF             0200*   ; inputs: none
042AEF             0201*   ; outputs: values of every register printed to screen
042AEF             0202*   ;    values of each register in global scratch memory
042AEF             0203*   ; destroys: nothing
042AEF             0204*   dumpRegistersHex:
042AEF             0205*   ; store everything in scratch
042AEF 22 35 03 04 0206*       ld (uhl),hl
042AF3 ED 43 38 03 0207*       ld (ubc),bc
       04          
042AF8 ED 53 3B 03 0208*       ld (ude),de
       04          
042AFD DD 22 3E 03 0209*       ld (uix),ix
       04          
042B02 FD 22 41 03 0210*       ld (uiy),iy
       04          
042B07 F5          0211*       push af ; fml
042B08 E1          0212*       pop hl ; thanks, zilog
042B09 22 32 03 04 0213*       ld (uaf),hl
042B0D F5          0214*       push af ; dammit
042B0E             0215*   
042B0E             0216*   ; home the cursor
042B0E             0217*       ; call vdu_home_cursor
042B0E             0218*       ; call printNewLine
042B0E             0219*   
042B0E             0220*   ; print each register
042B0E 21 B8 02 04 0221*       ld hl,str_afu
042B12 CD 67 00 04 0222*       call printString
042B16 2A 32 03 04 0223*       ld hl,(uaf)
042B1A CD A0 00 04 0224*       call printHex24
042B1E CD 7C 00 04 0225*       call printNewLine
042B22             0226*   
042B22 21 BD 02 04 0227*       ld hl,str_hlu
042B26 CD 67 00 04 0228*       call printString
042B2A 2A 35 03 04 0229*       ld hl,(uhl)
042B2E CD A0 00 04 0230*       call printHex24
042B32 CD 7C 00 04 0231*       call printNewLine
042B36             0232*   
042B36 21 C2 02 04 0233*       ld hl,str_bcu
042B3A CD 67 00 04 0234*       call printString
042B3E 2A 38 03 04 0235*       ld hl,(ubc)
042B42 CD A0 00 04 0236*       call printHex24
042B46 CD 7C 00 04 0237*       call printNewLine
042B4A             0238*   
042B4A 21 C7 02 04 0239*       ld hl,str_deu
042B4E CD 67 00 04 0240*       call printString
042B52 2A 3B 03 04 0241*       ld hl,(ude)
042B56 CD A0 00 04 0242*       call printHex24
042B5A CD 7C 00 04 0243*       call printNewLine
042B5E             0244*   
042B5E 21 CC 02 04 0245*       ld hl,str_ixu
042B62 CD 67 00 04 0246*       call printString
042B66 2A 3E 03 04 0247*       ld hl,(uix)
042B6A CD A0 00 04 0248*       call printHex24
042B6E CD 7C 00 04 0249*       call printNewLine
042B72             0250*   
042B72 21 D1 02 04 0251*       ld hl,str_iyu
042B76 CD 67 00 04 0252*       call printString
042B7A 2A 41 03 04 0253*       ld hl,(uiy)
042B7E CD A0 00 04 0254*       call printHex24
042B82             0255*   
042B82 CD 7C 00 04 0256*       call printNewLine
042B86 CD 7C 00 04 0257*       call printNewLine
042B8A             0258*   ; restore everything
042B8A 2A 35 03 04 0259*       ld hl, (uhl)
042B8E ED 4B 38 03 0260*       ld bc, (ubc)
       04          
042B93 ED 5B 3B 03 0261*       ld de, (ude)
       04          
042B98 DD 2A 3E 03 0262*       ld ix, (uix)
       04          
042B9D FD 2A 41 03 0263*       ld iy, (uiy)
       04          
042BA2 F1          0264*       pop af
042BA3             0265*   ; all done
042BA3 C9          0266*       ret
042BA4             0267*   
042BA4             0268*   dumpRegistersHexPrime:
042BA4 D9          0269*       exx
042BA5 08          0270*       ex af,af'
042BA6 CD EF 2A 04 0271*       call dumpRegistersHex
042BAA 08          0272*       ex af,af'
042BAB D9          0273*       exx
042BAC C9          0274*       ret
042BAD             0275*   
042BAD             0276*   ; additionally dump prime registers
042BAD             0277*   ; inputs: none
042BAD             0278*   ; outputs: values of every register printed to screen
042BAD             0279*   ; destroys: nothing
042BAD             0280*   dumpRegistersHexAll:
042BAD CD EF 2A 04 0281*       call dumpRegistersHex
042BB1 08          0282*       ex af,af'
042BB2 D9          0283*       exx
042BB3 CD EF 2A 04 0284*       call dumpRegistersHex
042BB7 08          0285*       ex af,af'
042BB8 D9          0286*       exx
042BB9 C9          0287*       ret
042BBA             0288*   
042BBA             0289*   ; print hlu to screen in hexidecimal format
042BBA             0290*   ; inputs: none
042BBA             0291*   ; destroys: nothing
042BBA             0292*   print_hex_hl:
042BBA F5          0293*       push af
042BBB E5          0294*       push hl
042BBC 21 BD 02 04 0295*       ld hl,str_hlu
042BC0 CD 67 00 04 0296*       call printString
042BC4 E1          0297*       pop hl
042BC5 E5          0298*       push hl
042BC6 CD A0 00 04 0299*       call printHex24
042BCA 3E 20       0300*       ld a,' '
042BCC 5B D7       0301*       rst.lil 10h
042BCE E1          0302*       pop hl
042BCF F1          0303*       pop af
042BD0 C9          0304*       ret
042BD1             0305*   
042BD1             0306*   ; print bcu to screen in hexidecimal format
042BD1             0307*   ; inputs: none
042BD1             0308*   ; destroys: nothing
042BD1             0309*   print_hex_bc:
042BD1 F5          0310*       push af
042BD2 E5          0311*       push hl
042BD3 C5          0312*       push bc
042BD4 21 C2 02 04 0313*       ld hl,str_bcu
042BD8 CD 67 00 04 0314*       call printString
042BDC E1          0315*       pop hl
042BDD E5          0316*       push hl
042BDE CD A0 00 04 0317*       call printHex24
042BE2 3E 20       0318*       ld a,' '
042BE4 5B D7       0319*       rst.lil 10h
042BE6 C1          0320*       pop bc
042BE7 E1          0321*       pop hl
042BE8 F1          0322*       pop af
042BE9 C9          0323*       ret
042BEA             0324*   
042BEA             0325*   ; print deu to screen in hexidecimal format
042BEA             0326*   ; inputs: none
042BEA             0327*   ; destroys: nothing
042BEA             0328*   print_hex_de:
042BEA F5          0329*       push af
042BEB E5          0330*       push hl
042BEC D5          0331*       push de
042BED 21 C7 02 04 0332*       ld hl,str_deu
042BF1 CD 67 00 04 0333*       call printString
042BF5 E1          0334*       pop hl
042BF6 E5          0335*       push hl
042BF7 CD A0 00 04 0336*       call printHex24
042BFB 3E 20       0337*       ld a,' '
042BFD 5B D7       0338*       rst.lil 10h
042BFF D1          0339*       pop de
042C00 E1          0340*       pop hl
042C01 F1          0341*       pop af
042C02 C9          0342*       ret
042C03             0343*   
042C03             0344*   
042C03             0345*   ; inputs: whatever is in the flags register
042C03             0346*   ; outputs: binary representation of flags
042C03             0347*   ;          with a header so we know which is what
042C03             0348*   ; destroys: nothing
042C03             0349*   ; preserves: everything
042C03             0350*   dumpFlags:
042C03             0351*   ; first we curse zilog for not giving direct access to flags
042C03 F5          0352*       push af ; this is so we can send it back unharmed
042C04 F5          0353*       push af ; this is so we can pop it to hl
042C05             0354*   ; store everything in scratch
042C05 22 35 03 04 0355*       ld (uhl),hl
042C09 ED 43 38 03 0356*       ld (ubc),bc
       04          
042C0E ED 53 3B 03 0357*       ld (ude),de
       04          
042C13 DD 22 3E 03 0358*       ld (uix),ix
       04          
042C18 FD 22 41 03 0359*       ld (uiy),iy
       04          
042C1D             0360*   ; next we print the header
042C1D 21 49 2C 04 0361*       ld hl,@header
042C21 CD 67 00 04 0362*       call printString
042C25 E1          0363*       pop hl ; flags are now in l
042C26 7D          0364*       ld a,l ; flags are now in a
042C27 CD 6E 02 04 0365*       call printBin8
042C2B CD 7C 00 04 0366*       call printNewLine
042C2F             0367*   ; restore everything
042C2F 2A 35 03 04 0368*       ld hl, (uhl)
042C33 ED 4B 38 03 0369*       ld bc, (ubc)
       04          
042C38 ED 5B 3B 03 0370*       ld de, (ude)
       04          
042C3D DD 2A 3E 03 0371*       ld ix, (uix)
       04          
042C42 FD 2A 41 03 0372*       ld iy, (uiy)
       04          
042C47 F1          0373*       pop af ; send her home the way she came
042C48 C9          0374*       ret
042C49             0375*   ; Bit 7 (S): Sign flag
042C49             0376*   ; Bit 6 (Z): Zero flag
042C49             0377*   ; Bit 5 (5): Reserved (copy of bit 5 of the result)
042C49             0378*   ; Bit 4 (H): Half Carry flag
042C49             0379*   ; Bit 3 (3): Reserved (copy of bit 3 of the result)
042C49             0380*   ; Bit 2 (PV): Parity/Overflow flag
042C49             0381*   ; Bit 1 (N): Subtract flag
042C49             0382*   ; Bit 0 (C): Carry flag
042C49 53 5A 78 48 0383*   @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
042C54             0384*   
042C54             0385*   
042C54             0386*   ; print bytes from an address to the screen in hexidecimal format
042C54             0387*   ; inputs: hl = address of first byte to print, a = number of bytes to print
042C54             0388*   ; outputs: values of each byte printed to screen separated by spaces
042C54             0389*   ; destroys: nothing
042C54             0390*   dumpMemoryHex:
042C54             0391*   ; save registers to the stack
042C54 C5          0392*       push bc
042C55 E5          0393*       push hl
042C56 F5          0394*       push af
042C57             0395*   
042C57             0396*   ; print the address and separator
042C57 CD A0 00 04 0397*       call printHex24
042C5B 3E 3A       0398*       ld a,':'
042C5D 5B D7       0399*       rst.lil 10h
042C5F 3E 20       0400*       ld a,' '
042C61 5B D7       0401*       rst.lil 10h
042C63             0402*   
042C63             0403*   ; set b to be our loop counter
042C63 F1          0404*       pop af
042C64 47          0405*       ld b,a
042C65 E1          0406*       pop hl
042C66 E5          0407*       push hl
042C67 F5          0408*       push af
042C68             0409*   @loop:
042C68             0410*   ; print the byte
042C68 7E          0411*       ld a,(hl)
042C69 CD AE 00 04 0412*       call printHex8
042C6D             0413*   ; print a space
042C6D 3E 20       0414*       ld a,' '
042C6F 5B D7       0415*       rst.lil 10h
042C71 23          0416*       inc hl
042C72 10 F4       0417*       djnz @loop
042C74             0418*       ; call printNewLine
042C74             0419*   
042C74             0420*   ; restore everything
042C74 F1          0421*       pop af
042C75 E1          0422*       pop hl
042C76 C1          0423*       pop bc
042C77             0424*   
042C77             0425*   ; all done
042C77 C9          0426*       ret
042C78             0427*   
042C78             0428*   
042C78             0429*   ; print bytes from an address to the screen in binary format
042C78             0430*   ; inputs: hl = address of first byte to print, a = number of bytes to print
042C78             0431*   ; outputs: values of each byte printed to screen separated by spaces
042C78             0432*   ; destroys: nothing
042C78             0433*   dumpMemoryBin:
042C78             0434*   ; save all registers to the stack
042C78 F5          0435*       push af
042C79 C5          0436*       push bc
042C7A D5          0437*       push de
042C7B E5          0438*       push hl
042C7C DD E5       0439*       push ix
042C7E FD E5       0440*       push iy
042C80             0441*   
042C80             0442*   ; set b to be our loop counter
042C80 47          0443*       ld b,a
042C81             0444*   @loop:
042C81             0445*   ; print the byte
042C81 7E          0446*       ld a,(hl)
042C82 E5          0447*       push hl
042C83 C5          0448*       push bc
042C84 CD 6E 02 04 0449*       call printBin8
042C88 C1          0450*       pop bc
042C89             0451*   ; print a space
042C89 3E 20       0452*       ld a,' '
042C8B 5B D7       0453*       rst.lil 10h
042C8D E1          0454*       pop hl
042C8E 23          0455*       inc hl
042C8F 10 F0       0456*       djnz @loop
042C91 CD 7C 00 04 0457*       call printNewLine
042C95             0458*   
042C95             0459*   ; restore everything
042C95 FD E1       0460*       pop iy
042C97 DD E1       0461*       pop ix
042C99 E1          0462*       pop hl
042C9A D1          0463*       pop de
042C9B C1          0464*       pop bc
042C9C F1          0465*       pop af
042C9D             0466*   ; all done
042C9D C9          0467*       ret
042C9E             0468*   
042C9E             0469*   ; print bytes from an address to the screen in binary format
042C9E             0470*   ; with the bits of each byte in reverse order (lsb first)
042C9E             0471*   ; inputs: hl = address of first byte to print, a = number of bytes to print
042C9E             0472*   ; outputs: values of each byte printed to screen separated by spaces
042C9E             0473*   ; destroys: nothing
042C9E             0474*   dumpMemoryBinRev:
042C9E             0475*   ; save all registers to the stack
042C9E F5          0476*       push af
042C9F C5          0477*       push bc
042CA0 D5          0478*       push de
042CA1 E5          0479*       push hl
042CA2 DD E5       0480*       push ix
042CA4 FD E5       0481*       push iy
042CA6             0482*   
042CA6             0483*   ; set b to be our loop counter
042CA6 47          0484*       ld b,a
042CA7             0485*   @loop:
042CA7             0486*   ; print the byte
042CA7 7E          0487*       ld a,(hl)
042CA8 E5          0488*       push hl
042CA9 C5          0489*       push bc
042CAA CD 93 02 04 0490*       call printBin8Rev
042CAE C1          0491*       pop bc
042CAF             0492*   ; print a space
042CAF 3E 20       0493*       ld a,' '
042CB1 5B D7       0494*       rst.lil 10h
042CB3 E1          0495*       pop hl
042CB4 23          0496*       inc hl
042CB5 10 F0       0497*       djnz @loop
042CB7 CD 7C 00 04 0498*       call printNewLine
042CBB             0499*   
042CBB             0500*   ; restore everything
042CBB FD E1       0501*       pop iy
042CBD DD E1       0502*       pop ix
042CBF E1          0503*       pop hl
042CC0 D1          0504*       pop de
042CC1 C1          0505*       pop bc
042CC2 F1          0506*       pop af
042CC3             0507*   ; all done
042CC3 C9          0508*       ret
042CC4             0509*   
042CC4             0510*   DEBUG_PRINT:
042CC4             0511*       PUSH_ALL
                       M1 Args: none
042CC4 08          0001*M1     ex af,af'
042CC5 D9          0002*M1     exx
042CC6 F5          0003*M1     push af
042CC7 E5          0004*M1     push hl
042CC8 C5          0005*M1     push bc
042CC9 D5          0006*M1     push de
042CCA             0007*M1 
042CCA 08          0008*M1     ex af,af'
042CCB D9          0009*M1     exx
042CCC F5          0010*M1     push af
042CCD E5          0011*M1     push hl
042CCE C5          0012*M1     push bc
042CCF D5          0013*M1     push de
042CD0 DD E5       0014*M1     push ix
042CD2 FD E5       0015*M1     push iy
042CD4             0512*       ; ld c,0 ; X
042CD4             0513*       ; ld b,0 ; Y
042CD4             0514*       ; call vdu_move_cursor
042CD4 CD 7C 00 04 0515*       call printNewLine
042CD8             0516*       POP_ALL
                       M1 Args: none
042CD8 FD E1       0001*M1     pop iy
042CDA DD E1       0002*M1     pop ix
042CDC D1          0003*M1     pop de
042CDD C1          0004*M1     pop bc
042CDE E1          0005*M1     pop hl
042CDF F1          0006*M1     pop af
042CE0 08          0007*M1     ex af,af'
042CE1 D9          0008*M1     exx
042CE2             0009*M1 
042CE2 D1          0010*M1     pop de
042CE3 C1          0011*M1     pop bc
042CE4 E1          0012*M1     pop hl
042CE5 F1          0013*M1     pop af
042CE6 08          0014*M1     ex af,af'
042CE7 D9          0015*M1     exx
042CE8             0517*       PUSH_ALL
                       M1 Args: none
042CE8 08          0001*M1     ex af,af'
042CE9 D9          0002*M1     exx
042CEA F5          0003*M1     push af
042CEB E5          0004*M1     push hl
042CEC C5          0005*M1     push bc
042CED D5          0006*M1     push de
042CEE             0007*M1 
042CEE 08          0008*M1     ex af,af'
042CEF D9          0009*M1     exx
042CF0 F5          0010*M1     push af
042CF1 E5          0011*M1     push hl
042CF2 C5          0012*M1     push bc
042CF3 D5          0013*M1     push de
042CF4 DD E5       0014*M1     push ix
042CF6 FD E5       0015*M1     push iy
042CF8 CD 03 2C 04 0518*       call dumpFlags
042CFC             0519*       POP_ALL
                       M1 Args: none
042CFC FD E1       0001*M1     pop iy
042CFE DD E1       0002*M1     pop ix
042D00 D1          0003*M1     pop de
042D01 C1          0004*M1     pop bc
042D02 E1          0005*M1     pop hl
042D03 F1          0006*M1     pop af
042D04 08          0007*M1     ex af,af'
042D05 D9          0008*M1     exx
042D06             0009*M1 
042D06 D1          0010*M1     pop de
042D07 C1          0011*M1     pop bc
042D08 E1          0012*M1     pop hl
042D09 F1          0013*M1     pop af
042D0A 08          0014*M1     ex af,af'
042D0B D9          0015*M1     exx
042D0C             0520*       PUSH_ALL
                       M1 Args: none
042D0C 08          0001*M1     ex af,af'
042D0D D9          0002*M1     exx
042D0E F5          0003*M1     push af
042D0F E5          0004*M1     push hl
042D10 C5          0005*M1     push bc
042D11 D5          0006*M1     push de
042D12             0007*M1 
042D12 08          0008*M1     ex af,af'
042D13 D9          0009*M1     exx
042D14 F5          0010*M1     push af
042D15 E5          0011*M1     push hl
042D16 C5          0012*M1     push bc
042D17 D5          0013*M1     push de
042D18 DD E5       0014*M1     push ix
042D1A FD E5       0015*M1     push iy
042D1C CD EF 2A 04 0521*       call dumpRegistersHex
042D20             0522*       ; call waitKeypress
042D20 CD 7C 00 04 0523*       call printNewLine
042D24             0524*       POP_ALL
                       M1 Args: none
042D24 FD E1       0001*M1     pop iy
042D26 DD E1       0002*M1     pop ix
042D28 D1          0003*M1     pop de
042D29 C1          0004*M1     pop bc
042D2A E1          0005*M1     pop hl
042D2B F1          0006*M1     pop af
042D2C 08          0007*M1     ex af,af'
042D2D D9          0008*M1     exx
042D2E             0009*M1 
042D2E D1          0010*M1     pop de
042D2F C1          0011*M1     pop bc
042D30 E1          0012*M1     pop hl
042D31 F1          0013*M1     pop af
042D32 08          0014*M1     ex af,af'
042D33 D9          0015*M1     exx
042D34 C9          0525*       ret
042D35             0526*   DEBUG_WAITKEYPRESS:
042D35             0527*       PUSH_ALL
                       M1 Args: none
042D35 08          0001*M1     ex af,af'
042D36 D9          0002*M1     exx
042D37 F5          0003*M1     push af
042D38 E5          0004*M1     push hl
042D39 C5          0005*M1     push bc
042D3A D5          0006*M1     push de
042D3B             0007*M1 
042D3B 08          0008*M1     ex af,af'
042D3C D9          0009*M1     exx
042D3D F5          0010*M1     push af
042D3E E5          0011*M1     push hl
042D3F C5          0012*M1     push bc
042D40 D5          0013*M1     push de
042D41 DD E5       0014*M1     push ix
042D43 FD E5       0015*M1     push iy
042D45 CD 5A 03 04 0528*       call waitKeypress
042D49             0529*       POP_ALL
                       M1 Args: none
042D49 FD E1       0001*M1     pop iy
042D4B DD E1       0002*M1     pop ix
042D4D D1          0003*M1     pop de
042D4E C1          0004*M1     pop bc
042D4F E1          0005*M1     pop hl
042D50 F1          0006*M1     pop af
042D51 08          0007*M1     ex af,af'
042D52 D9          0008*M1     exx
042D53             0009*M1 
042D53 D1          0010*M1     pop de
042D54 C1          0011*M1     pop bc
042D55 E1          0012*M1     pop hl
042D56 F1          0013*M1     pop af
042D57 08          0014*M1     ex af,af'
042D58 D9          0015*M1     exx
042D59 C9          0530*       RET
042D5A             0531*   
042D5A             0532*   dumpVduCmdStr:
042D5A             0533*       PUSH_ALL
                       M1 Args: none
042D5A 08          0001*M1     ex af,af'
042D5B D9          0002*M1     exx
042D5C F5          0003*M1     push af
042D5D E5          0004*M1     push hl
042D5E C5          0005*M1     push bc
042D5F D5          0006*M1     push de
042D60             0007*M1 
042D60 08          0008*M1     ex af,af'
042D61 D9          0009*M1     exx
042D62 F5          0010*M1     push af
042D63 E5          0011*M1     push hl
042D64 C5          0012*M1     push bc
042D65 D5          0013*M1     push de
042D66 DD E5       0014*M1     push ix
042D68 FD E5       0015*M1     push iy
042D6A 79          0534*       ld a,c
042D6B CD 54 2C 04 0535*       call dumpMemoryHex
042D6F CD 5A 03 04 0536*       call waitKeypress
042D73             0537*       POP_ALL
                       M1 Args: none
042D73 FD E1       0001*M1     pop iy
042D75 DD E1       0002*M1     pop ix
042D77 D1          0003*M1     pop de
042D78 C1          0004*M1     pop bc
042D79 E1          0005*M1     pop hl
042D7A F1          0006*M1     pop af
042D7B 08          0007*M1     ex af,af'
042D7C D9          0008*M1     exx
042D7D             0009*M1 
042D7D D1          0010*M1     pop de
042D7E C1          0011*M1     pop bc
042D7F E1          0012*M1     pop hl
042D80 F1          0013*M1     pop af
042D81 08          0014*M1     ex af,af'
042D82 D9          0015*M1     exx
042D83 C9          0538*       ret
042D84             0539*   ; end dumpVduCmdStr
042D84             0054    
042D84             0055    ; --- MAIN PROGRAM FILE ---
042D84             0056    init:
042D84 CD 0E 1C 04 0057        call ui_init
042D88 CD F1 25 04 0058        call ps_get_dir
042D8C CD 2B 29 04 0059        call ps_prt_irq_init
042D90 C9          0060        ret
042D91             0061    ; end init
042D91             0062    main:
042D91             0063    ; call the change directory routine and jp to user input
042D91 CD F1 25 04 0064        call ps_get_dir
042D95 CD 64 20 04 0065        call get_input
042D99             0066    
042D99             0067    ; we come back here when user wants to quit app
042D99             0068    ; shut down everytyhing and gracefully exit to MOS
042D99 CD 25 29 04 0069        call ps_prt_stop ; stop the PRT timer
042D9D FB          0070        ei ; interrupts were disabled by get_input
042D9E             0071    ; restore original screen mode
042D9E 3A E2 1A 04 0072        ld a,(original_screen_mode)
042DA2 CD 44 14 04 0073        call vdu_set_screen_mode
042DA6 CD 3F 14 04 0074        call vdu_reset_viewports
042DAA CD 76 13 04 0075        call vdu_cls
042DAE             0076    ; print thanks for playing message
042DAE CD 60 00 04 0077        call printInline
042DB2 54 68 61 6E 0078        asciz "Thank you for using\r\n"
       6B 20 79 6F 
       75 20 66 6F 
       72 20 75 73 
       69 6E 67 0D 
       0A 00       
042DC8 21 92 1D 04 0079        ld hl,agon_jukebox_ascii
042DCC CD 67 00 04 0080        call printString
042DD0             0081    ; set cursor behaviuor
042DD0 CD F0 12 04 0082        call vdu_cursor_on
042DD4 26 10       0083        ld h,%00010000 ; bit 4 controls cursor scroll at bottom of screen
042DD6 2E 00       0084        ld l,%00000000 ; bit 4 reset means cursor scrolls screen
042DD8 CD 62 13 04 0085        call vdu_cursor_behaviour
042DDC C9          0086        ret ; back to MOS
042DDD             0087    ; end main
042DDD             0088    
042DDD             0089    ; must be final include in program so file data does not stomp on program code or other data
042DDD             0090        include "files.inc"
042DDD             0001*   ; THIS MUST BE LAST INCLUDE SO FILE DATA DOES NOT OVERWRITE OTHER CODE OR DATA
042DDD             0002*   
042DDD             0003*   ; buffer for loading files unrelated to audio
042DDD             0004*   ; e.g.: fonts, sprites, etc. (limited to 8k)
042DDD             0005*   filedata: equ 0xB7E000 ; address of onboard 8k sram
042DDD             0006*   
042DDD             0007*   ;     align 256 ; make things nice for indexing into especially ps_dir_fil_list
042DDD             0008*   ; ; buffer for sound data
042DDD             0009*   ps_wav_data_start: equ 0x050000 ;    equ $   ; (042E00) Start of audio data
042DDD             0010*   
042DDD             0011*   ; this list can grow as large as necessary to hold all the files in the directory
042DDD             0012*   ; each entry will be 278 bytes (filinfo_struct_size)
042DDD             0013*   ps_dir_fil_list: equ 0x060000 ; equ ps_wav_data_start+65536 ; (052E00) max file data we can load in one chunk is 64k
