PC     Output      Line
040000             0001        assume adl=1
040000             0002        org 0x040000
040000 C3 45 00 04 0003        jp start
040004             0004        align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0005        db "MOS"
040043 00          0006        db 00h
040044 01          0007        db 01h
040045             0008    
040045             0009    start:
040045 F5          0010        push af
040046 C5          0011        push bc
040047 D5          0012        push de
040048 DD E5       0013        push ix
04004A FD E5       0014        push iy
04004C             0015    
04004C CD 4B 37 04 0016        call init
040050 CD 58 37 04 0017        call main
040054             0018    
040054             0019    exit:
040054 FD E1       0020        pop iy
040056 DD E1       0021        pop ix
040058 D1          0022        pop de
040059 C1          0023        pop bc
04005A F1          0024        pop af
04005B 21 00 00 00 0025        ld hl,0
04005F             0026    
04005F C9          0027        ret
040060             0028    
040060             0029    ; API INCLUDES
040060             0030        include "mos_api.inc"
040060             0001*   ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.inc
040060             0002*   ; Title:	AGON MOS - API for user projects
040060             0003*   ; Author:	Dean Belfield
040060             0004*   ;			Adapted for agon-ez80asm by Jeroen Venema
040060             0005*   ;			Added MOS error codes for return in HL
040060             0006*   ; Created:	03/08/2022
040060             0007*   ; Last Updated:	10/08/2023
040060             0008*   ;
040060             0009*   ; Modinfo:
040060             0010*   ; 05/08/2022:	Added mos_feof
040060             0011*   ; 09/08/2022:	Added system variables: cursorX, cursorY
040060             0012*   ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040060             0013*   ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040060             0014*   ; 24/09/2022:	Added mos_getError, mos_mkdir
040060             0015*   ; 13/10/2022:	Added mos_oscli
040060             0016*   ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040060             0017*   ; 04/03/2023:	Added sysvar_scrpixelIndex
040060             0018*   ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040060             0019*   ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040060             0020*   ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040060             0021*   ; 22/03/2023:	The VDP commands are now indexed from 0x80
040060             0022*   ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040060             0023*   ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040060             0024*   ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040060             0025*   ; 19/05/2023:	Added sysvar_scrMode
040060             0026*   ; 05/06/2023:	Added sysvar_rtcEnable
040060             0027*   ; 03/08/2023:	Added mos_setkbvector
040060             0028*   ; 10/08/2023:	Added mos_getkbmap
040060             0029*   
040060             0030*   ; VDP control (VDU 23, 0, n)
040060             0031*   ;
040060             0032*   vdp_gp:				EQU 80h
040060             0033*   vdp_keycode:		EQU 81h
040060             0034*   vdp_cursor:			EQU	82h
040060             0035*   vdp_scrchar:		EQU	83h
040060             0036*   vdp_scrpixel:		EQU	84h
040060             0037*   vdp_audio:			EQU	85h
040060             0038*   vdp_mode:			EQU	86h
040060             0039*   vdp_rtc:			EQU	87h
040060             0040*   vdp_keystate:		EQU	88h
040060             0041*   vdp_logicalcoords:	EQU	C0h
040060             0042*   vdp_terminalmode:	EQU	FFh
040060             0043*   
040060             0044*   ; MOS high level functions
040060             0045*   ;
040060             0046*   mos_getkey:			EQU	00h
040060             0047*   mos_load:			EQU	01h
040060             0048*   mos_save:			EQU	02h
040060             0049*   mos_cd:				EQU	03h
040060             0050*   mos_dir:			EQU	04h
040060             0051*   mos_del:			EQU	05h
040060             0052*   mos_ren:			EQU	06h
040060             0053*   mos_mkdir:			EQU	07h
040060             0054*   mos_sysvars:		EQU	08h
040060             0055*   mos_editline:		EQU	09h
040060             0056*   mos_fopen:			EQU	0Ah
040060             0057*   mos_fclose:			EQU	0Bh
040060             0058*   mos_fgetc:			EQU	0Ch
040060             0059*   mos_fputc:			EQU	0Dh
040060             0060*   mos_feof:			EQU	0Eh
040060             0061*   mos_getError:		EQU	0Fh
040060             0062*   mos_oscli:			EQU	10h
040060             0063*   mos_copy:			EQU	11h
040060             0064*   mos_getrtc:			EQU	12h
040060             0065*   mos_setrtc:			EQU	13h
040060             0066*   mos_setintvector:	EQU	14h
040060             0067*   mos_uopen:			EQU	15h
040060             0068*   mos_uclose:			EQU	16h
040060             0069*   mos_ugetc:			EQU	17h
040060             0070*   mos_uputc:			EQU	18h
040060             0071*   mos_getfil:			EQU	19h
040060             0072*   mos_fread:			EQU	1Ah
040060             0073*   mos_fwrite:			EQU	1Bh
040060             0074*   mos_flseek:			EQU	1Ch
040060             0075*   mos_setkbvector:	EQU	1Dh
040060             0076*   mos_getkbmap:		EQU	1Eh
040060             0077*   
040060             0078*   ; MOS program exit codes
040060             0079*   ;
040060             0080*   EXIT_OK:				EQU  0;	"OK",
040060             0081*   EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
040060             0082*   EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
040060             0083*   EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
040060             0084*   EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
040060             0085*   EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
040060             0086*   EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
040060             0087*   EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
040060             0088*   EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
040060             0089*   EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
040060             0090*   EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
040060             0091*   EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
040060             0092*   EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
040060             0093*   EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
040060             0094*   EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
040060             0095*   EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
040060             0096*   EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
040060             0097*   EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
040060             0098*   EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
040060             0099*   EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
040060             0100*   EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
040060             0101*   EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
040060             0102*   ; FatFS file access functions
040060             0103*   ;
040060             0104*   ffs_fopen:			EQU	80h
040060             0105*   ffs_fclose:			EQU	81h
040060             0106*   ffs_fread:			EQU	82h
040060             0107*   ffs_fwrite:			EQU	83h
040060             0108*   ffs_flseek:			EQU	84h
040060             0109*   ffs_ftruncate:		EQU	85h
040060             0110*   ffs_fsync:			EQU	86h
040060             0111*   ffs_fforward:		EQU	87h
040060             0112*   ffs_fexpand:		EQU	88h
040060             0113*   ffs_fgets:			EQU	89h
040060             0114*   ffs_fputc:			EQU	8Ah
040060             0115*   ffs_fputs:			EQU	8Bh
040060             0116*   ffs_fprintf:		EQU	8Ch
040060             0117*   ffs_ftell:			EQU	8Dh
040060             0118*   ffs_feof:			EQU	8Eh
040060             0119*   ffs_fsize:			EQU	8Fh
040060             0120*   ffs_ferror:			EQU	90h
040060             0121*   
040060             0122*   ; FatFS directory access functions
040060             0123*   ;
040060             0124*   ffs_dopen:			EQU	91h
040060             0125*   ffs_dclose:			EQU	92h
040060             0126*   ffs_dread:			EQU	93h
040060             0127*   ffs_dfindfirst:		EQU	94h
040060             0128*   ffs_dfindnext:		EQU	95h
040060             0129*   
040060             0130*   ; FatFS file and directory management functions
040060             0131*   ;
040060             0132*   ffs_stat:			EQU	96h
040060             0133*   ffs_unlink:			EQU	97h
040060             0134*   ffs_rename:			EQU	98h
040060             0135*   ffs_chmod:			EQU	99h
040060             0136*   ffs_utime:			EQU	9Ah
040060             0137*   ffs_mkdir:			EQU	9Bh
040060             0138*   ffs_chdir:			EQU	9Ch
040060             0139*   ffs_chdrive:		EQU	9Dh
040060             0140*   ffs_getcwd:			EQU	9Eh
040060             0141*   
040060             0142*   ; FatFS volume management and system configuration functions
040060             0143*   ;
040060             0144*   ffs_mount:			EQU	9Fh
040060             0145*   ffs_mkfs:			EQU	A0h
040060             0146*   ffs_fdisk:			EQU	A1h
040060             0147*   ffs_getfree:		EQU	A2h
040060             0148*   ffs_getlabel:		EQU	A3h
040060             0149*   ffs_setlabel:		EQU	A4h
040060             0150*   ffs_setcp:			EQU	A5h
040060             0151*   
040060             0152*   ; File access modes
040060             0153*   ;
040060             0154*   fa_read:			EQU	01h
040060             0155*   fa_write:			EQU	02h
040060             0156*   fa_open_existing:	EQU	00h
040060             0157*   fa_create_new:		EQU	04h
040060             0158*   fa_create_always:	EQU	08h
040060             0159*   fa_open_always:		EQU	10h
040060             0160*   fa_open_append:		EQU	30h
040060             0161*   
040060             0162*   ; System variable indexes for api_sysvars
040060             0163*   ; Index into _sysvars in globals.inc
040060             0164*   ;
040060             0165*   sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040060             0166*   sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
040060             0167*   sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040060             0168*   sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
040060             0169*   sysvar_cursorX:			EQU	07h	; 1: Cursor X position
040060             0170*   sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
040060             0171*   sysvar_scrchar:			EQU	09h	; 1: Character read from screen
040060             0172*   sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040060             0173*   sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040060             0174*   sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040060             0175*   sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
040060             0176*   sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
040060             0177*   sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
040060             0178*   sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
040060             0179*   sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
040060             0180*   sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040060             0181*   sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
040060             0182*   sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040060             0183*   sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
040060             0184*   sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
040060             0185*   sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
040060             0186*   sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
040060             0187*   sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
040060             0188*   sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
040060             0189*   sysvar_scrMode:			EQU	27h	; 1: Screen mode
040060             0190*   sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040060             0191*   
040060             0192*   ; Flags for the VPD protocol
040060             0193*   ;
040060             0194*   vdp_pflag_cursor:		EQU	00000001b
040060             0195*   vdp_pflag_scrchar:		EQU	00000010b
040060             0196*   vdp_pflag_point:		EQU	00000100b
040060             0197*   vdp_pflag_audio:		EQU	00001000b
040060             0198*   vdp_pflag_mode:			EQU	00010000b
040060             0199*   vdp_pflag_rtc:			EQU	00100000b
040060             0200*   
040060             0201*   ;
040060             0202*   ; FatFS structures
040060             0203*   ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040060             0204*   ;
040060             0205*   ; Object ID and allocation information (FFOBJID)
040060             0206*   ;
040060             0207*   ; Indexes into FFOBJID structure
040060             0208*   ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
040060             0209*   ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
040060             0210*   ffobjid_attr:		EQU	5	; 1: Object attribute
040060             0211*   ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040060             0212*   ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
040060             0213*   ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
040060             0214*   ;
040060             0215*   ; File object structure (FIL)
040060             0216*   ;
040060             0217*   ; Indexes into FIL structure
040060             0218*   fil_obj:		EQU 0	; 15: Object identifier
040060             0219*   fil_flag:		EQU	15 	;  1: File status flags
040060             0220*   fil_err:		EQU	16	;  1: Abort flag (error code)
040060             0221*   fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
040060             0222*   fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
040060             0223*   fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
040060             0224*   fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
040060             0225*   fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
040060             0226*   ;
040060             0227*   ; Directory object structure (DIR)
040060             0228*   ; Indexes into DIR structure
040060             0229*   dir_obj:		EQU  0	; 15: Object identifier
040060             0230*   dir_dptr:		EQU	15	;  4: Current read/write offset
040060             0231*   dir_clust:		EQU	19	;  4: Current cluster
040060             0232*   dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
040060             0233*   dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
040060             0234*   dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
040060             0235*   dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040060             0236*   dir_struct_size:	EQU	46	;  4: Size of the object
040060             0237*   ;
040060             0238*   ; File information structure (FILINFO)
040060             0239*   ;
040060             0240*   ; Indexes into FILINFO structure
040060             0241*   filinfo_fsize:		EQU 0	;   4: File size
040060             0242*   filinfo_fdate:		EQU	4	;   2: Modified date
040060             0243*   filinfo_ftime:		EQU	6	;   2: Modified time
040060             0244*   filinfo_fattrib:	EQU	8	;   1: File attribute
040060             0245*   filinfo_altname:	EQU	9	;  13: Alternative file name
040060             0246*   filinfo_fname:		EQU	22	; 256: Primary file name
040060             0247*   filinfo_struct_size: EQU filinfo_fname+256 ; size of the FILINFO structure
040060             0248*   
040060             0249*   ; /* File attribute bits for directory entry (FILINFO.fattrib) */
040060             0250*   AM_RDO: equ 0x01 ; Read only
040060             0251*   AM_HID: equ 0x02 ; Hidden
040060             0252*   AM_SYS: equ 0x04 ; System
040060             0253*   AM_DIR: equ 0x10 ; Directory
040060             0254*   AM_ARC: equ 0x20 ; Archive
040060             0255*   ;
040060             0256*   ; Macro for calling the API
040060             0257*   ; Parameters:
040060             0258*   ; - function: One of the function numbers listed above
040060             0259*   ;
040060             0260*   	MACRO	MOSCALL	function
040060             0261*   			LD	A, function
040060             0262*   			RST.LIL	08h
040060             0263*   	ENDMACRO
040060             0031        include "macros.inc"
040060             0001*   
040060             0002*   ; test the sign of HL
040060             0003*   ; inputs: HL obviously
040060             0004*   ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
040060             0005*   ; destroys: flags
040060             0006*       MACRO SIGN_HLU
040060             0007*       add hl,de ; 1 cycle
040060             0008*       or a ; clear flags ; 1 cycle
040060             0009*       sbc hl,de ; 2 cycles
040060             0010*       ; 4 cycles total
040060             0011*       ENDMACRO
040060             0012*   
040060             0013*   ; put the value in A into HLU
040060             0014*   ; affects: HLU
040060             0015*   ; destroys: nothing
040060             0016*   ; note: $ instead of @@ b/c anon labels deprecated in ez80asm
040060             0017*       MACRO A_TO_HLU
040060             0018*       xor a ; 1 cycle
040060             0019*       ld ($+8+1),hl ; 7 cycles
040060             0020*       ld ($+4+3),a ; 5 cycles
040060             0021*       ld hl,0x000000 ; 4 cycles
040060             0022*       ; 17 cycles total
040060             0023*       ENDMACRO
040060             0024*   
040060             0025*   ; alternative: https://discord.com/channels/1158535358624039014/1282290921815408681/1318315567102300220
040060             0026*   ; one cycle less but burns flags
040060             0027*       MACRO A_TO_HLU_ALT
040060             0028*       push hl ; 4 cycles
040060             0029*       ld hl,2 ; 4 cycles
040060             0030*       add hl,sp ; 1 cycle
040060             0031*       ld (hl),a ; 2 cycles
040060             0032*       pop hl ; 4 cycles
040060             0033*       ; 15 cycles total
040060             0034*       ENDMACRO
040060             0035*   
040060             0036*       MACRO hlu_mul256
040060             0037*       add hl,hl ; * 2
040060             0038*       add hl,hl ; * 4
040060             0039*       add hl,hl ; * 8
040060             0040*       add hl,hl ; * 16
040060             0041*       add hl,hl ; * 32
040060             0042*       add hl,hl ; * 64
040060             0043*       add hl,hl ; * 128
040060             0044*       add hl,hl ; * 256
040060             0045*       ENDMACRO
040060             0046*   
040060             0047*   ; https://discord.com/channels/1158535358624039014/1282290921815408681/1317793870070812715
040060             0048*       MACRO SRL_UHL
040060             0049*       dec sp ; 1 cycle
040060             0050*       push hl ; 4 cycles
040060             0051*       inc sp ; 1 cycle
040060             0052*       pop hl ; 4 cycles
040060             0053*       inc hl ; 1 cycle
040060             0054*       dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
040060             0055*       ; 13 cycles total
040060             0056*       ENDMACRO
040060             0057*   
040060             0058*       MACRO printChar char
040060             0059*       LD A, char
040060             0060*       RST.LIL 10h
040060             0061*       ENDMACRO
040060             0062*   
040060             0063*   ; Simulated call to subroutine at HL
040060             0064*   ; inputs: HL pointing to the subroutine address plus whatever the called function expects
040060             0065*   ; outputs: whatever the subroutine does, including HL and BC
040060             0066*   ; destroys: only what the subroutine does, but always BC
040060             0067*       MACRO CALL_HL
040060             0068*       ld bc,$+6 ; Address of first instruction after the jump
040060             0069*       push bc ; which constitutes the return address
040060             0070*       jp (hl) ; Jump to the address in HL
040060             0071*       ENDMACRO
040060             0072*   
040060             0073*   ; Simulated call to subroutine at IX
040060             0074*   ; inputs: IX pointing to the subroutine address plus whatever the called function expects
040060             0075*   ; outputs: whatever the subroutine does, including IX and BC
040060             0076*   ; destroys: only what the subroutine does, but always BC
040060             0077*       MACRO CALL_IX
040060             0078*       ld bc,$+6 ; Address of first instruction after the jump
040060             0079*       push bc ; which constitutes the return address
040060             0080*       jp (ix) ; Jump to the address in IX
040060             0081*       ENDMACRO
040060             0082*   
040060             0083*   ; Simulated call to soubroutinte at IY
040060             0084*   ; inputs: IY pointing to the subroutine address plus whatever the called function expects
040060             0085*   ; outputs: whatever the subroutine does, including IY and BC
040060             0086*   ; destroys: only what the subroutine does, but always BC
040060             0087*       MACRO CALL_IY
040060             0088*       ld bc,$+6 ; Address of first instruction after the jump
040060             0089*       push bc ; which constitutes the return address
040060             0090*       jp (iy) ; Jump to the address in IY
040060             0091*       ENDMACRO
040060             0092*   
040060             0093*   ; put the value in HLU into A
040060             0094*   ; destroys: af
040060             0095*       MACRO HLU_TO_A
040060             0096*       dec sp ; 1 cycle
040060             0097*       push hl ; 4 cycles
040060             0098*       inc sp ; 1 cycle
040060             0099*       pop af ; 4 cycles
040060             0100*       ; 10 cycles total
040060             0101*       ENDMACRO
040060             0102*   
040060             0103*       MACRO PUSH_ALL
040060             0104*       ex af,af'
040060             0105*       exx
040060             0106*       push af
040060             0107*       push hl
040060             0108*       push bc
040060             0109*       push de
040060             0110*   
040060             0111*       ex af,af'
040060             0112*       exx
040060             0113*       push af
040060             0114*       push hl
040060             0115*       push bc
040060             0116*       push de
040060             0117*       push ix
040060             0118*       push iy
040060             0119*       ENDMACRO
040060             0120*   
040060             0121*       MACRO POP_ALL
040060             0122*       pop iy
040060             0123*       pop ix
040060             0124*       pop de
040060             0125*       pop bc
040060             0126*       pop hl
040060             0127*       pop af
040060             0128*       ex af,af'
040060             0129*       exx
040060             0130*   
040060             0131*       pop de
040060             0132*       pop bc
040060             0133*       pop hl
040060             0134*       pop af
040060             0135*       ex af,af'
040060             0136*       exx
040060             0137*       ENDMACRO
040060             0032        include "functions.inc"
040060             0001*   ; Print a zero-terminated string inline with code, e.g.:
040060             0002*   ;
040060             0003*   ;    call printInline
040060             0004*   ;    ASCIZ "Hello, world!\r\n"
040060             0005*   ;
040060             0006*   ; Destroys: HL,AF
040060             0007*   printInline:
040060 E1          0008*       pop hl ; get the return address = pointer to start of string
040061 CD 67 00 04 0009*       call printString ; HL advances to end of string
040065 E5          0010*       push hl ; restore the return address = pointer to end of string
040066 C9          0011*       ret
040067             0012*   
040067             0013*   ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
040067             0014*   ; Print a zero-terminated string
040067             0015*   ; HL: Pointer to string
040067             0016*   ; returns: hl pointed to character after string terminator
040067             0017*   ; destroys: af, hl
040067             0018*   printString:
040067 C5          0019*       PUSH BC
040068 01 00 00 00 0020*       LD BC,0
04006C 3E 00       0021*       LD A,0
04006E 5B DF       0022*       RST.LIL 18h
040070 C1          0023*       POP BC
040071 C9          0024*       RET
040072             0025*   ; print a VDU sequence
040072             0026*   ; HL: Pointer to VDU sequence - <1 byte length> <data>
040072             0027*   sendVDUsequence:
040072 C5          0028*       PUSH BC
040073 01 00 00 00 0029*       LD BC, 0
040077 4E          0030*       LD C, (HL)
040078 5B DF       0031*       RST.LIL 18h
04007A C1          0032*       POP BC
04007B C9          0033*       RET
04007C             0034*   ; Print Newline sequence to VDP
04007C             0035*   ; destroys: nothing
04007C             0036*   printNewLine:
04007C F5          0037*       push af ; for some reason rst.lil 10h sets carry flag
04007D 3E 0D       0038*       LD A, '\r'
04007F 5B D7       0039*       RST.LIL 10h
040081 3E 0A       0040*       LD A, '\n'
040083 5B D7       0041*       RST.LIL 10h
040085 F1          0042*       pop af
040086 C9          0043*       RET
040087             0044*   
040087             0045*   ; print a zero-terminated string at a graphics coordinate
040087             0046*   ; Inputs: HL Pointer to string, BC,DE x,y position (in pixels)
040087             0047*   printStringGfx:
040087 E5          0048*       push hl ; preserve string pointer
040088             0049*   ; move graphics cursor to x,y location
040088 3E 44       0050*       ld a,plot_pt+mv_abs
04008A CD 19 20 04 0051*       call vdu_plot
04008E             0052*   ; print string
04008E E1          0053*       pop hl ; restore string pointer
04008F             0054*   @print_loop:
04008F 7E          0055*       ld a,(hl)
040090 B7          0056*       or a ; check for end of string
040091 C8          0057*       ret z ; if zero, we're done
040092 08          0058*       ex af,af' ; preserve character
040093 3E 05       0059*       ld a,5 ; VDU 5 char to gfx cursor
040095 5B D7       0060*       rst.lil 10h ; send it
040097 08          0061*       ex af,af' ; restore character
040098 5B D7       0062*       rst.lil 10h ; print character
04009A 23          0063*       inc hl
04009B C3 8F 00 04 0064*       jp @print_loop
04009F C9          0065*       ret
0400A0             0066*   ; end printStringGfx
0400A0             0067*   
0400A0             0068*   ; Print a 24-bit HEX number
0400A0             0069*   ; HLU: Number to print
0400A0             0070*   printHex24:
0400A0             0071*       HLU_TO_A
                       M1 Args: none
0400A0 3B          0001*M1     dec sp ; 1 cycle
0400A1 E5          0002*M1     push hl ; 4 cycles
0400A2 33          0003*M1     inc sp ; 1 cycle
0400A3 F1          0004*M1     pop af ; 4 cycles
0400A4             0005*M1     ; 10 cycles total
0400A4 CD AE 00 04 0072*       CALL printHex8
0400A8             0073*   ; Print a 16-bit HEX number
0400A8             0074*   ; HL: Number to print
0400A8             0075*   printHex16:
0400A8 7C          0076*       LD A,H
0400A9 CD AE 00 04 0077*       CALL printHex8
0400AD 7D          0078*       LD A,L
0400AE             0079*   ; Print an 8-bit HEX number
0400AE             0080*   ; A: Number to print
0400AE             0081*   printHex8:
0400AE 4F          0082*       LD C,A
0400AF 1F          0083*       RRA
0400B0 1F          0084*       RRA
0400B1 1F          0085*       RRA
0400B2 1F          0086*       RRA
0400B3 CD B8 00 04 0087*       CALL @F
0400B7 79          0088*       LD A,C
0400B8             0089*   @@:
0400B8 E6 0F       0090*       AND 0Fh
0400BA C6 90       0091*       ADD A,90h
0400BC 27          0092*       DAA
0400BD CE 40       0093*       ADC A,40h
0400BF 27          0094*       DAA
0400C0 5B D7       0095*       RST.LIL 10h
0400C2 C9          0096*       RET
0400C3             0097*   
0400C3             0098*   ; Print a 0x HEX prefix
0400C3             0099*   DisplayHexPrefix:
0400C3 3E 30       0100*       LD A, '0'
0400C5 5B D7       0101*       RST.LIL 10h
0400C7 3E 78       0102*       LD A, 'x'
0400C9 5B D7       0103*       RST.LIL 10h
0400CB C9          0104*       RET
0400CC             0105*   
0400CC             0106*       MACRO printDecBC
0400CC             0107*       push hl
0400CC             0108*       push bc
0400CC             0109*       pop hl
0400CC             0110*       call printDec
0400CC             0111*       pop hl
0400CC             0112*       ENDMACRO
0400CC             0113*   
0400CC             0114*       MACRO printDecDE
0400CC             0115*       push hl
0400CC             0116*       push de
0400CC             0117*       pop hl
0400CC             0118*       call printDec
0400CC             0119*       pop hl
0400CC             0120*       ENDMACRO
0400CC             0121*   
0400CC             0122*       MACRO printDecHL
0400CC             0123*       call printDec
0400CC             0124*       ENDMACRO
0400CC             0125*   
0400CC             0126*       MACRO printDecIX
0400CC             0127*       push hl
0400CC             0128*       push ix
0400CC             0129*       pop hl
0400CC             0130*       call printDec
0400CC             0131*       pop hl
0400CC             0132*       ENDMACRO
0400CC             0133*   
0400CC             0134*       MACRO printDecIY
0400CC             0135*       push hl
0400CC             0136*       push iy
0400CC             0137*       pop hl
0400CC             0138*       call printDec
0400CC             0139*       pop hl
0400CC             0140*       ENDMACRO
0400CC             0141*   
0400CC             0142*   
0400CC             0143*   ; Prints the right justified decimal value in HL without leading zeroes
0400CC             0144*   ; HL : Value to print
0400CC             0145*   ; preserves all registers and flags
0400CC             0146*   printDec:
0400CC             0147*   ; BEGIN MY CODE
0400CC             0148*   ; back up all the things
0400CC F5          0149*       push af
0400CD C5          0150*       push bc
0400CE D5          0151*       push de
0400CF E5          0152*       push hl
0400D0             0153*   ; END MY CODE
0400D0 11 F8 00 04 0154*       LD DE, _printDecBuffer
0400D4 CD 08 01 04 0155*       CALL u24_to_ascii
0400D8             0156*   ; BEGIN MY CODE
0400D8             0157*   ; replace leading zeroes with spaces
0400D8 21 F8 00 04 0158*       LD HL, _printDecBuffer
0400DC 06 07       0159*       ld B, 7 ; if HL was 0, we want to keep the final zero
0400DE             0160*   @loop:
0400DE 7E          0161*       LD A, (HL)
0400DF FE 30       0162*       CP '0'
0400E1 C2 EB 00 04 0163*       JP NZ, @done
0400E5 3E 20       0164*       LD A, ' '
0400E7 77          0165*       LD (HL), A
0400E8 23          0166*       INC HL
0400E9             0167*       ; CALL vdu_cursor_forward
0400E9 10 F3       0168*       DJNZ @loop
0400EB             0169*   @done:
0400EB             0170*   ; END MY CODE
0400EB 21 F8 00 04 0171*       LD HL, _printDecBuffer
0400EF CD 67 00 04 0172*       CALL printString
0400F3             0173*   ; BEGIN MY CODE
0400F3             0174*   ; restore all the things
0400F3 E1          0175*       pop hl
0400F4 D1          0176*       pop de
0400F5 C1          0177*       pop bc
0400F6 F1          0178*       pop af
0400F7             0179*   ; END MY CODE
0400F7 C9          0180*       RET
0400F8 00 00 00 00 0181*   _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040108             0182*   
040108             0183*   ; This routine converts the unsigned 24-bit value in HLU into its ASCII representation,
040108             0184*   ; starting to memory location pointing by DE, in decimal form and with leading zeroes
040108             0185*   ; so it will allways be 8 characters length
040108             0186*   ; HL : Value to convert to string
040108             0187*   ; DE : pointer to buffer, at least 8 byte + 0
040108             0188*   u24_to_ascii:
040108 01 80 69 67 0189*       LD BC,-10000000
04010C CD 3F 01 04 0190*       CALL one_digit
040110 01 C0 BD F0 0191*       LD BC,-1000000
040114 CD 3F 01 04 0192*       CALL one_digit
040118 01 60 79 FE 0193*       LD BC,-100000
04011C CD 3F 01 04 0194*       CALL one_digit
040120 01 F0 D8 FF 0195*       LD BC,-10000
040124 CD 3F 01 04 0196*       CALL one_digit
040128             0197*   u8_to_ascii: ; same arguments but hl <= 255, uhl and h = 0
040128 01 18 FC FF 0198*       LD BC,-1000
04012C CD 3F 01 04 0199*       CALL one_digit
040130 01 9C FF FF 0200*       LD BC,-100
040134 CD 3F 01 04 0201*       CALL one_digit
040138 0E F6       0202*       LD C,-10
04013A CD 3F 01 04 0203*       CALL one_digit
04013E 48          0204*       LD C,B
04013F             0205*   one_digit:
04013F 3E 2F       0206*       LD A,'0'-1
040141             0207*   @divide_me:
040141 3C          0208*       INC A
040142 09          0209*       ADD HL,BC
040143 38 FC       0210*       JR C,@divide_me
040145 ED 42       0211*       SBC HL,BC
040147 12          0212*       LD (DE),A
040148 13          0213*       INC DE
040149 C9          0214*       RET
04014A             0215*   
04014A             0216*   print_u24:
04014A D5          0217*       push de
04014B E5          0218*       push hl
04014C 11 F8 00 04 0219*       ld de,_printDecBuffer
040150 CD 08 01 04 0220*       call u24_to_ascii
040154 21 F8 00 04 0221*       ld hl,_printDecBuffer
040158 CD 67 00 04 0222*       call printString
04015C 3E 20       0223*       ld a,' '
04015E 5B D7       0224*       rst.lil 10h
040160 E1          0225*       pop hl
040161 D1          0226*       pop de
040162 C9          0227*       ret
040163             0228*   
040163             0229*   ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
040163             0230*   ; HL : Value to convert to string (integer part in H, fractional part in L)
040163             0231*   ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
040163             0232*   u168_to_ascii:
040163             0233*   ; add a leading space to make room for sign flag if needed
040163 3E 20       0234*       ld a,' '
040165 12          0235*       ld (de),a
040166 13          0236*       inc de
040167             0237*   ; Convert integer part
040167 E5          0238*       push hl ; Save HL (we’ll need the fractional part later)
040168             0239*       ; call hlu_udiv256 ; Shift to get integer portion in HL
040168             0240*       SRL_UHL ; Shift to get integer portion in HL
                       M1 Args: none
040168 3B          0001*M1     dec sp ; 1 cycle
040169 E5          0002*M1     push hl ; 4 cycles
04016A 33          0003*M1     inc sp ; 1 cycle
04016B E1          0004*M1     pop hl ; 4 cycles
04016C 23          0005*M1     inc hl ; 1 cycle
04016D 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
04016F             0007*M1     ; 13 cycles total
04016F 01 F0 D8 FF 0241*       ld bc, -10000
040173 CD 96 01 04 0242*       call @one_int
040177 01 18 FC FF 0243*       ld bc, -1000
04017B CD 96 01 04 0244*       call @one_int
04017F 01 9C FF FF 0245*       ld bc, -100
040183 CD 96 01 04 0246*       call @one_int
040187 0E F6       0247*       ld c, -10
040189 CD 96 01 04 0248*       call @one_int
04018D 48          0249*       ld c, b
04018E CD 96 01 04 0250*       call @one_int
040192 C3 A1 01 04 0251*       jp @frac ; Jump to fractional part conversion
040196             0252*   @one_int:
040196 3E 2F       0253*       ld a, '0' - 1 ; Start ASCII character at '0'
040198             0254*   @divide_me:
040198 3C          0255*       inc a
040199 09          0256*       add hl, bc ; Accumulate until overflow
04019A 38 FC       0257*       jr c, @divide_me
04019C ED 42       0258*       sbc hl, bc ; Remove excess after overflow
04019E 12          0259*       ld (de), a ; Store ASCII digit
04019F 13          0260*       inc de
0401A0 C9          0261*       ret
0401A1             0262*   ; Convert fractional part
0401A1             0263*   @frac:
0401A1 3E 2E       0264*       ld a, '.' ; Decimal point
0401A3 12          0265*       ld (de), a
0401A4 13          0266*       inc de
0401A5 E1          0267*       pop hl ; Restore HL with original fraction
0401A6 06 03       0268*       ld b, 3 ; Loop counter for 3 fractional digits
0401A8             0269*   @frac_loop:
0401A8 26 0A       0270*       ld h, 10 ; Load multiplier for fractional part
0401AA ED 6C       0271*       mlt hl ; Multiply by 10, result in HL (H holds the integer part)
0401AC 3E 30       0272*       ld a, '0'
0401AE 84          0273*       add a, h ; Convert integer part to ASCII
0401AF 12          0274*       ld (de), a
0401B0 13          0275*       inc de
0401B1 10 F5       0276*       djnz @frac_loop ; Repeat for each fractional digit
0401B3             0277*   ; Add null terminator
0401B3 AF          0278*       xor a ; Null terminator
0401B4 12          0279*       ld (de), a
0401B5 C9          0280*       ret
0401B6             0281*   
0401B6             0282*   print_u168:
0401B6 D5          0283*       push de
0401B7 E5          0284*       push hl
0401B8 11 F8 00 04 0285*       ld de,_printDecBuffer
0401BC CD 63 01 04 0286*       call u168_to_ascii
0401C0 21 F8 00 04 0287*       ld hl,_printDecBuffer
0401C4 CD 67 00 04 0288*       call printString
0401C8 E1          0289*       pop hl
0401C9 D1          0290*       pop de
0401CA C9          0291*       ret
0401CB             0292*   
0401CB             0293*   ; signed version of u168_to_ascii
0401CB             0294*   s168_to_ascii:
0401CB D5          0295*       push de ; save starting address of buffer
0401CC CD 70 04 04 0296*       call hlu_abs
0401D0 F5          0297*       push af ; save sign flag
0401D1 CD 63 01 04 0298*       call u168_to_ascii
0401D5 F1          0299*       pop af ; restore sign flag
0401D6 D1          0300*       pop de ; restore starting address of buffer
0401D7 F0          0301*       ret p ; hlu was positive so nothing to do
0401D8 3E 2D       0302*       ld a,'-'
0401DA 12          0303*       ld (de),a
0401DB C9          0304*       ret
0401DC             0305*   
0401DC             0306*   print_s168:
0401DC D5          0307*       push de
0401DD E5          0308*       push hl
0401DE 11 F8 00 04 0309*       ld de,_printDecBuffer
0401E2 CD CB 01 04 0310*       call s168_to_ascii
0401E6 21 F8 00 04 0311*       ld hl,_printDecBuffer
0401EA CD 67 00 04 0312*       call printString
0401EE E1          0313*       pop hl
0401EF D1          0314*       pop de
0401F0 C9          0315*       ret
0401F1             0316*   
0401F1             0317*   print_s168_hl:
0401F1 F5          0318*       push af
0401F2 E5          0319*       push hl
0401F3 CD DC 01 04 0320*       call print_s168
0401F7 3E 20       0321*       ld a,' '
0401F9 5B D7       0322*       rst.lil 10h
0401FB E1          0323*       pop hl
0401FC F1          0324*       pop af
0401FD C9          0325*       ret
0401FE             0326*   
0401FE             0327*   print_s168_bc:
0401FE F5          0328*       push af
0401FF C5          0329*       push bc
040200 E5          0330*       push hl
040201 C5          0331*       push bc
040202 E1          0332*       pop hl
040203 CD DC 01 04 0333*       call print_s168
040207 3E 20       0334*       ld a,' '
040209 5B D7       0335*       rst.lil 10h
04020B E1          0336*       pop hl
04020C C1          0337*       pop bc
04020D F1          0338*       pop af
04020E C9          0339*       ret
04020F             0340*   
04020F             0341*   print_s168_de:
04020F F5          0342*       push af
040210 D5          0343*       push de
040211 E5          0344*       push hl
040212 EB          0345*       ex de,hl
040213 CD DC 01 04 0346*       call print_s168
040217 3E 20       0347*       ld a,' '
040219 5B D7       0348*       rst.lil 10h
04021B E1          0349*       pop hl
04021C D1          0350*       pop de
04021D F1          0351*       pop af
04021E C9          0352*       ret
04021F             0353*   
04021F             0354*   print_s168_hl_bc_de:
04021F F5          0355*       push af
040220 C5          0356*       push bc
040221 D5          0357*       push de
040222 E5          0358*       push hl
040223 CD DC 01 04 0359*       call print_s168
040227 3E 20       0360*       ld a,' '
040229 5B D7       0361*       rst.lil 10h
04022B C5          0362*       push bc
04022C E1          0363*       pop hl
04022D CD DC 01 04 0364*       call print_s168
040231 3E 20       0365*       ld a,' '
040233 5B D7       0366*       rst.lil 10h
040235 EB          0367*       ex de,hl
040236 CD DC 01 04 0368*       call print_s168
04023A 3E 20       0369*       ld a,' '
04023C 5B D7       0370*       rst.lil 10h
04023E E1          0371*       pop hl
04023F D1          0372*       pop de
040240 C1          0373*       pop bc
040241 F1          0374*       pop af
040242 C9          0375*       ret
040243             0376*   
040243             0377*   print_s168_bc_de:
040243 F5          0378*       push af
040244 C5          0379*       push bc
040245 D5          0380*       push de
040246 C5          0381*       push bc
040247 E1          0382*       pop hl
040248 CD DC 01 04 0383*       call print_s168
04024C 3E 20       0384*       ld a,' '
04024E 5B D7       0385*       rst.lil 10h
040250 EB          0386*       ex de,hl
040251 CD DC 01 04 0387*       call print_s168
040255 3E 20       0388*       ld a,' '
040257 5B D7       0389*       rst.lil 10h
040259 E1          0390*       pop hl
04025A D1          0391*       pop de
04025B C1          0392*       pop bc
04025C F1          0393*       pop af
04025D C9          0394*       ret
04025E             0395*   
04025E             0396*   print_s168_a:
04025E F5          0397*       push af
04025F C5          0398*       push bc
040260 E5          0399*       push hl
040261 21 00 00 00 0400*       ld hl,0
040265 6F          0401*       ld l,a
040266 CD F1 01 04 0402*       call print_s168_hl
04026A E1          0403*       pop hl
04026B C1          0404*       pop bc
04026C F1          0405*       pop af
04026D C9          0406*       ret
04026E             0407*   
04026E             0408*   ; #### new functions added by Brandon R. Gates ####
04026E             0409*   
04026E             0410*   ; print the binary representation of the 8-bit value in a
04026E             0411*   ; destroys a, hl, bc
04026E             0412*   printBin8:
04026E 06 08       0413*       ld b,8 ; loop counter for 8 bits
040270 21 8B 02 04 0414*       ld hl,@cmd ; set hl to the low byte of the output string
040274             0415*       ; (which will be the high bit of the value in a)
040274             0416*   @loop:
040274 07          0417*       rlca ; put the next highest bit into carry
040275 38 04       0418*       jr c,@one
040277 36 30       0419*       ld (hl),'0'
040279 18 02       0420*       jr @next_bit
04027B             0421*   @one:
04027B 36 31       0422*       ld (hl),'1'
04027D             0423*   @next_bit:
04027D 23          0424*       inc hl
04027E 10 F4       0425*       djnz @loop
040280             0426*   ; print it
040280 21 8B 02 04 0427*       ld hl,@cmd
040284 01 08 00 00 0428*       ld bc,@end-@cmd
040288 5B DF       0429*       rst.lil $18
04028A C9          0430*       ret
04028B             0431*   @cmd: ds 8 ; eight bytes for eight bits
040293             0432*   @end:
040293             0433*   
040293             0434*   ; print the binary representation of the 8-bit value in a
040293             0435*   ; in reverse order (lsb first)
040293             0436*   ; destroys a, hl, bc
040293             0437*   printBin8Rev:
       FF FF FF FF 
       FF FF FF FF 
040293 06 08       0438*       ld b,8 ; loop counter for 8 bits
040295 21 B0 02 04 0439*       ld hl,@cmd ; set hl to the low byte of the output string
040299             0440*       ; (which will be the high bit of the value in a)
040299             0441*   @loop:
040299 0F          0442*       rrca ; put the next lowest bit into carry
04029A 38 04       0443*       jr c,@one
04029C 36 30       0444*       ld (hl),'0'
04029E 18 02       0445*       jr @next_bit
0402A0             0446*   @one:
0402A0 36 31       0447*       ld (hl),'1'
0402A2             0448*   @next_bit:
0402A2 23          0449*       inc hl
0402A3 10 F4       0450*       djnz @loop
0402A5             0451*   ; print it
0402A5 21 B0 02 04 0452*       ld hl,@cmd
0402A9 01 08 00 00 0453*       ld bc,@end-@cmd
0402AD 5B DF       0454*       rst.lil $18
0402AF C9          0455*       ret
0402B0             0456*   @cmd: ds 8 ; eight bytes for eight bits
0402B8             0457*   @end:
0402B8             0458*   
       FF FF FF FF 
       FF FF FF FF 
0402B8 20 61 66 3D 0459*   str_afu: db " af=",0
       00          
0402BD 20 68 6C 3D 0460*   str_hlu: db " hl=",0
       00          
0402C2 20 62 63 3D 0461*   str_bcu: db " bc=",0
       00          
0402C7 20 64 65 3D 0462*   str_deu: db " de=",0
       00          
0402CC 20 69 78 3D 0463*   str_ixu: db " ix=",0
       00          
0402D1 20 69 79 3D 0464*   str_iyu: db " iy=",0
       00          
0402D6             0465*   
0402D6             0466*   ; print udeuhl to screen in hexidecimal format
0402D6             0467*   ; inputs: none
0402D6             0468*   ; outputs: concatenated hexidecimal udeuhl
0402D6             0469*   ; destroys: nothing
0402D6             0470*   dumpUDEUHLHex:
0402D6             0471*   ; store everything in scratch
0402D6 22 35 03 04 0472*       ld (uhl),hl
0402DA ED 43 38 03 0473*       ld (ubc),bc
       04          
0402DF ED 53 3B 03 0474*       ld (ude),de
       04          
0402E4 DD 22 3E 03 0475*       ld (uix),ix
       04          
0402E9 FD 22 41 03 0476*       ld (uiy),iy
       04          
0402EE F5          0477*       push af
0402EF             0478*   
0402EF             0479*   ; print each register
0402EF             0480*   
0402EF 21 29 03 04 0481*       ld hl,str_udeuhl
0402F3 CD 67 00 04 0482*       call printString
0402F7 2A 3B 03 04 0483*       ld hl,(ude)
0402FB CD A0 00 04 0484*       call printHex24
0402FF 3E 2E       0485*       ld a,'.' ; print a dot to separate the values
040301 5B D7       0486*       rst.lil 10h
040303 2A 35 03 04 0487*       ld hl,(uhl)
040307 CD A0 00 04 0488*       call printHex24
04030B CD 7C 00 04 0489*       call printNewLine
04030F             0490*   
04030F             0491*   ; restore everything
04030F 2A 35 03 04 0492*       ld hl, (uhl)
040313 ED 4B 38 03 0493*       ld bc, (ubc)
       04          
040318 ED 5B 3B 03 0494*       ld de, (ude)
       04          
04031D DD 2A 3E 03 0495*       ld ix, (uix)
       04          
040322 FD 2A 41 03 0496*       ld iy, (uiy)
       04          
040327 F1          0497*       pop af
040328             0498*   ; all done
040328 C9          0499*       ret
040329             0500*   
040329 75 64 65 2E 0501*   str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
040332             0502*   
040332             0503*   ; global scratch memory for registers
040332 00 00 00    0504*   uaf: dl 0
040335 00 00 00    0505*   uhl: dl 0
040338 00 00 00    0506*   ubc: dl 0
04033B 00 00 00    0507*   ude: dl 0
04033E 00 00 00    0508*   uix: dl 0
040341 00 00 00    0509*   uiy: dl 0
040344 00 00 00    0510*   usp: dl 0
040347 00 00 00    0511*   upc: dl 0
04034A             0512*   
04034A             0513*   
04034A             0514*   ; set all the bits in the flag register
04034A             0515*   ; more of an academic exercise than anything useful
04034A             0516*   ; inputs; none
04034A             0517*   ; outputs; a=0,f=255
04034A             0518*   ; destroys: flags, hl
04034A             0519*   ; preserves: a, because why not
04034A             0520*   setAllFlags:
04034A 21 FF 00 00 0521*       ld hl,255
04034E 67          0522*       ld h,a ; four cycles to preserve a is cheap
04034F E5          0523*       push hl
040350 F1          0524*       pop af
040351 C9          0525*       ret
040352             0526*   
040352             0527*   ; reset all the bits in the flag register
040352             0528*   ; unlike its inverse counterpart, this may actually be useful
040352             0529*   ; inputs; none
040352             0530*   ; outputs; a=0,f=0
040352             0531*   ; destroys: flags, hl
040352             0532*   ; preserves: a, because why not
040352             0533*   resetAllFlags:
040352 21 00 00 00 0534*       ld hl,0
040356 67          0535*       ld h,a ; four cycles to preserve a is cheap
040357 E5          0536*       push hl
040358 F1          0537*       pop af
040359 C9          0538*       ret
04035A             0539*   
04035A             0540*   ; wait until user presses a key
04035A             0541*   ; inputs: none
04035A             0542*   ; outputs: ascii code of key pressed in a
04035A             0543*   ; destroys: af,ix
04035A             0544*   waitKeypress:
04035A             0545*       MOSCALL mos_getkey
                       M1 Args: function=mos_getkey 
04035A 3E 00       0001*M1 			LD	A, function
04035C 5B CF       0002*M1 			RST.LIL	08h
04035E C9          0546*       ret
04035F             0547*   
04035F             0548*   ; clear a block of memory by writing a prescribed value to each byte in the range
04035F             0549*   ; inputs: a = value to write, hl = address of first byte, bc = number of bytes
04035F             0550*   ; outputs: memory block is cleared
04035F             0551*   ; destroys: hl, de
04035F             0552*   clear_mem:
04035F 0B          0553*       dec bc ; we do this because we will increment de before writing the first byte
040360 77          0554*       ld (hl),a
040361 E5          0555*       push hl
040362 D1          0556*       pop de
040363 13          0557*       inc de ; target address
040364 ED B0       0558*       ldir
040366 C9          0559*       ret
040367             0033        include "arith24.inc"
040367             0001*   ;------------------------------------------------------------------------
040367             0002*   ;  arith24.asm
040367             0003*   ;  24-bit ez80 arithmetic routines
040367             0004*   ;  Copyright (c) Shawn Sijnstra 2024
040367             0005*   ;  MIT license
040367             0006*   ;
040367             0007*   ;  This library was created as a tool to help make ez80
040367             0008*   ;  24-bit native assembly routines for simple mathematical problems
040367             0009*   ;  more widely available.
040367             0010*   ;
040367             0011*   ;------------------------------------------------------------------------
040367             0012*   
040367             0013*   ;------------------------------------------------------------------------
040367             0014*   ; umul24:	HL = HL*DE (unsigned)
040367             0015*   ; Preserves AF, BC, DE
040367             0016*   ; Uses a fast multiply routine.
040367             0017*   ;------------------------------------------------------------------------
040367             0018*   umul24:
040367 D5          0019*   	push	DE
040368 C5          0020*   	push	BC
040369 F5          0021*   	push	AF
04036A E5          0022*   	push	HL
04036B C1          0023*   	pop		BC
04036C 3E 18       0024*       ld	 	a, 24 ; No. of bits to process
04036E 21 00 00 00 0025*       ld	 	hl, 0 ; Result
040372             0026*   umul24_lp:
040372 29          0027*   	add	hl,hl
040373 EB          0028*   	ex	de,hl
040374 29          0029*   	add	hl,hl
040375 EB          0030*   	ex	de,hl
040376 30 01       0031*   	jr	nc,umul24_nc
040378 09          0032*   	add	hl,bc
040379             0033*   umul24_nc:
040379 3D          0034*   	dec	a
04037A 20 F6       0035*   	jr	nz,umul24_lp
04037C F1          0036*   	pop	af
04037D C1          0037*   	pop	bc
04037E D1          0038*   	pop	de
04037F C9          0039*   	ret
040380             0040*   
040380             0041*   
040380             0042*   ;------------------------------------------------------------------------
040380             0043*   ; udiv24
040380             0044*   ; Unsigned 24-bit division
040380             0045*   ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
040380             0046*   ;
040380             0047*   ; Uses AF BC DE HL
040380             0048*   ; Uses Restoring Division algorithm
040380             0049*   ;------------------------------------------------------------------------
040380             0050*   
040380             0051*   udiv24:
040380 E5          0052*   	push	hl
040381 C1          0053*   	pop		bc	;move dividend to BCU
040382 21 00 00 00 0054*   	ld		hl,0	;result
040386 A7          0055*   	and		a
040387 ED 52       0056*   	sbc		hl,de	;test for div by 0
040389 C8          0057*   	ret		z		;it's zero, carry flag is clear
04038A 19          0058*   	add		hl,de	;HL is 0 again
04038B 3E 18       0059*   	ld		a,24	;number of loops through.
04038D             0060*   udiv1:
04038D C5          0061*   	push	bc	;complicated way of doing this because of lack of access to top bits
04038E E3          0062*   	ex		(sp),hl
04038F 37          0063*   	scf
040390 ED 6A       0064*   	adc	hl,hl
040392 E3          0065*   	ex	(sp),hl
040393 C1          0066*   	pop	bc		;we now have bc = (bc * 2) + 1
040394             0067*   
040394 ED 6A       0068*   	adc	hl,hl
040396 A7          0069*   	and	a		;is this the bug
040397 ED 52       0070*   	sbc	hl,de
040399 30 02       0071*   	jr	nc,udiv2
04039B 19          0072*   	add	hl,de
04039C             0073*   ;	dec	c
04039C 0B          0074*   	dec	bc
04039D             0075*   udiv2:
04039D 3D          0076*   	dec	a
04039E 20 ED       0077*   	jr	nz,udiv1
0403A0 37          0078*   	scf		;flag used for div0 error
0403A1 C5          0079*   	push	bc
0403A2 D1          0080*   	pop		de	;remainder
0403A3 C9          0081*   	ret
0403A4             0082*   
0403A4             0083*   
0403A4             0084*   
0403A4             0085*   ;------------------------------------------------------------------------
0403A4             0086*   ; neg24
0403A4             0087*   ; Returns: HLU = 0-HLU
0403A4             0088*   ; preserves all other registers
0403A4             0089*   ;------------------------------------------------------------------------
0403A4             0090*   neg24:
0403A4 D5          0091*   	push	de
0403A5 EB          0092*   	ex		de,hl
0403A6 21 00 00 00 0093*   	ld		hl,0
0403AA B7          0094*   	or		a
0403AB ED 52       0095*   	sbc		hl,de
0403AD D1          0096*   	pop		de
0403AE C9          0097*   	ret
0403AF             0098*   
0403AF             0099*   ;------------------------------------------------------------------------
0403AF             0100*   ; or_hlu_deu: 24 bit bitwise OR
0403AF             0101*   ; Returns: hlu = hlu OR deu
0403AF             0102*   ; preserves all other registers
0403AF             0103*   ;------------------------------------------------------------------------
0403AF             0104*   or_hlu_deu:
0403AF 22 38 04 04 0105*   	ld	(bitbuf1),hl
0403B3 ED 53 3B 04 0106*   	ld	(bitbuf2),de
       04          
0403B8 D5          0107*   	push	de	;preserve DEU
0403B9 C5          0108*   	push	bc	;preserve BCU
0403BA 06 03       0109*   	ld		b,3
0403BC 21 38 04 04 0110*   	ld	hl,bitbuf1
0403C0 11 38 04 04 0111*   	ld	de,bitbuf1
0403C4             0112*   orloop_24:
0403C4 1A          0113*   	ld	a,(de)
0403C5 B6          0114*   	or	(hl)
0403C6 12          0115*   	ld	(de),a
0403C7 13          0116*   	inc	de
0403C8 23          0117*   	inc	hl
0403C9 10 F9       0118*   	djnz	orloop_24
0403CB 2A 3B 04 04 0119*   	ld	hl,(bitbuf2)
0403CF C1          0120*   	pop		bc	;restore BC
0403D0 D1          0121*   	pop		de	;restore DE
0403D1             0122*   
0403D1             0123*   ;------------------------------------------------------------------------
0403D1             0124*   ; and_hlu_deu: 24 bit bitwise AND
0403D1             0125*   ; Returns: hlu = hlu AND deu
0403D1             0126*   ; preserves all other registers
0403D1             0127*   ;------------------------------------------------------------------------
0403D1             0128*   and_hlu_deu:
0403D1 22 38 04 04 0129*   	ld	(bitbuf1),hl
0403D5 ED 53 3B 04 0130*   	ld	(bitbuf2),de
       04          
0403DA D5          0131*   	push	de	;preserve DEU
0403DB C5          0132*   	push	bc	;preserve BCU
0403DC 06 03       0133*   	ld		b,3
0403DE 21 38 04 04 0134*   	ld	hl,bitbuf1
0403E2 11 38 04 04 0135*   	ld	de,bitbuf1
0403E6             0136*   andloop_24:
0403E6 1A          0137*   	ld	a,(de)
0403E7 A6          0138*   	and	(hl)
0403E8 12          0139*   	ld	(de),a
0403E9 13          0140*   	inc	de
0403EA 23          0141*   	inc	hl
0403EB 10 F9       0142*   	djnz	andloop_24
0403ED 2A 3B 04 04 0143*   	ld	hl,(bitbuf2)
0403F1 C1          0144*   	pop		bc	;restore BC
0403F2 D1          0145*   	pop		de	;restore DE
0403F3             0146*   
0403F3             0147*   ;------------------------------------------------------------------------
0403F3             0148*   ; xor_hlu_deu: 24 bit bitwise XOR
0403F3             0149*   ; Returns: hlu = hlu XOR deu
0403F3             0150*   ; preserves all other registers
0403F3             0151*   ;------------------------------------------------------------------------
0403F3             0152*   xor_hlu_deu:
0403F3 22 38 04 04 0153*   	ld	(bitbuf1),hl
0403F7 ED 53 3B 04 0154*   	ld	(bitbuf2),de
       04          
0403FC D5          0155*   	push	de	;preserve DEU
0403FD C5          0156*   	push	bc	;preserve BCU
0403FE 06 03       0157*   	ld		b,3
040400 21 38 04 04 0158*   	ld	hl,bitbuf1
040404 11 38 04 04 0159*   	ld	de,bitbuf1
040408             0160*   xorloop_24:
040408 1A          0161*   	ld	a,(de)
040409 AE          0162*   	xor	(hl)
04040A 12          0163*   	ld	(de),a
04040B 13          0164*   	inc	de
04040C 23          0165*   	inc	hl
04040D 10 F9       0166*   	djnz	xorloop_24
04040F 2A 3B 04 04 0167*   	ld	hl,(bitbuf2)
040413 C1          0168*   	pop		bc	;restore BC
040414 D1          0169*   	pop		de	;restore DE
040415             0170*   
040415             0171*   ;------------------------------------------------------------------------
040415             0172*   ; shl_hlu: 24 bit shift left hlu by a positions
040415             0173*   ; Returns: hlu = hlu << a
040415             0174*   ;		   a = 0
040415             0175*   ; NOTE: only considers a up to 16 bits.
040415             0176*   ; preserves all other registers
040415             0177*   ; modified by Brandon R. Gates to use a instead of de
040415             0178*   ;------------------------------------------------------------------------
040415             0179*   shl_hlu:
040415 B7          0180*   	or a
040416 C8          0181*   	ret		z		;we're done
040417 29          0182*   	add		hl,hl	;shift HLU left
040418 3D          0183*   	dec a
040419 18 FA       0184*   	jr		shl_hlu
04041B             0185*   
04041B             0186*   ;------------------------------------------------------------------------
04041B             0187*   ; shr_hlu: 24 bit shift right hlu by a positions
04041B             0188*   ; Returns: hlu = hlu >> a
04041B             0189*   ;		   a = 0
04041B             0190*   ; NOTE: only considers a up to 16 bits.
04041B             0191*   ; preserves all other registers
04041B             0192*   ; modified by Brandon R. Gates to use a instead of de
04041B             0193*   ;------------------------------------------------------------------------
04041B             0194*   shr_hlu:
04041B 22 38 04 04 0195*   	ld		(bitbuf1),hl
04041F 21 3A 04 04 0196*   	ld		hl,bitbuf1+2
040423             0197*   @shr_loop:
040423 B7          0198*   	or a
040424 28 0D       0199*   	jr		z,@shr_done		;we're done
040426             0200*   ;carry is clear from or instruction
040426 CB 1E       0201*   	rr		(hl)
040428 2B          0202*   	dec		hl
040429 CB 1E       0203*   	rr		(hl)
04042B 2B          0204*   	dec		hl
04042C CB 1E       0205*   	rr		(hl)
04042E 23          0206*   	inc		hl
04042F 23          0207*   	inc		hl
040430 3D          0208*   	dec a
040431 18 F0       0209*   	jr		@shr_loop
040433             0210*   @shr_done:
040433 2A 38 04 04 0211*   	ld		hl,(bitbuf1)	;collect result
040437 C9          0212*   	ret
040438             0213*   
040438             0214*   ;------------------------------------------------------------------------
040438             0215*   ; Scratch area for calculations
040438             0216*   ;------------------------------------------------------------------------
040438 00 00 00    0217*   bitbuf1:	dw24	0	;bit manipulation buffer 1
04043B 00 00 00    0218*   bitbuf2:	dw24	0	;bit manipulation buffer 2
04043E             0219*   
04043E             0220*   ; -----------------------------------------------------------------------
04043E             0221*   ; Functions added by Brandon R. Gates
04043E             0222*   ; -----------------------------------------------------------------------
04043E             0223*   
04043E             0224*   ;------------------------------------------------------------------------
04043E             0225*   ; shr_hlu_div: Quick division by powers of two based on log2 of A
04043E             0226*   ;              Determines the LSB of A and shifts HLU accordingly.
04043E             0227*   ;              HLU = HLU >> LSB(A)
04043E             0228*   ; Returns: HLU = HLU >> LSB(A)
04043E             0229*   ; Destroys: af
04043E             0230*   ;------------------------------------------------------------------------
04043E             0231*   shr_hlu_log2a:
04043E B7          0232*   	or a    ; check for zero
04043F C8          0233*   	ret z   ; nothing to shift so we're done
040440 C5          0234*   	push 	bc ; preserve
040441 06 00       0235*   	ld		b,0 ; clear b
040443             0236*   @find_bit:
040443 0F          0237*   	rrca ; bit 0 to carry
040444 DA 4D 04 04 0238*   	jp c,@found_bit
040448 04          0239*   	inc b ; next bit
040449 C3 43 04 04 0240*   	jp @find_bit
04044D             0241*   @found_bit:
04044D 78          0242*   	ld a,b
04044E CD 1B 04 04 0243*   	call shr_hlu
040452 C1          0244*   	pop 	bc ; restore
040453 C9          0245*   	ret
040454             0246*   ; end shr_hlu_log2a
040454             0247*   
040454             0248*   ;------------------------------------------------------------------------
040454             0249*   ; shl_hlu_log2a: Quick multiplication by powers of two based on log2 of A
040454             0250*   ;                Determines the LSB of A and shifts HLU accordingly.
040454             0251*   ;                HLU = HLU << LSB(A)
040454             0252*   ; Returns: HLU = HLU << LSB(A)
040454             0253*   ; Destroys: af
040454             0254*   ;------------------------------------------------------------------------
040454             0255*   shl_hlu_log2a:
040454 B7          0256*   	or a    ; check for zero
040455 C8          0257*   	ret z   ; nothing to shift so we're done
040456 C5          0258*   	push 	bc ; preserve
040457 06 00       0259*   	ld		b,0 ; clear b
040459             0260*   @find_bit:
040459 0F          0261*   	rrca ; bit 0 to carry
04045A DA 63 04 04 0262*   	jp c,@found_bit
04045E 04          0263*   	inc b ; next bit
04045F C3 59 04 04 0264*   	jp @find_bit
040463             0265*   @found_bit:
040463 78          0266*   	ld a,b
040464 CD 15 04 04 0267*   	call shl_hlu
040468 C1          0268*   	pop 	bc ; restore
040469 C9          0269*   	ret
04046A             0270*   ; end shl_hlu_log2a
04046A             0034        include "maths.inc"
04046A             0001*   ;------------------------------------------------------------------------
04046A             0002*   ; Scratch area for calculations
04046A             0003*   ;------------------------------------------------------------------------
04046A 00 00 00    0004*   scratch1: dw24 0 ;bit manipulation buffer 1
04046D 00 00 00    0005*   scratch2: dw24 0 ;bit manipulation buffer 2
040470             0006*   
040470             0007*   ; absolute value of hlu
040470             0008*   ; returns: abs(hlu), flags set according to the incoming sign of hlu:
040470             0009*   ;         s1,z0,pv0,n1,c0 if hlu was negative
040470             0010*   ;         s0,z1,pv0,n1,c0 if hlu was zero
040470             0011*   ;         s0,z0,pv0,n1,c0 if hlu was positive
040470             0012*   ; destroys: a
040470             0013*   hlu_abs:
040470 19          0014*       add hl,de
040471 B7          0015*       or a
040472 ED 52       0016*       sbc hl,de
040474 FA 79 04 04 0017*       jp m,@is_neg
040478 C9          0018*       ret ; hlu is positive or zero so we're done
040479             0019*   @is_neg:
040479 F5          0020*       push af ; otherwise, save current flags for return
04047A CD 80 04 04 0021*       call neg_hlu ; negate hlu
04047E F1          0022*       pop af ; get back flags
04047F C9          0023*       ret
040480             0024*   
040480             0025*   ; flip the sign of hlu
040480             0026*   ; inputs: hlu
040480             0027*   ; returns: 0-hlu, flags set appropriately for the result:
040480             0028*   ;         s1,z0,pv0,n1,c1 if result is negative
040480             0029*   ;         s0,z1,pv0,n1,c0 if result is zero
040480             0030*   ;         s0,z0,pv0,n1,c1 if result is positive
040480             0031*   ; destroys a
040480             0032*   neg_hlu:
040480 D5          0033*       push de ; save de
040481 EB          0034*       ex de,hl ; put hl into de
040482 21 00 00 00 0035*       ld hl,0 ; clear hl
040486 AF          0036*       xor a ; clear carry
040487 ED 52       0037*       sbc hl,de ; 0-hlu = -hlu
040489 D1          0038*       pop de ; get de back
04048A C9          0039*       ret ; easy peasy
04048B             0040*   
04048B             0041*   ;------------------------------------------------------------------------
04048B             0042*   ; divide hlu by 2, inspired by above
04048B             0043*   ;------------------------------------------------------------------------
04048B             0044*   hlu_div2:
04048B 22 6A 04 04 0045*       ld (scratch1),hl
04048F 21 6C 04 04 0046*       ld hl,scratch1+2
040493 CB 1E       0047*       rr (hl)
040495 2B          0048*       dec hl
040496 CB 1E       0049*       rr (hl)
040498 2B          0050*       dec hl
040499 CB 1E       0051*       rr (hl)
04049B 23          0052*       inc hl
04049C 23          0053*       inc hl
04049D 2A 6A 04 04 0054*       ld hl,(scratch1)
0404A1 C9          0055*       ret
0404A2             0056*   
0404A2             0057*   ; this is my little hack to divide by 16
0404A2             0058*   hlu_div16:
0404A2 AF          0059*       xor a
0404A3 29          0060*       add hl,hl
0404A4 17          0061*       rla
0404A5 29          0062*       add hl,hl
0404A6 17          0063*       rla
0404A7 29          0064*       add hl,hl
0404A8 17          0065*       rla
0404A9 29          0066*       add hl,hl
0404AA 17          0067*       rla
0404AB 22 B8 04 04 0068*       ld (@scratch),hl
0404AF 32 BB 04 04 0069*       ld (@scratch+3),a
0404B3 2A B9 04 04 0070*       ld hl,(@scratch+1)
0404B7 C9          0071*       ret
0404B8             0072*   @scratch: ds 4
0404BC             0073*   
0404BC             0074*   ; hlu signed division by 256
0404BC             0075*   ; returns: hlu / 256
0404BC             0076*   ; destroys: af
0404BC             0077*   hlu_sdiv256:
       FF FF FF FF 
0404BC AF          0078*       xor a ; assume hl is positive
0404BD 22 D3 04 04 0079*       ld (@buffer),hl
0404C1             0080*       SIGN_HLU
                       M1 Args: none
0404C1 19          0001*M1     add hl,de ; 1 cycle
0404C2 B7          0002*M1     or a ; clear flags ; 1 cycle
0404C3 ED 52       0003*M1     sbc hl,de ; 2 cycles
0404C5             0004*M1     ; 4 cycles total
0404C5 F2 CA 04 04 0081*       jp p,@hl_pos
0404C9 3D          0082*       dec a
0404CA             0083*   @hl_pos:
0404CA 32 D6 04 04 0084*       ld (@buffer+3),a
0404CE 2A D4 04 04 0085*       ld hl,(@buffer+1)
0404D2 C9          0086*       ret
0404D3             0087*   @buffer: ds 4
0404D7             0088*   
0404D7             0089*   ; hlu 1 byte right shift, unsigned
0404D7             0090*   ; returns: hlu / 256, fractional portion in a
0404D7             0091*   ; destroys: af
0404D7             0092*   hlu_udiv256:
       FF FF FF FF 
0404D7 AF          0093*       xor a
0404D8 32 E9 04 04 0094*       ld (@buffer+3),a
0404DC 7D          0095*       ld a,l ; save the fractional portion
0404DD 22 E6 04 04 0096*       ld (@buffer),hl
0404E1 2A E7 04 04 0097*       ld hl,(@buffer+1)
0404E5 C9          0098*       ret
0404E6             0099*   @buffer: ds 4
0404EA             0100*   
0404EA             0101*   ; floor(value,n)
0404EA             0102*   ; inputs: hl = value to floor, de = n
0404EA             0103*   ; outputs: hl = value floored to n
0404EA             0104*   ; destroys: af, hl, bc, de
0404EA             0105*   hlu_floor:
       FF FF FF FF 
0404EA D5          0106*       push de ; save n
0404EB CD 80 03 04 0107*       call udiv24 ; de = quotient, hl = remainder
0404EF E1          0108*       pop hl ; get n back (was de)
0404F0 CD 67 03 04 0109*       call umul24 ; hl = n * quotient
0404F4 C9          0110*       ret
0404F5             0111*   ; end hlu_floor
0404F5             0112*   
0404F5             0113*   ; ceil(value,n)
0404F5             0114*   ; inputs: hl = value to ceil, de = n
0404F5             0115*   ; outputs: hl = value ceiled to n
0404F5             0116*   ; destroys: af, hl, bc, de
0404F5             0117*   hlu_ceiling:
0404F5 D5          0118*       push de ; save n
0404F6 CD 80 03 04 0119*       call udiv24 ; de = quotient, hl = remainder
0404FA             0120*       SIGN_HLU ; test remaider for zero
                       M1 Args: none
0404FA 19          0001*M1     add hl,de ; 1 cycle
0404FB B7          0002*M1     or a ; clear flags ; 1 cycle
0404FC ED 52       0003*M1     sbc hl,de ; 2 cycles
0404FE             0004*M1     ; 4 cycles total
0404FE CA 03 05 04 0121*       jp z,@F ; if zero, nothing to add
040502 13          0122*       inc de ; add 1 to quotient for the ceiling
040503             0123*   @@:
040503 E1          0124*       pop hl ; get n back (was de)
040504 CD 67 03 04 0125*       call umul24 ; hl = n * quotient
040508 C9          0126*       ret
040509             0127*   ; end hlu_ceiling
040509             0128*   
040509 C9          0129*       ret
04050A             0130*   
04050A 00 00 00 00 0131*   add_bcd_arg1: db #00,#00,#00,#00
04050E 00 00 00 00 0132*   add_bcd_arg2: db #00,#00,#00,#00
040512             0133*   
040512             0134*   ; set bcd values in a scratch memory address from registers bcde
040512             0135*   ; input: hl; scratch address,bcde; 8-place bcd number
040512             0136*   ; destroys ; hl
040512             0137*   set_bcd:
040512 73          0138*       ld (hl),e
040513 23          0139*       inc hl
040514 72          0140*       ld (hl),d
040515 23          0141*       inc hl
040516 71          0142*       ld (hl),c
040517 23          0143*       inc hl
040518 70          0144*       ld (hl),b
040519 C9          0145*       ret
04051A             0146*   
04051A             0147*   ; load bcd values from a scratch memory address to bcde
04051A             0148*   ; input: hl; scratch address
04051A             0149*   ; output: bcde; 8-place bcd number
04051A             0150*   ; destroys: hl
04051A             0151*   get_bcd:
04051A 5E          0152*       ld e,(hl)
04051B 23          0153*       inc hl
04051C 56          0154*       ld d,(hl)
04051D 23          0155*       inc hl
04051E 4E          0156*       ld c,(hl)
04051F 23          0157*       inc hl
040520 46          0158*       ld b,(hl)
040521 C9          0159*       ret
040522             0160*   
040522             0161*   ; BCD addition
040522             0162*   ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
040522             0163*   ;       a is the number of bytes holding each number (number of places/2)
040522             0164*   ; outputs: (hl) + (de) --> (hl)
040522             0165*   ; destroys: a,b,de,hl
040522             0166*   add_bcd:
040522 47          0167*       ld b,a ; loop counter
040523 AF          0168*       xor a ; reset a, clear carry flag
040524             0169*   adcec:
040524 1A          0170*       ld a,(de) ; addend to acc
040525 8E          0171*       adc a,(hl) ; add (hl) to acc
040526 27          0172*       daa ; adjust result to bcd
040527 77          0173*       ld (hl),a ; store result
040528 23          0174*       inc hl ; advance memory pointers
040529 13          0175*       inc de
04052A 10 F8       0176*       djnz adcec ; loop until b == 0
04052C C9          0177*       ret
04052D             0178*   
04052D             0179*   ; BCD subtraction
04052D             0180*   ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
04052D             0181*   ;       a is the number of bytes holding each number (number of places/2)
04052D             0182*   ; outputs: (hl) - (de) --> (hl)
04052D             0183*   ; destroys: a,b,de,hl
04052D             0184*   sub_bcd:
04052D 47          0185*       ld b,a ; loop counter
04052E AF          0186*       xor a ; reset a,clear carry flag
04052F             0187*   subdec:
04052F 1A          0188*       ld a,(de) ; subtrahend to acc
040530 9E          0189*       sbc a,(hl) ; subtract (hl) from acc
040531 27          0190*       daa ; adjust result to bcd
040532 77          0191*       ld (hl),a ; store result
040533 23          0192*       inc hl ; advance memory pointers
040534 13          0193*       inc de
040535 10 F8       0194*       djnz subdec ; loop until b == 0
040537 C9          0195*       ret
040538             0196*   
040538             0197*   ; http://www.z80.info/pseudo-random.txt
040538             0198*   rand_8:
040538 C5          0199*       push bc
040539 3A 4C 05 04 0200*       ld a,(r_seed)
04053D 4F          0201*       ld c,a
04053E             0202*   
04053E 0F          0203*       rrca ; multiply by 32
04053F 0F          0204*       rrca
040540 0F          0205*       rrca
040541 EE 1F       0206*       xor 0x1f
040543             0207*   
040543 81          0208*       add a,c
040544 DE FF       0209*       sbc a,255 ; carry
040546             0210*   
040546 32 4C 05 04 0211*       ld (r_seed),a
04054A C1          0212*       pop bc
04054B C9          0213*       ret
04054C 50          0214*   r_seed: defb $50
04054D             0215*   
04054D             0216*   ; https://www.omnimaga.org/asm-language/ez80-optimized-routines/msg399325/#msg399325
04054D             0217*   prng24:
04054D             0218*   ;;Expects ADL mode.
04054D             0219*   ;;Output: HL
04054D             0220*   ;;50cc
04054D             0221*   ;;33 bytes
04054D             0222*   ;;cycle length: 281,474,959,933,440 (about 2.8 trillion)
04054D ED 5B 6E 05 0223*       ld de,(seed1)
       04          
040552 B7          0224*       or a
040553 ED 62       0225*       sbc hl,hl
040555 19          0226*       add hl,de
040556 29          0227*       add hl,hl
040557 29          0228*       add hl,hl
040558 2C          0229*       inc l
040559 19          0230*       add hl,de
04055A 22 6E 05 04 0231*       ld (seed1),hl
04055E 2A 71 05 04 0232*       ld hl,(seed2)
040562 29          0233*       add hl,hl
040563 9F          0234*       sbc a,a
040564 E6 1B       0235*       and %00011011
040566 AD          0236*       xor l
040567 6F          0237*       ld l,a
040568 22 71 05 04 0238*       ld (seed2),hl
04056C 19          0239*       add hl,de
04056D C9          0240*       ret
04056E 00 00 00    0241*   seed1: dl 0
040571 00 00 00    0242*   seed2: dl 0
040574             0243*   
040574             0244*   
040574             0245*   ; https://map.grauw.nl/sources/external/z80bits.html#2.1
040574             0246*   ; 2.1 Restoring 8-bit / 8-bit Unsigned
040574             0247*   ; Input: H = Dividend, L = Divisor, A = 0
040574             0248*   ; Output: H = Quotient, A = Remainder, L = Divisor (unchanged)
040574             0249*   udiv8:
040574 AF          0250*       xor a
040575 06 08       0251*       ld b,8
040577             0252*   @loop:
040577 CB 24       0253*       sla h
040579 17          0254*       rla
04057A BD          0255*       cp l
04057B 38 02       0256*       jr c,$+4
04057D 95          0257*       sub l
04057E 24          0258*       inc h
04057F 10 F6       0259*       djnz @loop
040581 C9          0260*       ret
040582             0261*   
040582             0262*   ; https://www.omnimaga.org/asm-language/(z80)-32-bit-by-16-bits-division-and-32-bit-square-root/msg406903/#msg406903
040582             0263*   ; This divides HLIX by BC
040582             0264*   ; The result is stored in HLIX, the remainder in DE
040582             0265*   ; BC is unmodified
040582             0266*   ; A is 0
040582             0267*   udiv3216:
040582 11 00 00 00 0268*       ld de,0		; 10
040586 3E 20       0269*       ld a,32		; 7
040588             0270*   @loop:
040588 52 DD 29    0271*       add.s ix,ix		; 15
04058B 52 ED 6A    0272*       adc.s hl,hl		; 15
04058E EB          0273*       ex de,hl		; 4
04058F 52 ED 6A    0274*       adc.s hl,hl		; 15
040592 B7          0275*       or a			; 4
040593 52 ED 42    0276*       sbc.s hl,bc		; 15
040596 52 DD 23    0277*       inc.s ix		; 10
040599 30 05       0278*       jr nc,@cansub		; 12/7
04059B 52 09       0279*       add.s hl,bc		; 11
04059D 52 DD 2B    0280*       dec.s ix		; 10
0405A0             0281*   @cansub:
0405A0 EB          0282*       ex de,hl		; 4
0405A1 3D          0283*       dec a		; 4
0405A2 20 E4       0284*       jr nz,@loop	; 12/7
0405A4 C9          0285*       ret			; 10
0405A5             0286*   ; end udiv3216
0405A5             0287*   
0405A5             0288*   ; https://discord.com/channels/1158535358624039014/1282290921815408681/1329274504022720512
0405A5             0289*   ; calc84maniac's 32-bit by 23-bit division routine
0405A5             0290*   ; This divides AUIX by UDE (maximum 23 bits)
0405A5             0291*   ; The result is stored in AUIX, the remainder in UHL
0405A5             0292*   ; UDE, C are unmodified
0405A5             0293*   ; B is 0
0405A5             0294*   udiv3223:
0405A5 B7          0295*       or a,a         ; 1
0405A6 ED 62       0296*       sbc hl,hl      ; 2
0405A8 06 20       0297*       ld b,32        ; 2
0405AA             0298*   @loop:
0405AA DD 29       0299*       add ix,ix      ; 2
0405AC 8F          0300*       adc a,a        ; 1
0405AD ED 6A       0301*       adc hl,hl      ; 2
0405AF ED 52       0302*       sbc hl,de      ; 2
0405B1 DD 23       0303*       inc ix         ; 2
0405B3 30 03       0304*       jr nc,@cansub  ; 2/4
0405B5 19          0305*       add hl,de      ; 1
0405B6 DD 2B       0306*       dec ix         ; 2
0405B8             0307*   @cansub:
0405B8 10 F0       0308*       djnz @loop     ; 2/4
0405BA C9          0309*       ret            ; 10
0405BB             0310*   ; end udiv3223
0405BB             0035        include "font.inc"
0405BB             0001*   Lat2_VGA8_8x8: equ 64016
0405BB             0002*   font_data:
0405BB 00 00 78 0C 0003*       incbin "Lat2-VGA8_8x8.font"
       7C CC 76 0F 
       3C 42 B9 A5 
       B9 A5 42 3C 
       00 00 18 3C 
       66 FF 00 00 
       7E 81 A5 81 
       BD 99 81 7E 
       10 38 7C FE 
       7C 38 10 00 
       3C 7E DB FF 
       C3 7E 3C 00 
       10 38 7C FE 
       FE 10 38 00 
       00 00 18 3C 
       18 00 00 00 
       00 3C 18 FF 
       FF 08 18 00 
       00 EE FE FE 
       7C 38 10 00 
       00 3C 42 81 
       81 42 3C 00 
       1F 07 0D 7C 
       C6 C6 7C 00 
       00 7E C3 C3 
       7E 18 7E 18 
       04 06 07 04 
       04 FC F8 00 
       0C 0A 0D 0B 
       F9 F9 1F 1F 
       00 92 7C 44 
       C6 7C 92 00 
       FF FF E7 C3 
       E7 FF FF FF 
       FF C3 BD 7E 
       7E BD C3 FF 
       18 3C 7E 18 
       18 7E 3C 18 
       66 66 66 66 
       66 00 66 00 
       7F DB 7B 3B 
       1B 1B 1B 00 
       3E 61 3C 66 
       66 3C 86 7C 
       38 64 F0 60 
       F0 64 38 00 
       18 7E 18 18 
       7E 18 00 FF 
       18 3C 7E 18 
       18 18 18 00 
       18 18 18 18 
       7E 3C 18 00 
       00 18 0C FE 
       0C 18 00 00 
       00 30 60 FE 
       60 30 00 00 
       00 00 00 C0 
       C0 C0 FF 00 
       00 24 66 FF 
       66 24 00 00 
       48 78 84 60 
       18 84 78 00 
       78 00 7C C0 
       78 0C F8 00 
       00 00 00 00 
       00 00 00 00 
       30 78 78 30 
       30 00 30 00 
       6C 6C 00 00 
       00 00 00 00 
       6C 6C FE 6C 
       FE 6C 6C 00 
       10 7E 90 7C 
       12 FC 10 00 
       00 C6 CC 18 
       30 66 C6 00 
       38 6C 38 76 
       DC CC 76 00 
       30 30 60 00 
       00 00 00 00 
       18 30 60 60 
       60 30 18 00 
       60 30 18 18 
       18 30 60 00 
       00 66 3C FF 
       3C 66 00 00 
       00 30 30 FC 
       30 30 00 00 
       00 00 00 00 
       00 30 30 60 
       00 00 00 FC 
       00 00 00 00 
       00 00 00 00 
       00 30 30 00 
       00 06 0C 18 
       30 60 C0 00 
       7C C6 C6 D6 
       C6 C6 7C 00 
       30 70 30 30 
       30 30 FC 00 
       78 CC 0C 38 
       60 CC FC 00 
       78 CC 0C 38 
       0C CC 78 00 
       1C 3C 6C CC 
       FE 0C 1E 00 
       FC C0 F8 0C 
       0C CC 78 00 
       38 60 C0 F8 
       CC CC 78 00 
       FC CC 0C 18 
       30 30 30 00 
       78 CC CC 78 
       CC CC 78 00 
       78 CC CC 7C 
       0C 18 70 00 
       00 30 30 00 
       00 30 30 00 
       00 30 30 00 
       00 30 30 60 
       18 30 60 C0 
       60 30 18 00 
       00 00 FC 00 
       00 FC 00 00 
       60 30 18 0C 
       18 30 60 00 
       78 CC 0C 18 
       30 00 30 00 
       7C C6 DE DE 
       DE C0 78 00 
       30 78 CC CC 
       FC CC CC 00 
       FC 66 66 7C 
       66 66 FC 00 
       3C 66 C0 C0 
       C0 66 3C 00 
       F8 6C 66 66 
       66 6C F8 00 
       FE 62 68 78 
       68 62 FE 00 
       FE 62 68 78 
       68 60 F0 00 
       3C 66 C0 C0 
       CE 66 3E 00 
       CC CC CC FC 
       CC CC CC 00 
       78 30 30 30 
       30 30 78 00 
       1E 0C 0C 0C 
       CC CC 78 00 
       E6 66 6C 78 
       6C 66 E6 00 
       F0 60 60 60 
       62 66 FE 00 
       C6 EE FE FE 
       D6 C6 C6 00 
       C6 E6 F6 DE 
       CE C6 C6 00 
       38 6C C6 C6 
       C6 6C 38 00 
       FC 66 66 7C 
       60 60 F0 00 
       78 CC CC CC 
       DC 78 1C 00 
       FC 66 66 7C 
       6C 66 E6 00 
       78 CC E0 70 
       1C CC 78 00 
       FC B4 30 30 
       30 30 78 00 
       CC CC CC CC 
       CC CC 78 00 
       CC CC CC CC 
       CC 78 30 00 
       C6 C6 C6 D6 
       FE EE C6 00 
       C6 C6 6C 38 
       6C C6 C6 00 
       CC CC CC 78 
       30 30 78 00 
       FE C6 0C 18 
       30 66 FE 00 
       78 60 60 60 
       60 60 78 00 
       00 C0 60 30 
       18 0C 06 00 
       78 18 18 18 
       18 18 78 00 
       18 3C 66 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 FF 
       30 30 18 00 
       00 00 00 00 
       00 00 78 0C 
       7C CC 76 00 
       E0 60 60 7C 
       66 66 DC 00 
       00 00 78 CC 
       C0 CC 78 00 
       1C 0C 0C 7C 
       CC CC 76 00 
       00 00 78 CC 
       FC C0 78 00 
       38 6C 60 F0 
       60 60 F0 00 
       00 00 76 CC 
       CC 7C 0C F8 
       E0 60 6C 76 
       66 66 E6 00 
       30 00 70 30 
       30 30 78 00 
       0C 00 0C 0C 
       0C CC CC 78 
       E0 60 66 6C 
       78 6C E6 00 
       E0 60 60 60 
       60 68 30 00 
       00 00 CC FE 
       FE D6 C6 00 
       00 00 F8 CC 
       CC CC CC 00 
       00 00 78 CC 
       CC CC 78 00 
       00 00 DC 66 
       66 7C 60 F0 
       00 00 76 CC 
       CC 7C 0C 1E 
       00 00 DC 76 
       66 60 F0 00 
       00 00 7C C0 
       78 0C F8 00 
       10 30 7C 30 
       30 34 18 00 
       00 00 CC CC 
       CC CC 76 00 
       00 00 CC CC 
       CC 78 30 00 
       00 00 C6 D6 
       FE FE 6C 00 
       00 00 C6 6C 
       38 6C C6 00 
       00 00 CC CC 
       CC 7C 0C F8 
       00 00 FC 98 
       30 64 FC 00 
       1C 30 30 E0 
       30 30 1C 00 
       30 30 30 30 
       30 30 30 00 
       E0 30 30 1C 
       30 30 E0 00 
       76 DC 00 00 
       00 00 00 00 
       7C 82 9A A2 
       A2 9A 82 7C 
       3C 66 C0 C0 
       66 3C 0C 78 
       CC 00 CC CC 
       CC CC 76 00 
       0C 18 78 CC 
       FC C0 78 00 
       78 84 78 0C 
       7C CC 76 00 
       6C 00 78 0C 
       7C CC 76 00 
       60 30 78 0C 
       7C CC 76 00 
       7C 82 B2 AA 
       B2 AA 82 7C 
       00 78 CC C0 
       CC 78 18 70 
       78 84 78 CC 
       FC C0 78 00 
       CC 00 78 CC 
       FC C0 78 00 
       60 30 78 CC 
       FC C0 78 00 
       00 D8 00 70 
       30 30 78 00 
       70 D8 00 70 
       30 30 78 00 
       6C FE CC 18 
       30 66 FE 00 
       CC 00 78 CC 
       FC CC CC 00 
       78 00 FC 98 
       30 64 FC 00 
       0C 18 FE 62 
       78 62 FE 00 
       00 00 7E 1B 
       7E D8 7E 00 
       3E 78 D8 FC 
       D8 D8 DE 00 
       78 CC 00 78 
       CC CC 78 00 
       00 CC 00 78 
       CC CC 78 00 
       18 30 78 CC 
       FC CC CC 00 
       78 CC 00 CC 
       CC CC 76 00 
       60 30 CC CC 
       CC CC 76 00 
       CC 00 CC CC 
       CC 7C 0C F8 
       CC 00 78 CC 
       CC CC 78 00 
       CC 00 CC CC 
       CC CC 78 00 
       30 78 CC C0 
       CC 78 30 00 
       38 6C 64 F0 
       60 E6 FC 00 
       CC CC 78 FC 
       30 FC 30 30 
       78 84 78 CC 
       FC CC CC 00 
       6C 00 FE 62 
       78 62 FE 00 
       18 30 78 0C 
       7C CC 76 00 
       18 30 00 70 
       30 30 78 00 
       18 30 00 78 
       CC CC 78 00 
       18 30 CC CC 
       CC CC 76 00 
       76 DC F8 CC 
       CC CC CC 00 
       76 DC E6 F6 
       DE CE C6 00 
       3C 6C 3E 00 
       7E 00 00 00 
       38 6C 38 00 
       7C 00 00 00 
       00 18 00 18 
       30 60 66 3C 
       18 30 78 30 
       30 30 78 00 
       00 00 00 FC 
       0C 0C 00 00 
       00 00 7E DB 
       DE D8 7E 00 
       7E D8 D8 DC 
       D8 D8 7E 00 
       00 30 00 30 
       30 78 78 30 
       00 33 66 CC 
       66 33 00 00 
       00 CC 66 33 
       66 CC 00 00 
       22 88 22 88 
       22 88 22 88 
       55 AA 55 AA 
       55 AA 55 AA 
       78 CC 78 30 
       30 30 78 00 
       18 18 18 18 
       18 18 18 18 
       18 18 18 F8 
       18 18 18 18 
       18 30 78 CC 
       CC CC 78 00 
       78 CC 78 CC 
       CC CC 78 00 
       00 6C 38 38 
       6C 00 00 00 
       18 30 CC CC 
       CC CC 78 00 
       18 30 CC CC 
       78 30 78 00 
       18 30 CC CC 
       CC 7C 0C F8 
       38 6C C6 FE 
       C6 CE 18 0E 
       6C 38 7C C6 
       C0 C0 C6 7C 
       00 CC 78 78 
       CC C0 CC 78 
       F8 6C 66 F6 
       66 6C F8 00 
       00 00 00 F8 
       18 18 18 18 
       18 18 18 1F 
       00 00 00 00 
       18 18 18 FF 
       00 00 00 00 
       00 00 00 FF 
       18 18 18 18 
       18 18 18 1F 
       18 18 18 18 
       00 00 00 FF 
       00 00 00 00 
       18 18 18 FF 
       18 18 18 18 
       00 0C 3E 0C 
       7C CC CC 76 
       FE 66 60 78 
       60 66 FE 1C 
       00 00 7C C6 
       FE C0 7A 1E 
       48 78 84 60 
       18 84 78 00 
       78 00 7C C0 
       78 0C F8 00 
       6C FE CC 18 
       30 66 FE 00 
       78 00 FC 98 
       30 64 FC 00 
       6C 38 00 00 
       00 00 00 00 
       18 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 10 1C 
       00 00 00 00 
       FE 00 00 00 
       00 38 30 18 
       00 00 00 00 
       00 38 18 70 
       00 00 00 00 
       00 00 00 00 
       00 38 18 70 
       66 CC EE 00 
       00 00 00 00 
       00 EE 66 CC 
       00 00 00 00 
       00 00 00 00 
       00 EE 66 CC 
       00 00 18 30 
       60 30 18 00 
       00 00 30 18 
       0C 18 30 00 
       18 18 18 F8 
       00 00 00 00 
       00 00 00 1F 
       18 18 18 18 
       FF FF FF FF 
       FF FF FF FF 
       38 64 F0 60 
       F0 64 38 00 
       00 0C FE 18 
       30 FE 60 00 
       60 30 78 CC 
       FC CC CC 00 
       60 30 FE 62 
       78 62 FE 00 
       38 6C FE 62 
       78 62 FE 00 
       7C C6 C6 CC 
       C6 D6 DC 80 
       CC 00 78 30 
       30 30 78 00 
       00 C0 7C 6E 
       6C 6C 6C 00 
       76 D8 D8 DC 
       D8 D8 76 00 
       00 00 6E D8 
       DE D8 6E 00 
       00 00 CC CC 
       CC CC F6 C0 
       60 30 CC CC 
       CC CC 78 00 
       78 CC 00 CC 
       CC CC 78 00 
       CC 00 CC CC 
       78 30 78 00 
       60 E0 60 60 
       F0 00 00 00 
       70 D8 30 D8 
       70 00 00 00 
       CC 00 CC 78 
       30 30 78 00 
       06 06 36 66 
       FE 60 30 00 
       10 38 7C FE 
       7C 38 10 00 
       A0 A0 E0 AE 
       A4 04 04 04 
       80 80 80 8E 
       E8 0C 08 08 
       30 30 FC 30 
       30 00 FC 00 
       60 30 18 30 
       60 00 FC 00 
       18 30 60 30 
       18 00 FC 00 
       08 14 10 10 
       10 10 10 10 
       10 10 10 10 
       10 50 20 00 
       00 30 00 FC 
       00 30 00 00 
       00 76 DC 00 
       76 DC 00 00 
       70 D8 70 00 
       00 00 00 00 
       00 00 00 30 
       30 00 00 00 
       00 00 00 18 
       18 00 00 00 
       1F 10 10 90 
       50 30 10 00 
       A0 D0 90 90 
       90 00 00 00 
       70 D8 30 60 
       F8 00 00 00 
       00 00 3C 3C 
       3C 3C 00 00 
       A0 A0 A0 AE 
       44 04 04 04 
040DBB             0004*   font_data_end:
040DBB             0005*   font_load:
040DBB             0006*   ; load font into a buffer
040DBB 21 10 FA 00 0007*       ld hl,Lat2_VGA8_8x8
040DBF 11 BB 05 04 0008*       ld de,font_data
040DC3 01 00 08 00 0009*       ld bc,font_data_end-font_data
040DC7 CD E4 1C 04 0010*       call vdu_load_buffer
040DCB             0011*   ; create font from buffer
040DCB 21 10 FA 00 0012*       ld hl,Lat2_VGA8_8x8
040DCF 1E 08       0013*       ld e,8
040DD1 16 08       0014*       ld d,8
040DD3 3E 00       0015*       ld a,0 ; flags
040DD5 CD A0 1F 04 0016*       call vdu_font_create
040DD9             0017*   ; all done
040DD9 C9          0018*       ret
040DDA             0036        include "fixed168.inc"
040DDA             0001*   ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
040DDA             0002*   ; uses EZ80 MLT instruction for speed
040DDA             0003*   ; operation: UHL * A --> UHL
040DDA             0004*   ; destroys: AF, HL
040DDA             0005*   smul24x8:
040DDA             0006*   ; make hl positive and store sign flag
040DDA CD 70 04 04 0007*       call hlu_abs
040DDE F5          0008*       push af
040DDF             0009*   ; do the division
040DDF CD EA 0D 04 0010*       call mul24x8 ; hl = product
040DE3             0011*   ; adjust sign of result
040DE3 F1          0012*       pop af ; sign de
040DE4 F0          0013*       ret p ; hl was positive, nothing to do
040DE5 CD 80 04 04 0014*       call neg_hlu ; result is negative
040DE9 C9          0015*       ret
040DEA             0016*   
040DEA             0017*   ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
040DEA             0018*   ; uses EZ80 MLT instruction for speed
040DEA             0019*   ; operation: UHL * A --> AUHL
040DEA             0020*   ; destroys: AF, HL
040DEA             0021*   mul24x8:
040DEA D5          0022*       push de ; preserve de
040DEB             0023*   ; low byte
040DEB 5D          0024*       ld e,l
040DEC 57          0025*       ld d,a
040DED ED 5C       0026*       mlt de
040DEF 6B          0027*       ld l,e ; product low byte
040DF0 08          0028*       ex af,af' ; save multiplier
040DF1 7A          0029*       ld a,d ; carry
040DF2 08          0030*       ex af,af' ; save carry, restore multiplier
040DF3             0031*   ; high byte
040DF3 5C          0032*       ld e,h
040DF4 57          0033*       ld d,a
040DF5 ED 5C       0034*       mlt de
040DF7 08          0035*       ex af,af' ; save multiplier, restore carry
040DF8 83          0036*       add a,e ; add carry
040DF9 67          0037*       ld h,a ; product middle byte
040DFA 7A          0038*       ld a,d ; carry
040DFB 08          0039*       ex af,af' ; save carry, restore multiplier
040DFC             0040*   ; upper byte
040DFC 22 17 0E 04 0041*       ld (@scratch),hl ; 7 cycles
040E00 5F          0042*       ld e,a
040E01 3A 19 0E 04 0043*       ld a,(@scratch+2)
040E05 57          0044*       ld d,a
040E06 ED 5C       0045*       mlt de
040E08 08          0046*       ex af,af' ; restore carry
040E09 8B          0047*       adc a,e ; add carry
040E0A 32 19 0E 04 0048*       ld (@scratch+2),a ; 5 cycles
040E0E 2A 17 0E 04 0049*       ld hl,(@scratch) ; 7 cycles
040E12             0050*   ; highest byte
040E12 3E 00       0051*       ld a,0 ; preserve carry flag
040E14 8A          0052*       adc a,d ; product highest byte
040E15 D1          0053*       pop de ; restore de
040E16 C9          0054*       ret
040E17             0055*   @scratch: ds 3
040E1A             0056*   
       FF FF FF 
040E1A 00 00 00 00 0057*   mul24out: blkb 6,0
       00 00       
040E20             0058*   
040E20             0059*   ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
040E20             0060*   ; operation: UHL * UDE --> mul24out
040E20             0061*   mul24:
040E20 DD E5       0062*       push ix ; preserve
040E22             0063*   ; point to output buffer and clear it
040E22 DD 21 1A 0E 0064*       ld ix,mul24out
       04          
040E27 C5          0065*       push bc
040E28 01 00 00 00 0066*       ld bc,0
040E2C DD 0F 00    0067*       ld (ix),bc
040E2F DD 0F 03    0068*       ld (ix+3),bc
040E32 C1          0069*       pop bc
040E33             0070*   ; STEP 1: UHL * E
040E33 7B          0071*       ld a,e
040E34 E5          0072*       push hl
040E35 CD EA 0D 04 0073*       call mul24x8
040E39 DD 2F 00    0074*       ld (ix+0),hl
040E3C DD 77 03    0075*       ld (ix+3),a
040E3F             0076*   ; STEP 2: UHL * D
040E3F E1          0077*       pop hl
040E40 E5          0078*       push hl
040E41 7A          0079*       ld a,d
040E42 CD EA 0D 04 0080*       call mul24x8
040E46 CD 5F 0E 04 0081*       call @accumulate
040E4A             0082*   ; STEP 3: UHL * DEU
040E4A E1          0083*       pop hl
040E4B ED 53 8F 0E 0084*       ld (@de),de
       04          
040E50 3A 91 0E 04 0085*       ld a,(@de+2)
040E54 CD EA 0D 04 0086*       call mul24x8
040E58 CD 5F 0E 04 0087*       call @accumulate
040E5C             0088*   ; all done
040E5C DD E1       0089*       pop ix ; restore
040E5E C9          0090*       ret
040E5F             0091*   @accumulate:
040E5F DD 23       0092*       inc ix
040E61             0093*   ; highest byte of product to carry
040E61 DD 77 03    0094*       ld (ix+3),a
040E64             0095*   ; low byte of product
040E64 7D          0096*       ld a,l
040E65 DD 86 00    0097*       add a,(ix+0)
040E68 DD 77 00    0098*       ld (ix+0),a
040E6B             0099*   ; high byte of product
040E6B 7C          0100*       ld a,h
040E6C DD 8E 01    0101*       adc a,(ix+1)
040E6F DD 77 01    0102*       ld (ix+1),a
040E72             0103*   ; uppper byte of product
040E72 22 8C 0E 04 0104*       ld (@hl),hl
040E76 3A 8E 0E 04 0105*       ld a,(@hl+2)
040E7A DD 8E 02    0106*       adc a,(ix+2)
040E7D DD 77 02    0107*       ld (ix+2),a
040E80             0108*   ; carry
040E80 3E 00       0109*       ld a,0 ; preserve flags
040E82 DD 8E 03    0110*       adc a,(ix+3)
040E85 DD 77 03    0111*       ld (ix+3),a
040E88 C9          0112*       ret
040E89             0113*   
040E89 00 00 00    0114*   @ix: dl 0
040E8C 00 00 00    0115*   @hl: dl 0
040E8F 00 00 00    0116*   @de: dl 0
040E92             0117*   
040E92             0118*   ; ; UHL * UDE --> UHL (unsigned)
040E92             0119*   ; umul24:
040E92             0120*   ;     call mul24
040E92             0121*   ;     ld hl,(mul24out)
040E92             0122*   ;     ret
040E92             0123*   
040E92             0124*   ; UH.L = UH.L*UD.E (unsigned)
040E92             0125*   umul168:
040E92 CD 20 0E 04 0126*       call mul24
040E96 2A 1B 0E 04 0127*       ld hl,(mul24out+1)
040E9A C9          0128*       ret
040E9B             0129*   
040E9B             0130*   ; UH.L * UD.E --> UH.L (signed)
040E9B             0131*   smul168:
040E9B             0132*   ; make everything positive and store sign flags
040E9B CD 70 04 04 0133*       call hlu_abs
040E9F F5          0134*       push af
040EA0 EB          0135*       ex de,hl
040EA1 CD 70 04 04 0136*       call hlu_abs
040EA5 EB          0137*       ex de,hl
040EA6 F5          0138*       push af
040EA7             0139*   ; do the division
040EA7 CD 92 0E 04 0140*       call umul168 ; hl = product
040EAB             0141*   ; adjust sign of result
040EAB F1          0142*       pop af ; sign de
040EAC FA B7 0E 04 0143*       jp m,@de_neg
040EB0 F1          0144*       pop af ; sign hl
040EB1 F0          0145*       ret p ; both positive, nothing to do
040EB2             0146*   @hl_neg:
040EB2 CD 80 04 04 0147*       call neg_hlu ; de pos, hl neg, result is negative
040EB6 C9          0148*       ret
040EB7             0149*   @de_neg:
040EB7 F1          0150*       pop af
040EB8 F8          0151*       ret m ; both negative, nothing to do
040EB9 CD 80 04 04 0152*       call neg_hlu ; result is negative
040EBD C9          0153*       ret
040EBE             0154*   
040EBE             0155*   ; UH.L / UD.E --> UD.E rem UHL (unsigned)
040EBE             0156*   ; perform unsigned division of 16.8 fixed place values
040EBE             0157*   ; with an unsigned 16.8 fixed place result and 24-bit remainder
040EBE             0158*   udiv168:
040EBE             0159*   ; back up divisor
040EBE ED 53 F5 0E 0160*       ld (@ude),de
       04          
040EC3             0161*   ; get the 16-bit integer part of the quotient
040EC3 CD 80 03 04 0162*       call udiv24 ; de = quotient, hl = remainder
040EC7             0163*   ; load quotient to upper three bytes of output
040EC7 ED 53 FC 0E 0164*       ld (div168_out+1),de
       04          
040ECC             0165*   @div256:
040ECC             0166*   ; multiply remainder by 256
040ECC             0167*       hlu_mul256
                       M1 Args: none
040ECC 29          0001*M1     add hl,hl ; * 2
040ECD 29          0002*M1     add hl,hl ; * 4
040ECE 29          0003*M1     add hl,hl ; * 8
040ECF 29          0004*M1     add hl,hl ; * 16
040ED0 29          0005*M1     add hl,hl ; * 32
040ED1 29          0006*M1     add hl,hl ; * 64
040ED2 29          0007*M1     add hl,hl ; * 128
040ED3 29          0008*M1     add hl,hl ; * 256
040ED4             0168*   ; skip fractional computation if remainder is zero
040ED4             0169*       SIGN_HLU
                       M1 Args: none
040ED4 19          0001*M1     add hl,de ; 1 cycle
040ED5 B7          0002*M1     or a ; clear flags ; 1 cycle
040ED6 ED 52       0003*M1     sbc hl,de ; 2 cycles
040ED8             0004*M1     ; 4 cycles total
040ED8 20 03       0170*       jr nz,@div_frac
040EDA AF          0171*       xor a
040EDB 18 0A       0172*       jr @write_frac
040EDD             0173*   ; now divide the shifted remainder by the divisor
040EDD             0174*   @div_frac:
040EDD ED 5B F5 0E 0175*       ld de,(@ude) ; get back divisor
       04          
040EE2 CD 80 03 04 0176*       call udiv24 ; de = quotient, hl = remainder
040EE6             0177*   ; load low byte of quotient to low byte of output
040EE6 7B          0178*       ld a,e
040EE7             0179*   @write_frac:
040EE7 32 FB 0E 04 0180*       ld (div168_out),a
040EEB             0181*   ; load de with return value
040EEB ED 5B FB 0E 0182*       ld de,(div168_out)
       04          
040EF0             0183*   ; load a with any overflow
040EF0 3A FE 0E 04 0184*       ld a,(div168_out+3)
040EF4 C9          0185*       ret ; ud.e is the 16.8 result
040EF5             0186*   @ude: ds 6
040EFB             0187*   div168_out: ds 4 ; the extra byte is for overflow
040EFF             0188*   
040EFF             0189*   ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
040EFF             0190*   ; perform signed division of 16.8 fixed place values
040EFF             0191*   ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
040EFF             0192*   sdiv168:
040EFF             0193*   ; make everything positive and store sign flags
       FF FF FF FF 
       FF FF FF FF 
       FF FF 
040EFF CD 70 04 04 0194*       call hlu_abs
040F03 F5          0195*       push af
040F04 EB          0196*       ex de,hl
040F05 CD 70 04 04 0197*       call hlu_abs
040F09 EB          0198*       ex de,hl
040F0A F5          0199*       push af
040F0B             0200*   ; do the division
040F0B CD BE 0E 04 0201*       call udiv168 ; de = quotient, hl = remainder
040F0F             0202*   ; adjust sign of result
040F0F F1          0203*       pop af ; sign de
040F10 FA 1D 0F 04 0204*       jp m,@de_neg
040F14 F1          0205*       pop af ; sign hl
040F15 F0          0206*       ret p ; both positive, nothing to do
040F16             0207*   @hl_neg:
040F16 EB          0208*       ex de,hl ; hl = quotient, de = remainder
040F17 CD 80 04 04 0209*       call neg_hlu ; de pos, hl neg, result is negative
040F1B EB          0210*       ex de,hl ; de = negated quotient, hl = remainder
040F1C C9          0211*       ret
040F1D             0212*   @de_neg:
040F1D F1          0213*       pop af
040F1E F8          0214*       ret m ; both negative, nothing to do
040F1F EB          0215*       ex de,hl ; hl = quotient, de = remainder
040F20 CD 80 04 04 0216*       call neg_hlu ; result is negative
040F24 EB          0217*       ex de,hl ; de = negated quotient, hl = remainder
040F25 C9          0218*       ret
040F26             0219*   
040F26             0220*   ; convert signed angles from a 360 to 256 degree circle
040F26             0221*   ; inputs: uh.l is the angle360 in 16.8 fixed format
040F26             0222*   ; outputs: uh.l is the angle256 in 16.8 fixed format
040F26             0223*   ; destroys: TODO
040F26             0224*   deg_360_to_256:
040F26 D5          0225*       push de ; preserve de
040F27             0226*   ; make angle positive and store sign flag
040F27 CD 70 04 04 0227*       call hlu_abs
040F2B F5          0228*       push af
040F2C             0229*   ; multiply by coversion factor of 256/360
040F2C 11 B6 00 00 0230*       ld de,0x0000B6 ; 0.711
040F30 CD 92 0E 04 0231*       call umul168 ; uh.l = uh.l * 0.711
040F34             0232*   ; restore sign flag and adjust output accordingly
040F34 F1          0233*       pop af
040F35 F2 3D 0F 04 0234*       jp p,@pos ; positive number
040F39 CD 80 04 04 0235*       call neg_hlu
040F3D             0236*   @pos:
040F3D             0237*   ; restore de and return uh.l as the result
040F3D D1          0238*       pop de
040F3E C9          0239*       ret
040F3F             0240*   
040F3F             0241*   ; convert signed angles from a 256 to 360 degree circle
040F3F             0242*   ; inputs: uh.l is the angle256 in 16.8 fixed format
040F3F             0243*   ; outputs: uh.l is the angle360 in 16.8 fixed format
040F3F             0244*   ; destroys: TODO
040F3F             0245*   deg_256_to_360:
040F3F D5          0246*       push de ; preserve de
040F40             0247*   ; make angle positive and store sign flag
040F40 CD 70 04 04 0248*       call hlu_abs
040F44 F5          0249*       push af
040F45             0250*   ; multiply by coversion factor of 360/256
040F45 11 68 01 00 0251*       ld de,0x000168 ; 1.406
040F49 CD 92 0E 04 0252*       call umul168 ; uh.l = uh.l * 1.406
040F4D             0253*   ; restore sign flag and adjust output accordingly
040F4D F1          0254*       pop af
040F4E F2 56 0F 04 0255*       jp p,@pos ; positive number
040F52 CD 80 04 04 0256*       call neg_hlu
040F56             0257*   @pos:
040F56             0258*   ; restore de and return uh.l as the result
040F56 D1          0259*       pop de
040F57 C9          0260*       ret
040F58             0261*   
040F58             0262*   ; fixed 16.8 routine
040F58             0263*   ; cos(uh.l) --> uh.l
040F58             0264*   ; destroys: f, hl
040F58             0265*   cos168:
040F58 D5          0266*       push de ; preserve de
040F59             0267*   ; for cos we simply increment the angle by 90 degrees
040F59             0268*   ; or 0x004000 in 16.8 degrees256
040F59             0269*   ; which makes it a sin problem
040F59 11 00 40 00 0270*       ld de,0x004000
040F5D 19          0271*       add hl,de ; modulo 256 happens below
040F5E D1          0272*       pop de ; restore de
040F5F             0273*   ; fall through to sin168
040F5F             0274*   
040F5F             0275*   ; ---------------------
040F5F             0276*   ; fixed 16.8 routine
040F5F             0277*   ; sin(uh.l) --> uh.l
040F5F             0278*   ; destroys: f, hl
040F5F             0279*   sin168:
040F5F D5          0280*       push de
040F60             0281*   ; handle negative angles appropriately
040F60 CD 70 04 04 0282*       call hlu_abs
040F64 F2 6D 0F 04 0283*       jp p,@F
040F68 11 00 00 FF 0284*       ld de,-256*256
040F6C 19          0285*       add hl,de
040F6D             0286*   @@:
040F6D 2E 03       0287*       ld l,3 ; multiply by 3 to get our lookup index
040F6F ED 6C       0288*       mlt hl
040F71 11 25 12 04 0289*       ld de,sin_lut_168 ; grab the lut address
040F75 19          0290*       add hl,de ; bump hl by the index
040F76 ED 27       0291*       ld hl,(hl) ; don't try this on a z80!
040F78 D1          0292*       pop de
040F79 C9          0293*       ret
040F7A             0294*   
040F7A             0295*   ; 16.8 fixed inputs / outputs
040F7A             0296*   ; takes: uh.l as angle in degrees 256
040F7A             0297*   ;        ud.e as radius
040F7A             0298*   ; returns ub.c as dx, ud.e as dy, uh.l as radius
040F7A             0299*   ;        displacements from origin (0,0)
040F7A             0300*   ; destroys: everything except indexes
040F7A             0301*   polar_to_cartesian:
040F7A             0302*   ; back up input parameters
040F7A 22 A9 0F 04 0303*       ld (@angle), hl
040F7E ED 53 AC 0F 0304*       ld (@radius), de
       04          
040F83             0305*   ; compute dx = sin(uh.l) * ud.e
040F83 CD 5F 0F 04 0306*       call sin168 ; uh.l = sin(uh.l)
040F87 ED 5B AC 0F 0307*       ld de,(@radius)
       04          
040F8C CD 9B 0E 04 0308*       call smul168 ; uh.l = dx
040F90 E5          0309*       push hl
040F91             0310*   ; compute dy = -cos(uh.l) * ud.e
040F91 2A A9 0F 04 0311*       ld hl,(@angle)
040F95 CD 58 0F 04 0312*       call cos168 ; uh.l = cos(uh.l)
040F99 ED 5B AC 0F 0313*       ld de,(@radius)
       04          
040F9E CD 9B 0E 04 0314*       call smul168 ; uh.l = dy
040FA2 CD 80 04 04 0315*       call neg_hlu ; invert dy for screen coords convention
040FA6 EB          0316*       ex de,hl ; de = dy for output
040FA7 C1          0317*       pop bc ; bc = dx for output
040FA8             0318*   ; and out
040FA8 C9          0319*       ret
040FA9             0320*   @angle: ds 3
040FAC             0321*   @radius: ds 3
040FAF             0322*   
040FAF             0323*   ; 16.8 fixed inputs / outputs
040FAF             0324*   ; inputs: ub.c as dx, ud.e as dy
040FAF             0325*   ;        displacements from origin (0,0)
040FAF             0326*   ; returns: uh.l as angle in degrees 256
040FAF             0327*   ;        ud.e as radius
040FAF             0328*   ; destroys: everything except indexes
040FAF             0329*   cartesian_to_polar:
       FF FF FF FF 
       FF FF 
040FAF ED 43 08 10 0330*       ld (dx168),bc ; dx argument for distance168
       04          
040FB4 ED 53 0E 10 0331*       ld (dy168),de ; dy argument for distance168
       04          
040FB9             0332*   ; compute radius
040FB9 CD 14 10 04 0333*       call distance168 ; uh.l = radius
040FBD E5          0334*       push hl ; save radius
040FBE             0335*   ; compute angle
040FBE ED 4B 08 10 0336*       ld bc,(dx168) ; dx argument for atan2_168fast
       04          
040FC3 ED 5B 0E 10 0337*       ld de,(dy168) ; dy argument for atan2_168fast
       04          
040FC8 CD 74 10 04 0338*       call atan2_168fast ; uh.l = angle
040FCC             0339*   ; return result
040FCC D1          0340*       pop de ; de = radius (was hl)
040FCD C9          0341*       ret
040FCE             0342*   ; end cartesian_to_polar
040FCE             0343*   
040FCE             0344*   ; 16.8 fixed inputs / outputs
040FCE             0345*   ; inputs: ub.c as dx, ud.e as dy
040FCE             0346*   ;        displacements from origin (0,0)
040FCE             0347*   ; returns: uh.l as angle in degrees 256
040FCE             0348*   ;        ud.e as radius
040FCE             0349*   ; destroys: everything except indexes
040FCE             0350*   ; note: uses distance168sm which is more accurate for small deltas
040FCE             0351*   cartesian_to_polar_sm:
040FCE ED 43 08 10 0352*       ld (dx168),bc ; dx argument for distance168
       04          
040FD3 ED 53 0E 10 0353*       ld (dy168),de ; dy argument for distance168
       04          
040FD8             0354*   ; compute radius
040FD8 CD 4F 10 04 0355*       call distance168sm ; uh.l = radius
040FDC E5          0356*       push hl ; save radius
040FDD             0357*   ; compute angle
040FDD ED 4B 08 10 0358*       ld bc,(dx168) ; dx argument for atan2_168fast
       04          
040FE2 ED 5B 0E 10 0359*       ld de,(dy168) ; dy argument for atan2_168fast
       04          
040FE7 CD 74 10 04 0360*       call atan2_168fast ; uh.l = angle
040FEB             0361*   ; return result
040FEB D1          0362*       pop de ; de = radius (was hl)
040FEC C9          0363*       ret
040FED             0364*   ; end cartesian_to_polar
040FED             0365*   
040FED             0366*   ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
040FED             0367*   ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
040FED             0368*   ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
040FED             0369*   ;         also populates scratch locations dx168 and dy168
040FED             0370*   ; destroys: a,hl,bc,de
040FED             0371*   dxy168:
040FED             0372*   ; compute dx = x1-x0
040FED AF          0373*       xor a ; clear carry
040FEE DD E5       0374*       push ix ; move ix to hl via the stack
040FF0 E1          0375*       pop hl ; hl = x1
040FF1 ED 42       0376*       sbc hl,bc ; hl = dx
040FF3 22 08 10 04 0377*       ld (dx168),hl ; dx to scratch
040FF7             0378*   ; compute dy = y1-y0
040FF7 AF          0379*       xor a ; clear carry
040FF8 FD E5       0380*       push iy ; move iy to hl via the stack
040FFA E1          0381*       pop hl ; hl = y1
040FFB ED 52       0382*       sbc hl,de ; hl = dy
040FFD 22 0E 10 04 0383*       ld (dy168),hl ; dy to scratch
041001             0384*   ; populate output registers and return
041001 EB          0385*       ex de,hl ; ud.e = dy
041002 ED 4B 08 10 0386*       ld bc,(dx168) ; ub.c = dx
       04          
041007 C9          0387*       ret
041008 00 00 00 00 0388*   dx168: blkb 6,0
       00 00       
04100E 00 00 00 00 0389*   dy168: blkb 6,0
       00 00       
041014             0390*   
041014             0391*   ; compute the euclidian distance between two cartesian coordinates
041014             0392*   ; using the formula d = sqrt(dx^2+dy^2)
041014             0393*   ; inputs: dx168 and dy168 are dx and dy in 16.8 fixed format
041014             0394*   ; output; uh.l is the 16.8 fixed format distance
041014             0395*   ;         also populates scratch locations dx168 and dy168
041014             0396*   ; destroys: a,hl,bc,de
041014             0397*   ; NOTE: rounds both deltas down to the nearest integer to avoid overflow when squaring,
041014             0398*   ;       thus the result will always be an integer, albeit in 16.8 format
041014             0399*   distance168:
041014             0400*   ; compute dy^2
041014 2A 0E 10 04 0401*       ld hl,(dy168)
041018 CD 70 04 04 0402*       call hlu_abs
04101C             0403*       ; call hlu_udiv256 ; make integer to avoid overflow
04101C             0404*       SRL_UHL ; make integer to avoid overflow
                       M1 Args: none
04101C 3B          0001*M1     dec sp ; 1 cycle
04101D E5          0002*M1     push hl ; 4 cycles
04101E 33          0003*M1     inc sp ; 1 cycle
04101F E1          0004*M1     pop hl ; 4 cycles
041020 23          0005*M1     inc hl ; 1 cycle
041021 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
041023             0007*M1     ; 13 cycles total
041023 E5          0405*       push hl
041024 D1          0406*       pop de
041025 CD 67 03 04 0407*       call umul24 ; hl = dy^2
041029 E5          0408*       push hl ; save dy^2
04102A             0409*   ; compute dx^2
04102A 2A 08 10 04 0410*       ld hl,(dx168)
04102E CD 70 04 04 0411*       call hlu_abs
041032             0412*       ; call hlu_udiv256 ; make integer to avoid overflow
041032             0413*       SRL_UHL ; make integer to avoid overflow
                       M1 Args: none
041032 3B          0001*M1     dec sp ; 1 cycle
041033 E5          0002*M1     push hl ; 4 cycles
041034 33          0003*M1     inc sp ; 1 cycle
041035 E1          0004*M1     pop hl ; 4 cycles
041036 23          0005*M1     inc hl ; 1 cycle
041037 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
041039             0007*M1     ; 13 cycles total
041039 E5          0414*       push hl
04103A D1          0415*       pop de
04103B CD 67 03 04 0416*       call umul24 ; hl = dx^2
04103F             0417*   ; add dx^2 and dy^2
04103F D1          0418*       pop de ; de = dy^2 (was hl)
041040 19          0419*       add hl,de ; hl = dx^2 + dy^2
041041             0420*   ; compute the square root
041041 CD 3F 11 04 0421*       call sqrt24 ; de = sqrt(dx^2 + dy^2)
041045 EB          0422*       ex de,hl ; hl = distance
041046             0423*       hlu_mul256 ; convert back to 16.8 fixed
                       M1 Args: none
041046 29          0001*M1     add hl,hl ; * 2
041047 29          0002*M1     add hl,hl ; * 4
041048 29          0003*M1     add hl,hl ; * 8
041049 29          0004*M1     add hl,hl ; * 16
04104A 29          0005*M1     add hl,hl ; * 32
04104B 29          0006*M1     add hl,hl ; * 64
04104C 29          0007*M1     add hl,hl ; * 128
04104D 29          0008*M1     add hl,hl ; * 256
04104E C9          0424*       ret
04104F             0425*   
04104F             0426*   ; compute the euclidian distance between two cartesian coordinates
04104F             0427*   ; using the formula d = sqrt(dx^2+dy^2)
04104F             0428*   ; inputs: dx168 and dy168 are dx and dy in 16.8 fixed format
04104F             0429*   ; output; uh.l is the 16.8 fixed format distance
04104F             0430*   ;         also populates scratch locations dx168 and dy168
04104F             0431*   ; destroys: a,hl,bc,de
04104F             0432*   ; NOTE: sm means 'small' because it doesn't round down the deltas
04104F             0433*   ;       making it more accurate for small deltas,
04104F             0434*   ;       but will overflow if used for screen-sized deltas
04104F             0435*   distance168sm:
04104F             0436*   ; compute dy^2
04104F 2A 0E 10 04 0437*       ld hl,(dy168)
041053 CD 70 04 04 0438*       call hlu_abs
041057 E5          0439*       push hl
041058 D1          0440*       pop de
041059 CD 67 03 04 0441*       call umul24 ; hl = dy^2
04105D E5          0442*       push hl ; save dy^2
04105E             0443*   ; compute dx^2
04105E 2A 08 10 04 0444*       ld hl,(dx168)
041062 CD 70 04 04 0445*       call hlu_abs
041066 E5          0446*       push hl
041067 D1          0447*       pop de
041068 CD 67 03 04 0448*       call umul24 ; hl = dx^2
04106C             0449*   ; add dx^2 and dy^2
04106C D1          0450*       pop de ; de = dy^2 (was hl)
04106D 19          0451*       add hl,de ; hl = dx^2 + dy^2
04106E             0452*   ; compute the square root
04106E CD 3F 11 04 0453*       call sqrt24 ; de = sqrt(dx^2 + dy^2)
041072 EB          0454*       ex de,hl ; hl = distance
041073 C9          0455*       ret
041074             0456*   
041074             0457*   ; atan2_(ub.c,ud.e) --> uh.l
041074             0458*   ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
041074             0459*   ;   whether inputs are integers or fractional doesn't matter
041074             0460*   ;   so long as the sign bit of the upper byte is correct
041074             0461*   ; output: uh.l is the 16.8 fixed angle in degrees 256
041074             0462*   ; angles are COMPASS HEADINGS based on
041074             0463*   ; screen coordinate conventions,where the y axis is flipped
041074             0464*   ; #E0 224      0       32 #20
041074             0465*   ;        -x,-y | +x,-y
041074             0466*   ; #C0 192------+------ 64 #40
041074             0467*   ;        -x,+y | +x,+y
041074             0468*   ; #A0 160   128 #80   96 #60
041074             0469*   atan2_168fast:
041074             0470*   ; get signs and make everything positive
041074             0471*   ; get abs(x) and store its original sign
041074 C5          0472*       push bc
041075 E1          0473*       pop hl
041076 CD 70 04 04 0474*       call hlu_abs ; if x was negative this also sets the sign flag
04107A E5          0475*       push hl ; store abs(x)
04107B C1          0476*       pop bc ; bc = abs(x)
04107C F5          0477*       push af ; store sign of x
04107D             0478*   ; get abs(y) and store its original sign
04107D EB          0479*       ex de,hl ; hl = y
04107E CD 70 04 04 0480*       call hlu_abs ; if y was negative this also sets the sign flag
041082 EB          0481*       ex de,hl ; de = abs(y)
041083 F5          0482*       push af ; store sign of y
041084             0483*   ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
041084             0484*   ; this ensures that our lookup value is between 0 and 1 inclusive
041084 AF          0485*       xor a ; clear the carry flag
041085 D5          0486*       push de
041086 E1          0487*       pop hl
041087 ED 42       0488*       sbc hl,bc
041089 F5          0489*       push af ; save sign of de - bc
04108A F2 93 10 04 0490*       jp p,@1 ; bc <= de, so we skip ahead
04108E             0491*   ; otherwise we swap bc and de
04108E C5          0492*       push bc
04108F E1          0493*       pop hl
041090 EB          0494*       ex de,hl
041091 E5          0495*       push hl
041092 C1          0496*       pop bc
041093             0497*   @1:
041093             0498*   ; now we're ready to snag our preliminary result
041093 C5          0499*       push bc
041094 E1          0500*       pop hl
041095 CD 03 11 04 0501*       call atan_168fast ; uh.l comes back with prelim result
041099             0502*   ; now we adjust uh.l based on sign of de - bc
041099 F1          0503*       pop af
04109A F2 A6 10 04 0504*       jp p,@2 ; bc <= de,so we skip ahead
04109E EB          0505*       ex de,hl
04109F 21 00 40 00 0506*       ld hl,64*256 ; subtract from 64 (90) degrees
0410A3 AF          0507*       xor a ; clear the carry flag
0410A4 ED 52       0508*       sbc hl,de
0410A6             0509*   @2:
0410A6             0510*   ; adjust the result based on quadrant
0410A6             0511*   ; #E0 224      0       32 #20
0410A6             0512*   ;        -x,-y | +x,-y
0410A6             0513*   ; #C0 192------+------ 64 #40
0410A6             0514*   ;        -x,+y | +x,+y
0410A6             0515*   ; #A0 160   128 #80   96 #60
0410A6 F1          0516*       pop af ; sign of y
0410A7 CA E4 10 04 0517*       jp z,@y_zero
0410AB F2 C4 10 04 0518*       jp p,@y_pos
0410AF             0519*   ; y neg,check x
0410AF F1          0520*       pop af ; sign of x
0410B0 CA BE 10 04 0521*       jp z,@y_neg_x_zero
0410B4 F2 C3 10 04 0522*       jp p,@y_neg_x_pos
0410B8             0523*   ; y neg,x neg
0410B8             0524*   ; angle is 128 to 256 (270 to 360)
0410B8             0525*   ; negating the intermediate does the trick
0410B8 CD 80 04 04 0526*       call neg_hlu
0410BC 18 31       0527*       jr @zero_hlu
0410BE             0528*   
0410BE             0529*   @y_neg_x_zero:
0410BE             0530*   ; y neg,x zero
0410BE             0531*   ; angle is 0
0410BE 21 00 00 00 0532*       ld hl,0
0410C2 C9          0533*       ret
0410C3             0534*   @y_neg_x_pos:
0410C3             0535*   ; y neg,x pos
0410C3             0536*   ; angle is 0 to 64 (0 to 90)
0410C3             0537*   ; so we're good
0410C3 C9          0538*       ret
0410C4             0539*   
0410C4             0540*   @y_pos:
0410C4 F1          0541*       pop af ; sign of x
0410C5 CA D4 10 04 0542*       jp z,@y_pos_x_zero
0410C9 F2 D9 10 04 0543*       jp p,@y_pos_x_pos
0410CD             0544*   ; y pos,x neg
0410CD             0545*   ; angle is 128 to 192 (180-270)
0410CD             0546*   ; so we add 128 to intermediate
0410CD 11 00 80 00 0547*       ld de,128*256
0410D1 19          0548*       add hl,de
0410D2 18 1B       0549*       jr @zero_hlu
0410D4             0550*   @y_pos_x_zero:
0410D4             0551*   ; y pos,x zero
0410D4             0552*   ; angle is 128 (180)
0410D4 21 00 80 00 0553*       ld hl,128*256
0410D8 C9          0554*       ret
0410D9             0555*   @y_pos_x_pos:
0410D9             0556*   ; y pos,x pos
0410D9             0557*   ; angle is 64 to 128 (90 to 180)
0410D9             0558*   ; neg the intermediate and add 180 degrees
0410D9 CD 80 04 04 0559*       call neg_hlu
0410DD 11 00 80 00 0560*       ld de,128*256
0410E1 19          0561*       add hl,de
0410E2 18 0B       0562*       jr @zero_hlu
0410E4             0563*   
0410E4             0564*   @y_zero:
0410E4 F1          0565*       pop af ; sign of x
0410E5 FA EA 10 04 0566*       jp m,@y_zero_x_neg
0410E9             0567*   ; y zero,x pos
0410E9             0568*   ; angle is 64 (90),nothing to do
0410E9 C9          0569*       ret
0410EA             0570*   @y_zero_x_neg:
0410EA             0571*   ; y zero ,x neg
0410EA             0572*   ; angle is 192 (270)
0410EA 21 00 C0 00 0573*       ld hl,192*256
0410EE C9          0574*       ret
0410EF             0575*   @zero_hlu:
0410EF AF          0576*       xor a
0410F0 22 FD 10 04 0577*       ld (@scratch),hl
0410F4 32 FF 10 04 0578*       ld (@scratch+2),a
0410F8 2A FD 10 04 0579*       ld hl,(@scratch)
0410FC C9          0580*       ret
0410FD             0581*   @scratch: ds 6
041103             0582*   
041103             0583*   ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
041103             0584*   ; output: uh.l is the 16.8 fixed format angle in degrees 256
041103             0585*   ; destroys: a,hl,bc,de
041103             0586*   ; note: only works for angles from 0 to 32 (45) degrees
041103             0587*   ;   use atan2_168fast (which calls this proc) to handle the full 256 (360) degrees
041103             0588*   atan_168fast:
041103             0589*   ; because we use compass headings instead of geometric angles
041103             0590*   ; we compute dx/dy which is 1/tan(theta) in the maths world
041103             0591*   ; we can do faster unsigned division here because we know dx and dy are positive
       FF FF FF FF 
       FF FF 
041103 CD BE 0E 04 0592*       call udiv168 ; ud.e = dx/dy
041107 EB          0593*       ex de,hl ; uh.l = dx/dy
041108             0594*   ; test uh.l for 0
041108 19          0595*       add hl,de
041109 B7          0596*       or a
04110A ED 52       0597*       sbc hl,de
04110C 28 22       0598*       jr z,@is_zero
04110E             0599*   ; test uh.l for 1
04110E AF          0600*       xor a ; clear carry
04110F EB          0601*       ex de,hl
041110 21 00 01 00 0602*       ld hl,1*256 ; 1 in 16.8 fixed format
041114 ED 52       0603*       sbc hl,de
041116 28 13       0604*       jr z,@is_45
041118 EB          0605*       ex de,hl
041119             0606*   ; no special cases so we move on
041119             0607*   ; l contains the fractional portion of tan(uh.l)
041119             0608*   ; we multiply it by three to get our lookup table index
041119 26 03       0609*       ld h,3
04111B ED 6C       0610*       mlt hl ; index into lut
04111D 11 00 00 00 0611*       ld de,0 ; clear deu
041121 54          0612*       ld d,h ; copy hl to de
041122 5D          0613*       ld e,l ; de contains our index
041123 21 28 15 04 0614*       ld hl,atan_lut_168 ; grab the lut address
041127 19          0615*       add hl,de ; bump hl by the index
041128 ED 27       0616*       ld hl,(hl) ; don't try this on a z80!
04112A C9          0617*       ret ; and out
04112B             0618*   @is_45:
04112B 21 00 20 00 0619*       ld hl,32*256
04112F C9          0620*       ret
041130             0621*   ; for the case tan(0)
041130             0622*   @is_zero:
041130 21 00 00 00 0623*       ld hl,0*256
041134 C9          0624*       ret
041135             0625*   
041135             0626*   ; Expects  ADL mode
041135             0627*   ; Inputs:  UH.L
041135             0628*   ; Outputs: UH.L is the 16.8 square root
041135             0629*   ;          UDE is the integer difference inputHL-DE^2
041135             0630*   sqrt168:
041135 CD 3F 11 04 0631*       call sqrt24
041139 EB          0632*       ex de,hl
04113A 29          0633*       add hl,hl
04113B 29          0634*       add hl,hl
04113C 29          0635*       add hl,hl
04113D 29          0636*       add hl,hl
04113E C9          0637*       ret
04113F             0638*   
04113F             0639*   ; credit: xeda112358
04113F             0640*   ; https://www.cemetech.net/forum/viewtopic.php?t=11178&postdays=0&postorder=asc&start=0
04113F             0641*   sqrt24:
04113F             0642*   ; Expects ADL mode
04113F             0643*   ; Inputs: HL
04113F             0644*   ; Outputs: DE is the integer square root
04113F             0645*   ;  HL is the difference inputHL-DE^2
04113F             0646*   ;  c flag reset
04113F 01 00 00 00 0647*       ld bc,0 ; clear bcu
041143 11 00 00 00 0648*       ld de,0 ; clear deu
041147 AF          0649*       xor a
041148 45          0650*       ld b,l
041149 C5          0651*       push bc
04114A 47          0652*       ld b,a
04114B 6F          0653*       ld l,a
04114C             0654*   ; Iteration 1
04114C 29          0655*       add hl,hl
04114D CB 11       0656*       rl c
04114F 29          0657*       add hl,hl
041150 CB 11       0658*       rl c
041152 91          0659*       sub c
041153 30 04       0660*       jr nc,$+6
041155 1C          0661*       inc e
041156 1C          0662*       inc e
041157 2F          0663*       cpl
041158 4F          0664*       ld c,a
041159             0665*   ; Iteration 2
041159 29          0666*       add hl,hl
04115A CB 11       0667*       rl c
04115C 29          0668*       add hl,hl
04115D CB 11       0669*       rl c
04115F CB 13       0670*       rl e
041161 7B          0671*       ld a,e
041162 91          0672*       sub c
041163 30 04       0673*       jr nc,$+6
041165 1C          0674*       inc e
041166 1C          0675*       inc e
041167 2F          0676*       cpl
041168 4F          0677*       ld c,a
041169             0678*   ; Iteration 3
041169 29          0679*       add hl,hl
04116A CB 11       0680*       rl c
04116C 29          0681*       add hl,hl
04116D CB 11       0682*       rl c
04116F CB 13       0683*       rl e
041171 7B          0684*       ld a,e
041172 91          0685*       sub c
041173 30 04       0686*       jr nc,$+6
041175 1C          0687*       inc e
041176 1C          0688*       inc e
041177 2F          0689*       cpl
041178 4F          0690*       ld c,a
041179             0691*   ; Iteration 4
041179 29          0692*       add hl,hl
04117A CB 11       0693*       rl c
04117C 29          0694*       add hl,hl
04117D CB 11       0695*       rl c
04117F CB 13       0696*       rl e
041181 7B          0697*       ld a,e
041182 91          0698*       sub c
041183 30 04       0699*       jr nc,$+6
041185 1C          0700*       inc e
041186 1C          0701*       inc e
041187 2F          0702*       cpl
041188 4F          0703*       ld c,a
041189             0704*   ; Iteration 5
041189 29          0705*       add hl,hl
04118A CB 11       0706*       rl c
04118C 29          0707*       add hl,hl
04118D CB 11       0708*       rl c
04118F CB 13       0709*       rl e
041191 7B          0710*       ld a,e
041192 91          0711*       sub c
041193 30 04       0712*       jr nc,$+6
041195 1C          0713*       inc e
041196 1C          0714*       inc e
041197 2F          0715*       cpl
041198 4F          0716*       ld c,a
041199             0717*   ; Iteration 6
041199 29          0718*       add hl,hl
04119A CB 11       0719*       rl c
04119C 29          0720*       add hl,hl
04119D CB 11       0721*       rl c
04119F CB 13       0722*       rl e
0411A1 7B          0723*       ld a,e
0411A2 91          0724*       sub c
0411A3 30 04       0725*       jr nc,$+6
0411A5 1C          0726*       inc e
0411A6 1C          0727*       inc e
0411A7 2F          0728*       cpl
0411A8 4F          0729*       ld c,a
0411A9             0730*   ; Iteration 7
0411A9 29          0731*       add hl,hl
0411AA CB 11       0732*       rl c
0411AC 29          0733*       add hl,hl
0411AD CB 11       0734*       rl c
0411AF CB 10       0735*       rl b
0411B1 EB          0736*       ex de,hl
0411B2 29          0737*       add hl,hl
0411B3 E5          0738*       push hl
0411B4 ED 42       0739*       sbc hl,bc
0411B6 30 06       0740*       jr nc,$+8
0411B8 7C          0741*       ld a,h
0411B9 2F          0742*       cpl
0411BA 47          0743*       ld b,a
0411BB 7D          0744*       ld a,l
0411BC 2F          0745*       cpl
0411BD 4F          0746*       ld c,a
0411BE E1          0747*       pop hl
0411BF 30 02       0748*       jr nc,$+4
0411C1 23          0749*       inc hl
0411C2 23          0750*       inc hl
0411C3 EB          0751*       ex de,hl
0411C4             0752*   ; Iteration 8
0411C4 29          0753*       add hl,hl
0411C5 69          0754*       ld l,c
0411C6 60          0755*       ld h,b
0411C7 ED 6A       0756*       adc hl,hl
0411C9 ED 6A       0757*       adc hl,hl
0411CB EB          0758*       ex de,hl
0411CC 29          0759*       add hl,hl
0411CD ED 52       0760*       sbc hl,de
0411CF 19          0761*       add hl,de
0411D0 EB          0762*       ex de,hl
0411D1 30 04       0763*       jr nc,$+6
0411D3 ED 52       0764*       sbc hl,de
0411D5 13          0765*       inc de
0411D6 13          0766*       inc de
0411D7             0767*   ; Iteration 9
0411D7 F1          0768*       pop af
0411D8 17          0769*       rla
0411D9 ED 6A       0770*       adc hl,hl
0411DB 17          0771*       rla
0411DC ED 6A       0772*       adc hl,hl
0411DE EB          0773*       ex de,hl
0411DF 29          0774*       add hl,hl
0411E0 ED 52       0775*       sbc hl,de
0411E2 19          0776*       add hl,de
0411E3 EB          0777*       ex de,hl
0411E4 30 04       0778*       jr nc,$+6
0411E6 ED 52       0779*       sbc hl,de
0411E8 13          0780*       inc de
0411E9 13          0781*       inc de
0411EA             0782*   ; Iteration 10
0411EA 17          0783*       rla
0411EB ED 6A       0784*       adc hl,hl
0411ED 17          0785*       rla
0411EE ED 6A       0786*       adc hl,hl
0411F0 EB          0787*       ex de,hl
0411F1 29          0788*       add hl,hl
0411F2 ED 52       0789*       sbc hl,de
0411F4 19          0790*       add hl,de
0411F5 EB          0791*       ex de,hl
0411F6 30 04       0792*       jr nc,$+6
0411F8 ED 52       0793*       sbc hl,de
0411FA 13          0794*       inc de
0411FB 13          0795*       inc de
0411FC             0796*   ; Iteration 11
0411FC 17          0797*       rla
0411FD ED 6A       0798*       adc hl,hl
0411FF 17          0799*       rla
041200 ED 6A       0800*       adc hl,hl
041202 EB          0801*       ex de,hl
041203 29          0802*       add hl,hl
041204 ED 52       0803*       sbc hl,de
041206 19          0804*       add hl,de
041207 EB          0805*       ex de,hl
041208 30 04       0806*       jr nc,$+6
04120A ED 52       0807*       sbc hl,de
04120C 13          0808*       inc de
04120D 13          0809*       inc de
04120E             0810*   ; Iteration 12
04120E 17          0811*       rla
04120F ED 6A       0812*       adc hl,hl
041211 17          0813*       rla
041212 ED 6A       0814*       adc hl,hl
041214 EB          0815*       ex de,hl
041215 29          0816*       add hl,hl
041216 ED 52       0817*       sbc hl,de
041218 19          0818*       add hl,de
041219 EB          0819*       ex de,hl
04121A 30 04       0820*       jr nc,$+6
04121C ED 52       0821*       sbc hl,de
04121E 13          0822*       inc de
04121F 13          0823*       inc de
041220 CB 1A       0824*       rr d
041222 CB 1B       0825*       rr e
041224 C9          0826*       ret
041225             0827*   
041225             0828*   sin_lut_168:
041225 00 00 00    0829*       dl 0x000000 ; 0.000 00, 0.000
041228 06 00 00    0830*       dl 0x000006 ; 1.406 01, 0.025
04122B 0C 00 00    0831*       dl 0x00000C ; 2.813 02, 0.049
04122E 12 00 00    0832*       dl 0x000012 ; 4.219 03, 0.074
041231 19 00 00    0833*       dl 0x000019 ; 5.625 04, 0.098
041234 1F 00 00    0834*       dl 0x00001F ; 7.031 05, 0.122
041237 25 00 00    0835*       dl 0x000025 ; 8.438 06, 0.147
04123A 2B 00 00    0836*       dl 0x00002B ; 9.844 07, 0.171
04123D 31 00 00    0837*       dl 0x000031 ; 11.250 08, 0.195
041240 38 00 00    0838*       dl 0x000038 ; 12.656 09, 0.219
041243 3E 00 00    0839*       dl 0x00003E ; 14.063 0A, 0.243
041246 44 00 00    0840*       dl 0x000044 ; 15.469 0B, 0.267
041249 4A 00 00    0841*       dl 0x00004A ; 16.875 0C, 0.290
04124C 50 00 00    0842*       dl 0x000050 ; 18.281 0D, 0.314
04124F 56 00 00    0843*       dl 0x000056 ; 19.688 0E, 0.337
041252 5C 00 00    0844*       dl 0x00005C ; 21.094 0F, 0.360
041255 61 00 00    0845*       dl 0x000061 ; 22.500 10, 0.383
041258 67 00 00    0846*       dl 0x000067 ; 23.906 11, 0.405
04125B 6D 00 00    0847*       dl 0x00006D ; 25.313 12, 0.428
04125E 73 00 00    0848*       dl 0x000073 ; 26.719 13, 0.450
041261 78 00 00    0849*       dl 0x000078 ; 28.125 14, 0.471
041264 7E 00 00    0850*       dl 0x00007E ; 29.531 15, 0.493
041267 83 00 00    0851*       dl 0x000083 ; 30.938 16, 0.514
04126A 88 00 00    0852*       dl 0x000088 ; 32.344 17, 0.535
04126D 8E 00 00    0853*       dl 0x00008E ; 33.750 18, 0.556
041270 93 00 00    0854*       dl 0x000093 ; 35.156 19, 0.576
041273 98 00 00    0855*       dl 0x000098 ; 36.563 1A, 0.596
041276 9D 00 00    0856*       dl 0x00009D ; 37.969 1B, 0.615
041279 A2 00 00    0857*       dl 0x0000A2 ; 39.375 1C, 0.634
04127C A7 00 00    0858*       dl 0x0000A7 ; 40.781 1D, 0.653
04127F AB 00 00    0859*       dl 0x0000AB ; 42.188 1E, 0.672
041282 B0 00 00    0860*       dl 0x0000B0 ; 43.594 1F, 0.690
041285 B5 00 00    0861*       dl 0x0000B5 ; 45.000 20, 0.707
041288 B9 00 00    0862*       dl 0x0000B9 ; 46.406 21, 0.724
04128B BD 00 00    0863*       dl 0x0000BD ; 47.813 22, 0.741
04128E C1 00 00    0864*       dl 0x0000C1 ; 49.219 23, 0.757
041291 C5 00 00    0865*       dl 0x0000C5 ; 50.625 24, 0.773
041294 C9 00 00    0866*       dl 0x0000C9 ; 52.031 25, 0.788
041297 CD 00 00    0867*       dl 0x0000CD ; 53.438 26, 0.803
04129A D1 00 00    0868*       dl 0x0000D1 ; 54.844 27, 0.818
04129D D4 00 00    0869*       dl 0x0000D4 ; 56.250 28, 0.831
0412A0 D8 00 00    0870*       dl 0x0000D8 ; 57.656 29, 0.845
0412A3 DB 00 00    0871*       dl 0x0000DB ; 59.063 2A, 0.858
0412A6 DE 00 00    0872*       dl 0x0000DE ; 60.469 2B, 0.870
0412A9 E1 00 00    0873*       dl 0x0000E1 ; 61.875 2C, 0.882
0412AC E4 00 00    0874*       dl 0x0000E4 ; 63.281 2D, 0.893
0412AF E7 00 00    0875*       dl 0x0000E7 ; 64.688 2E, 0.904
0412B2 EA 00 00    0876*       dl 0x0000EA ; 66.094 2F, 0.914
0412B5 EC 00 00    0877*       dl 0x0000EC ; 67.500 30, 0.924
0412B8 EE 00 00    0878*       dl 0x0000EE ; 68.906 31, 0.933
0412BB F1 00 00    0879*       dl 0x0000F1 ; 70.313 32, 0.942
0412BE F3 00 00    0880*       dl 0x0000F3 ; 71.719 33, 0.950
0412C1 F4 00 00    0881*       dl 0x0000F4 ; 73.125 34, 0.957
0412C4 F6 00 00    0882*       dl 0x0000F6 ; 74.531 35, 0.964
0412C7 F8 00 00    0883*       dl 0x0000F8 ; 75.938 36, 0.970
0412CA F9 00 00    0884*       dl 0x0000F9 ; 77.344 37, 0.976
0412CD FB 00 00    0885*       dl 0x0000FB ; 78.750 38, 0.981
0412D0 FC 00 00    0886*       dl 0x0000FC ; 80.156 39, 0.985
0412D3 FD 00 00    0887*       dl 0x0000FD ; 81.563 3A, 0.989
0412D6 FE 00 00    0888*       dl 0x0000FE ; 82.969 3B, 0.992
0412D9 FE 00 00    0889*       dl 0x0000FE ; 84.375 3C, 0.995
0412DC FF 00 00    0890*       dl 0x0000FF ; 85.781 3D, 0.997
0412DF FF 00 00    0891*       dl 0x0000FF ; 87.188 3E, 0.999
0412E2 FF 00 00    0892*       dl 0x0000FF ; 88.594 3F, 1.000
0412E5 00 01 00    0893*       dl 0x000100 ; 90.000 40, 1.000
0412E8 FF 00 00    0894*       dl 0x0000FF ; 91.406 41, 1.000
0412EB FF 00 00    0895*       dl 0x0000FF ; 92.813 42, 0.999
0412EE FF 00 00    0896*       dl 0x0000FF ; 94.219 43, 0.997
0412F1 FE 00 00    0897*       dl 0x0000FE ; 95.625 44, 0.995
0412F4 FE 00 00    0898*       dl 0x0000FE ; 97.031 45, 0.992
0412F7 FD 00 00    0899*       dl 0x0000FD ; 98.438 46, 0.989
0412FA FC 00 00    0900*       dl 0x0000FC ; 99.844 47, 0.985
0412FD FB 00 00    0901*       dl 0x0000FB ; 101.250 48, 0.981
041300 F9 00 00    0902*       dl 0x0000F9 ; 102.656 49, 0.976
041303 F8 00 00    0903*       dl 0x0000F8 ; 104.063 4A, 0.970
041306 F6 00 00    0904*       dl 0x0000F6 ; 105.469 4B, 0.964
041309 F4 00 00    0905*       dl 0x0000F4 ; 106.875 4C, 0.957
04130C F3 00 00    0906*       dl 0x0000F3 ; 108.281 4D, 0.950
04130F F1 00 00    0907*       dl 0x0000F1 ; 109.688 4E, 0.942
041312 EE 00 00    0908*       dl 0x0000EE ; 111.094 4F, 0.933
041315 EC 00 00    0909*       dl 0x0000EC ; 112.500 50, 0.924
041318 EA 00 00    0910*       dl 0x0000EA ; 113.906 51, 0.914
04131B E7 00 00    0911*       dl 0x0000E7 ; 115.313 52, 0.904
04131E E4 00 00    0912*       dl 0x0000E4 ; 116.719 53, 0.893
041321 E1 00 00    0913*       dl 0x0000E1 ; 118.125 54, 0.882
041324 DE 00 00    0914*       dl 0x0000DE ; 119.531 55, 0.870
041327 DB 00 00    0915*       dl 0x0000DB ; 120.938 56, 0.858
04132A D8 00 00    0916*       dl 0x0000D8 ; 122.344 57, 0.845
04132D D4 00 00    0917*       dl 0x0000D4 ; 123.750 58, 0.831
041330 D1 00 00    0918*       dl 0x0000D1 ; 125.156 59, 0.818
041333 CD 00 00    0919*       dl 0x0000CD ; 126.563 5A, 0.803
041336 C9 00 00    0920*       dl 0x0000C9 ; 127.969 5B, 0.788
041339 C5 00 00    0921*       dl 0x0000C5 ; 129.375 5C, 0.773
04133C C1 00 00    0922*       dl 0x0000C1 ; 130.781 5D, 0.757
04133F BD 00 00    0923*       dl 0x0000BD ; 132.188 5E, 0.741
041342 B9 00 00    0924*       dl 0x0000B9 ; 133.594 5F, 0.724
041345 B5 00 00    0925*       dl 0x0000B5 ; 135.000 60, 0.707
041348 B0 00 00    0926*       dl 0x0000B0 ; 136.406 61, 0.690
04134B AB 00 00    0927*       dl 0x0000AB ; 137.813 62, 0.672
04134E A7 00 00    0928*       dl 0x0000A7 ; 139.219 63, 0.653
041351 A2 00 00    0929*       dl 0x0000A2 ; 140.625 64, 0.634
041354 9D 00 00    0930*       dl 0x00009D ; 142.031 65, 0.615
041357 98 00 00    0931*       dl 0x000098 ; 143.438 66, 0.596
04135A 93 00 00    0932*       dl 0x000093 ; 144.844 67, 0.576
04135D 8E 00 00    0933*       dl 0x00008E ; 146.250 68, 0.556
041360 88 00 00    0934*       dl 0x000088 ; 147.656 69, 0.535
041363 83 00 00    0935*       dl 0x000083 ; 149.063 6A, 0.514
041366 7E 00 00    0936*       dl 0x00007E ; 150.469 6B, 0.493
041369 78 00 00    0937*       dl 0x000078 ; 151.875 6C, 0.471
04136C 73 00 00    0938*       dl 0x000073 ; 153.281 6D, 0.450
04136F 6D 00 00    0939*       dl 0x00006D ; 154.688 6E, 0.428
041372 67 00 00    0940*       dl 0x000067 ; 156.094 6F, 0.405
041375 61 00 00    0941*       dl 0x000061 ; 157.500 70, 0.383
041378 5C 00 00    0942*       dl 0x00005C ; 158.906 71, 0.360
04137B 56 00 00    0943*       dl 0x000056 ; 160.313 72, 0.337
04137E 50 00 00    0944*       dl 0x000050 ; 161.719 73, 0.314
041381 4A 00 00    0945*       dl 0x00004A ; 163.125 74, 0.290
041384 44 00 00    0946*       dl 0x000044 ; 164.531 75, 0.267
041387 3E 00 00    0947*       dl 0x00003E ; 165.938 76, 0.243
04138A 38 00 00    0948*       dl 0x000038 ; 167.344 77, 0.219
04138D 31 00 00    0949*       dl 0x000031 ; 168.750 78, 0.195
041390 2B 00 00    0950*       dl 0x00002B ; 170.156 79, 0.171
041393 25 00 00    0951*       dl 0x000025 ; 171.563 7A, 0.147
041396 1F 00 00    0952*       dl 0x00001F ; 172.969 7B, 0.122
041399 19 00 00    0953*       dl 0x000019 ; 174.375 7C, 0.098
04139C 12 00 00    0954*       dl 0x000012 ; 175.781 7D, 0.074
04139F 0C 00 00    0955*       dl 0x00000C ; 177.188 7E, 0.049
0413A2 06 00 00    0956*       dl 0x000006 ; 178.594 7F, 0.025
0413A5 00 00 00    0957*       dl 0x000000 ; 180.000 80, 0.000
0413A8 FA FF FF    0958*       dl 0xFFFFFA ; 181.406 81, -0.025
0413AB F4 FF FF    0959*       dl 0xFFFFF4 ; 182.813 82, -0.049
0413AE EE FF FF    0960*       dl 0xFFFFEE ; 184.219 83, -0.074
0413B1 E7 FF FF    0961*       dl 0xFFFFE7 ; 185.625 84, -0.098
0413B4 E1 FF FF    0962*       dl 0xFFFFE1 ; 187.031 85, -0.122
0413B7 DB FF FF    0963*       dl 0xFFFFDB ; 188.438 86, -0.147
0413BA D5 FF FF    0964*       dl 0xFFFFD5 ; 189.844 87, -0.171
0413BD CF FF FF    0965*       dl 0xFFFFCF ; 191.250 88, -0.195
0413C0 C8 FF FF    0966*       dl 0xFFFFC8 ; 192.656 89, -0.219
0413C3 C2 FF FF    0967*       dl 0xFFFFC2 ; 194.063 8A, -0.243
0413C6 BC FF FF    0968*       dl 0xFFFFBC ; 195.469 8B, -0.267
0413C9 B6 FF FF    0969*       dl 0xFFFFB6 ; 196.875 8C, -0.290
0413CC B0 FF FF    0970*       dl 0xFFFFB0 ; 198.281 8D, -0.314
0413CF AA FF FF    0971*       dl 0xFFFFAA ; 199.688 8E, -0.337
0413D2 A4 FF FF    0972*       dl 0xFFFFA4 ; 201.094 8F, -0.360
0413D5 9F FF FF    0973*       dl 0xFFFF9F ; 202.500 90, -0.383
0413D8 99 FF FF    0974*       dl 0xFFFF99 ; 203.906 91, -0.405
0413DB 93 FF FF    0975*       dl 0xFFFF93 ; 205.313 92, -0.428
0413DE 8D FF FF    0976*       dl 0xFFFF8D ; 206.719 93, -0.450
0413E1 88 FF FF    0977*       dl 0xFFFF88 ; 208.125 94, -0.471
0413E4 82 FF FF    0978*       dl 0xFFFF82 ; 209.531 95, -0.493
0413E7 7D FF FF    0979*       dl 0xFFFF7D ; 210.938 96, -0.514
0413EA 78 FF FF    0980*       dl 0xFFFF78 ; 212.344 97, -0.535
0413ED 72 FF FF    0981*       dl 0xFFFF72 ; 213.750 98, -0.556
0413F0 6D FF FF    0982*       dl 0xFFFF6D ; 215.156 99, -0.576
0413F3 68 FF FF    0983*       dl 0xFFFF68 ; 216.563 9A, -0.596
0413F6 63 FF FF    0984*       dl 0xFFFF63 ; 217.969 9B, -0.615
0413F9 5E FF FF    0985*       dl 0xFFFF5E ; 219.375 9C, -0.634
0413FC 59 FF FF    0986*       dl 0xFFFF59 ; 220.781 9D, -0.653
0413FF 55 FF FF    0987*       dl 0xFFFF55 ; 222.188 9E, -0.672
041402 50 FF FF    0988*       dl 0xFFFF50 ; 223.594 9F, -0.690
041405 4B FF FF    0989*       dl 0xFFFF4B ; 225.000 A0, -0.707
041408 47 FF FF    0990*       dl 0xFFFF47 ; 226.406 A1, -0.724
04140B 43 FF FF    0991*       dl 0xFFFF43 ; 227.813 A2, -0.741
04140E 3F FF FF    0992*       dl 0xFFFF3F ; 229.219 A3, -0.757
041411 3B FF FF    0993*       dl 0xFFFF3B ; 230.625 A4, -0.773
041414 37 FF FF    0994*       dl 0xFFFF37 ; 232.031 A5, -0.788
041417 33 FF FF    0995*       dl 0xFFFF33 ; 233.438 A6, -0.803
04141A 2F FF FF    0996*       dl 0xFFFF2F ; 234.844 A7, -0.818
04141D 2C FF FF    0997*       dl 0xFFFF2C ; 236.250 A8, -0.831
041420 28 FF FF    0998*       dl 0xFFFF28 ; 237.656 A9, -0.845
041423 25 FF FF    0999*       dl 0xFFFF25 ; 239.063 AA, -0.858
041426 22 FF FF    1000*       dl 0xFFFF22 ; 240.469 AB, -0.870
041429 1F FF FF    1001*       dl 0xFFFF1F ; 241.875 AC, -0.882
04142C 1C FF FF    1002*       dl 0xFFFF1C ; 243.281 AD, -0.893
04142F 19 FF FF    1003*       dl 0xFFFF19 ; 244.688 AE, -0.904
041432 16 FF FF    1004*       dl 0xFFFF16 ; 246.094 AF, -0.914
041435 14 FF FF    1005*       dl 0xFFFF14 ; 247.500 B0, -0.924
041438 12 FF FF    1006*       dl 0xFFFF12 ; 248.906 B1, -0.933
04143B 0F FF FF    1007*       dl 0xFFFF0F ; 250.313 B2, -0.942
04143E 0D FF FF    1008*       dl 0xFFFF0D ; 251.719 B3, -0.950
041441 0C FF FF    1009*       dl 0xFFFF0C ; 253.125 B4, -0.957
041444 0A FF FF    1010*       dl 0xFFFF0A ; 254.531 B5, -0.964
041447 08 FF FF    1011*       dl 0xFFFF08 ; 255.938 B6, -0.970
04144A 07 FF FF    1012*       dl 0xFFFF07 ; 257.344 B7, -0.976
04144D 05 FF FF    1013*       dl 0xFFFF05 ; 258.750 B8, -0.981
041450 04 FF FF    1014*       dl 0xFFFF04 ; 260.156 B9, -0.985
041453 03 FF FF    1015*       dl 0xFFFF03 ; 261.563 BA, -0.989
041456 02 FF FF    1016*       dl 0xFFFF02 ; 262.969 BB, -0.992
041459 02 FF FF    1017*       dl 0xFFFF02 ; 264.375 BC, -0.995
04145C 01 FF FF    1018*       dl 0xFFFF01 ; 265.781 BD, -0.997
04145F 01 FF FF    1019*       dl 0xFFFF01 ; 267.188 BE, -0.999
041462 01 FF FF    1020*       dl 0xFFFF01 ; 268.594 BF, -1.000
041465 00 FF FF    1021*       dl 0xFFFF00 ; 270.000 C0, -1.000
041468 01 FF FF    1022*       dl 0xFFFF01 ; 271.406 C1, -1.000
04146B 01 FF FF    1023*       dl 0xFFFF01 ; 272.813 C2, -0.999
04146E 01 FF FF    1024*       dl 0xFFFF01 ; 274.219 C3, -0.997
041471 02 FF FF    1025*       dl 0xFFFF02 ; 275.625 C4, -0.995
041474 02 FF FF    1026*       dl 0xFFFF02 ; 277.031 C5, -0.992
041477 03 FF FF    1027*       dl 0xFFFF03 ; 278.438 C6, -0.989
04147A 04 FF FF    1028*       dl 0xFFFF04 ; 279.844 C7, -0.985
04147D 05 FF FF    1029*       dl 0xFFFF05 ; 281.250 C8, -0.981
041480 07 FF FF    1030*       dl 0xFFFF07 ; 282.656 C9, -0.976
041483 08 FF FF    1031*       dl 0xFFFF08 ; 284.063 CA, -0.970
041486 0A FF FF    1032*       dl 0xFFFF0A ; 285.469 CB, -0.964
041489 0C FF FF    1033*       dl 0xFFFF0C ; 286.875 CC, -0.957
04148C 0D FF FF    1034*       dl 0xFFFF0D ; 288.281 CD, -0.950
04148F 0F FF FF    1035*       dl 0xFFFF0F ; 289.688 CE, -0.942
041492 12 FF FF    1036*       dl 0xFFFF12 ; 291.094 CF, -0.933
041495 14 FF FF    1037*       dl 0xFFFF14 ; 292.500 D0, -0.924
041498 16 FF FF    1038*       dl 0xFFFF16 ; 293.906 D1, -0.914
04149B 19 FF FF    1039*       dl 0xFFFF19 ; 295.313 D2, -0.904
04149E 1C FF FF    1040*       dl 0xFFFF1C ; 296.719 D3, -0.893
0414A1 1F FF FF    1041*       dl 0xFFFF1F ; 298.125 D4, -0.882
0414A4 22 FF FF    1042*       dl 0xFFFF22 ; 299.531 D5, -0.870
0414A7 25 FF FF    1043*       dl 0xFFFF25 ; 300.938 D6, -0.858
0414AA 28 FF FF    1044*       dl 0xFFFF28 ; 302.344 D7, -0.845
0414AD 2C FF FF    1045*       dl 0xFFFF2C ; 303.750 D8, -0.831
0414B0 2F FF FF    1046*       dl 0xFFFF2F ; 305.156 D9, -0.818
0414B3 33 FF FF    1047*       dl 0xFFFF33 ; 306.563 DA, -0.803
0414B6 37 FF FF    1048*       dl 0xFFFF37 ; 307.969 DB, -0.788
0414B9 3B FF FF    1049*       dl 0xFFFF3B ; 309.375 DC, -0.773
0414BC 3F FF FF    1050*       dl 0xFFFF3F ; 310.781 DD, -0.757
0414BF 43 FF FF    1051*       dl 0xFFFF43 ; 312.188 DE, -0.741
0414C2 47 FF FF    1052*       dl 0xFFFF47 ; 313.594 DF, -0.724
0414C5 4B FF FF    1053*       dl 0xFFFF4B ; 315.000 E0, -0.707
0414C8 50 FF FF    1054*       dl 0xFFFF50 ; 316.406 E1, -0.690
0414CB 55 FF FF    1055*       dl 0xFFFF55 ; 317.813 E2, -0.672
0414CE 59 FF FF    1056*       dl 0xFFFF59 ; 319.219 E3, -0.653
0414D1 5E FF FF    1057*       dl 0xFFFF5E ; 320.625 E4, -0.634
0414D4 63 FF FF    1058*       dl 0xFFFF63 ; 322.031 E5, -0.615
0414D7 68 FF FF    1059*       dl 0xFFFF68 ; 323.438 E6, -0.596
0414DA 6D FF FF    1060*       dl 0xFFFF6D ; 324.844 E7, -0.576
0414DD 72 FF FF    1061*       dl 0xFFFF72 ; 326.250 E8, -0.556
0414E0 78 FF FF    1062*       dl 0xFFFF78 ; 327.656 E9, -0.535
0414E3 7D FF FF    1063*       dl 0xFFFF7D ; 329.063 EA, -0.514
0414E6 82 FF FF    1064*       dl 0xFFFF82 ; 330.469 EB, -0.493
0414E9 88 FF FF    1065*       dl 0xFFFF88 ; 331.875 EC, -0.471
0414EC 8D FF FF    1066*       dl 0xFFFF8D ; 333.281 ED, -0.450
0414EF 93 FF FF    1067*       dl 0xFFFF93 ; 334.688 EE, -0.428
0414F2 99 FF FF    1068*       dl 0xFFFF99 ; 336.094 EF, -0.405
0414F5 9F FF FF    1069*       dl 0xFFFF9F ; 337.500 F0, -0.383
0414F8 A4 FF FF    1070*       dl 0xFFFFA4 ; 338.906 F1, -0.360
0414FB AA FF FF    1071*       dl 0xFFFFAA ; 340.313 F2, -0.337
0414FE B0 FF FF    1072*       dl 0xFFFFB0 ; 341.719 F3, -0.314
041501 B6 FF FF    1073*       dl 0xFFFFB6 ; 343.125 F4, -0.290
041504 BC FF FF    1074*       dl 0xFFFFBC ; 344.531 F5, -0.267
041507 C2 FF FF    1075*       dl 0xFFFFC2 ; 345.938 F6, -0.243
04150A C8 FF FF    1076*       dl 0xFFFFC8 ; 347.344 F7, -0.219
04150D CF FF FF    1077*       dl 0xFFFFCF ; 348.750 F8, -0.195
041510 D5 FF FF    1078*       dl 0xFFFFD5 ; 350.156 F9, -0.171
041513 DB FF FF    1079*       dl 0xFFFFDB ; 351.563 FA, -0.147
041516 E1 FF FF    1080*       dl 0xFFFFE1 ; 352.969 FB, -0.122
041519 E7 FF FF    1081*       dl 0xFFFFE7 ; 354.375 FC, -0.098
04151C EE FF FF    1082*       dl 0xFFFFEE ; 355.781 FD, -0.074
04151F F4 FF FF    1083*       dl 0xFFFFF4 ; 357.188 FE, -0.049
041522 FA FF FF    1084*       dl 0xFFFFFA ; 358.594 FF, -0.025
041525 00 00 00    1085*       dl 0x000000 ; 0.000 00, 0.000 for interpolation
041528             1086*   
041528             1087*   atan_lut_168:
041528 00 00 00    1088*       dl 0x000000 ; 000000, 0.000
04152B 28 00 00    1089*       dl 0x000028 ; 000001, 0.224
04152E 51 00 00    1090*       dl 0x000051 ; 000002, 0.448
041531 7A 00 00    1091*       dl 0x00007A ; 000003, 0.671
041534 A2 00 00    1092*       dl 0x0000A2 ; 000004, 0.895
041537 CB 00 00    1093*       dl 0x0000CB ; 000005, 1.119
04153A F4 00 00    1094*       dl 0x0000F4 ; 000006, 1.343
04153D 1D 01 00    1095*       dl 0x00011D ; 000007, 1.566
041540 45 01 00    1096*       dl 0x000145 ; 000008, 1.790
041543 6E 01 00    1097*       dl 0x00016E ; 000009, 2.013
041546 97 01 00    1098*       dl 0x000197 ; 00000A, 2.237
041549 BF 01 00    1099*       dl 0x0001BF ; 00000B, 2.460
04154C E8 01 00    1100*       dl 0x0001E8 ; 00000C, 2.684
04154F 11 02 00    1101*       dl 0x000211 ; 00000D, 2.907
041552 39 02 00    1102*       dl 0x000239 ; 00000E, 3.130
041555 62 02 00    1103*       dl 0x000262 ; 00000F, 3.353
041558 8B 02 00    1104*       dl 0x00028B ; 000010, 3.576
04155B B3 02 00    1105*       dl 0x0002B3 ; 000011, 3.799
04155E DC 02 00    1106*       dl 0x0002DC ; 000012, 4.022
041561 04 03 00    1107*       dl 0x000304 ; 000013, 4.245
041564 2D 03 00    1108*       dl 0x00032D ; 000014, 4.467
041567 55 03 00    1109*       dl 0x000355 ; 000015, 4.690
04156A 7E 03 00    1110*       dl 0x00037E ; 000016, 4.912
04156D A6 03 00    1111*       dl 0x0003A6 ; 000017, 5.134
041570 CE 03 00    1112*       dl 0x0003CE ; 000018, 5.356
041573 F7 03 00    1113*       dl 0x0003F7 ; 000019, 5.578
041576 1F 04 00    1114*       dl 0x00041F ; 00001A, 5.799
041579 48 04 00    1115*       dl 0x000448 ; 00001B, 6.021
04157C 70 04 00    1116*       dl 0x000470 ; 00001C, 6.242
04157F 98 04 00    1117*       dl 0x000498 ; 00001D, 6.463
041582 C0 04 00    1118*       dl 0x0004C0 ; 00001E, 6.684
041585 E8 04 00    1119*       dl 0x0004E8 ; 00001F, 6.905
041588 11 05 00    1120*       dl 0x000511 ; 000020, 7.125
04158B 39 05 00    1121*       dl 0x000539 ; 000021, 7.345
04158E 61 05 00    1122*       dl 0x000561 ; 000022, 7.565
041591 89 05 00    1123*       dl 0x000589 ; 000023, 7.785
041594 B1 05 00    1124*       dl 0x0005B1 ; 000024, 8.005
041597 D9 05 00    1125*       dl 0x0005D9 ; 000025, 8.224
04159A 01 06 00    1126*       dl 0x000601 ; 000026, 8.443
04159D 28 06 00    1127*       dl 0x000628 ; 000027, 8.662
0415A0 50 06 00    1128*       dl 0x000650 ; 000028, 8.881
0415A3 78 06 00    1129*       dl 0x000678 ; 000029, 9.099
0415A6 A0 06 00    1130*       dl 0x0006A0 ; 00002A, 9.317
0415A9 C7 06 00    1131*       dl 0x0006C7 ; 00002B, 9.535
0415AC EF 06 00    1132*       dl 0x0006EF ; 00002C, 9.752
0415AF 16 07 00    1133*       dl 0x000716 ; 00002D, 9.970
0415B2 3E 07 00    1134*       dl 0x00073E ; 00002E, 10.187
0415B5 65 07 00    1135*       dl 0x000765 ; 00002F, 10.403
0415B8 8D 07 00    1136*       dl 0x00078D ; 000030, 10.620
0415BB B4 07 00    1137*       dl 0x0007B4 ; 000031, 10.836
0415BE DB 07 00    1138*       dl 0x0007DB ; 000032, 11.051
0415C1 03 08 00    1139*       dl 0x000803 ; 000033, 11.267
0415C4 2A 08 00    1140*       dl 0x00082A ; 000034, 11.482
0415C7 51 08 00    1141*       dl 0x000851 ; 000035, 11.697
0415CA 78 08 00    1142*       dl 0x000878 ; 000036, 11.911
0415CD 9F 08 00    1143*       dl 0x00089F ; 000037, 12.125
0415D0 C6 08 00    1144*       dl 0x0008C6 ; 000038, 12.339
0415D3 ED 08 00    1145*       dl 0x0008ED ; 000039, 12.553
0415D6 13 09 00    1146*       dl 0x000913 ; 00003A, 12.766
0415D9 3A 09 00    1147*       dl 0x00093A ; 00003B, 12.978
0415DC 61 09 00    1148*       dl 0x000961 ; 00003C, 13.191
0415DF 87 09 00    1149*       dl 0x000987 ; 00003D, 13.403
0415E2 AE 09 00    1150*       dl 0x0009AE ; 00003E, 13.614
0415E5 D4 09 00    1151*       dl 0x0009D4 ; 00003F, 13.825
0415E8 FB 09 00    1152*       dl 0x0009FB ; 000040, 14.036
0415EB 21 0A 00    1153*       dl 0x000A21 ; 000041, 14.247
0415EE 47 0A 00    1154*       dl 0x000A47 ; 000042, 14.457
0415F1 6D 0A 00    1155*       dl 0x000A6D ; 000043, 14.666
0415F4 94 0A 00    1156*       dl 0x000A94 ; 000044, 14.876
0415F7 BA 0A 00    1157*       dl 0x000ABA ; 000045, 15.085
0415FA E0 0A 00    1158*       dl 0x000AE0 ; 000046, 15.293
0415FD 05 0B 00    1159*       dl 0x000B05 ; 000047, 15.501
041600 2B 0B 00    1160*       dl 0x000B2B ; 000048, 15.709
041603 51 0B 00    1161*       dl 0x000B51 ; 000049, 15.916
041606 77 0B 00    1162*       dl 0x000B77 ; 00004A, 16.123
041609 9C 0B 00    1163*       dl 0x000B9C ; 00004B, 16.329
04160C C2 0B 00    1164*       dl 0x000BC2 ; 00004C, 16.535
04160F E7 0B 00    1165*       dl 0x000BE7 ; 00004D, 16.740
041612 0C 0C 00    1166*       dl 0x000C0C ; 00004E, 16.945
041615 32 0C 00    1167*       dl 0x000C32 ; 00004F, 17.150
041618 57 0C 00    1168*       dl 0x000C57 ; 000050, 17.354
04161B 7C 0C 00    1169*       dl 0x000C7C ; 000051, 17.558
04161E A1 0C 00    1170*       dl 0x000CA1 ; 000052, 17.761
041621 C6 0C 00    1171*       dl 0x000CC6 ; 000053, 17.964
041624 EB 0C 00    1172*       dl 0x000CEB ; 000054, 18.166
041627 0F 0D 00    1173*       dl 0x000D0F ; 000055, 18.368
04162A 34 0D 00    1174*       dl 0x000D34 ; 000056, 18.569
04162D 58 0D 00    1175*       dl 0x000D58 ; 000057, 18.770
041630 7D 0D 00    1176*       dl 0x000D7D ; 000058, 18.970
041633 A1 0D 00    1177*       dl 0x000DA1 ; 000059, 19.170
041636 C6 0D 00    1178*       dl 0x000DC6 ; 00005A, 19.370
041639 EA 0D 00    1179*       dl 0x000DEA ; 00005B, 19.569
04163C 0E 0E 00    1180*       dl 0x000E0E ; 00005C, 19.767
04163F 32 0E 00    1181*       dl 0x000E32 ; 00005D, 19.965
041642 56 0E 00    1182*       dl 0x000E56 ; 00005E, 20.163
041645 7A 0E 00    1183*       dl 0x000E7A ; 00005F, 20.360
041648 9E 0E 00    1184*       dl 0x000E9E ; 000060, 20.556
04164B C1 0E 00    1185*       dl 0x000EC1 ; 000061, 20.752
04164E E5 0E 00    1186*       dl 0x000EE5 ; 000062, 20.947
041651 08 0F 00    1187*       dl 0x000F08 ; 000063, 21.142
041654 2C 0F 00    1188*       dl 0x000F2C ; 000064, 21.337
041657 4F 0F 00    1189*       dl 0x000F4F ; 000065, 21.531
04165A 72 0F 00    1190*       dl 0x000F72 ; 000066, 21.724
04165D 95 0F 00    1191*       dl 0x000F95 ; 000067, 21.917
041660 B8 0F 00    1192*       dl 0x000FB8 ; 000068, 22.109
041663 DB 0F 00    1193*       dl 0x000FDB ; 000069, 22.301
041666 FE 0F 00    1194*       dl 0x000FFE ; 00006A, 22.493
041669 21 10 00    1195*       dl 0x001021 ; 00006B, 22.683
04166C 44 10 00    1196*       dl 0x001044 ; 00006C, 22.874
04166F 66 10 00    1197*       dl 0x001066 ; 00006D, 23.063
041672 89 10 00    1198*       dl 0x001089 ; 00006E, 23.253
041675 AB 10 00    1199*       dl 0x0010AB ; 00006F, 23.441
041678 CD 10 00    1200*       dl 0x0010CD ; 000070, 23.629
04167B EF 10 00    1201*       dl 0x0010EF ; 000071, 23.817
04167E 11 11 00    1202*       dl 0x001111 ; 000072, 24.004
041681 33 11 00    1203*       dl 0x001133 ; 000073, 24.191
041684 55 11 00    1204*       dl 0x001155 ; 000074, 24.376
041687 77 11 00    1205*       dl 0x001177 ; 000075, 24.562
04168A 99 11 00    1206*       dl 0x001199 ; 000076, 24.747
04168D BA 11 00    1207*       dl 0x0011BA ; 000077, 24.931
041690 DC 11 00    1208*       dl 0x0011DC ; 000078, 25.115
041693 FD 11 00    1209*       dl 0x0011FD ; 000079, 25.298
041696 1E 12 00    1210*       dl 0x00121E ; 00007A, 25.481
041699 3F 12 00    1211*       dl 0x00123F ; 00007B, 25.663
04169C 60 12 00    1212*       dl 0x001260 ; 00007C, 25.844
04169F 81 12 00    1213*       dl 0x001281 ; 00007D, 26.025
0416A2 A2 12 00    1214*       dl 0x0012A2 ; 00007E, 26.206
0416A5 C3 12 00    1215*       dl 0x0012C3 ; 00007F, 26.386
0416A8 E4 12 00    1216*       dl 0x0012E4 ; 000080, 26.565
0416AB 04 13 00    1217*       dl 0x001304 ; 000081, 26.744
0416AE 25 13 00    1218*       dl 0x001325 ; 000082, 26.922
0416B1 45 13 00    1219*       dl 0x001345 ; 000083, 27.100
0416B4 65 13 00    1220*       dl 0x001365 ; 000084, 27.277
0416B7 85 13 00    1221*       dl 0x001385 ; 000085, 27.453
0416BA A5 13 00    1222*       dl 0x0013A5 ; 000086, 27.629
0416BD C5 13 00    1223*       dl 0x0013C5 ; 000087, 27.805
0416C0 E5 13 00    1224*       dl 0x0013E5 ; 000088, 27.979
0416C3 05 14 00    1225*       dl 0x001405 ; 000089, 28.154
0416C6 24 14 00    1226*       dl 0x001424 ; 00008A, 28.327
0416C9 44 14 00    1227*       dl 0x001444 ; 00008B, 28.501
0416CC 63 14 00    1228*       dl 0x001463 ; 00008C, 28.673
0416CF 83 14 00    1229*       dl 0x001483 ; 00008D, 28.845
0416D2 A2 14 00    1230*       dl 0x0014A2 ; 00008E, 29.017
0416D5 C1 14 00    1231*       dl 0x0014C1 ; 00008F, 29.187
0416D8 E0 14 00    1232*       dl 0x0014E0 ; 000090, 29.358
0416DB FF 14 00    1233*       dl 0x0014FF ; 000091, 29.527
0416DE 1E 15 00    1234*       dl 0x00151E ; 000092, 29.697
0416E1 3C 15 00    1235*       dl 0x00153C ; 000093, 29.865
0416E4 5B 15 00    1236*       dl 0x00155B ; 000094, 30.033
0416E7 79 15 00    1237*       dl 0x001579 ; 000095, 30.201
0416EA 98 15 00    1238*       dl 0x001598 ; 000096, 30.368
0416ED B6 15 00    1239*       dl 0x0015B6 ; 000097, 30.534
0416F0 D4 15 00    1240*       dl 0x0015D4 ; 000098, 30.700
0416F3 F2 15 00    1241*       dl 0x0015F2 ; 000099, 30.865
0416F6 10 16 00    1242*       dl 0x001610 ; 00009A, 31.030
0416F9 2E 16 00    1243*       dl 0x00162E ; 00009B, 31.194
0416FC 4C 16 00    1244*       dl 0x00164C ; 00009C, 31.357
0416FF 6A 16 00    1245*       dl 0x00166A ; 00009D, 31.520
041702 87 16 00    1246*       dl 0x001687 ; 00009E, 31.682
041705 A5 16 00    1247*       dl 0x0016A5 ; 00009F, 31.844
041708 C2 16 00    1248*       dl 0x0016C2 ; 0000A0, 32.005
04170B DF 16 00    1249*       dl 0x0016DF ; 0000A1, 32.166
04170E FC 16 00    1250*       dl 0x0016FC ; 0000A2, 32.326
041711 19 17 00    1251*       dl 0x001719 ; 0000A3, 32.486
041714 36 17 00    1252*       dl 0x001736 ; 0000A4, 32.645
041717 53 17 00    1253*       dl 0x001753 ; 0000A5, 32.803
04171A 70 17 00    1254*       dl 0x001770 ; 0000A6, 32.961
04171D 8C 17 00    1255*       dl 0x00178C ; 0000A7, 33.118
041720 A9 17 00    1256*       dl 0x0017A9 ; 0000A8, 33.275
041723 C5 17 00    1257*       dl 0x0017C5 ; 0000A9, 33.431
041726 E2 17 00    1258*       dl 0x0017E2 ; 0000AA, 33.587
041729 FE 17 00    1259*       dl 0x0017FE ; 0000AB, 33.742
04172C 1A 18 00    1260*       dl 0x00181A ; 0000AC, 33.896
04172F 36 18 00    1261*       dl 0x001836 ; 0000AD, 34.050
041732 52 18 00    1262*       dl 0x001852 ; 0000AE, 34.203
041735 6E 18 00    1263*       dl 0x00186E ; 0000AF, 34.356
041738 8A 18 00    1264*       dl 0x00188A ; 0000B0, 34.509
04173B A5 18 00    1265*       dl 0x0018A5 ; 0000B1, 34.660
04173E C1 18 00    1266*       dl 0x0018C1 ; 0000B2, 34.811
041741 DC 18 00    1267*       dl 0x0018DC ; 0000B3, 34.962
041744 F7 18 00    1268*       dl 0x0018F7 ; 0000B4, 35.112
041747 13 19 00    1269*       dl 0x001913 ; 0000B5, 35.262
04174A 2E 19 00    1270*       dl 0x00192E ; 0000B6, 35.410
04174D 49 19 00    1271*       dl 0x001949 ; 0000B7, 35.559
041750 64 19 00    1272*       dl 0x001964 ; 0000B8, 35.707
041753 7F 19 00    1273*       dl 0x00197F ; 0000B9, 35.854
041756 99 19 00    1274*       dl 0x001999 ; 0000BA, 36.001
041759 B4 19 00    1275*       dl 0x0019B4 ; 0000BB, 36.147
04175C CE 19 00    1276*       dl 0x0019CE ; 0000BC, 36.293
04175F E9 19 00    1277*       dl 0x0019E9 ; 0000BD, 36.438
041762 03 1A 00    1278*       dl 0x001A03 ; 0000BE, 36.582
041765 1D 1A 00    1279*       dl 0x001A1D ; 0000BF, 36.726
041768 37 1A 00    1280*       dl 0x001A37 ; 0000C0, 36.870
04176B 51 1A 00    1281*       dl 0x001A51 ; 0000C1, 37.013
04176E 6B 1A 00    1282*       dl 0x001A6B ; 0000C2, 37.155
041771 85 1A 00    1283*       dl 0x001A85 ; 0000C3, 37.297
041774 9F 1A 00    1284*       dl 0x001A9F ; 0000C4, 37.439
041777 B9 1A 00    1285*       dl 0x001AB9 ; 0000C5, 37.579
04177A D2 1A 00    1286*       dl 0x001AD2 ; 0000C6, 37.720
04177D EC 1A 00    1287*       dl 0x001AEC ; 0000C7, 37.859
041780 05 1B 00    1288*       dl 0x001B05 ; 0000C8, 37.999
041783 1E 1B 00    1289*       dl 0x001B1E ; 0000C9, 38.137
041786 37 1B 00    1290*       dl 0x001B37 ; 0000CA, 38.276
041789 50 1B 00    1291*       dl 0x001B50 ; 0000CB, 38.413
04178C 69 1B 00    1292*       dl 0x001B69 ; 0000CC, 38.550
04178F 82 1B 00    1293*       dl 0x001B82 ; 0000CD, 38.687
041792 9B 1B 00    1294*       dl 0x001B9B ; 0000CE, 38.823
041795 B4 1B 00    1295*       dl 0x001BB4 ; 0000CF, 38.959
041798 CC 1B 00    1296*       dl 0x001BCC ; 0000D0, 39.094
04179B E5 1B 00    1297*       dl 0x001BE5 ; 0000D1, 39.228
04179E FD 1B 00    1298*       dl 0x001BFD ; 0000D2, 39.362
0417A1 16 1C 00    1299*       dl 0x001C16 ; 0000D3, 39.496
0417A4 2E 1C 00    1300*       dl 0x001C2E ; 0000D4, 39.629
0417A7 46 1C 00    1301*       dl 0x001C46 ; 0000D5, 39.762
0417AA 5E 1C 00    1302*       dl 0x001C5E ; 0000D6, 39.894
0417AD 76 1C 00    1303*       dl 0x001C76 ; 0000D7, 40.025
0417B0 8E 1C 00    1304*       dl 0x001C8E ; 0000D8, 40.156
0417B3 A5 1C 00    1305*       dl 0x001CA5 ; 0000D9, 40.286
0417B6 BD 1C 00    1306*       dl 0x001CBD ; 0000DA, 40.416
0417B9 D5 1C 00    1307*       dl 0x001CD5 ; 0000DB, 40.546
0417BC EC 1C 00    1308*       dl 0x001CEC ; 0000DC, 40.675
0417BF 04 1D 00    1309*       dl 0x001D04 ; 0000DD, 40.803
0417C2 1B 1D 00    1310*       dl 0x001D1B ; 0000DE, 40.931
0417C5 32 1D 00    1311*       dl 0x001D32 ; 0000DF, 41.059
0417C8 49 1D 00    1312*       dl 0x001D49 ; 0000E0, 41.186
0417CB 60 1D 00    1313*       dl 0x001D60 ; 0000E1, 41.312
0417CE 77 1D 00    1314*       dl 0x001D77 ; 0000E2, 41.438
0417D1 8E 1D 00    1315*       dl 0x001D8E ; 0000E3, 41.564
0417D4 A5 1D 00    1316*       dl 0x001DA5 ; 0000E4, 41.689
0417D7 BB 1D 00    1317*       dl 0x001DBB ; 0000E5, 41.814
0417DA D2 1D 00    1318*       dl 0x001DD2 ; 0000E6, 41.938
0417DD E9 1D 00    1319*       dl 0x001DE9 ; 0000E7, 42.061
0417E0 FF 1D 00    1320*       dl 0x001DFF ; 0000E8, 42.184
0417E3 15 1E 00    1321*       dl 0x001E15 ; 0000E9, 42.307
0417E6 2C 1E 00    1322*       dl 0x001E2C ; 0000EA, 42.429
0417E9 42 1E 00    1323*       dl 0x001E42 ; 0000EB, 42.551
0417EC 58 1E 00    1324*       dl 0x001E58 ; 0000EC, 42.672
0417EF 6E 1E 00    1325*       dl 0x001E6E ; 0000ED, 42.793
0417F2 84 1E 00    1326*       dl 0x001E84 ; 0000EE, 42.913
0417F5 99 1E 00    1327*       dl 0x001E99 ; 0000EF, 43.033
0417F8 AF 1E 00    1328*       dl 0x001EAF ; 0000F0, 43.152
0417FB C5 1E 00    1329*       dl 0x001EC5 ; 0000F1, 43.271
0417FE DA 1E 00    1330*       dl 0x001EDA ; 0000F2, 43.390
041801 F0 1E 00    1331*       dl 0x001EF0 ; 0000F3, 43.508
041804 05 1F 00    1332*       dl 0x001F05 ; 0000F4, 43.625
041807 1B 1F 00    1333*       dl 0x001F1B ; 0000F5, 43.742
04180A 30 1F 00    1334*       dl 0x001F30 ; 0000F6, 43.859
04180D 45 1F 00    1335*       dl 0x001F45 ; 0000F7, 43.975
041810 5A 1F 00    1336*       dl 0x001F5A ; 0000F8, 44.091
041813 6F 1F 00    1337*       dl 0x001F6F ; 0000F9, 44.206
041816 84 1F 00    1338*       dl 0x001F84 ; 0000FA, 44.321
041819 99 1F 00    1339*       dl 0x001F99 ; 0000FB, 44.435
04181C AD 1F 00    1340*       dl 0x001FAD ; 0000FC, 44.549
04181F C2 1F 00    1341*       dl 0x001FC2 ; 0000FD, 44.662
041822 D7 1F 00    1342*       dl 0x001FD7 ; 0000FE, 44.775
041825 EB 1F 00    1343*       dl 0x001FEB ; 0000FF, 44.888
041828 00 20 00    1344*       dl 0x002000 ; 000100, 45.000 only needed for interpolation
04182B             0037        include "time.inc"
04182B             0001*   ; Convert seconds to HH:MM:SS format.
04182B             0002*   ; inputs: hl = seconds
04182B             0003*   ; outputs: hl = pointer to zero-terminated string representation of HH:MM:SS
04182B             0004*   ; destroys: a,bc,de
04182B             0005*   seconds_to_hhmmss:
04182B             0006*   ; Divide the total seconds into hours, minutes, and seconds.
04182B             0007*   ; Hours = Total seconds ÷ 3600.
04182B 11 10 0E 00 0008*       ld de,3600
04182F CD 80 03 04 0009*       call udiv24 ; de = hours, hl = remaining seconds
041833 E5          0010*       push hl ; save remainder
041834 EB          0011*       ex de,hl ; hl = hours
041835 11 8E 18 04 0012*       ld de,@bin2asc
041839 CD 28 01 04 0013*       call u8_to_ascii ; answer in @bin2asc
04183D 3A 90 18 04 0014*       ld a,(@bin2asc+2)
041841 32 98 18 04 0015*       ld (hhmmss+0),a
041845 3A 91 18 04 0016*       ld a,(@bin2asc+3)
041849 32 99 18 04 0017*       ld (hhmmss+1),a
04184D             0018*   ; Minutes = Remaining seconds ÷ 60.
04184D E1          0019*       pop hl ; restore remainder
04184E 11 3C 00 00 0020*       ld de,60
041852 CD 80 03 04 0021*       call udiv24 ; de = minutes, hl = remaining seconds
041856 E5          0022*       push hl ; save remainder
041857 EB          0023*       ex de,hl ; hl = minutes
041858 11 8E 18 04 0024*       ld de,@bin2asc
04185C CD 28 01 04 0025*       call u8_to_ascii ; answer in @bin2asc
041860 3A 90 18 04 0026*       ld a,(@bin2asc+2)
041864 32 9B 18 04 0027*       ld (hhmmss+3),a
041868 3A 91 18 04 0028*       ld a,(@bin2asc+3)
04186C 32 9C 18 04 0029*       ld (hhmmss+4),a
041870             0030*   ; Seconds = Remaining seconds.
041870 E1          0031*       pop hl ; restore remainder
041871 11 8E 18 04 0032*       ld de,@bin2asc
041875 CD 28 01 04 0033*       call u8_to_ascii ; answer in @bin2asc
041879 3A 90 18 04 0034*       ld a,(@bin2asc+2)
04187D 32 9E 18 04 0035*       ld (hhmmss+6),a
041881 3A 91 18 04 0036*       ld a,(@bin2asc+3)
041885 32 9F 18 04 0037*       ld (hhmmss+7),a
041889 21 98 18 04 0038*       ld hl,hhmmss
04188D C9          0039*       ret
04188E 00 00 00 00 0040*   @bin2asc: blkw 5,0 ; scratch space for binary to ascii decimal conversion
       00 00 00 00 
       00 00       
041898 30 30 3A 30 0041*   hhmmss: asciz "00:00:00" ; buffer for output string
       30 3A 30 30 
       00          
0418A1             0042*   ; end seconds_to_hhmmss
0418A1             0038        include "timer.inc"
0418A1             0001*   ; Table 32. Timer Control Registers
0418A1             0002*   TMR0_CTL: equ 80h
0418A1             0003*   TMR1_CTL: equ 83h
0418A1             0004*   TMR2_CTL: equ 86h
0418A1             0005*   TMR3_CTL: equ 89h
0418A1             0006*   TMR4_CTL: equ 8Ch
0418A1             0007*   TMR5_CTL: equ 8Fh
0418A1             0008*   
0418A1             0009*   ; each timer register takes three bytes:
0418A1             0010*   ;   0: control register
0418A1             0011*   ;   1: low byte of timer reset value
0418A1             0012*   ;   2: high byte of timer reset value
0418A1             0013*   ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
0418A1             0014*   ; which correctly force the high and upper bytes of the address bus to zero
0418A1             0015*   
0418A1             0016*   TMR_REG_CTL: equ 0
0418A1             0017*   TMR_RES_LOW: equ 1
0418A1             0018*   TMR_RES_HIGH: equ 2
0418A1             0019*   
0418A1             0020*   ; Timer Control Register Bit Definitions
0418A1             0021*   PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
0418A1             0022*                               ; This bit is reset to 0 every time the TMRx_CTL register is read.
0418A1             0023*   PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
0418A1             0024*                               ; an interrupt signal is sent to the CPU. This bit remains 1 until
0418A1             0025*                               ; the TMRx_CTL register is read.
0418A1             0026*   
0418A1             0027*   IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
0418A1             0028*   IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
0418A1             0029*   
0418A1             0030*   PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
0418A1             0031*                               ;  0,and counting stops when the end-of-count value is reached.
0418A1             0032*   PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
0418A1             0033*                               ; written to the counter when the end-of-count value is reached.
0418A1             0034*   
0418A1             0035*   ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
0418A1             0036*   CLK_DIV_256:  equ %00001100 ;
0418A1             0037*   CLK_DIV_64:   equ %00001000 ;
0418A1             0038*   CLK_DIV_16:   equ %00000100 ;
0418A1             0039*   CLK_DIV_4:    equ %00000000 ;
0418A1             0040*   
0418A1             0041*   RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
0418A1             0042*   RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
0418A1             0043*                               ; When a 1 is written to this bit,the values in the reload registers
0418A1             0044*                               ;  are loaded into the downcounter when the timer restarts. The
0418A1             0045*                               ; programmer must ensure that this bit is set to 1 each time
0418A1             0046*                               ; SINGLE-PASS mode is used.
0418A1             0047*   
0418A1             0048*   ; disable/enable the programmable reload timer
0418A1             0049*   PRT_EN_0:     equ %00000000 ;
0418A1             0050*   PRT_EN_1:     equ %00000001 ;
0418A1             0051*   
0418A1             0052*   ; Table 37. Timer Input Source Select Register
0418A1             0053*   ; Each of the 4 timers are allocated two bits of the 8-bit register
0418A1             0054*   ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
0418A1             0055*   ;   00: System clock / CLK_DIV
0418A1             0056*   ;   01: RTC / CLK_DIV
0418A1             0057*   ;   NOTE: these are the values given in the manual,but it may be a typo
0418A1             0058*   ;   10: GPIO port B pin 1.
0418A1             0059*   ;   11: GPIO port B pin 1.
0418A1             0060*   TMR_ISS:   equ 92h ; register address
0418A1             0061*   
0418A1             0062*   ; Table 51. Real-Time Clock Control Register
0418A1             0063*   RTC_CTRL: equ EDh ; register address
0418A1             0064*   
0418A1             0065*   ; alarm interrupt disable/enable
0418A1             0066*   RTC_ALARM_0:    equ %00000000
0418A1             0067*   RTC_ALARM_1:    equ %10000000
0418A1             0068*   
0418A1             0069*   ; interrupt on alarm disable/enable
0418A1             0070*   RTC_INT_ENT_0:  equ %00000000
0418A1             0071*   RTC_INT_ENT_1:  equ %01000000
0418A1             0072*   
0418A1             0073*   RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
0418A1             0074*   RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
0418A1             0075*   
0418A1             0076*   RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
0418A1             0077*                                   ; On-chip 32768 Hz oscillator is enabled.
0418A1             0078*   RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
0418A1             0079*                                   ; On-chip 32768 Hz oscillator is disabled.
0418A1             0080*   
0418A1             0081*   RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
0418A1             0082*   RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
0418A1             0083*   
0418A1             0084*   RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
0418A1             0085*   RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
0418A1             0086*   
0418A1             0087*   RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
0418A1             0088*                                   ; RTC counter is enabled.
0418A1             0089*   RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
0418A1             0090*                                   ; RTC counter is disabled.
0418A1             0091*   
0418A1             0092*   ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
0418A1             0093*   
0418A1             0094*   prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
0418A1             0095*   prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
0418A1 00 00 00    0096*   prt_reload: dl 0x000000
0418A4             0097*   
0418A4             0098*   ; returns: a = 0 if running on hardware,1 if running on emulator
0418A4             0099*   ;          de = number PRT interrupts during test interval
0418A4             0100*   prt_calibrate:
0418A4 CD B3 1B 04 0101*       call vdu_vblank
0418A8             0102*   ; set a MOS timer
0418A8 21 78 00 00 0103*       ld hl,120*1 ; 1 second
0418AC FD 21 2C 1A 0104*       ld iy,tmr_test
       04          
0418B1 CD 0A 1A 04 0105*       call tmr_set
0418B5             0106*   ; set a PRT timer
0418B5             0107*       ; ld hl,prt_reload_hardware
0418B5             0108*       ; ld hl,prt_reload_emulator
0418B5 21 05 2D 00 0109*       ld hl,prt_reload_emulator + prt_reload_hardware / 2
0418B9 22 A1 18 04 0110*       ld (prt_reload),hl
0418BD CD 45 19 04 0111*       call prt_set
0418C1             0112*   @loop:
0418C1             0113*   ; check time remaining on MOS timer
0418C1 CD 18 1A 04 0114*       call tmr_get
0418C5 CA CF 18 04 0115*       jp z,@done ; time expired,so quit
0418C9 FA CF 18 04 0116*       jp m,@done ; time past expiration (negative),so quit
0418CD 18 F2       0117*       jr @loop
0418CF             0118*   @done:
0418CF ED 5B 93 19 0119*       ld de,(prt_irq_counter)
       04          
0418D4 01 0C 2D 00 0120*       ld bc,prt_reload_hardware ; default value for running on hardware
0418D8 ED 43 A1 18 0121*       ld (prt_reload),bc
       04          
0418DD 21 64 00 00 0122*       ld hl,100 ; halfway between 101 for real hardware and 99 for emulator
0418E1 AF          0123*       xor a ; clear carry,zero is default value for running on hardware
0418E2 32 04 19 04 0124*       ld (is_emulator),a
0418E6 ED 52       0125*       sbc hl,de
0418E8 21 05 19 04 0126*       ld hl,on_hardware ; default message for running on hardware
0418EC CA A4 18 04 0127*       jp z,prt_calibrate ; zero result is indeterminate so we try again
0418F0 F8          0128*       ret m ; negative result means we're on hardware
0418F1 3C          0129*       inc a ; we're on emulator
0418F2 32 04 19 04 0130*       ld (is_emulator),a
0418F6 01 FF 2C 00 0131*       ld bc,prt_reload_emulator
0418FA ED 43 A1 18 0132*       ld (prt_reload),bc
       04          
0418FF 21 1B 19 04 0133*       ld hl,on_emulator
041903 C9          0134*       ret
041904 00          0135*   is_emulator: db 0
041905 52 75 6E 6E 0136*   on_hardware: defb "Running on hardware\r\n",0
       69 6E 67 20 
       6F 6E 20 68 
       61 72 64 77 
       61 72 65 0D 
       0A 00       
04191B 52 75 6E 6E 0137*   on_emulator: defb "Running on emulator\r\n",0
       69 6E 67 20 
       6F 6E 20 65 
       6D 75 6C 61 
       74 6F 72 0D 
       0A 00       
041931             0138*   
041931 43 61 6C 69 0139*   calibrating_timer: defb "Calibrating timer\r\n",0
       62 72 61 74 
       69 6E 67 20 
       74 69 6D 65 
       72 0D 0A 00 
041945             0140*   
041945             0141*   ; set PRT timer
041945             0142*   prt_set:
041945 21 00 00 00 0143*       ld hl,0
041949 22 93 19 04 0144*       ld (prt_irq_counter),hl
04194D 2A A1 18 04 0145*       ld hl,(prt_reload)
041951 ED 29 84    0146*       out0 (TMR1_CTL+TMR_RES_LOW),l
041954 ED 21 85    0147*   	out0 (TMR1_CTL+TMR_RES_HIGH),h
041957             0148*   ; disable timer
041957 3E 06       0149*       ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
041959 ED 39 83    0150*   	out0 (TMR1_CTL+TMR_REG_CTL),a
04195C             0151*   ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
04195C 3E 57       0152*       ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
04195E ED 39 83    0153*   	out0 (TMR1_CTL+TMR_REG_CTL),a
041961 C9          0154*       ret
041962             0155*   
041962             0156*   ; ===============================================
041962             0157*   ; PRT Timer Interrupt Handling
041962             0158*   ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.asm
041962             0159*   ; -----------------------------------------------
041962             0160*   prt_irq_init:
041962             0161*       ; set up interrupt vector table 2
041962 21 00 00 00 0162*   	ld hl,0
041966 3A 0C 01 00 0163*   	ld a,($10c)
04196A 6F          0164*   	ld l,a
04196B 3A 0D 01 00 0165*   	ld a,($10d)
04196F 67          0166*   	ld h,a
041970             0167*   
041970             0168*   	; skip over CALL ($c3)
041970 23          0169*   	inc hl
041971             0170*   	; load address of jump into vector table 2 (in ram)
041971 ED 27       0171*   	ld hl,(hl)
041973             0172*   
041973             0173*   	; write CALL prt_irq_handler to vector table 2
041973 3E C3       0174*   	ld a,$c3
041975 77          0175*   	ld (hl),a
041976 23          0176*   	inc hl
041977 11 7E 19 04 0177*   	ld de,prt_irq_handler
04197B ED 1F       0178*   	ld (hl),de
04197D             0179*   
04197D C9          0180*       ret
04197E             0181*   
04197E             0182*   prt_irq_handler:
04197E F3          0183*   	di
04197F F5          0184*   	push af
041980 E5          0185*       push hl
041981 ED 38 83    0186*   	in0 a,(TMR1_CTL+TMR_REG_CTL)
041984 2A 93 19 04 0187*   	ld hl,(prt_irq_counter)
041988 23          0188*   	inc hl
041989 22 93 19 04 0189*   	ld (prt_irq_counter),hl
04198D E1          0190*       pop hl
04198E F1          0191*   	pop af
04198F FB          0192*   	ei
041990 5B ED 4D    0193*   	reti.l
041993             0194*   
041993             0195*   prt_irq_counter:
041993 00 00 00    0196*   	.dl 0
041996             0197*   prt_irq_counter_saved:
041996 00 00 00    0198*       .dl 0
041999             0199*   
041999             0200*   prt_loop_reset:
041999 E5          0201*       push hl
04199A 21 00 00 00 0202*   	ld hl,0
04199E 22 93 19 04 0203*   	ld (prt_irq_counter),hl
0419A2 22 04 1A 04 0204*       ld (prt_loop_counter),hl
0419A6 22 07 1A 04 0205*       ld (prt_loops),hl
0419AA CD 45 19 04 0206*       call prt_set
0419AE E1          0207*       pop hl
0419AF C9          0208*       ret
0419B0             0209*   
0419B0             0210*   prt_loop_start:
0419B0 E5          0211*       push hl
0419B1 21 00 00 00 0212*   	ld hl,0
0419B5 22 93 19 04 0213*   	ld (prt_irq_counter),hl
0419B9 E1          0214*       pop hl
0419BA C9          0215*       ret
0419BB             0216*   
0419BB             0217*   prt_loop_stop:
0419BB E5          0218*       push hl
0419BC D5          0219*       push de
0419BD 2A 93 19 04 0220*       ld hl,(prt_irq_counter)
0419C1 ED 5B 04 1A 0221*       ld de,(prt_loop_counter)
       04          
0419C6 19          0222*       add hl,de
0419C7 22 04 1A 04 0223*       ld (prt_loop_counter),hl
0419CB 21 00 00 00 0224*       ld hl,0
0419CF 22 93 19 04 0225*       ld (prt_irq_counter),hl
0419D3 2A 07 1A 04 0226*       ld hl,(prt_loops)
0419D7 23          0227*       inc hl
0419D8 22 07 1A 04 0228*       ld (prt_loops),hl
0419DC D1          0229*       pop de
0419DD E1          0230*       pop hl
0419DE C9          0231*       ret
0419DF             0232*   
0419DF             0233*   ; inputs: bc = y,x text coordinates to print
0419DF             0234*   prt_loop_print:
0419DF F5          0235*       push af
0419E0 E5          0236*       push hl
0419E1 C5          0237*       push bc
0419E2 D5          0238*       push de
0419E3 DD E5       0239*       push ix
0419E5 FD E5       0240*       push iy
0419E7 CD 17 1B 04 0241*       call vdu_move_cursor
0419EB             0242*   
0419EB 2A 04 1A 04 0243*       ld hl,(prt_loop_counter)
0419EF CD CC 00 04 0244*       call printDec
0419F3             0245*   
0419F3 2A 07 1A 04 0246*       ld hl,(prt_loops)
0419F7 CD CC 00 04 0247*       call printDec
0419FB             0248*   
0419FB FD E1       0249*       pop iy
0419FD DD E1       0250*       pop ix
0419FF D1          0251*       pop de
041A00 C1          0252*       pop bc
041A01 E1          0253*       pop hl
041A02 F1          0254*       pop af
041A03 C9          0255*       ret
041A04             0256*   
041A04             0257*   prt_loop_counter:
041A04 00 00 00    0258*       .dl 0
041A07             0259*   prt_loops:
041A07 00 00 00    0260*       .dl 0
041A0A             0261*   
041A0A             0262*   ; ===============================================
041A0A             0263*   ; Timer functions
041A0A             0264*   ; -----------------------------------------------
041A0A             0265*   ; set a countdown timer
041A0A             0266*   ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
041A0A             0267*   ; returns: hl = current time
041A0A             0268*   tmr_set:
041A0A FD 2F 03    0269*       ld (iy+3),hl            ; set time remaining
041A0D             0270*       MOSCALL mos_sysvars     ; ix points to syvars table
                       M1 Args: function=mos_sysvars 
041A0D 3E 08       0001*M1 			LD	A, function
041A0F 5B CF       0002*M1 			RST.LIL	08h
041A11 DD 27 00    0271*       ld hl,(ix+sysvar_time)  ; get current time
041A14 FD 2F 00    0272*       ld (iy+0),hl            ; set start time
041A17 C9          0273*       ret
041A18             0274*   
041A18             0275*   ; gets time remaining on a countdown timer
041A18             0276*   ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
041A18             0277*   ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
041A18             0278*   ;          sign flags: pos = time not expired,zero or neg = time expired
041A18             0279*   tmr_get:
041A18             0280*       MOSCALL mos_sysvars     ; ix points to syvars table
                       M1 Args: function=mos_sysvars 
041A18 3E 08       0001*M1 			LD	A, function
041A1A 5B CF       0002*M1 			RST.LIL	08h
041A1C DD 17 00    0281*       ld de,(ix+sysvar_time)  ; get current time
041A1F FD 27 00    0282*       ld hl,(iy+0)            ; get start time
041A22 AF          0283*       xor a                   ; clear carry
041A23 ED 52       0284*       sbc hl,de               ; hl = time elapsed (will always be zero or negative)
041A25 FD 17 03    0285*       ld de,(iy+3)            ; get timer set value
041A28 AF          0286*       xor a                   ; clear carry
041A29 ED 5A       0287*       adc hl,de               ; hl = time remaining
041A2B             0288*                               ; (we do adc because add hl,rr doesn't set sign or zero flags)
041A2B C9          0289*       ret
041A2C             0290*   
041A2C             0291*   tmr_test: ds 6 ; example of a buffer to hold timer data
041A32             0292*   
       FF FF FF FF 
       FF FF 
041A32 00 00 00    0293*   timestamp_now: dl 0
041A35 00 00 00    0294*   timestamp_old: dl 0
041A38 00 00 00    0295*   timestamp_chg: dl 0
041A3B             0296*   
041A3B             0297*   ; update the global timestamp from the system clock
041A3B             0298*   ; inputs: none
041A3B             0299*   ; returns: hl = time elapsed in 1/120ths of a second
041A3B             0300*   ;          de = current time
041A3B             0301*   ;          ix = pointer to syvars table
041A3B             0302*   ; destroys: af,hl,de,ix
041A3B             0303*   timestamp_tick:
041A3B ED 5B 32 1A 0304*       ld de,(timestamp_now)   ; get previous time
       04          
041A40 ED 53 35 1A 0305*       ld (timestamp_old),de   ; save previous time
       04          
041A45             0306*       MOSCALL mos_sysvars     ; ix points to syvars table
                       M1 Args: function=mos_sysvars 
041A45 3E 08       0001*M1 			LD	A, function
041A47 5B CF       0002*M1 			RST.LIL	08h
041A49 DD 27 00    0307*       ld hl,(ix+sysvar_time)  ; get current time
041A4C 22 32 1A 04 0308*       ld (timestamp_now),hl   ; save current time
041A50 AF          0309*       xor a                   ; clear carry
041A51 ED 52       0310*       sbc hl,de               ; hl = time elapsed
041A53 22 38 1A 04 0311*       ld (timestamp_chg),hl   ; save elapsed time
041A57 C9          0312*       ret
041A58             0313*   
041A58             0314*   ; set a countdown timer
041A58             0315*   ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
041A58             0316*   ; requires: timestamp_tick to be called at least once before this function
041A58             0317*   ; returns: hl = current time
041A58             0318*   ; destroys: hl
041A58             0319*   timestamp_tmr_set:
041A58 FD 2F 03    0320*       ld (iy+3),hl            ; set time remaining
041A5B 2A 32 1A 04 0321*       ld hl,(timestamp_now)   ; get current timestamp
041A5F FD 2F 00    0322*       ld (iy+0),hl            ; set start time
041A62 C9          0323*       ret
041A63             0324*   
041A63             0325*   ; gets time remaining on a countdown timer following the global timestamp
041A63             0326*   ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
041A63             0327*   ; requires: timestamp_tick to be called at least once before this function
041A63             0328*   ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
041A63             0329*   ;          sign flags: pos = time not expired,zero or neg = time expired
041A63             0330*   ; destroys: af,hl,de
041A63             0331*   timestamp_tmr_get:
041A63 ED 5B 32 1A 0332*       ld de,(timestamp_now)   ; get current timestamp
       04          
041A68 FD 27 00    0333*       ld hl,(iy+0)            ; get start time
041A6B AF          0334*       xor a                   ; clear carry
041A6C ED 52       0335*       sbc hl,de               ; hl = time elapsed (will always be zero or negative)
041A6E FD 17 03    0336*       ld de,(iy+3)            ; get timer set value
041A71 AF          0337*       xor a                   ; clear carry
041A72 ED 5A       0338*       adc hl,de               ; hl = time remaining
041A74             0339*                               ; (we do adc because add hl,rr doesn't set sign or zero flags)
041A74 C9          0340*       ret
041A75             0341*   
041A75             0342*   ; set a stopwatch
041A75             0343*   ; returns: hl = start time
041A75             0344*   ; destroys: hl,ix
041A75             0345*   stopwatch_set:
041A75             0346*       MOSCALL mos_sysvars     ; ix points to syvars table
                       M1 Args: function=mos_sysvars 
041A75 3E 08       0001*M1 			LD	A, function
041A77 5B CF       0002*M1 			RST.LIL	08h
041A79 DD 27 00    0347*       ld hl,(ix+sysvar_time)  ; get current time
041A7C 22 91 1A 04 0348*       ld (stopwatch_started),hl            ; set start time
041A80 C9          0349*       ret
041A81             0350*   
041A81             0351*   ; gets time elapsed on a stopwatch
041A81             0352*   ; returns: hl = time elapsed in 1/120ths of a second
041A81             0353*   ; destroys: af,hl,de,ix
041A81             0354*   stopwatch_get:
041A81             0355*       MOSCALL mos_sysvars     ; ix points to syvars table
                       M1 Args: function=mos_sysvars 
041A81 3E 08       0001*M1 			LD	A, function
041A83 5B CF       0002*M1 			RST.LIL	08h
041A85 DD 27 00    0356*       ld hl,(ix+sysvar_time)  ; get current time
041A88 ED 5B 91 1A 0357*       ld de,(stopwatch_started)            ; get start time
       04          
041A8D AF          0358*       xor a                   ; clear carry
041A8E ED 52       0359*       sbc hl,de               ; hl = time elapsed (will always be zero or positive)
041A90 C9          0360*       ret
041A91             0361*   
041A91             0362*   stopwatch_started: ds 3 ; buffer to hold stopwatch start time
041A94             0363*   
041A94             0364*   ; ------------------
041A94             0365*   ; delay routine
041A94             0366*   ; Author: Richard Turrnidge
041A94             0367*   ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.asm
041A94             0368*   ; routine waits a fixed time,then returns
041A94             0369*   ; arrive with A =  the delay byte. One bit to be set only.
041A94             0370*   ; eg. ld A,00000100b
041A94             0371*   
041A94             0372*   multiPurposeDelay:
       FF FF FF 
041A94 F5          0373*       push af
041A95 C5          0374*       push bc
041A96 DD E5       0375*       push ix
041A98 47          0376*       ld b,a
041A99 3E 08       0377*       ld a,$08
041A9B 5B CF       0378*       RST.LIL	08h                 ; get IX pointer to sysvars
041A9D             0379*   
041A9D             0380*   waitLoop:
041A9D             0381*   
041A9D DD 7E 00    0382*       ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
041AA0             0383*   
041AA0             0384*                                   ;   we check if bit set is same as last time we checked.
041AA0             0385*                                   ;   bit 0 - don't use
041AA0             0386*                                   ;   bit 1 - changes 64 times per second
041AA0             0387*                                   ;   bit 2 - changes 32 times per second
041AA0             0388*                                   ;   bit 3 - changes 16 times per second
041AA0             0389*   
041AA0             0390*                                   ;   bit 4 - changes 8 times per second
041AA0             0391*                                   ;   bit 5 - changes 4 times per second
041AA0             0392*                                   ;   bit 6 - changes 2 times per second
041AA0             0393*                                   ;   bit 7 - changes 1 times per second
041AA0 A0          0394*       and b
041AA1 4F          0395*       ld c,a
041AA2 3A B3 1A 04 0396*       ld a,(oldTimeStamp)
041AA6 B9          0397*       cp c                        ; is A same as last value?
041AA7 28 F4       0398*       jr z,waitLoop              ; loop here if it is
041AA9 79          0399*       ld a,c
041AAA 32 B3 1A 04 0400*       ld (oldTimeStamp),a        ; set new value
041AAE             0401*   
041AAE DD E1       0402*       pop ix
041AB0 C1          0403*       pop bc
041AB1 F1          0404*       pop af
041AB2 C9          0405*       ret
041AB3             0406*   
041AB3 00          0407*   oldTimeStamp:   .db 00h
041AB4             0039        include "vdu.inc"
041AB4             0001*   ; VDU 30: Home cursor
041AB4             0002*   vdu_home_cursor:
041AB4 3E 1E       0003*       ld a,30
041AB6 5B D7       0004*   	rst.lil $10
041AB8 C9          0005*   	ret
041AB9             0006*   
041AB9             0007*   vdu_cursor_on:
041AB9 21 C4 1A 04 0008*   	ld hl,@cmd
041ABD 01 03 00 00 0009*   	ld bc,@end-@cmd
041AC1 5B DF       0010*   	rst.lil $18
041AC3 C9          0011*   	ret
041AC4             0012*   @cmd:
041AC4 17 01 01    0013*   	db 23,1,1
041AC7             0014*   @end:
041AC7             0015*   
041AC7             0016*   vdu_cursor_off:
041AC7 21 D2 1A 04 0017*   	ld hl,@cmd
041ACB 01 03 00 00 0018*   	ld bc,@end-@cmd
041ACF 5B DF       0019*   	rst.lil $18
041AD1 C9          0020*   	ret
041AD2             0021*   @cmd:
041AD2 17 01 00    0022*   	db 23,1,0
041AD5             0023*   @end:
041AD5             0024*   
041AD5             0025*   ; VDU 4: Write text at text cursor
041AD5             0026*   ; This causes text to be written at th current text cursor position. This is the default mode for text display.
041AD5             0027*   ; inputs: none
041AD5             0028*   ; prerequisites: the text cursor at the intended position on screen
041AD5             0029*   ; outputs: none
041AD5             0030*   ; destroys: af
041AD5             0031*   vdu_text_to_text_cursor:
041AD5 3E 04       0032*       ld a,4
041AD7 5B D7       0033*       rst.lil $10
041AD9 C9          0034*       ret
041ADA             0035*   ; end vdu_text_to_text_cursor
041ADA             0036*   
041ADA             0037*   ; set the text cursor to a specified location and print a string there
041ADA             0038*   ; inputs: hl = address of string to print, c,b = x,y text coordinates
041ADA             0039*   ; outputs: text
041ADA             0040*   ; destroys: af, bc, hl
041ADA             0041*   ; affects: moves text cursor to position after final char printed by default
041ADA             0042*   ;          unless overridden by VDU 23, 16 cursor control command settings
041ADA             0043*   ;          all subsequent print commands (rst.lil $10 or $18) will go to the text cursor
041ADA             0044*   vdu_print_to_text_location:
041ADA E5          0045*       push hl ; preserve string pointer
041ADB 3E 04       0046*       ld a,4 ; VDU 4 char to text cursor
041ADD 5B D7       0047*       rst.lil $10
041ADF CD 17 1B 04 0048*       call vdu_move_cursor
041AE3 E1          0049*       pop hl ; restore string pointer
041AE4 CD 67 00 04 0050*       call printString
041AE8 C9          0051*       ret
041AE9             0052*   ; end vdu_print_at_text_location
041AE9             0053*   
041AE9             0054*   ; VDU 5: Write text at graphics cursor
041AE9             0055*   ; inputs: none
041AE9             0056*   ; prerequisites: the graphics cursor at the intended position on screen
041AE9             0057*   ; outputs: none
041AE9             0058*   ; destroys: af
041AE9             0059*   vdu_text_to_gfx_cursor:
041AE9 3E 05       0060*       ld a,5
041AEB 5B D7       0061*   	rst.lil $10
041AED C9          0062*   	ret
041AEE             0063*   ; end vdu_char_to_gfx_cursor
041AEE             0064*   
041AEE             0065*   ; set the graphics cursor to a specified location and print a string there
041AEE             0066*   ; inputs: hl = address of string to print, bc,de = x,y graphics coordinates
041AEE             0067*   ; outputs: text
041AEE             0068*   ; destroys: af, bc, de, hl
041AEE             0069*   ; affects: moves graphics cursor to position after final char printed by default
041AEE             0070*   ;          unless overridden by setting bit 6 of the cursor control register (VDU 23, 16)
041AEE             0071*   ;          all subsequent print commands (rst.lil $10 or $18) will go to the graphics cursor
041AEE             0072*   vdu_print_to_gfx_location:
041AEE E5          0073*       push hl ; preserve string pointer
041AEF 3E 44       0074*       ld a,plot_pt+mv_abs
041AF1 CD 19 20 04 0075*       call vdu_plot ; moves the graphics cursor to the specified location
041AF5 3E 05       0076*       ld a,5 ; VDU 5 char to gfx cursor
041AF7 5B D7       0077*       rst.lil $10
041AF9 E1          0078*       pop hl ; restore string pointer
041AFA 01 00 00 00 0079*       ld bc,0
041AFE 3E 00       0080*       ld a,0
041B00 5B DF       0081*       rst.lil $18 ; print the string
041B02 C9          0082*       ret
041B03             0083*   ; end vdu_print_at_gfx_location
041B03             0084*   
041B03             0085*   ; VDU 8: Move cursor back one character
041B03             0086*   vdu_cursor_back:
041B03 3E 08       0087*       ld a,8
041B05 5B D7       0088*       rst.lil $10
041B07 C9          0089*       ret
041B08             0090*   ; end vdu_cursor_back
041B08             0091*   
041B08             0092*   ; VDU 9: Move cursor forward one character
041B08             0093*   vdu_cursor_forward:
041B08 3E 09       0094*       ld a,9
041B0A 5B D7       0095*   	rst.lil $10
041B0C C9          0096*   	ret
041B0D             0097*   ; end vdu_cursor_forward
041B0D             0098*   
041B0D             0099*   ; VDU 10: Move cursor down one line
041B0D             0100*   vdu_cursor_down:
041B0D 3E 0A       0101*       ld a,10
041B0F 5B D7       0102*       rst.lil $10
041B11 C9          0103*       ret
041B12             0104*   ; end vdu_cursor_down
041B12             0105*   
041B12             0106*   ; VDU 11: Move cursor up one line
041B12             0107*   vdu_cursor_up:
041B12 3E 0B       0108*       ld a,11
041B14 5B D7       0109*       rst.lil $10
041B16 C9          0110*       ret
041B17             0111*   ; end vdu_cursor_up
041B17             0112*   
041B17             0113*   
041B17             0114*   ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
041B17             0115*   ; inputs: c=x, b=y 8-bit unsigned integers
041B17             0116*   vdu_move_cursor:
041B17 ED 43 28 1B 0117*       ld (@x0),bc
       04          
041B1C 21 27 1B 04 0118*   	ld hl,@cmd
041B20 01 03 00 00 0119*   	ld bc,@end-@cmd
041B24 5B DF       0120*   	rst.lil $18
041B26 C9          0121*   	ret
041B27 1F          0122*   @cmd: 	db 31
041B28 00          0123*   @x0:	db 0
041B29 00          0124*   @y0: 	db 0
041B2A 00          0125*   @end: 	db 0 ; padding
041B2B             0126*   
041B2B             0127*   ; https://agonconsole8.github.io/agon-docs/vdp/VDU-Commands/#vdu-23-1-n-cursor-control
041B2B             0128*   ; VDU 23, 16, setting, mask: Define cursor movement behaviour
041B2B             0129*   ; inputs: l = setting, h = mask
041B2B             0130*   ; new_setting = (current_setting AND mask) EOR setting
041B2B             0131*   ; in English: mask controls which bit to turn on or off, setting is the value of the bits to set or reset
041B2B             0132*   vdu_cursor_behaviour:
041B2B 22 3C 1B 04 0133*       ld (@setting),hl ; little-endian!
041B2F 21 3A 1B 04 0134*       ld hl,@cmd
041B33 01 04 00 00 0135*       ld bc,@end-@cmd
041B37 5B DF       0136*       rst.lil $18
041B39 C9          0137*       ret
041B3A 17 10       0138*   @cmd: db 23,16
041B3C 00          0139*   @setting: db 0
041B3D 00          0140*   @mask: db 0
041B3E 00          0141*   @end: db 0 ; padding
041B3F             0142*   
041B3F             0143*   ; VDU 12: Clear text area (CLS)
041B3F             0144*   vdu_cls:
041B3F 3E 0C       0145*       ld a,12
041B41 5B D7       0146*   	rst.lil $10
041B43 C9          0147*   	ret
041B44             0148*   
041B44             0149*   vdu_flip:
041B44 21 4F 1B 04 0150*   	ld hl,@cmd
041B48 01 03 00 00 0151*   	ld bc,@end-@cmd
041B4C 5B DF       0152*   	rst.lil $18
041B4E C9          0153*   	ret
041B4F 17 00 C3    0154*   @cmd: db 23,0,0xC3
041B52             0155*   @end:
041B52             0156*   
041B52             0157*   ; VDU 16: Clear graphics area (CLG)
041B52             0158*   vdu_clg:
041B52 3E 10       0159*       ld a,16
041B54 5B D7       0160*   	rst.lil $10
041B56 C9          0161*   	ret
041B57             0162*   
041B57             0163*   ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
041B57             0164*   ; VDU 23, 7: Scrolling
041B57             0165*   ;     VDU 23, 7, extent, direction, speed: Scroll the screen
041B57             0166*   ; inputs: a, extent; l, direction; h; speed
041B57             0167*   vdu_scroll_down:
041B57 32 6C 1B 04 0168*   	ld (@extent),a
041B5B 22 6D 1B 04 0169*   	ld (@dir),hl ; implicitly populates @speed
041B5F 21 6A 1B 04 0170*   	ld hl,@cmd
041B63 01 05 00 00 0171*   	ld bc,@end-@cmd
041B67 5B DF       0172*   	rst.lil $18     ;; Sending command to VDP
041B69 C9          0173*   	ret
041B6A 17 07       0174*   @cmd:       db 23,7
041B6C 00          0175*   @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
041B6D 00          0176*   @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
041B6E 00          0177*   @speed:     db 0x00 ; pixels
041B6F 00          0178*   @end:		db 0x00 ; padding
041B70             0179*   
041B70             0180*   ; COLOUR MODES
041B70             0181*   ; Mode	Effect
041B70             0182*   ; 0	Set on-screen pixel to target colour value
041B70             0183*   ; 1	OR value with the on-screen pixel
041B70             0184*   ; 2	AND value with the on-screen pixel
041B70             0185*   ; 3	XOR value with the on-screen pixel
041B70             0186*   ; 4	Invert the on-screen pixel
041B70             0187*   ; 5	No operation
041B70             0188*   ; 6	AND the inverse of the specified colour with the on-screen pixel
041B70             0189*   ; 7	OR the inverse of the specified colour with the on-screen pixel
041B70             0190*   
041B70             0191*   ; VDU 17, colour: Define text colour (COLOUR)
041B70             0192*   vdu_colour_text:
041B70 32 80 1B 04 0193*   	ld (@arg),a
041B74 21 7F 1B 04 0194*   	ld hl,@cmd
041B78 01 02 00 00 0195*   	ld bc,@end-@cmd
041B7C 5B DF       0196*   	rst.lil $18
041B7E C9          0197*   	ret
041B7F 11          0198*   @cmd: db 17
041B80 00          0199*   @arg: db 0
041B81             0200*   @end:
041B81             0201*   
041B81             0202*   ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
041B81             0203*   ; inputs: a=mode, c=colour (add 128 to set background colour)
041B81             0204*   vdu_gcol:
041B81 32 96 1B 04 0205*   	ld (@mode),a
041B85 79          0206*       ld a,c
041B86 32 97 1B 04 0207*       ld (@col),a
041B8A 21 95 1B 04 0208*   	ld hl,@cmd
041B8E 01 03 00 00 0209*   	ld bc,@end-@cmd
041B92 5B DF       0210*   	rst.lil $18
041B94 C9          0211*   	ret
041B95 12          0212*   @cmd:  db 18
041B96 00          0213*   @mode: db 0
041B97 00          0214*   @col:  db 0
041B98             0215*   @end:
041B98             0216*   
041B98             0217*   
041B98             0218*   ; VDU 28, left, bottom, right, top: Set text viewport **
041B98             0219*   ; MIND THE LITTLE-ENDIANESS
041B98             0220*   ; inputs: c=left,b=bottom,e=right,d=top
041B98             0221*   ; outputs; nothing
041B98             0222*   ; destroys: af, hl, bc, de
041B98             0223*   vdu_set_txt_viewport:
041B98 ED 43 AE 1B 0224*       ld (@lb),bc
       04          
041B9D ED 53 B0 1B 0225*   	ld (@rt),de
       04          
041BA2 21 AD 1B 04 0226*   	ld hl,@cmd
041BA6 01 05 00 00 0227*   	ld bc,@end-@cmd
041BAA 5B DF       0228*   	rst.lil $18
041BAC C9          0229*   	ret
041BAD 1C          0230*   @cmd:   db 28 ; set text viewport command
041BAE 00 00       0231*   @lb: 	dw 0x0000 ; set by bc
041BB0 00 00       0232*   @rt: 	dw 0x0000 ; set by de
041BB2 00          0233*   @end:   db 0x00	  ; padding
041BB3             0234*   
041BB3             0235*   ; Wait for VBLANK interrupt
041BB3             0236*   vdu_vblank:
041BB3 DD E5       0237*       PUSH 	IX
041BB5             0238*   	MOSCALL	mos_sysvars
                       M1 Args: function=mos_sysvars 
041BB5 3E 08       0001*M1 			LD	A, function
041BB7 5B CF       0002*M1 			RST.LIL	08h
041BB9 DD 7E 00    0239*   	LD	A, (IX + sysvar_time + 0)
041BBC             0240*   @wait:
041BBC DD BE 00    0241*       CP 	A, (IX + sysvar_time + 0)
041BBF 28 FB       0242*       JR	Z, @wait
041BC1 DD E1       0243*       POP	IX
041BC3 C9          0244*       RET
041BC4             0245*   
041BC4             0246*   ; VDU 29, x; y;: Set graphics origin
041BC4             0247*   ; This command sets the graphics origin.
041BC4             0248*   ; The origin is the point on the screen where the coordinates (0,0) are located.
041BC4             0249*   ; inputs: bc=x0,de=y0
041BC4             0250*   ; outputs; nothing
041BC4             0251*   ; destroys: a might make it out alive
041BC4             0252*   vdu_set_gfx_origin:
041BC4 ED 43 DA 1B 0253*       ld (@x0),bc
       04          
041BC9 ED 53 DC 1B 0254*       ld (@y0),de
       04          
041BCE 21 D9 1B 04 0255*       ld hl,@cmd
041BD2 01 05 00 00 0256*       ld bc,@end-@cmd
041BD6 5B DF       0257*       rst.lil $18
041BD8 C9          0258*       ret
041BD9 1D          0259*   @cmd:   db 29 ; set graphics origin command
041BDA 00 00       0260*   @x0: 	dw 0x0000 ; set by bc
041BDC 00 00       0261*   @y0: 	dw 0x0000 ; set by de
041BDE 00          0262*   @end:   db 0x00	  ; padding
041BDF             0263*   
041BDF             0264*   ; VDU 24, left; bottom; right; top;: Set graphics viewport
041BDF             0265*   ; NOTE: the order of the y-coordinate parameters are inverted
041BDF             0266*   ; 	because we have turned off logical screen scaling
041BDF             0267*   ; NOTE: coordinates are relative to current gfx origin
041BDF             0268*   ; inputs: bc=x0,de=y0,ix=x1,iy=y1
041BDF             0269*   ; outputs; nothing
041BDF             0270*   ; destroys: a might make it out alive
041BDF             0271*   vdu_set_gfx_viewport:
041BDF ED 43 FF 1B 0272*       ld (@x0),bc
       04          
041BE4 FD 22 01 1C 0273*       ld (@y1),iy
       04          
041BE9 DD 22 03 1C 0274*   	ld (@x1),ix
       04          
041BEE ED 53 05 1C 0275*   	ld (@y0),de
       04          
041BF3 21 FE 1B 04 0276*   	ld hl,@cmd
041BF7 01 09 00 00 0277*   	ld bc,@end-@cmd
041BFB 5B DF       0278*   	rst.lil $18
041BFD C9          0279*   	ret
041BFE 18          0280*   @cmd:   db 24 ; set graphics viewport command
041BFF 00 00       0281*   @x0: 	dw 0x0000 ; set by bc
041C01 00 00       0282*   @y1: 	dw 0x0000 ; set by iy
041C03 00 00       0283*   @x1: 	dw 0x0000 ; set by ix
041C05 00 00       0284*   @y0: 	dw 0x0000 ; set by de
041C07 00          0285*   @end:   db 0x00	  ; padding
041C08             0286*   
041C08             0287*   ; VDU 26: Reset graphics and text viewports
041C08             0288*   vdu_reset_viewports:
041C08 3E 1A       0289*       ld a,26
041C0A 5B D7       0290*       rst.lil $10
041C0C C9          0291*       ret
041C0D             0292*   
041C0D             0293*   ; SCREEN MODES
041C0D             0294*   ; ===============================
041C0D             0295*   ; Mode  Horz  Vert  Cols  Refresh
041C0D             0296*   ; ---   ----  ----  ----  -------
041C0D             0297*   ; 11    320   240   2     60hz
041C0D             0298*   ; 139   320   240   2     60hz
041C0D             0299*   ; 23    512   384   2     60hz
041C0D             0300*   ; 151   512   384   2     60hz
041C0D             0301*   ; 6     640   240   2     60hz
041C0D             0302*   ; 134   640   240   2     60hz
041C0D             0303*   ; 2     640   480   2     60hz
041C0D             0304*   ; 130   640   480   2     60hz
041C0D             0305*   ; 17    800   600   2     60hz
041C0D             0306*   ; 145   800   600   2     60hz
041C0D             0307*   ; 18    1024  768   2     60hz
041C0D             0308*   ; 146   1024  768   2     60hz
041C0D             0309*   ; ---   ----  ----  ----  -------
041C0D             0310*   ; 10    320   240   4     60hz
041C0D             0311*   ; 138   320   240   4     60hz
041C0D             0312*   ; 22    512   384   4     60hz
041C0D             0313*   ; 150   512   384   4     60hz
041C0D             0314*   ; 5     640   240   4     60hz
041C0D             0315*   ; 133   640   240   4     60hz
041C0D             0316*   ; 1     640   480   4     60hz
041C0D             0317*   ; 129   640   480   4     60hz
041C0D             0318*   ; 16    800   600   4     60hz
041C0D             0319*   ; 19    1024  768   4     60hz
041C0D             0320*   ; ---   ----  ----  ----  -------
041C0D             0321*   ; 9     320   240   16    60hz
041C0D             0322*   ; 137   320   240   16    60hz
041C0D             0323*   ; 21    512   384   16    60hz
041C0D             0324*   ; 149   512   384   16    60hz
041C0D             0325*   ; 4     640   240   16    60hz
041C0D             0326*   ; 132   640   240   16    60hz
041C0D             0327*   ; 0     640   480   16    60hz
041C0D             0328*   ; 7     n/a   n/a   16    60hz
041C0D             0329*   ; ---   ----  ----  ----  -------
041C0D             0330*   ; 8     320   240   64    60hz
041C0D             0331*   ; 136   320   240   64    60hz
041C0D             0332*   ; 20    512   384   64    60hz
041C0D             0333*   ; 3     640   240   64    60hz
041C0D             0334*   ; ---   ----  ----  ----  -------
041C0D             0335*   vdu_set_screen_mode:
041C0D 32 1D 1C 04 0336*   	ld (@arg),a
041C11 21 1C 1C 04 0337*   	ld hl,@cmd
041C15 01 02 00 00 0338*   	ld bc,@end-@cmd
041C19 5B DF       0339*   	rst.lil $18
041C1B C9          0340*   	ret
041C1C 16          0341*   @cmd: db 22 ; set screen mode
041C1D 00          0342*   @arg: db 0  ; screen mode parameter
041C1E             0343*   @end:
041C1E             0344*   
041C1E             0345*   ; get the current screen mode
041C1E             0346*   ; inputs: none
041C1E             0347*   ; outputs: a=screen mode
041C1E             0348*   ; destroys: af, ix
041C1E             0349*   vdu_get_screen_mode:
041C1E             0350*       MOSCALL mos_sysvars
                       M1 Args: function=mos_sysvars 
041C1E 3E 08       0001*M1 			LD	A, function
041C20 5B CF       0002*M1 			RST.LIL	08h
041C22 DD 7E 27    0351*       ld a,(IX+sysvar_scrMode)
041C25 C9          0352*       ret
041C26             0353*   ; end vdu_get_screen_mode
041C26             0354*   
041C26             0355*   ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
041C26             0356*   ; inputs: a is scaling mode, 1=on, 0=off
041C26             0357*   ; note: default setting on boot is scaling ON
041C26             0358*   vdu_set_scaling:
041C26 32 38 1C 04 0359*   	ld (@arg),a
041C2A 21 35 1C 04 0360*   	ld hl,@cmd
041C2E 01 04 00 00 0361*   	ld bc,@end-@cmd
041C32 5B DF       0362*   	rst.lil $18
041C34 C9          0363*   	ret
041C35 17 00 C0    0364*   @cmd: db 23,0,0xC0
041C38 00          0365*   @arg: db 0  ; scaling on/off
041C39             0366*   @end:
041C39             0367*   
041C39             0368*   ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
041C39             0369*   ; inputs: hl=bufferId
041C39             0370*   vdu_buff_select:
041C39 22 4B 1C 04 0371*   	ld (@bufferId),hl
041C3D 21 48 1C 04 0372*   	ld hl,@cmd
041C41 01 05 00 00 0373*   	ld bc,@end-@cmd
041C45 5B DF       0374*   	rst.lil $18
041C47 C9          0375*   	ret
041C48 17 1B 20    0376*   @cmd: db 23,27,0x20
041C4B 00 00       0377*   @bufferId: dw 0x0000
041C4D 00          0378*   @end: db 0x00 ; padding
041C4E             0379*   
041C4E             0380*   ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
041C4E             0381*   ; inputs: a=format; bc=width; de=height
041C4E             0382*   ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
041C4E             0383*   ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
041C4E             0384*   ; 0 	RGBA8888 (4-bytes per pixel)
041C4E             0385*   ; 1 	RGBA2222 (1-bytes per pixel)
041C4E             0386*   ; 2 	Mono/Mask (1-bit per pixel)
041C4E             0387*   ; 3 	Reserved for internal use by VDP (“native” format)
041C4E             0388*   vdu_bmp_create:
041C4E ED 43 6A 1C 0389*       ld (@width),bc
       04          
041C53 ED 53 6C 1C 0390*       ld (@height),de
       04          
041C58 32 6E 1C 04 0391*       ld (@fmt),a
041C5C 21 67 1C 04 0392*   	ld hl,@cmd
041C60 01 08 00 00 0393*   	ld bc,@end-@cmd
041C64 5B DF       0394*   	rst.lil $18
041C66 C9          0395*   	ret
041C67 17 1B 21    0396*   @cmd:       db 23,27,0x21
041C6A 00 00       0397*   @width:     dw 0x0000
041C6C 00 00       0398*   @height:    dw 0x0000
041C6E 00          0399*   @fmt:       db 0x00
041C6F             0400*   @end:
041C6F             0401*   
041C6F             0402*   ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
041C6F             0403*   ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
041C6F             0404*   vdu_load_img_rgba2_to_8:
041C6F             0405*   ; backup the target buffer id and image dimensions
041C6F E5          0406*       push hl
041C70 D5          0407*       push de
041C71 C5          0408*       push bc
041C72             0409*   ; load the rgba2 image to working buffer 65534
041C72 21 FE FF 00 0410*       ld hl,65534 ; temporary working buffer id
041C76 CD 4D 1D 04 0411*   	call vdu_load_buffer_from_file
041C7A             0412*   ; restore the image dimensions and target buffer id
041C7A C1          0413*       pop bc
041C7B D1          0414*       pop de
041C7C E1          0415*       pop hl
041C7D             0416*   ; fall through to vdu_rgba2_to_8
041C7D             0417*   
041C7D             0418*   ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
041C7D             0419*   ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
041C7D             0420*   ; the "expand bitmap" command is:
041C7D             0421*   ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
041C7D             0422*   ; and then to reverse the byte order to fix endian-ness:
041C7D             0423*   ; VDU 23,0,&A0,targetBufferID%;24,4,4;
041C7D             0424*   ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
041C7D             0425*   ; VDU 23,27,&20,targetBufferID%;
041C7D             0426*   ; VDU 23,27,&21,width%;height%;0
041C7D             0427*   ; -------------------------------------------------------------------
041C7D             0428*   ; inputs: bc,de image width,height ; hl = targetBufferId
041C7D             0429*   ; prerequisites: rgba2 image data loaded into workingBufferId 65534
041C7D             0430*   vdu_rgba2_to_8:
041C7D             0431*   ; load the image dimensions and buffer id parameters
041C7D ED 43 D9 1C 0432*       ld (@width),bc
       04          
041C82 ED 53 DB 1C 0433*       ld (@height),de
       04          
041C87 22 BE 1C 04 0434*       ld (@bufferId0),hl
041C8B 22 CB 1C 04 0435*       ld (@bufferId2),hl
041C8F 22 D4 1C 04 0436*       ld (@bufferId1),hl
041C93             0437*   ; clean up bytes that got stomped on by the ID loads
041C93 3E 48       0438*       ld a,0x48
041C95 32 C0 1C 04 0439*       ld (@bufferId0+2),a
041C99 3E 17       0440*       ld a,23
041C9B 32 D6 1C 04 0441*       ld (@bufferId1+2),a
041C9F 3E 18       0442*       ld a,24
041CA1 32 CD 1C 04 0443*       ld (@bufferId2+2),a
041CA5 AF          0444*       xor a
041CA6 32 DD 1C 04 0445*       ld (@height+2),a
041CAA             0446*   ; send the vdu command strings
041CAA 21 B5 1C 04 0447*       ld hl,@beg
041CAE 01 29 00 00 0448*       ld bc,@end-@beg
041CB2 5B DF       0449*       rst.lil $18
041CB4 C9          0450*       ret
041CB5             0451*   @beg:
041CB5             0452*   ; Command 14: Consolidate blocks in a buffer
041CB5             0453*   ; VDU 23, 0, &A0, bufferId; 14
041CB5 17 00 A0    0454*       db 23,0,0xA0
041CB8 FE FF       0455*       dw 65534 ; workingBufferId
041CBA 0E          0456*       db 14 ; consolidate blocks
041CBB             0457*   ; the "expand bitmap" command is:
041CBB             0458*   ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
041CBB 17 00 A0    0459*       db 23,0,0xA0
041CBE 00 00       0460*   @bufferId0: dw 0x0000 ; targetBufferId
041CC0 48          0461*       db 0x48 ; given as decimal command 72 in the docs
041CC1 02          0462*       db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
041CC2 FE FF       0463*       dw 65534 ; sourceBufferId
041CC4 00 7F BF FF 0464*       db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
041CC8             0465*   ; reverse the byte order to fix endian-ness:
041CC8             0466*   ; Command 24: Reverse the order of data of blocks within a buffer
041CC8             0467*   ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
041CC8             0468*   ; VDU 23,0,&A0,targetBufferID%;24,4,4;
041CC8 17 00 A0    0469*       db 23,0,0xA0
041CCB 00 00       0470*   @bufferId2:    dw 0x0000 ; targetBufferId
041CCD 18          0471*       db 24 ; reverse byte order
041CCE 04          0472*       db 4 ; option: Reverse data of the value size within chunk of data of the specified size
041CCF 04 00       0473*       dw 4 ; size (4 bytes)
041CD1             0474*   ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
041CD1             0475*   ; VDU 23,27,&20,targetBufferID%;
041CD1 17 1B 20    0476*       db 23,27,0x20 ; select bitmap
041CD4 00 00       0477*   @bufferId1: dw 0x0000 ; targetBufferId
041CD6             0478*   ; VDU 23,27,&21,width%;height%;0
041CD6 17 1B 21    0479*       db 23,27,0x21 ; create bitmap from buffer
041CD9 00 00       0480*   @width: dw 0x0000
041CDB 00 00       0481*   @height: dw 0x0000
041CDD 00          0482*       db 0x00 ; rgba8888 format
041CDE             0483*   @end:
041CDE             0484*   
041CDE             0485*   ; scratch variables
041CDE 00 00 00    0486*   bufferId0: dl 0x000000
041CE1 00 00 00    0487*   bufferId1: dl 0x000000
041CE4             0488*   
041CE4             0489*   ; load a vdu buffer from local memory
041CE4             0490*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
041CE4             0491*   vdu_load_buffer:
041CE4 ED 43 0D 1D 0492*       ld (@length),bc
       04          
041CE9 D5          0493*       push de ; save data pointer
041CEA             0494*   ; send the vdu command string
041CEA 7D          0495*       ld a,l
041CEB 32 0A 1D 04 0496*       ld (@bufferId),a
041CEF 7C          0497*       ld a,h
041CF0 32 0B 1D 04 0498*       ld (@bufferId+1),a
041CF4 21 07 1D 04 0499*       ld hl,@cmd
041CF8 01 08 00 00 0500*       ld bc,@end-@cmd
041CFC 5B DF       0501*       rst.lil $18
041CFE             0502*   ; send the buffer data
041CFE E1          0503*       pop hl ; pointer to data
041CFF ED 4B 0D 1D 0504*       ld bc,(@length)
       04          
041D04 5B DF       0505*       rst.lil $18 ; send it
041D06 C9          0506*       ret
041D07             0507*   ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041D07 17 00 A0    0508*   @cmd:       db 23,0,0xA0
041D0A 00 00       0509*   @bufferId:	dw 0x0000
041D0C 00          0510*   		    db 0 ; load buffer
041D0D 00 00       0511*   @length:	dw 0x0000
041D0F 00          0512*   @end: db 0 ; padding
041D10             0513*   
041D10             0514*   ; Command 14: Consolidate blocks in a buffer
041D10             0515*   vdu_consolidate_buffer:
041D10             0516*   ; set parameters for vdu call
041D10 7D          0517*       ld a,l
041D11 32 28 1D 04 0518*       ld (@bufferId),a
041D15 7C          0519*       ld a,h
041D16 32 29 1D 04 0520*       ld (@bufferId+1),a
041D1A 21 25 1D 04 0521*       ld hl,@beg
041D1E 01 06 00 00 0522*       ld bc,@end-@beg
041D22 5B DF       0523*       rst.lil $18
041D24 C9          0524*       ret
041D25             0525*   ; VDU 23, 0, &A0, bufferId; 14
041D25 17 00 A0    0526*   @beg: db 23,0,0xA0
041D28 00 00       0527*   @bufferId: dw 0x0000
041D2A 0E          0528*              db 14
041D2B             0529*   @end:
041D2B             0530*   
041D2B             0531*   ; load an image file to a buffer and make it a bitmap
041D2B             0532*   ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
041D2B             0533*   vdu_load_img:
041D2B             0534*   ; back up image type and dimension parameters
041D2B 22 DE 1C 04 0535*       ld (bufferId0),hl
041D2F F5          0536*       push af
041D30 C5          0537*   	push bc
041D31 D5          0538*   	push de
041D32             0539*   ; load the image
041D32 CD 4D 1D 04 0540*   	call vdu_load_buffer_from_file
041D36             0541*   ; now make it a bitmap
041D36 2A DE 1C 04 0542*       ld hl,(bufferId0)
041D3A CD 10 1D 04 0543*       call vdu_consolidate_buffer
041D3E 2A DE 1C 04 0544*       ld hl,(bufferId0)
041D42 CD 39 1C 04 0545*       call vdu_buff_select
041D46 D1          0546*   	pop de ; image height
041D47 C1          0547*   	pop bc ; image width
041D48 F1          0548*   	pop af ; image type
041D49 C3 4E 1C 04 0549*   	jp vdu_bmp_create ; will return to caller from there
041D4D             0550*   
041D4D             0551*   ; inputs: hl = bufferId; iy = pointer to filename
041D4D             0552*   vdu_load_buffer_from_file:
041D4D 22 DE 1C 04 0553*       ld (bufferId0),hl
041D51             0554*   
041D51             0555*   ; clear target buffer
041D51 CD F9 1E 04 0556*       call vdu_clear_buffer
041D55             0557*   
041D55             0558*   ; open the file in read mode
041D55             0559*   ; Open a file
041D55             0560*   ; HLU: Filename
041D55             0561*   ;   C: Mode
041D55             0562*   ; Returns:
041D55             0563*   ;   A: Filehandle, or 0 if couldn't open
041D55 FD E5       0564*   	push iy ; pointer to filename
041D57 E1          0565*   	pop hl
041D58 0E 01       0566*   	ld c,fa_read
041D5A             0567*       MOSCALL mos_fopen
                       M1 Args: function=mos_fopen 
041D5A 3E 0A       0001*M1 			LD	A, function
041D5C 5B CF       0002*M1 			RST.LIL	08h
041D5E 32 99 1D 04 0568*       ld (@filehandle),a
041D62             0569*   
041D62             0570*   @read_file:
041D62             0571*   ; Read a block of data from a file
041D62             0572*   ;   C: Filehandle
041D62             0573*   ; HLU: Pointer to where to write the data to
041D62             0574*   ; DEU: Number of bytes to read
041D62             0575*   ; Returns:
041D62             0576*   ; DEU: Number of bytes read
041D62 3A 99 1D 04 0577*       ld a,(@filehandle)
041D66 4F          0578*       ld c,a
041D67 21 00 E0 B7 0579*       ld hl,filedata
041D6B 11 00 20 00 0580*       ld de,8192 ; max we can read into onboard sram at one time
041D6F             0581*       MOSCALL mos_fread
                       M1 Args: function=mos_fread 
041D6F 3E 1A       0001*M1 			LD	A, function
041D71 5B CF       0002*M1 			RST.LIL	08h
041D73             0582*   
041D73             0583*   ; test de for zero bytes read
041D73 21 00 00 00 0584*       ld hl,0
041D77 AF          0585*       xor a ; clear carry
041D78 ED 52       0586*       sbc hl,de
041D7A CA 90 1D 04 0587*       jp z,@close_file
041D7E             0588*   
041D7E             0589*   ; load a vdu buffer from local memory
041D7E             0590*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
041D7E 2A DE 1C 04 0591*       ld hl,(bufferId0)
041D82 D5          0592*       push de ; chunksize
041D83 C1          0593*       pop bc
041D84 11 00 E0 B7 0594*       ld de,filedata
041D88 CD E4 1C 04 0595*       call vdu_load_buffer
041D8C             0596*   
041D8C             0597*   ; read the next block
041D8C C3 62 1D 04 0598*       jp @read_file
041D90             0599*   
041D90             0600*   ; close the file
041D90             0601*   @close_file:
041D90 3A 99 1D 04 0602*       ld a,(@filehandle)
041D94             0603*       MOSCALL mos_fclose
                       M1 Args: function=mos_fclose 
041D94 3E 0B       0001*M1 			LD	A, function
041D96 5B CF       0002*M1 			RST.LIL	08h
041D98 C9          0604*       ret ; vdu_load_buffer_from_file
041D99             0605*   
041D99 00          0606*   @filehandle: db 0 ; file handle
041D9A 00 00 00    0607*   @fil: dl 0 ; pointer to FIL struct
041D9D             0608*   
041D9D 00 00 00    0609*   @chunkpointer: dl 0 ; pointer to current chunk
041DA0             0610*   
041DA0             0611*   ; File information structure (FILINFO)
041DA0             0612*   @filinfo:
041DA0 00 00 00 00 0613*   @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
041DA4 00 00       0614*   @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
041DA6 00 00       0615*   @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
041DA8 00          0616*   @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
041DA9 00 00 00 00 0617*   @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
041DB6 00 00 00 00 0618*   @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041EB6             0040        include "vdu_buffered_api.inc"
041EB6             0001*   ; https://agonconsole8.github.io/agon-docs/vdp/Buffered-Commands-API/
041EB6             0002*   
041EB6             0003*   ; Command 0: Write block to a buffer
041EB6             0004*   ; VDU 23, 0, &A0, bufferId; 0, length; <buffer-data>
041EB6             0005*   ; inputs: hl = bufferId, bc = length of data, de = pointer to data
041EB6             0006*   vdu_write_block_to_buffer:
041EB6             0007*   ; back up input parameters
041EB6 D5          0008*       push de ; pointer to data
041EB7 C5          0009*       push bc ; length of data
041EB8             0010*   ; set up the vdu command string
041EB8 22 D8 1E 04 0011*       ld (@bufferId),hl
041EBC ED 43 DB 1E 0012*       ld (@length),bc
       04          
041EC1 AF          0013*       xor a ; load buffer
041EC2 32 DA 1E 04 0014*       ld (@bufferId+2),a
041EC6 21 D5 1E 04 0015*       ld hl,@cmd0
041ECA 01 08 00 00 0016*       ld bc,@end0-@cmd0
041ECE 5B DF       0017*       rst.lil $18
041ED0             0018*   ; send the buffer data
041ED0 C1          0019*       pop bc ; length of data
041ED1 E1          0020*       pop hl ; pointer to data (was de)
041ED2 5B DF       0021*       rst.lil $18 ; send it
041ED4 C9          0022*       ret
041ED5             0023*   ; command string data
041ED5 17 00 A0    0024*   @cmd0:      db 23,0,0xA0
041ED8 00 00       0025*   @bufferId:	dw 0x0000
041EDA 00          0026*               db 0 ; load buffer
041EDB 00 00       0027*   @length:	dw 0x0000
041EDD 00          0028*   @end0:      db 0x00 ; padding
041EDE             0029*   ; end vdu_write_block_to_buffer
041EDE             0030*   
041EDE             0031*   ; Command 1: Call a buffer
041EDE             0032*   ; VDU 23, 0, &A0, bufferId; 1
041EDE             0033*   ; inputs: hl = bufferId
041EDE             0034*   vdu_call_buffer:
041EDE 22 F6 1E 04 0035*       ld (@bufferId),hl
041EE2 3E 01       0036*       ld a,1 ; call buffer
041EE4 32 F8 1E 04 0037*       ld (@bufferId+2),a
041EE8 21 F3 1E 04 0038*       ld hl,@cmd
041EEC 01 06 00 00 0039*       ld bc,@end-@cmd
041EF0 5B DF       0040*       rst.lil $18
041EF2 C9          0041*       ret
041EF3 17 00 A0    0042*   @cmd:     db 23,0,0xA0
041EF6 00 00       0043*   @bufferId: dw 0x0000
041EF8 01          0044*              db 1 ; call buffer
041EF9             0045*   @end:
041EF9             0046*   ; end vdu_call_buffer
041EF9             0047*   
041EF9             0048*   ; Command 2: Clear a buffer
041EF9             0049*   ; VDU 23, 0 &A0, bufferId; 2
041EF9             0050*   ; inputs: hl = bufferId
041EF9             0051*   vdu_clear_buffer:
041EF9 22 11 1F 04 0052*       ld (@bufferId),hl
041EFD 3E 02       0053*       ld a,2 ; clear buffer
041EFF 32 13 1F 04 0054*       ld (@bufferId+2),a
041F03 21 0E 1F 04 0055*       ld hl,@cmd
041F07 01 06 00 00 0056*       ld bc,@end-@cmd
041F0B 5B DF       0057*       rst.lil $18
041F0D C9          0058*       ret
041F0E 17 00 A0    0059*   @cmd:     db 23,0,0xA0
041F11 00 00       0060*   @bufferId: dw 0x0000
041F13 02          0061*              db 2 ; clear buffer
041F14             0062*   @end:
041F14             0063*   ; end vdu_clear_buffer
041F14             0064*   
041F14             0065*   ; Clear all buffers
041F14             0066*   ; inputs: none
041F14             0067*   vdu_clear_all_buffers:
041F14             0068*   ; clear all buffers
041F14 21 1F 1F 04 0069*       ld hl,@beg
041F18 01 06 00 00 0070*       ld bc,@end-@beg
041F1C 5B DF       0071*       rst.lil $18
041F1E C9          0072*       ret
041F1F 17 00 A0    0073*   @beg: db 23,0,$A0
041F22 FF FF       0074*         dw -1 ; bufferId -1 (65535) means clear all buffers
041F24 02          0075*         db 2  ; command 2: clear a buffer
041F25             0076*   @end:
041F25             0077*   ; end vdu_clear_all_buffers
041F25             0078*   
041F25             0079*   ; Command 3: Create a writeable buffer
041F25             0080*   ; VDU 23, 0 &A0, bufferId; 3, length;
041F25             0081*   ; inputs: hl = bufferId, bc = length
041F25             0082*   vdu_create_writeable_buffer:
041F25 22 42 1F 04 0083*       ld (@bufferId),hl
041F29 ED 43 45 1F 0084*       ld (@length),bc
       04          
041F2E 3E 03       0085*       ld a,3 ; create writeable buffer
041F30 32 44 1F 04 0086*       ld (@bufferId+2),a
041F34 21 3F 1F 04 0087*       ld hl,@cmd
041F38 01 08 00 00 0088*       ld bc,@end-@cmd
041F3C 5B DF       0089*       rst.lil $18
041F3E C9          0090*       ret
041F3F 17 00 A0    0091*   @cmd:     db 23,0,0xA0
041F42 00 00       0092*   @bufferId: dw 0x0000
041F44 03          0093*              db 3 ; create writeable buffer
041F45 00 00       0094*   @length: dw 0x0000
041F47 00          0095*   @end:     db 0x00 ; padding
041F48             0096*   ; end vdu_create_writeable_buffer
041F48             0097*   
041F48             0098*   ; Command 4: Set output stream to a buffer
041F48             0099*   ; VDU 23, 0 &A0, bufferId; 4
041F48             0100*   ; inputs: hl = bufferId
041F48             0101*   vdu_set_output_stream_buffer:
041F48 22 60 1F 04 0102*       ld (@bufferId),hl
041F4C 3E 04       0103*       ld a,4 ; set output stream to buffer
041F4E 32 62 1F 04 0104*       ld (@bufferId+2),a
041F52 21 5D 1F 04 0105*       ld hl,@cmd
041F56 01 06 00 00 0106*       ld bc,@end-@cmd
041F5A 5B DF       0107*       rst.lil $18
041F5C C9          0108*       ret
041F5D 17 00 A0    0109*   @cmd:     db 23,0,0xA0
041F60 00 00       0110*   @bufferId: dw 0x0000
041F62 04          0111*              db 4 ; set output stream to buffer
041F63 00          0112*   @end:     db 0x00 ; padding
041F64             0113*   ; end vdu_set_output_stream_buffer
041F64             0114*   
041F64             0115*   ; Command 5: Adjust buffer contents
041F64             0116*   ; VDU 23, 0, &A0, bufferId; 5, operation, offset; [count;] <operand>, [arguments]
041F64             0117*   vdu_adjust_buffer:
041F64 C9          0118*       ret ; TODO: implement
041F65             0119*   ; end vdu_adjust_buffer
041F65             0120*   
041F65             0121*   ; Command 6: Conditionally call a buffer
041F65             0122*   ; VDU 23, 0, &A0, bufferId; 6, operation, checkBufferId; checkOffset; [arguments]
041F65             0123*   vdu_call_buffer_conditional:
041F65 C9          0124*       ret ; TODO: implement
041F66             0125*   ; end vdu_call_buffer_conditional
041F66             0126*   
041F66             0127*   ; Command 7: Jump to a buffer
041F66             0128*   ; VDU 23, 0, &A0, bufferId; 7
041F66             0129*   ; inputs: hl = bufferId
041F66             0130*   vdu_jump_to_buffer:
041F66 22 7E 1F 04 0131*       ld (@bufferId),hl
041F6A 3E 07       0132*       ld a,7 ; jump to buffer
041F6C 32 80 1F 04 0133*       ld (@bufferId+2),a
041F70 21 7B 1F 04 0134*       ld hl,@cmd
041F74 01 06 00 00 0135*       ld bc,@end-@cmd
041F78 5B DF       0136*       rst.lil $18
041F7A C9          0137*       ret
041F7B 17 00 A0    0138*   @cmd:     db 23,0,0xA0
041F7E 00 00       0139*   @bufferId: dw 0x0000
041F80 07          0140*              db 7 ; jump to buffer
041F81 00          0141*   @end:     db 0x00 ; padding
041F82             0142*   ; end vdu_jump_to_buffer
041F82             0143*   
041F82             0144*   ; Command 8: Conditional Jump to a buffer
041F82             0145*   ; VDU 23, 0, &A0, bufferId; 8, operation, checkBufferId; checkOffset; [arguments]
041F82             0146*   vdu_jump_to_buffer_conditional:
041F82 C9          0147*       ret ; TODO: implement
041F83             0148*   ; end vdu_jump_to_buffer_conditional
041F83             0149*   
041F83             0150*   ; Command 9: Jump to an offset in a buffer
041F83             0151*   ; VDU 23, 0, &A0, bufferId; 9, offset; offsetHighByte, [blockNumber;]
041F83             0152*   vdu_jump_to_buffer_offset:
041F83 C9          0153*       ret ; TODO: implement
041F84             0154*   ; end vdu_jump_to_buffer_offset
041F84             0155*   
041F84             0156*   ; Command 10: Conditional jump to an offset in a buffer
041F84             0157*   ; VDU 23, 0, &A0, bufferId; 10, offset; offsetHighByte, [blockNumber;] [arguments]
041F84             0158*   vdu_jump_to_buffer_offset_conditional:
041F84 C9          0159*       ret ; TODO: implement
041F85             0160*   ; end vdu_jump_to_buffer_offset_conditional
041F85             0161*   
041F85             0162*   ; Command 11: Call buffer with an offset
041F85             0163*   ; VDU 23, 0, &A0, bufferId; 11, offset; offsetHighByte, [blockNumber;]
041F85             0164*   vdu_call_buffer_offset:
041F85 C9          0165*       ret ; TODO: implement
041F86             0166*   ; end vdu_call_buffer_offset
041F86             0167*   
041F86             0041        include "vdu_fonts.inc"
041F86             0001*   ; select font
041F86             0002*   ; inputs: hl = bufferId, a = font flags
041F86             0003*   ; Flags:
041F86             0004*   ; Bit	Description
041F86             0005*   ; 0	Adjust cursor position to ensure text baseline is aligned
041F86             0006*   ;   0: Do not adjust cursor position (best for changing font on a new line)
041F86             0007*   ;   1: Adjust cursor position (best for changing font in the middle of a line)
041F86             0008*   ; 1-7	Reserved for future use
041F86             0009*   ; VDU 23, 0, &95, 0, bufferId; flags: Select font
041F86             0010*   vdu_font_select:
041F86 22 9D 1F 04 0011*       ld (@bufferId),hl
041F8A 32 9F 1F 04 0012*       ld (@flags),a
041F8E 21 99 1F 04 0013*       ld hl,@cmd
041F92 01 07 00 00 0014*       ld bc,@end-@cmd
041F96 5B DF       0015*       rst.lil $18
041F98 C9          0016*       ret
041F99 17 00 95 00 0017*   @cmd: db 23, 0, 0x95, 0
041F9D 00 00       0018*   @bufferId: dw 0x0000
041F9F 00          0019*   @flags: db 0x00
041FA0             0020*   @end:
041FA0             0021*   
041FA0             0022*   ; create font from buffer
041FA0             0023*   ; inputs: hl = bufferId, e = width, d = height, d = ascent, a = flags
041FA0             0024*   ; VDU 23, 0, &95, 1, bufferId; width, height, ascent, flags: Create font from buffer
041FA0             0025*   vdu_font_create:
041FA0 22 C5 1F 04 0026*       ld (@bufferId),hl
041FA4 ED 53 C7 1F 0027*       ld (@width),de ; also loads height
       04          
041FA9 32 CA 1F 04 0028*       ld (@flags),a
041FAD 7A          0029*       ld a,d ; height
041FAE 32 C9 1F 04 0030*       ld (@ascent),a ; ascent = height
041FB2             0031*   ; consolidate buffer
041FB2 CD 10 1D 04 0032*       call vdu_consolidate_buffer
041FB6             0033*   ; create font
041FB6 21 C1 1F 04 0034*       ld hl,@cmd
041FBA 01 0A 00 00 0035*       ld bc,@end-@cmd
041FBE 5B DF       0036*       rst.lil $18
041FC0 C9          0037*       ret
041FC1 17 00 95 01 0038*   @cmd: db 23, 0, 0x95, 1
041FC5 00 00       0039*   @bufferId: dw 0x0000
041FC7 00          0040*   @width: db 0x00
041FC8 00          0041*   @height: db 0x00
041FC9 00          0042*   @ascent: db 0x00
041FCA 00          0043*   @flags: db 0x00
041FCB             0044*   @end:
041FCB             0045*   
041FCB             0046*   ; set or adjust font property
041FCB             0047*   ; inputs: hl = bufferId, a = field, de = value
041FCB             0048*   ; VDU 23, 0, &95, 2, bufferId; field, value;: Set or adjust font property
041FCB             0049*   vdu_font_property:
041FCB 22 E7 1F 04 0050*       ld (@bufferId),hl
041FCF 32 E9 1F 04 0051*       ld (@field),a
041FD3 ED 53 EA 1F 0052*       ld (@value),de
       04          
041FD8 21 E3 1F 04 0053*       ld hl,@cmd
041FDC 01 09 00 00 0054*       ld bc,@end-@cmd
041FE0 5B DF       0055*       rst.lil $18
041FE2 C9          0056*       ret
041FE3 17 00 95 02 0057*   @cmd: db 23, 0, 0x95, 2
041FE7 00 00       0058*   @bufferId: dw 0x0000
041FE9 00          0059*   @field: db 0x00
041FEA 00 00       0060*   @value: dw 0x0000
041FEC 00          0061*   @end: db 0x00 ; padding
041FED             0062*   
041FED             0063*   ; VDU 23, 0, &95, 3, bufferId; [<args>]: Reserved
041FED             0064*   
041FED             0065*   ; Clear/Delete font
041FED             0066*   ; inputs: hl = bufferId
041FED             0067*   ; VDU 23, 0, &95, 4, bufferId;: Clear/Delete font
041FED             0068*   vdu_font_clear:
041FED 22 00 20 04 0069*       ld (@bufferId),hl
041FF1 21 FC 1F 04 0070*       ld hl,@cmd
041FF5 01 06 00 00 0071*       ld bc,@end-@cmd
041FF9 5B DF       0072*       rst.lil $18
041FFB C9          0073*       ret
041FFC 17 00 95 04 0074*   @cmd: db 23, 0, 0x95, 4
042000 00 00       0075*   @bufferId: dw 0x0000
042002 00          0076*   @end: db 0x00 ; padding
042003             0077*   
042003             0078*   ; Copy system font to buffer
042003             0079*   ; inputs: hl = bufferId
042003             0080*   ; VDU 23, 0, &95, 5, bufferId;: Copy system font to buffer
042003             0081*   vdu_font_copy_system:
042003 22 16 20 04 0082*       ld (@bufferId),hl
042007 21 12 20 04 0083*       ld hl,@cmd
04200B 01 06 00 00 0084*       ld bc,@end-@cmd
04200F 5B DF       0085*       rst.lil $18
042011 C9          0086*       ret
042012 17 00 95 05 0087*   @cmd: db 23, 0, 0x95, 5
042016 00 00       0088*   @bufferId: dw 0x0000
042018 00          0089*   @end: db 0x00 ; padding
042019             0042        include "vdu_plot.inc"
042019             0001*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
042019             0002*   ; PLOT code 	(Decimal) 	Effect
042019             0003*   ; &00-&07 	0-7 	Solid line, includes both ends
042019             0004*   plot_sl_both: equ 0x00
042019             0005*   
042019             0006*   ; &08-&0F 	8-15 	Solid line, final point omitted
042019             0007*   plot_sl_first: equ 0x08
042019             0008*   
042019             0009*   ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
042019             0010*   ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
042019             0011*   
042019             0012*   ; &20-&27 	32-39 	Solid line, first point omitted
042019             0013*   plot_sl_last: equ 0x20
042019             0014*   
042019             0015*   ; &28-&2F 	40-47 	Solid line, both points omitted
042019             0016*   plot_sl_none: equ 0x28
042019             0017*   
042019             0018*   ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
042019             0019*   ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
042019             0020*   
042019             0021*   ; &40-&47 	64-71 	Point plot
042019             0022*   plot_pt: equ 0x40
042019             0023*   
042019             0024*   ; &48-&4F 	72-79 	Line fill left and right to non-background §§
042019             0025*   plot_lf_lr_non_bg: equ 0x48
042019             0026*   
042019             0027*   ; &50-&57 	80-87 	Triangle fill
042019             0028*   plot_tf: equ 0x50
042019             0029*   
042019             0030*   ; &58-&5F 	88-95 	Line fill right to background §§
042019             0031*   plot_lf_r_bg: equ 0x58
042019             0032*   
042019             0033*   ; &60-&67 	96-103 	Rectangle fill
042019             0034*   plot_rf: equ 0x60
042019             0035*   
042019             0036*   ; &68-&6F 	104-111 	Line fill left and right to foreground §§
042019             0037*   plot_lf_lr_fg: equ 0x60
042019             0038*   
042019             0039*   ; &70-&77 	112-119 	Parallelogram fill
042019             0040*   plot_pf: equ 0x70
042019             0041*   
042019             0042*   ; &78-&7F 	120-127 	Line fill right to non-foreground §§
042019             0043*   plot_lf_r_non_fg: equ 0x78
042019             0044*   
042019             0045*   ; &80-&87 	128-135 	Not supported (Flood until non-background)
042019             0046*   ; &88-&8F 	136-143 	Not supported (Flood until foreground)
042019             0047*   
042019             0048*   ; &90-&97 	144-151 	Circle outline
042019             0049*   plot_co: equ 0x90
042019             0050*   
042019             0051*   ; &98-&9F 	152-159 	Circle fill
042019             0052*   plot_cf: equ 0x98
042019             0053*   
042019             0054*   ; &A0-&A7 	160-167 	Not supported (Circular arc)
042019             0055*   ; &A8-&AF 	168-175 	Not supported (Circular segment)
042019             0056*   ; &B0-&B7 	176-183 	Not supported (Circular sector)
042019             0057*   
042019             0058*   ; &B8-&BF 	184-191 	Rectangle copy/move
042019             0059*   plot_rcm: equ 0xB8
042019             0060*   
042019             0061*   ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
042019             0062*   ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
042019             0063*   ; &D0-&D7 	208-215 	Not defined
042019             0064*   ; &D8-&DF 	216-223 	Not defined
042019             0065*   ; &E0-&E7 	224-231 	Not defined
042019             0066*   
042019             0067*   ; &E8-&EF 	232-239 	Bitmap plot §
042019             0068*   plot_bmp: equ 0xE8
042019             0069*   
042019             0070*   ; &F0-&F7 	240-247 	Not defined
042019             0071*   ; &F8-&FF 	248-255 	Not defined
042019             0072*   
042019             0073*   ; § Support added in Agon Console8 VDP 2.1.0 §§ Support added in
042019             0074*   ; Agon Console8 VDP 2.2.0
042019             0075*   
042019             0076*   ; Within each group of eight plot codes, the effects are as follows:
042019             0077*   ; Plot code 	Effect
042019             0078*   ; 0 	Move relative
042019             0079*   mv_rel: equ 0
042019             0080*   
042019             0081*   ; 1 	Plot relative in current foreground colour
042019             0082*   dr_rel_fg: equ 1
042019             0083*   
042019             0084*   ; 2 	Not supported (Plot relative in logical inverse colour)
042019             0085*   ; 3 	Plot relative in current background colour
042019             0086*   dr_rel_bg: equ 3
042019             0087*   
042019             0088*   ; 4 	Move absolute
042019             0089*   mv_abs: equ 4
042019             0090*   
042019             0091*   ; 5 	Plot absolute in current foreground colour
042019             0092*   dr_abs_fg: equ 5
042019             0093*   
042019             0094*   ; 6 	Not supported (Plot absolute in logical inverse colour)
042019             0095*   ; 7 	Plot absolute in current background colour
042019             0096*   dr_abs_bg: equ 7
042019             0097*   
042019             0098*   ; Codes 0-3 use the position data provided as part of the command
042019             0099*   ; as a relative position, adding the position given to the current
042019             0100*   ; graphical cursor position. Codes 4-7 use the position data provided
042019             0101*   ; as part of the command as an absolute position, setting the current
042019             0102*   ; graphical cursor position to the position given.
042019             0103*   
042019             0104*   ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
042019             0105*   ; current pixel colour. These operations cannot currently be supported
042019             0106*   ; by the graphics system the Agon VDP uses, so these codes are not
042019             0107*   ; supported. Support for these codes may be added in a future version
042019             0108*   ; of the VDP firmware.
042019             0109*   
042019             0110*   ; 16 colour palette constants
042019             0111*   c_black: equ 0
042019             0112*   c_red_dk: equ 1
042019             0113*   c_green_dk: equ 2
042019             0114*   c_yellow_dk: equ 3
042019             0115*   c_blue_dk: equ 4
042019             0116*   c_magenta_dk: equ 5
042019             0117*   c_cyan_dk: equ 6
042019             0118*   c_grey: equ 7
042019             0119*   c_grey_dk: equ 8
042019             0120*   c_red: equ 9
042019             0121*   c_green: equ 10
042019             0122*   c_yellow: equ 11
042019             0123*   c_blue: equ 12
042019             0124*   c_magenta: equ 13
042019             0125*   c_cyan: equ 14
042019             0126*   c_white: equ 15
042019             0127*   
042019             0128*   ; VDU 25, mode, x; y;: PLOT command
042019             0129*   ; inputs: a=mode, bc=x0, de=y0
042019             0130*   vdu_plot:
042019 32 33 20 04 0131*       ld (@mode),a
04201D ED 43 34 20 0132*       ld (@x0),bc
       04          
042022 ED 53 36 20 0133*       ld (@y0),de
       04          
042027 21 32 20 04 0134*   	ld hl,@cmd
04202B 01 06 00 00 0135*   	ld bc,@end-@cmd
04202F 5B DF       0136*   	rst.lil $18
042031 C9          0137*   	ret
042032 19          0138*   @cmd:   db 25
042033 00          0139*   @mode:  db 0
042034 00 00       0140*   @x0: 	dw 0
042036 00 00       0141*   @y0: 	dw 0
042038 00          0142*   @end:   db 0 ; extra byte to soak up deu
042039             0143*   
042039             0144*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
042039             0145*   ; &E8-&EF 	232-239 	Bitmap plot §
042039             0146*   ; VDU 25, mode, x; y;: PLOT command
042039             0147*   ; inputs: bc=x0, de=y0
042039             0148*   ; prerequisites: vdu_buff_select
042039             0149*   vdu_plot_bmp:
042039 ED 43 50 20 0150*       ld (@x0),bc
       04          
04203E ED 53 52 20 0151*       ld (@y0),de
       04          
042043 21 4E 20 04 0152*   	ld hl,@cmd
042047 01 06 00 00 0153*   	ld bc,@end-@cmd
04204B 5B DF       0154*   	rst.lil $18
04204D C9          0155*   	ret
04204E 19          0156*   @cmd:   db 25
04204F ED          0157*   @mode:  db plot_bmp+dr_abs_fg ; 0xED
042050 00 00       0158*   @x0: 	dw 0x0000
042052 00 00       0159*   @y0: 	dw 0x0000
042054 00          0160*   @end:   db 0x00 ; padding
042055             0161*   
042055             0162*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
042055             0163*   ; &E8-&EF 	232-239 	Bitmap plot §
042055             0164*   ; VDU 25, mode, x; y;: PLOT command
042055             0165*   ; inputs: bc=x0, de=y0
042055             0166*   ; USING 16.8 FIXED POINT COORDINATES
042055             0167*   ; inputs: ub.c is x coordinate, ud.e is y coordinate
042055             0168*   ;   the fractional portiion of the inputs are truncated
042055             0169*   ;   leaving only the 16-bit integer portion
042055             0170*   ; prerequisites: vdu_buff_select
042055             0171*   vdu_plot_bmp168:
042055             0172*   ; populate in the reverse of normal to keep the
042055             0173*   ; inputs from stomping on each other
042055 ED 53 73 20 0174*       ld (@y0-1),de
       04          
04205A ED 43 71 20 0175*       ld (@x0-1),bc
       04          
04205F 3E ED       0176*       ld a,plot_bmp+dr_abs_fg ; 0xED
042061 32 71 20 04 0177*       ld (@mode),a ; restore the mode byte that got stomped on by bcu
042065 21 70 20 04 0178*   	ld hl,@cmd
042069 01 06 00 00 0179*   	ld bc,@end-@cmd
04206D 5B DF       0180*   	rst.lil $18
04206F C9          0181*   	ret
042070 19          0182*   @cmd:   db 25
042071 ED          0183*   @mode:  db plot_bmp+dr_abs_fg ; 0xED
042072 00 00       0184*   @x0: 	dw 0x0000
042074 00 00       0185*   @y0: 	dw 0x0000
042076             0186*   @end:  ; no padding required b/c we shifted de right
042076             0187*   
042076             0188*   ; draw a filled rectangle
042076             0189*   vdu_plot_rf:
042076 ED 43 9D 20 0190*       ld (@x0),bc
       04          
04207B ED 53 9F 20 0191*       ld (@y0),de
       04          
042080 DD 22 A3 20 0192*       ld (@x1),ix
       04          
042085 FD 22 A5 20 0193*       ld (@y1),iy
       04          
04208A 3E 19       0194*       ld a,25 ; we have to reload the 2nd plot command
04208C 32 A1 20 04 0195*       ld (@cmd1),a ; because the 24-bit y0 load stomped on it
042090 21 9B 20 04 0196*   	ld hl,@cmd0
042094 01 0C 00 00 0197*   	ld bc,@end-@cmd0
042098 5B DF       0198*   	rst.lil $18
04209A C9          0199*       ret
04209B 19          0200*   @cmd0:  db 25 ; plot
04209C 04          0201*   @arg0:  db plot_sl_both+mv_abs
04209D 00 00       0202*   @x0:    dw 0x0000
04209F 00 00       0203*   @y0:    dw 0x0000
0420A1 19          0204*   @cmd1:  db 25 ; plot
0420A2 65          0205*   @arg1:  db plot_rf+dr_abs_fg
0420A3 00 00       0206*   @x1:    dw 0x0000
0420A5 00 00       0207*   @y1:    dw 0x0000
0420A7 00          0208*   @end:   db 0x00 ; padding
0420A8             0209*   
0420A8             0210*   ; draw a filled circle
0420A8             0211*   vdu_plot_cf:
0420A8 ED 43 CF 20 0212*       ld (@x0),bc
       04          
0420AD ED 53 D1 20 0213*       ld (@y0),de
       04          
0420B2 DD 22 D5 20 0214*       ld (@x1),ix
       04          
0420B7 FD 22 D7 20 0215*       ld (@y1),iy
       04          
0420BC 3E 19       0216*       ld a,25 ; we have to reload the 2nd plot command
0420BE 32 D3 20 04 0217*       ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0420C2 21 CD 20 04 0218*   	ld hl,@cmd0
0420C6 01 0C 00 00 0219*   	ld bc,@end-@cmd0
0420CA 5B DF       0220*   	rst.lil $18
0420CC C9          0221*       ret
0420CD 19          0222*   @cmd0:  db 25 ; plot
0420CE 04          0223*   @arg0:  db plot_sl_both+mv_abs
0420CF 00 00       0224*   @x0:    dw 0x0000
0420D1 00 00       0225*   @y0:    dw 0x0000
0420D3 19          0226*   @cmd1:  db 25 ; plot
0420D4 9D          0227*   @arg1:  db plot_cf+dr_abs_fg
0420D5 00 00       0228*   @x1:    dw 0x0000
0420D7 00 00       0229*   @y1:    dw 0x0000
0420D9 00          0230*   @end:   db 0x00 ; padding
0420DA             0043        include "vdu_sound.inc"
0420DA             0001*   ; enable enough additional channels so that total enabled = max_channels
0420DA             0002*   ; inputs: max_channels set
0420DA             0003*   ; returns: nothing
0420DA             0004*   ; destroys: af, bc, hl
0420DA             0005*   vdu_enable_channels:
0420DA 3E 01       0006*       ld a,max_channels
0420DC D6 03       0007*       sub 3 ; subtract number of default channels already enabled
0420DE F2 E5 20 04 0008*       jp p,@loop
0420E2 C9          0009*       ret
0420E3 3E 03       0010*       ld a,3 ; first non-default channel
0420E5             0011*   @loop:
0420E5 32 00 21 04 0012*       ld (@channel),a
0420E9 21 FD 20 04 0013*       ld hl,@beg
0420ED 01 05 00 00 0014*       ld bc,@end-@beg
0420F1 F5          0015*       push af
0420F2 5B DF       0016*       rst.lil $18
0420F4 F1          0017*       pop af
0420F5 3C          0018*       inc a
0420F6 FE 01       0019*       cp max_channels
0420F8 C2 E5 20 04 0020*       jp nz,@loop
0420FC C9          0021*       ret
0420FD             0022*   @beg:
0420FD 17 00 85    0023*               db 23, 0, $85
042100 00          0024*   @channel:   db 0
042101 08          0025*               db 8 ; command 8: enable channel
042102             0026*   @end:
042102             0027*   
042102             0028*   ; disable all but the three default sound channels
042102             0029*   ; inputs: max_channels set
042102             0030*   ; outputs: none
042102             0031*   ; destroys: ah,hl,bc
042102             0032*   vdu_disable_channels:
042102 3E 01       0033*       ld a,max_channels
042104 D6 03       0034*       sub 3 ; subtract number of default channels already enabled
042106 F2 0D 21 04 0035*       jp p,@loop
04210A C9          0036*       ret
04210B 3E 03       0037*       ld a,3 ; first non-default channel
04210D             0038*   @loop:
04210D 32 28 21 04 0039*       ld (@channel),a
042111 21 25 21 04 0040*       ld hl,@beg
042115 01 05 00 00 0041*       ld bc,@end-@beg
042119 F5          0042*       push af
04211A 5B DF       0043*       rst.lil $18
04211C F1          0044*       pop af
04211D 3C          0045*       inc a
04211E FE 01       0046*       cp max_channels
042120 C2 0D 21 04 0047*       jp nz,@loop
042124 C9          0048*       ret
042125             0049*   @beg:
042125 17 00 85    0050*       db 23, 0, $85
042128 00          0051*   @channel: db 0
042129 09          0052*       db 9 ; command 9: disable channel
04212A             0053*   @end:
04212A             0054*   
04212A             0055*   
04212A             0056*   ; ############################################################
04212A             0057*   ; VDU SOUND API
04212A             0058*   ; ############################################################
04212A             0059*   ; Command 0: Play note
04212A             0060*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
04212A             0061*       MACRO PLAY_NOTE channel, volume, frequency, duration
04212A             0062*       ld hl, @PLAY_NOTE_CMD        ; Start of command block
04212A             0063*       ld bc, @PLAY_NOTE_END - @PLAY_NOTE_CMD  ; Command block size
04212A             0064*       rst.lil $18
04212A             0065*       jr @PLAY_NOTE_END
04212A             0066*   @PLAY_NOTE_CMD:  db 23, 0, 0x85               ; Command header
04212A             0067*                    db channel                  ; Channel, 0 (commented out)
04212A             0068*                    db 0                        ; Play note command
04212A             0069*                    db volume                   ; Volume
04212A             0070*                    dw frequency                ; Frequency
04212A             0071*                    dw duration                 ; Duration
04212A             0072*   @PLAY_NOTE_END:
04212A             0073*       ENDMACRO
04212A             0074*   
04212A             0075*       MACRO MUTE_CHANNEL channel
04212A             0076*       ld hl, @MUTE_CHANNEL_CMD     ; Start of command block
04212A             0077*       ld bc, @MUTE_CHANNEL_END - @MUTE_CHANNEL_CMD  ; Command block size
04212A             0078*       rst.lil $18
04212A             0079*       jr @MUTE_CHANNEL_END
04212A             0080*   @MUTE_CHANNEL_CMD: db 23, 0, 0x85             ; Command header
04212A             0081*                      db channel                ; Channel, 0 (commented out)
04212A             0082*                      db 2                      ; Set volume command
04212A             0083*                      db 0                      ; Volume (mute)
04212A             0084*   @MUTE_CHANNEL_END:
04212A             0085*       ENDMACRO
04212A             0086*   
04212A             0087*   ; inputs: c = channel, b = volume, hl = frequency; de = duration;
04212A             0088*   vdu_play_note:
04212A 79          0089*       ld a,c
04212B 32 4B 21 04 0090*       ld (@channel),a
04212F 78          0091*       ld a,b
042130 32 4D 21 04 0092*       ld (@volume),a
042134 22 4E 21 04 0093*       ld (@frequency),hl
042138 ED 53 50 21 0094*       ld (@duration),de
       04          
04213D 21 48 21 04 0095*       ld hl,@cmd
042141 01 0A 00 00 0096*       ld bc,@end-@cmd
042145 5B DF       0097*       rst.lil $18
042147 C9          0098*       ret
042148 17 00 85    0099*   @cmd:       db 23, 0, 0x85
04214B 00          0100*   @channel:   db 0x00
04214C 00          0101*               db 0x00 ; play note command
04214D 00          0102*   @volume:    db 0x00
04214E 00 00       0103*   @frequency: dw 0x0000
042150 00 00       0104*   @duration:  dw 0x0000
042152 00          0105*   @end:       db 0x00 ; padding
042153             0106*   
042153             0107*   ; Command 1: Status
042153             0108*   ; VDU 23, 0, &85, channel, 1
042153             0109*   ; inputs: a = channel
042153             0110*   ; Returns a bit mask indicating the status of the specified channel, or 255 if the channel is not valid, or has been disabled. The bit mask is as follows:
042153             0111*   ; Bit 	Name 	Meaning
042153             0112*   ; 0 	Active 	When set this indicates the channel is in use (has an active waveform)
042153             0113*   ; 1 	Playing 	Indicates the channel is actively playing a note, and thus will reject calls to play a new note
042153             0114*   ; 2 	Indefinite 	Set if the channel is playing an indefinite duration note
042153             0115*   ; 3 	Has Volume Envelope 	Set if the channel has a volume envelope
042153             0116*   ; 4 	Has Frequency Envelope 	Set if the channel has a frequency envelope
042153             0117*   
042153             0118*   ; Bits 5-7 are reserved for future use and, for enabled channels, will currently always be zero.
042153             0119*   vdu_channel_status:
042153 32 65 21 04 0120*       ld (@channel),a
042157 21 62 21 04 0121*       ld hl,@cmd
04215B 01 05 00 00 0122*       ld bc,@end-@cmd
04215F 5B DF       0123*       rst.lil $18
042161 C9          0124*       ret
042162 17 00 85    0125*   @cmd:       db 23, 0, 0x85
042165 00          0126*   @channel:   db 0x00
042166 01          0127*               db 0x01 ; get channel status command
042167             0128*   @end:
042167             0129*   
042167             0130*   ; VDU 23, 0, &85, channel, 2, volume
042167             0131*   ; inputs: c = channel, b = volume
042167             0132*   ; Sets the volume of the specified channel. The volume is a value from 0 to 127, where 0 is silent and 127 is full volume. Values over 127 will be treated as 127 (with one exception described later).
042167             0133*   
042167             0134*   ; Specifying a channel of -1 (or 255) will set the global sound system volume level. (Requires Console8 VDP 2.5.0 or later.)
042167             0135*   
042167             0136*   ; Using this command provides more direct control over a channel than the play note command. It can be used to adjust the volume of a channel that is already playing a note.
042167             0137*   vdu_channel_volume:
042167 79          0138*       ld a,c
042168 32 7F 21 04 0139*       ld (@channel),a
04216C 78          0140*       ld a,b
04216D 32 81 21 04 0141*       ld (@volume),a
042171 21 7C 21 04 0142*       ld hl,@cmd
042175 01 06 00 00 0143*       ld bc,@end-@cmd
042179 5B DF       0144*       rst.lil $18
04217B C9          0145*       ret
04217C 17 00 85    0146*   @cmd:       db 23, 0, 0x85
04217F 00          0147*   @channel:   db 0x00
042180 02          0148*               db 0x02 ; set volume command
042181 00          0149*   @volume:    db 0x00
042182             0150*   @end:
042182             0151*   
042182             0152*   ; VDU 23, 0, &85, channel, 3, frequency;
042182             0153*   
042182             0154*   ; Sets the frequency of the specified channel. The frequency is a 16-bit value specifying in Hz the frequency of the note to be played.
042182             0155*   
042182             0156*   ; Using this command provides more direct control over a channel than the play note command. It can be used to adjust the frequency of a channel that is already playing a note.
042182             0157*   
042182             0158*   ; Returns 1 on success, 0 for failure.
042182             0159*   vdu_channel_frequency:
042182 79          0160*       ld a,c
042183 32 9A 21 04 0161*       ld (@channel),a
042187 ED 53 9C 21 0162*       ld (@frequency),de
       04          
04218C 21 97 21 04 0163*       ld hl,@cmd
042190 01 07 00 00 0164*       ld bc,@end-@cmd
042194 5B DF       0165*       rst.lil $18
042196 C9          0166*       ret
042197 17 00 85    0167*   @cmd:       db 23, 0, 0x85
04219A 00          0168*   @channel:   db 0x00
04219B 03          0169*               db 0x03 ; set frequency command
04219C 00 00       0170*   @frequency: dw 0x0000
04219E 00          0171*   @end:       db 0x00 ; padding
04219F             0172*   
04219F             0173*   
04219F             0174*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
04219F             0175*   ; inputs: c = channel, b = waveformOrSample, [hl = bufferId]
04219F             0176*   ; Sets the waveform type for a channel to use. The waveformOrSample value is a single byte treated as a signed value.
04219F             0177*   
04219F             0178*   ; Using a negative value for the waveform indicates that a sample should be used instead. For more information see the documentation for the sample command.
04219F             0179*   
04219F             0180*   ; By default a channel is set to use waveform 0 (square wave).
04219F             0181*   
04219F             0182*   ; Valid waveform values are as follows:
04219F             0183*   ; Value 	Waveform
04219F             0184*   ; 0 	Square wave
04219F             0185*   ; 1 	Triangle wave
04219F             0186*   ; 2 	Sawtooth wave
04219F             0187*   ; 3 	Sine wave
04219F             0188*   ; 4 	Noise (simple white noise with no frequency support)
04219F             0189*   ; 5 	VIC Noise (emulates a VIC6561; supports frequency)
04219F             0190*   ; 8 	Sample (specifying a 16-bit buffer ID for sample data)
04219F             0191*   
04219F             0192*   vdu_channel_waveform:
04219F 79          0193*       ld a,c
0421A0 32 C5 21 04 0194*       ld (@channel),a
0421A4 78          0195*       ld a,b
0421A5 32 C7 21 04 0196*       ld (@waveform),a
0421A9 FE 08       0197*       cp 8 ; check if the waveform is a sample
0421AB 28 06       0198*       jr z, @sample
0421AD 01 06 00 00 0199*       ld bc,@bufferId-@cmd
0421B1 18 08       0200*       jr @sendToVdu
0421B3             0201*   @sample:
0421B3 22 C8 21 04 0202*       ld (@bufferId),hl
0421B7 01 08 00 00 0203*       ld bc,@end-@cmd
0421BB             0204*   @sendToVdu:
0421BB 21 C2 21 04 0205*       ld hl,@cmd
0421BF 5B DF       0206*       rst.lil $18
0421C1 C9          0207*       ret
0421C2 17 00 85    0208*   @cmd:       db 23, 0, 0x85
0421C5 00          0209*   @channel:   db 0x00
0421C6 04          0210*               db 0x04 ; set waveform command
0421C7 00          0211*   @waveform:  db 0x00
0421C8 00 00       0212*   @bufferId:  dw 0x0000
0421CA 00          0213*   @end:       db 0x00 ; padding
0421CB             0214*   
0421CB             0215*   ; VDU 23, 0, &85, channel (ignored), 5, 2, bufferId; format, [sampleRate;]
0421CB             0216*   ; inputs: hl = bufferId; a = format, de = sample rate in Hz
0421CB             0217*   ; The format is a single byte giving the format of the sample data. The following formats are supported:
0421CB             0218*   ; Value	Description
0421CB             0219*   ; 0	8-bit signed
0421CB             0220*   ; 1	8-bit unsigned
0421CB             0221*   ; The format value can also have modifier bits set to modify the behaviour of the sample. The following modifier bits are supported:
0421CB             0222*   ; Value	Description
0421CB             0223*   ; 8	sample rate is sent in the next 16-bits
0421CB             0224*   ; 16	sample is tuneable
0421CB             0225*   ; The default sample rate for samples on the VDP is 16kHz (actually 16.384kHz to be precise).
0421CB             0226*   vdu_buffer_to_sound:
0421CB 22 EB 21 04 0227*       ld (@bufferId),hl
0421CF C6 08       0228*       add a,8 ; modify format byte to indicate sample rate argument is given
0421D1 32 ED 21 04 0229*       ld (@format),a
0421D5 ED 53 EE 21 0230*       ld (@sampleRate),de
       04          
0421DA 21 E5 21 04 0231*       ld hl,@cmd
0421DE 01 0B 00 00 0232*       ld bc,@end-@cmd
0421E2 5B DF       0233*       rst.lil $18
0421E4 C9          0234*       ret
0421E5 17 00 85    0235*   @cmd:       db 23, 0, 0x85
0421E8 00          0236*   @channel:   db 0x00 ; ignored
0421E9 05          0237*               db 0x05 ; buffer to sound command
0421EA 02          0238*               db 0x02 ; command 2 create sample
0421EB 00 00       0239*   @bufferId:  dw 0x0000
0421ED 00          0240*   @format:    db 0x00
0421EE 00 00       0241*   @sampleRate: dw 0x0000
0421F0 00          0242*   @end:       db 0x00 ; padding
0421F1             0243*   
0421F1             0244*   ; Command 13: Set sample rate
0421F1             0245*   ; VDU 23, 0, &85, channel, 13, sampleRate;
0421F1             0246*   ; inputs: c = channel, hl = sampleRate (Hz)
0421F1             0247*   vdu_set_sample_rate:
0421F1 79          0248*       ld a,c
0421F2 32 08 22 04 0249*       ld (@channel),a
0421F6 22 0A 22 04 0250*       ld (@sampleRate),hl
0421FA 21 05 22 04 0251*       ld hl,@cmd
0421FE 01 07 00 00 0252*       ld bc,@end-@cmd
042202 5B DF       0253*       rst.lil $18
042204 C9          0254*       ret
042205 17 00 85    0255*   @cmd:       db 23, 0, 0x85
042208 00          0256*   @channel:   db 0x00
042209 0D          0257*               db 13 ; set sample rate command
04220A 00 00       0258*   @sampleRate: dw 0x0000
04220C 00          0259*   @end:       db 0x00 ; padding
04220D             0260*   
04220D             0261*   ; load a sound file to a buffer
04220D             0262*   ; inputs: hl = bufferId ; de = sampleRate in Hz ; iy = pointer to filename
04220D             0263*   vdu_load_sfx:
04220D             0264*   ; back up input parameters
04220D E5          0265*       push hl ; bufferId
04220E D5          0266*       push de ; sample rate
04220F             0267*   ; load the sound
04220F CD 4D 1D 04 0268*       call vdu_load_buffer_from_file
042213             0269*   ; now make the buffer a sound sample
042213 D1          0270*       pop de ; sample rate
042214 E1          0271*       pop hl ; bufferId
042215 AF          0272*       xor a ; zero is the magic number for mono 8-bit signed PCM
042216 CD CB 21 04 0273*       call vdu_buffer_to_sound
04221A C9          0274*       ret
04221B             0275*   
04221B             0276*   
04221B 00          0277*   last_channel: db 0
04221C             0278*   max_channels: equ 1
04221C             0279*   
04221C             0280*   ; play a sound effect from an already loaded buffer
04221C             0281*   ; inputs: hl = bufferId ; bc = duration in milliseconds
04221C             0282*   vdu_play_sfx:
04221C 22 54 22 04 0283*       ld (@bufferId),hl
042220 ED 43 5E 22 0284*       ld (@duration),bc
       04          
042225 3E 17       0285*       ld a,23
042227 32 56 22 04 0286*       ld (@bufferId+2),a
04222B 3A 1B 22 04 0287*       ld a,(last_channel)
04222F 3C          0288*       inc a
042230             0289*       ; and 31 ; modulo 32
042230 FE 01       0290*       cp max_channels
042232 C2 37 22 04 0291*       jp nz,@load_channel
042236 AF          0292*       xor a
042237             0293*   @load_channel:
042237 32 1B 22 04 0294*       ld (last_channel),a
04223B 32 51 22 04 0295*       ld (@channel0),a
04223F 32 59 22 04 0296*       ld (@channel1),a
042243 21 4E 22 04 0297*       ld hl, @sample
042247 01 12 00 00 0298*       ld bc, @sample_end - @sample
04224B 5B DF       0299*       rst.lil $18
04224D C9          0300*       ret
04224E             0301*   @sample:
04224E             0302*   ; Command 4: Set waveform
04224E             0303*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
04224E 17 00 85    0304*       .db 23,0,$85                        ; do sound
042251             0305*   @channel0:
042251 00 04 08    0306*       .db 0,4,8 ; channel, command, waveform
042254             0307*   @bufferId:
042254 00 00       0308*       .dw 0x0000
042256             0309*   ; Command 0: Play note
042256             0310*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
042256 17 00 85    0311*       .db 23,0,$85                        ; do sound
042259             0312*   @channel1:
042259 00 00 7F    0313*       .db 0,0,127                ; channel, volume
04225C 00 00       0314*       .dw 0
04225E             0315*   @duration:                              ; freq (tuneable samples only)
04225E 00 00       0316*       .dw 0x0000                        ; duration
042260             0317*   @sample_end:
042260 00          0318*       .db 0x00 ; padding
042261             0319*   
042261             0320*   ; inputs: c = channel, b = volume, de = sample rate; hl = bufferId;
042261             0321*   vdu_play_sample:
042261             0322*       ; populate input parameters
042261 79          0323*       ld a,c
042262 32 94 22 04 0324*       ld (@channel0),a
042266 32 9C 22 04 0325*       ld (@channel1),a
04226A 32 A3 22 04 0326*       ld (@channel2),a
04226E 78          0327*       ld a,b
04226F 32 A5 22 04 0328*       ld (@volume),a
042273 ED 53 9E 22 0329*       ld (@sampleRate),de
       04          
042278 22 97 22 04 0330*       ld (@bufferId),hl
04227C 3E 17       0331*       ld a,23
04227E 32 99 22 04 0332*       ld (@cmd1),a
042282 32 A0 22 04 0333*       ld (@cmd2),a
042286             0334*       ; prep the vdu command string
042286 21 91 22 04 0335*       ld hl, @cmd0
04228A 01 19 00 00 0336*       ld bc, @end - @cmd0
04228E 5B DF       0337*       rst.lil $18
042290 C9          0338*       ret
042291             0339*   ; set waveform command
042291 17 00 85    0340*   @cmd0:       db 23, 0, 0x85
042294 00          0341*   @channel0:   db 0x00
042295 04          0342*                db 0x04 ; set waveform command
042296 08          0343*   @waveform:   db 0x08 ; sample
042297 00 00       0344*   @bufferId:   dw 0x0000
042299             0345*   ; set sample rate command
042299 17 00 85    0346*   @cmd1:       db 23, 0, 0x85
04229C 00          0347*   @channel1:   db 0x00
04229D 0D          0348*               db 13 ; set sample rate command
04229E 00 00       0349*   @sampleRate: dw 0x0000
0422A0             0350*   ; play note command
0422A0 17 00 85    0351*   @cmd2:       db 23, 0, 0x85
0422A3 00          0352*   @channel2:   db 0x00
0422A4 00          0353*                db 0x00 ; play note command
0422A5 00          0354*   @volume:     db 0x00
0422A6 00 00       0355*   @frequency:  dw 0x00 ; no effect unless buffer has been set to tuneable sample
0422A8 00 00       0356*   @duration:   dw 0x0000 ; milliseconds: set to -1 to loop indefinitely, 0 to play full duration once
0422AA 00          0357*   @end:        db 0x00 ; padding
0422AB             0044    
0422AB             0045    ; APPLICATION INCLUDES
0422AB             0046        include "layout.inc"
0422AB             0001*   text_top: equ 0
0422AB             0002*   text_left: equ 0
0422AB             0003*   text_bottom: equ 47      ; 48 rows, zero-based
0422AB             0004*   text_right: equ 63       ; 64 columns, zero-based
0422AB             0005*   
0422AB 00          0006*   original_screen_mode: db 0 ; screen mode when app started so we can return to it on exit
0422AC             0007*   
0422AC 2D 2D 2D 2D 0008*   str_dashes_thin: asciz  "----------------------------------------------------------------"
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       00          
0422ED 3D 3D 3D 3D 0009*   str_dashes_thick: asciz "================================================================"
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       00          
04232E             0010*   
04232E             0011*   ; set text viewport for current playing song
04232E             0012*   vp_now_playing_top: equ 34
04232E             0013*   vp_now_playing:
04232E 0E 00       0014*       ld c, text_left
042330 16 22       0015*       ld d, vp_now_playing_top
042332 1E 3F       0016*       ld e, text_right
042334 06 22       0017*       ld b, vp_now_playing_top
042336 CD 98 1B 04 0018*       call vdu_set_txt_viewport
04233A C9          0019*       ret
04233B             0020*   ; end vp_now_playing
04233B             0021*   
04233B             0022*   ; set text viewport for elapsed time
04233B             0023*   vp_elapsed_top: equ vp_now_playing_top+1
04233B             0024*   vp_elapsed_right: equ text_left+7 ; 8 chars for HH:MM:SS
04233B             0025*   vp_elapsed:
04233B 0E 00       0026*       ld c, text_left
04233D 16 23       0027*       ld d, vp_elapsed_top
04233F 1E 07       0028*       ld e, vp_elapsed_right
042341 06 23       0029*       ld b, vp_elapsed_top
042343 CD 98 1B 04 0030*       call vdu_set_txt_viewport
042347 C9          0031*       ret
042348             0032*   ; end vp_elapsed
042348             0033*   
042348             0034*   ; set text viewport for song duration
042348             0035*   vp_duration_left: equ text_right-7 ; 8 chars for HH:MM:SS
042348             0036*   vp_duration_top: equ vp_now_playing_top+1
042348             0037*   vp_duration:
042348 0E 38       0038*       ld c, vp_duration_left
04234A 16 23       0039*       ld d, vp_duration_top
04234C 1E 3F       0040*       ld e, text_right
04234E 06 23       0041*       ld b, vp_duration_top
042350 CD 98 1B 04 0042*       call vdu_set_txt_viewport
042354 C9          0043*       ret
042355             0044*   ; end vp_duration
042355             0045*   
042355             0046*   ; set text viewport for playing breadcrumbs
042355             0047*   vp_playhead_left: equ vp_elapsed_right+1 ; leave room for left arrow
042355             0048*   vp_playhead_top: equ vp_now_playing_top+1
042355             0049*   vp_playhead_right: equ vp_duration_left-1 ; leave room for right arrow
042355             0050*   vp_playhead:
042355 0E 08       0051*       ld c, vp_playhead_left
042357 16 23       0052*       ld d, vp_playhead_top
042359 1E 37       0053*       ld e, vp_playhead_right
04235B 06 23       0054*       ld b, vp_playhead_top
04235D CD 98 1B 04 0055*       call vdu_set_txt_viewport
042361 C9          0056*       ret
042362             0057*   ; end vp_playhead
042362             0058*   
042362             0059*   vp_dir_hdr_top: equ 20
042362             0060*   vp_dir_hdr:
042362 0E 00       0061*       ld c,text_left
042364 16 14       0062*       ld d,vp_dir_hdr_top
042366 1E 3F       0063*       ld e,text_right
042368 06 14       0064*       ld b,vp_dir_hdr_top
04236A CD 98 1B 04 0065*       call vdu_set_txt_viewport
04236E C9          0066*       ret
04236F             0067*   
04236F             0068*   vp_dir_name_top: equ vp_dir_hdr_top+1
04236F             0069*   vp_dir_name:
04236F 0E 00       0070*       ld c,text_left
042371 16 15       0071*       ld d,vp_dir_name_top
042373 1E 3F       0072*       ld e,text_right
042375 06 15       0073*       ld b,vp_dir_name_top
042377 CD 98 1B 04 0074*       call vdu_set_txt_viewport
04237B C9          0075*       ret
04237C             0076*   
04237C             0077*   ; set text viewport for directory listing
04237C             0078*   vp_dir_top: equ vp_dir_hdr_top+3
04237C             0079*   vp_dir_bottom: equ vp_dir_top+9
04237C             0080*   vp_dir:
04237C 0E 00       0081*       ld c,text_left
04237E 16 17       0082*       ld d,vp_dir_top
042380 1E 3F       0083*       ld e,text_right
042382 06 20       0084*       ld b,vp_dir_bottom
042384 CD 98 1B 04 0085*       call vdu_set_txt_viewport
042388 C9          0086*       ret
042389             0087*   
042389             0088*   vp_legend_top: equ vp_playhead_top+2
042389             0089*   vp_legend:
042389 0E 00       0090*       ld c,text_left
04238B 16 25       0091*       ld d,vp_legend_top
04238D 1E 3F       0092*       ld e,text_right
04238F 06 27       0093*       ld b,vp_legend_top+2
042391 CD 98 1B 04 0094*       call vdu_set_txt_viewport
042395 C9          0095*       ret
042396             0096*   
042396             0097*   vp_legend_shuffle_top: equ vp_legend_top+1
042396             0098*   vp_legend_shuffle_left: equ text_left+33
042396             0099*   vp_legend_shuffle:
042396 0E 21       0100*       ld c,vp_legend_shuffle_left
042398 16 26       0101*       ld d,vp_legend_shuffle_top
04239A 1E 23       0102*       ld e,vp_legend_shuffle_left+2
04239C 06 26       0103*       ld b,vp_legend_shuffle_top
04239E CD 98 1B 04 0104*       call vdu_set_txt_viewport
0423A2 C9          0105*       ret
0423A3             0106*   
0423A3             0107*   vp_legend_loop_top: equ vp_legend_top+1
0423A3             0108*   vp_legend_loop_left: equ text_left+51
0423A3             0109*   vp_legend_loop:
0423A3 0E 33       0110*       ld c,vp_legend_loop_left
0423A5 16 26       0111*       ld d,vp_legend_loop_top
0423A7 1E 35       0112*       ld e,vp_legend_loop_left+2
0423A9 06 26       0113*       ld b,vp_legend_loop_top
0423AB CD 98 1B 04 0114*       call vdu_set_txt_viewport
0423AF C9          0115*       ret
0423B0             0116*   
0423B0             0117*   vp_messages_top: equ vp_playhead_top+6
0423B0             0118*   vp_messages_bottom: equ text_bottom
0423B0             0119*   ; set text viewport for messages
0423B0             0120*   vp_messages:
0423B0 0E 00       0121*       ld c,text_left
0423B2 16 29       0122*       ld d,vp_messages_top
0423B4 1E 3F       0123*       ld e,text_right
0423B6 06 2F       0124*       ld b,vp_messages_bottom
0423B8 CD 98 1B 04 0125*       call vdu_set_txt_viewport
0423BC C9          0126*       ret
0423BD             0127*   
0423BD             0128*   set_text_colours_normal:
0423BD             0129*   ; set text background color
0423BD 3E 84       0130*       ld a,c_blue_dk+128
0423BF CD 70 1B 04 0131*       call vdu_colour_text
0423C3             0132*   ; set text foreground color
0423C3 3E 0F       0133*       ld a,c_white
0423C5 CD 70 1B 04 0134*       call vdu_colour_text
0423C9 C9          0135*       ret
0423CA             0136*   ; end set_text_colours_normal
0423CA             0137*   
0423CA             0138*   set_text_colours_inverse:
0423CA             0139*   ; set text background color
0423CA 3E 8F       0140*       ld a,c_white+128
0423CC CD 70 1B 04 0141*       call vdu_colour_text
0423D0             0142*   ; set text foreground color
0423D0 3E 04       0143*       ld a,c_blue_dk
0423D2 CD 70 1B 04 0144*       call vdu_colour_text
0423D6 C9          0145*       ret
0423D7             0146*   ; end set_text_colours_inverse
0423D7             0147*   
0423D7             0148*   ui_init:
0423D7             0149*   ; get current screen mode and save it so we can return to it on exit
0423D7 CD 1E 1C 04 0150*       call vdu_get_screen_mode
0423DB 32 AB 22 04 0151*       ld (original_screen_mode),a
0423DF             0152*   ; set up display
0423DF 3E 14       0153*       ld a,20 ; 512x384x64 single-buffered
0423E1 CD 0D 1C 04 0154*       call vdu_set_screen_mode
0423E5 AF          0155*       xor a
0423E6 CD 26 1C 04 0156*       call vdu_set_scaling
0423EA             0157*   ; load fonts and select one
0423EA CD 14 1F 04 0158*       call vdu_clear_all_buffers
0423EE CD BB 0D 04 0159*   	call font_load
0423F2 21 10 FA 00 0160*       ld hl,Lat2_VGA8_8x8
0423F6 3E 01       0161*       ld a,1
0423F8 CD 86 1F 04 0162*       call vdu_font_select
0423FC             0163*   ; set text fg and bg colours to normal
0423FC CD BD 23 04 0164*       call set_text_colours_normal
042400             0165*   ; set cursor behaviuor
042400 CD C7 1A 04 0166*       call vdu_cursor_off
042404 26 10       0167*       ld h,%00010000 ; bit 4 controls cursor scroll at bottom of screen
042406 2E 10       0168*       ld l,%00010000 ; bit 4 set means cursor wraps to top of screen
042408 CD 2B 1B 04 0169*       call vdu_cursor_behaviour
04240C             0170*   ; reset text viewports and clear the screen
04240C CD 08 1C 04 0171*       call vdu_reset_viewports
042410 CD 3F 1B 04 0172*       call vdu_cls
042414             0173*   
042414             0174*   ; tippy top border
042414 0E 00       0175*       ld c,text_left ; x
042416 06 00       0176*       ld b,text_top ; y
042418 CD 17 1B 04 0177*       call vdu_move_cursor
04241C 21 ED 22 04 0178*       ld hl,str_dashes_thick
042420 CD 67 00 04 0179*       call printString
042424             0180*   
042424             0181*   ; print ascii art splash screen
042424 0E 00       0182*       ld c,text_left ; x
042426 06 01       0183*       ld b,text_top+1 ; y
042428 CD 17 1B 04 0184*       call vdu_move_cursor
04242C 21 5B 25 04 0185*       ld hl,agon_jukebox_ascii
042430 CD 67 00 04 0186*       call printString
042434             0187*   
042434             0188*   ; below logo border
042434 0E 00       0189*       ld c,text_left ; x
042436 06 13       0190*       ld b,vp_dir_hdr_top-1 ; y
042438 CD 17 1B 04 0191*       call vdu_move_cursor
04243C 21 ED 22 04 0192*       ld hl,str_dashes_thick
042440 CD 67 00 04 0193*       call printString
042444             0194*   
042444             0195*   ; print the directory header
042444 0E 00       0196*       ld c,text_left ; x
042446 06 14       0197*       ld b,vp_dir_hdr_top ; y
042448 CD 17 1B 04 0198*       call vdu_move_cursor
04244C CD 60 00 04 0199*       call printInline
042450 4F 75 72 20 0200*       asciz "Our current directory is:"
       63 75 72 72 
       65 6E 74 20 
       64 69 72 65 
       63 74 6F 72 
       79 20 69 73 
       3A 00       
04246A             0201*   
04246A             0202*   ; file list top border
04246A 0E 00       0203*       ld c,text_left ; x
04246C 06 16       0204*       ld b,vp_dir_top-1 ; y
04246E CD 17 1B 04 0205*       call vdu_move_cursor
042472 21 AC 22 04 0206*       ld hl,str_dashes_thin
042476 CD 67 00 04 0207*       call printString
04247A             0208*   
04247A             0209*   ; file list bottom border
04247A 0E 00       0210*       ld c,text_left ; x
04247C 06 21       0211*       ld b,vp_dir_bottom+1 ; y
04247E CD 17 1B 04 0212*       call vdu_move_cursor
042482 21 AC 22 04 0213*       ld hl,str_dashes_thin
042486 CD 67 00 04 0214*       call printString
04248A             0215*   
04248A             0216*   ; below the breadcrumbs border
04248A 0E 00       0217*       ld c,text_left ; x
04248C 06 24       0218*       ld b,vp_playhead_top+1 ; y
04248E CD 17 1B 04 0219*       call vdu_move_cursor
042492 21 ED 22 04 0220*       ld hl,str_dashes_thick
042496 CD 67 00 04 0221*       call printString
04249A             0222*   
04249A             0223*   ; print the navigation and song control instructions
04249A 0E 00       0224*       ld c,text_left ; x
04249C 06 25       0225*       ld b,vp_playhead_top+2 ; y
04249E CD 17 1B 04 0226*       call vdu_move_cursor
0424A2 CD 60 00 04 0227*       call printInline
0424A6 20 53 6F 6E 0228*       db " Song \e",24," \e",25," or 0-9    | Page \e",27," \e",26,"           | [U]p directory\r\n"
       67 20 1B 18 
       20 1B 19 20 
       6F 72 20 30 
       2D 39 20 20 
       20 20 7C 20 
       50 61 67 65 
       20 1B 1B 20 
       1B 1A 20 20 
       20 20 20 20 
       20 20 20 20 
       20 7C 20 5B 
       55 5D 70 20 
       64 69 72 65 
       63 74 6F 72 
       79 0D 0A    
0424E5 20 5B 52 5D 0229*       db " [R]andom song      | [S]huffle: OFF     | [L]oop: OFF\r\n"
       61 6E 64 6F 
       6D 20 73 6F 
       6E 67 20 20 
       20 20 20 20 
       7C 20 5B 53 
       5D 68 75 66 
       66 6C 65 3A 
       20 4F 46 46 
       20 20 20 20 
       20 7C 20 5B 
       4C 5D 6F 6F 
       70 3A 20 4F 
       46 46 0D 0A 
04251D 20 5B 45 53 0230*       db " [ESC] or [Q]uit    |                    |\r\n"
       43 5D 20 6F 
       72 20 5B 51 
       5D 75 69 74 
       20 20 20 20 
       7C 20 20 20 
       20 20 20 20 
       20 20 20 20 
       20 20 20 20 
       20 20 20 20 
       20 7C 0D 0A 
042549 00          0231*       db 0 ; null terminator
04254A             0232*   
04254A             0233*   ; below the detailed instructions / status border
04254A 0E 00       0234*       ld c,text_left ; x
04254C 06 28       0235*       ld b,vp_playhead_top+5 ; y
04254E CD 17 1B 04 0236*       call vdu_move_cursor
042552 21 ED 22 04 0237*       ld hl,str_dashes_thick
042556 CD 67 00 04 0238*       call printString
04255A             0239*   
04255A C9          0240*       ret
04255B             0241*   ; end ui_init
04255B             0047        include "ascii.inc"
04255B             0001*   agon_jukebox_ascii:
04255B 20 20 20 5F 0002*       db 32,32,32,95,95,95,95,95,32,32,32,32,95,95,95,95,95,95,95,95,32,95,95,95,95,95,95,95,95,32,32,32,32,95,95,95,95,95,95,95,13,10
       5F 5F 5F 5F 
       20 20 20 20 
       5F 5F 5F 5F 
       5F 5F 5F 5F 
       20 5F 5F 5F 
       5F 5F 5F 5F 
       5F 20 20 20 
       20 5F 5F 5F 
       5F 5F 5F 5F 
       0D 0A       
042585 20 20 2F 20 0003*       db 32,32,47,32,32,95,32,32,92,32,32,47,32,32,95,95,95,95,95,47,32,92,95,95,95,95,95,32,32,92,32,32,32,92,32,32,32,32,32,32,92,13,10
       20 5F 20 20 
       5C 20 20 2F 
       20 20 5F 5F 
       5F 5F 5F 2F 
       20 5C 5F 5F 
       5F 5F 5F 20 
       20 5C 20 20 
       20 5C 20 20 
       20 20 20 20 
       5C 0D 0A    
0425B0 20 2F 20 20 0004*       db 32,47,32,32,47,95,92,32,32,92,47,32,32,32,92,32,32,95,95,95,32,32,47,32,32,32,124,32,32,32,92,32,32,47,32,32,32,124,32,32,32,92,13,10
       2F 5F 5C 20 
       20 5C 2F 20 
       20 20 5C 20 
       20 5F 5F 5F 
       20 20 2F 20 
       20 20 7C 20 
       20 20 5C 20 
       20 2F 20 20 
       20 7C 20 20 
       20 5C 0D 0A 
0425DC 2F 20 20 20 0005*       db 47,32,32,32,32,124,32,32,32,32,92,32,32,32,32,92,95,92,32,32,92,47,32,32,32,32,124,32,32,32,32,92,47,32,32,32,32,124,32,32,32,32,92,13,10
       20 7C 20 20 
       20 20 5C 20 
       20 20 20 5C 
       5F 5C 20 20 
       5C 2F 20 20 
       20 20 7C 20 
       20 20 20 5C 
       2F 20 20 20 
       20 7C 20 20 
       20 20 5C 0D 
       0A          
042609 5C 5F 5F 5F 0006*       db 92,95,95,95,95,124,95,95,32,32,47,92,95,95,95,95,95,95,32,32,47,92,95,95,95,95,95,95,95,32,32,47,92,95,95,95,95,124,95,95,32,32,47,13,10
       5F 7C 5F 5F 
       20 20 2F 5C 
       5F 5F 5F 5F 
       5F 5F 20 20 
       2F 5C 5F 5F 
       5F 5F 5F 5F 
       5F 20 20 2F 
       5C 5F 5F 5F 
       5F 7C 5F 5F 
       20 20 2F 0D 
       0A          
042636 20 20 20 20 0007*       db 32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,32,92,47,13,10
       20 20 20 20 
       5C 2F 20 20 
       20 20 20 20 
       20 20 5C 2F 
       20 20 20 20 
       20 20 20 20 
       20 5C 2F 20 
       20 20 20 20 
       20 20 20 20 
       5C 2F 0D 0A 
042662 20 20 20 20 0008*       db 32,32,32,32,32,95,95,95,95,32,95,95,95,95,32,95,95,95,32,95,95,95,95,32,32,95,95,32,95,95,95,95,95,95,95,95,95,95,95,13,10
       20 5F 5F 5F 
       5F 20 5F 5F 
       5F 5F 20 5F 
       5F 5F 20 5F 
       5F 5F 5F 20 
       20 5F 5F 20 
       5F 5F 5F 5F 
       5F 5F 5F 5F 
       5F 5F 5F 0D 
       0A          
04268B 20 20 20 20 0009*       db 32,32,32,32,124,32,32,32,32,124,32,32,32,32,124,32,32,32,92,32,32,32,32,124,47,32,95,124,92,95,32,32,32,95,95,95,95,95,47,13,10
       7C 20 20 20 
       20 7C 20 20 
       20 20 7C 20 
       20 20 5C 20 
       20 20 20 7C 
       2F 20 5F 7C 
       5C 5F 20 20 
       20 5F 5F 5F 
       5F 5F 2F 0D 
       0A          
0426B4 20 20 20 20 0010*       db 32,32,32,32,124,32,32,32,32,124,32,32,32,32,124,32,32,32,47,32,32,32,32,32,32,60,32,32,32,124,32,32,32,32,95,95,41,95,13,10
       7C 20 20 20 
       20 7C 20 20 
       20 20 7C 20 
       20 20 2F 20 
       20 20 20 20 
       20 3C 20 20 
       20 7C 20 20 
       20 20 5F 5F 
       29 5F 0D 0A 
0426DC 2F 5C 5F 5F 0011*       db 47,92,95,95,124,32,32,32,32,124,32,32,32,32,124,32,32,47,124,32,32,32,32,124,32,32,92,32,32,124,32,32,32,32,32,32,32,32,92,13,10
       7C 20 20 20 
       20 7C 20 20 
       20 20 7C 20 
       20 2F 7C 20 
       20 20 20 7C 
       20 20 5C 20 
       20 7C 20 20 
       20 20 20 20 
       20 20 5C 0D 
       0A          
042705 5C 5F 5F 5F 0012*       db 92,95,95,95,95,95,95,95,95,124,95,95,95,95,95,95,47,32,124,95,95,95,95,124,95,95,32,92,47,95,95,95,95,95,95,95,32,32,47,13,10
       5F 5F 5F 5F 
       5F 7C 5F 5F 
       5F 5F 5F 5F 
       2F 20 7C 5F 
       5F 5F 5F 7C 
       5F 5F 20 5C 
       2F 5F 5F 5F 
       5F 5F 5F 5F 
       20 20 2F 0D 
       0A          
04272E 20 20 20 20 0013*       db 32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,92,47,13,10
       20 20 20 20 
       20 20 20 20 
       20 20 20 20 
       20 20 20 20 
       20 20 20 20 
       20 20 5C 2F 
       20 20 20 20 
       20 20 20 20 
       5C 2F 0D 0A 
042756 20 20 20 20 0014*       db 32,32,32,32,95,95,95,95,95,95,95,95,95,95,32,95,95,95,95,95,95,95,95,32,32,95,95,95,95,32,32,95,95,95,13,10
       5F 5F 5F 5F 
       5F 5F 5F 5F 
       5F 5F 20 5F 
       5F 5F 5F 5F 
       5F 5F 5F 20 
       20 5F 5F 5F 
       5F 20 20 5F 
       5F 5F 0D 0A 
04277A 20 20 20 20 0015*       db 32,32,32,32,92,95,95,95,95,95,95,32,32,32,92,92,95,95,95,95,95,32,32,92,32,92,32,32,32,92,47,32,32,47,13,10
       5C 5F 5F 5F 
       5F 5F 5F 20 
       20 20 5C 5C 
       5F 5F 5F 5F 
       5F 20 20 5C 
       20 5C 20 20 
       20 5C 2F 20 
       20 2F 0D 0A 
04279E 20 20 20 20 0016*       db 32,32,32,32,32,124,32,32,32,32,124,32,32,95,47,32,47,32,32,32,124,32,32,32,92,32,92,32,32,32,32,32,47,13,10
       20 7C 20 20 
       20 20 7C 20 
       20 5F 2F 20 
       2F 20 20 20 
       7C 20 20 20 
       5C 20 5C 20 
       20 20 20 20 
       2F 0D 0A    
0427C1 20 20 20 20 0017*       db 32,32,32,32,32,124,32,32,32,32,124,32,32,32,92,47,32,32,32,32,124,32,32,32,32,92,47,32,32,32,32,32,92,13,10
       20 7C 20 20 
       20 20 7C 20 
       20 20 5C 2F 
       20 20 20 20 
       7C 20 20 20 
       20 5C 2F 20 
       20 20 20 20 
       5C 0D 0A    
0427E4 20 20 20 20 0018*       db 32,32,32,32,32,124,95,95,95,95,95,95,32,32,47,92,95,95,95,95,95,95,95,32,32,47,95,95,95,47,92,32,32,92,13,10
       20 7C 5F 5F 
       5F 5F 5F 5F 
       20 20 2F 5C 
       5F 5F 5F 5F 
       5F 5F 5F 20 
       20 2F 5F 5F 
       5F 2F 5C 20 
       20 5C 0D 0A 
042808 20 20 20 20 0019*       db 32,32,32,32,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,92,95,47,13,10
       20 20 20 20 
       20 20 20 20 
       5C 2F 20 20 
       20 20 20 20 
       20 20 20 5C 
       2F 20 20 20 
       20 20 20 5C 
       5F 2F 0D 0A 
04282C 00          0020*       db 0 ; list terminator
04282D             0048        include "browse.inc"
04282D             0001*   ; browse_song state variables
04282D             0002*   ; current active channel and bufferId's
04282D 00 00 00 00 0003*   bs_dir_path:   blkb 256,0 ; path of the current directory
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04292D 00 00 00    0004*   bs_dir_num_files: dl 0 ; number of files/directories in the directory (virtually unlimited)
042930 00 00 00    0005*   bs_dir_num_pages: dl 0 ; number of pages in the directory (virtually unlimited)
042933 00 00 00    0006*   bs_page_num_files: dl 0 ; number of files/directories in the current directory page (max 10)
042936 00 00 00    0007*   bs_pagelast_num_files: dl 0 ; mod(bs_dir_num_files,10)
042939 00 00 00    0008*   bs_page_cur: dl 0 ; current directory page number
04293C 00          0009*   bs_song_idx_cur: db 0 ; current song index in the directory page
04293D 00 00 00    0010*   bs_song_fn_cur: dl 0 ; pointer to current song filename
042940 00 00 00 00 0011*   bs_song_duration: blkw 5,0 ; duration of the current song in seconds (32-bit word plus a padding byte)
       00 00 00 00 
       00 00       
04294A 00 00 00    0012*   bs_playhead: dl 0 ; current playhead position in the song in seconds from the start
04294D 00 00 00 00 0013*   bs_page_fn_ptrs: blkw 10*3,0 ; list of filename pointers in the current directory page
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042989             0014*   
042989             0015*   ; browse_song directory info
042989             0016*   bs_dir_struct:
042989 00 00 00 00 0017*   bs_dptr:       blkb  4,0   ; Current read/write offset
04298D 00 00 00 00 0018*   bs_clust:      blkb  4,0   ; Current cluster
042991 00 00 00 00 0019*   bs_sect:       blkb  4,0   ; Current sector (0:Read operation has terminated)
042995 00 00 00    0020*   bs_dir:        blkb  3,0   ; Pointer to the directory item in the win[]
042998 00 00 00 00 0021*   bs_fn:         blkb  12,0  ; SFN (in/out) {body[8],ext[3],status[1]}
       00 00 00 00 
       00 00 00 00 
0429A4 00 00 00 00 0022*   bs_blk_ofs:    blkb  4,0   ; Offset of current entry block being processed (0xFFFFFFFF:Invalid)
0429A8             0023*   
0429A8             0024*   ; browse_song file info
0429A8 00          0025*   bs_filehandle_cur: db 0 ; file handle
0429A9 00 00 00    0026*   bs_chunkpointer: dl 0 ; pointer to current chunk
0429AC             0027*   ; File information structure (FILINFO)
0429AC             0028*   bs_file_struct:
0429AC 00 00 00 00 0029*   bs_file_fsize:    blkb 4, 0   ; File size (4 bytes)
0429B0 00 00       0030*   bs_file_fdate:    blkb 2, 0   ; Modified date (2 bytes)
0429B2 00 00       0031*   bs_file_ftime:    blkb 2, 0   ; Modified time (2 bytes)
0429B4 00          0032*   bs_file_fattrib:  blkb 1, 0   ; File attribute (1 byte)
0429B5 00 00 00 00 0033*   bs_file_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
0429C2 00 00 00 00 0034*   bs_file_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042AC2             0035*   
042AC2             0036*   ; buffer for browse_song sound data
042AC2             0037*   bs_wav_header: ; marker for top of the wav file header and song data
042AC2             0038*   ; (must be last so buffer doesn't overwrite other program code or data)
042AC2             0039*   ; .wav header data
042AC2             0040*   ; WAV File Structure in Memory with LIST Chunk
042AC2 00 00 00 00 0041*   bs_wav_riff:          blkb 4,0   ; 4 bytes: "RIFF" identifier
042AC6 00 00 00 00 0042*   bs_wav_file_size:     blkb 4,0   ; 4 bytes: Total file size minus 8 bytes for RIFF header
042ACA 00 00 00 00 0043*   bs_wav_wave:          blkb 4,0   ; 4 bytes: "WAVE" identifier
042ACE 00 00 00 00 0044*   bs_wav_fmt_marker:    blkb 4,0   ; 4 bytes: "fmt " subchunk marker
042AD2 00 00 00 00 0045*   bs_wav_fmt_size:      blkb 4,0   ; 4 bytes: Format chunk size (16 for PCM)
042AD6 00 00       0046*   bs_wav_audio_format:  blkb 2,0   ; 2 bytes: Audio format (1 = PCM)
042AD8 00 00       0047*   bs_wav_num_channels:  blkb 2,0   ; 2 bytes: Number of channels (1 = mono, 2 = stereo)
042ADA 00 00 00 00 0048*   bs_wav_sample_rate:   blkb 4,0   ; 4 bytes: Sample rate in Hz (e.g., 32768)
042ADE 00 00 00 00 0049*   bs_wav_byte_rate:     blkb 4,0   ; 4 bytes: Bytes per second (SampleRate * NumChannels * BitsPerSample / 8)
042AE2 00 00       0050*   bs_wav_block_align:   blkb 2,0   ; 2 bytes: Bytes per sample block (NumChannels * BitsPerSample / 8)
042AE4 00 00       0051*   bs_wav_bits_per_sample: blkb 2,0 ; 2 bytes: Bits per sample (e.g., 8 or 16)
042AE6             0052*   
042AE6             0053*   ; LIST Chunk (Extra Metadata)
042AE6 00 00 00 00 0054*   bs_wav_list_marker:   blkb 4,0   ; 4 bytes: "LIST" marker
042AEA 00 00 00 00 0055*   bs_wav_list_size:     blkb 4,0   ; 4 bytes: Size of the LIST chunk (e.g., 26)
042AEE 00 00 00 00 0056*   bs_wav_info_marker:   blkb 4,0   ; 4 bytes: "INFO" marker
042AF2 00 00 00 00 0057*   bs_wav_isft_marker:   blkb 4,0   ; 4 bytes: "ISFT" marker (software identifier)
042AF6 00 00 00 00 0058*   bs_wav_isft_data:     blkb 14,0  ; 14 bytes: Software info string (e.g., "Lavf59.27.100")
       00 00 00 00 
       00 00 00 00 
       00 00       
042B04 00 00       0059*   bs_wav_isft_padding:  blkb 2,0   ; 2 bytes: Padding/NULL terminator for alignment
042B06             0060*   
042B06             0061*   ; Data Chunk
042B06 00 00 00 00 0062*   bs_wav_data_marker:   blkb 4,0   ; 4 bytes: "data" subchunk marker
042B0A 00 00 00 00 0063*   bs_wav_data_size:     blkb 4,0   ; 4 bytes: Size of the audio data in bytes
042B0E             0064*   ; Total Header Size: 76 bytes
042B0E             0049        include "input.inc"
042B0E             0001*   get_input:
042B0E             0002*   ; wait for the user to push a button
042B0E FB          0003*       ei ; enable interrupts
042B0F             0004*       MOSCALL mos_getkey ; a = ascii code of key pressed
                       M1 Args: function=mos_getkey 
042B0F 3E 00       0001*M1 			LD	A, function
042B11 5B CF       0002*M1 			RST.LIL	08h
042B13 F3          0005*       di ; disable interrupts
042B14             0006*   
042B14             0007*   ; DEBUG
042B14             0008*   ; clear sysvar_keyascii
042B14 6F          0009*       ld l,a ; store for a sec
042B15             0010*   	MOSCALL mos_sysvars
                       M1 Args: function=mos_sysvars 
042B15 3E 08       0001*M1 			LD	A, function
042B17 5B CF       0002*M1 			RST.LIL	08h
042B19 AF          0011*   	xor a
042B1A DD 77 05    0012*   	ld (IX+sysvar_keyascii),a
042B1D 7D          0013*       ld a,l ; restore a
042B1E             0014*   ; DEBUG
042B1E             0015*   
042B1E             0016*   ; app control commands
042B1E             0017*   
042B1E             0018*   ; RETURN TO MAIN, which re-enables interrupts and exits app
042B1E FE 1B       0019*       cp '\e' ; escape
042B20 C8          0020*       ret z
042B21 FE 71       0021*       cp 'q' ; quit
042B23 C8          0022*       ret z
042B24             0023*   
042B24             0024*   ; DIRECTORY PAGING
042B24 FE 15       0025*       cp 0x15 ; right arrow
042B26 CA D0 30 04 0026*       jp z,ps_dir_next_page
042B2A FE 08       0027*       cp 0x08 ; left arrow
042B2C CA EF 30 04 0028*       jp z,ps_dir_prev_page
042B30 FE 75       0029*       cp 'u' ; go up one directory
042B32 CA 8A 2B 04 0030*       jp z,ps_up_dir
042B36             0031*   
042B36             0032*   ; SONG PLAYING COMMANDS
042B36             0033*   ; toggle play / pause
042B36 FE 70       0034*       cp 'p'
042B38 CA F2 2B 04 0035*       jp z,ps_toggle_pause
042B3C             0036*   ; toggle loop
042B3C FE 6C       0037*       cp 'l'
042B3E CA 6F 2C 04 0038*       jp z,ps_toggle_loop
042B42             0039*   ; toggle shuffle
042B42 FE 73       0040*       cp 's'
042B44 CA 36 2C 04 0041*       jp z,ps_toggle_shuffle
042B48             0042*   ; play random song
042B48 FE 72       0043*       cp 'r'
042B4A CA C0 31 04 0044*       jp z,ps_play_random
042B4E             0045*   ; up / down arrow play song keys
042B4E FE 0B       0046*       cp 0x0B ; up arrow
042B50 CA 8F 31 04 0047*       jp z,ps_play_prev_song
042B54 FE 0A       0048*       cp 0x0A ; down arrow
042B56 CA 61 31 04 0049*       jp z,ps_play_next_song
042B5A             0050*   ; 0-9 play song keys
042B5A             0051*   @@:
042B5A FE 30       0052*       cp '0'
042B5C DA 70 2B 04 0053*       jp c,@no_cmd ; not a song command
042B60 FE 3A       0054*       cp '9'+1
042B62 D2 70 2B 04 0055*       jp nc,@no_cmd ; not a song command
042B66             0056*   ; get pointer to song filename and play it
042B66 D6 30       0057*       sub '0' ; a = index into filename lut
042B68 CD 12 31 04 0058*       call ps_get_song_fn_from_pg_idx ; carry set indicates success
042B6C DA 74 2B 04 0059*       jp c,ps_play_or_chg_dir ; re-enables interrupts and jp's to get_input when finished
042B70             0060*   @no_cmd: ; no valid commands so loop
042B70 C3 0E 2B 04 0061*       jp get_input
042B74             0062*   ; end get_input
042B74             0063*   
042B74             0064*   ; play or song or change directory when user issues a play song command
042B74             0065*   ; inputs: hl pointer to the filename, a = file attribute
042B74             0066*   ps_play_or_chg_dir:
042B74 FE 10       0067*       cp AM_DIR ; file attribute check for directory
042B76 C2 ED 2D 04 0068*       jp nz,play_song ; not a directory so play the song
042B7A             0069*   ; otherwise change to the directory
042B7A             0070*       MOSCALL mos_cd ; change to the directory
                       M1 Args: function=mos_cd 
042B7A 3E 03       0001*M1 			LD	A, function
042B7C 5B CF       0002*M1 			RST.LIL	08h
042B7E CD 03 2F 04 0071*       call ps_get_dir ; get directory listing
042B82 CD A1 2B 04 0072*       call ps_stop ; TEMPORARY until we have separate buffers for playback and browsing
042B86 C3 0E 2B 04 0073*       jp get_input ; back to main loop
042B8A             0074*   ; end ps_play_or_chg_dir
042B8A             0075*   
042B8A             0076*   ; change directory one level up
042B8A             0077*   ; inputs: none
042B8A             0078*   ps_up_dir:
042B8A CD A1 2B 04 0079*       call ps_stop ; TEMPORARY until we have separate buffers for playback and browsing
042B8E 21 9E 2B 04 0080*       ld hl,@str_up_dir
042B92             0081*       MOSCALL mos_cd ; change to the directory
                       M1 Args: function=mos_cd 
042B92 3E 03       0001*M1 			LD	A, function
042B94 5B CF       0002*M1 			RST.LIL	08h
042B96 CD 03 2F 04 0082*       call ps_get_dir ; get directory listing
042B9A C3 0E 2B 04 0083*       jp get_input ; back to main loop
042B9E 2E 2E 00    0084*   @str_up_dir: asciz ".."
042BA1             0085*   ; end ps_up_dir
042BA1             0086*   
042BA1             0087*   ; TEMPORARY until we have separate buffers for playback and browsing
042BA1             0088*   ps_stop:
042BA1 21 A8 2C 04 0089*       ld hl,ps_mode
042BA5 CB 86       0090*       res ps_mode_playing,(hl)
042BA7 CD 2E 23 04 0091*       call vp_now_playing
042BAB CD 3F 1B 04 0092*       call vdu_cls
042BAF CD 60 00 04 0093*       call printInline
042BB3 53 74 6F 70 0094*       asciz "Stopped due to directory change. Select a new song to resume."
       70 65 64 20 
       64 75 65 20 
       74 6F 20 64 
       69 72 65 63 
       74 6F 72 79 
       20 63 68 61 
       6E 67 65 2E 
       20 53 65 6C 
       65 63 74 20 
       61 20 6E 65 
       77 20 73 6F 
       6E 67 20 74 
       6F 20 72 65 
       73 75 6D 65 
       2E 00       
042BF1 C9          0095*       ret
042BF2             0096*   ; end ps_stop
042BF2             0097*   
042BF2             0098*   ps_toggle_pause:
042BF2 CD 2E 23 04 0099*       call vp_now_playing
042BF6 CD 3F 1B 04 0100*       call vdu_cls
042BFA             0101*   
042BFA 21 A8 2C 04 0102*       ld hl,ps_mode
042BFE CB 46       0103*       bit ps_mode_playing,(hl)
042C00 C2 19 2C 04 0104*       jp nz,@playing
042C04             0105*   
042C04 CB C6       0106*       set ps_mode_playing,(hl)
042C06 CD 60 00 04 0107*       call printInline
042C0A 28 50 29 6C 0108*       asciz "(P)laying "
       61 79 69 6E 
       67 20 00    
042C15 C3 2A 2C 04 0109*       jp @F
042C19             0110*   
042C19             0111*   @playing:
042C19 CB 86       0112*       res ps_mode_playing,(hl)
042C1B CD 60 00 04 0113*       call printInline
042C1F 28 50 29 61 0114*       asciz "(P)aused  "
       75 73 65 64 
       20 20 00    
042C2A             0115*   
042C2A             0116*   @@:
042C2A 2A C0 2C 04 0117*       ld hl,(ps_song_fn_cur)
042C2E CD 67 00 04 0118*       call printString ; print the song filename
042C32             0119*   
042C32 C3 0E 2B 04 0120*       jp get_input
042C36             0121*   ; end ps_toggle_pause
042C36             0122*   
042C36             0123*   ps_toggle_shuffle:
042C36 CD 96 23 04 0124*       call vp_legend_shuffle
042C3A CD 3F 1B 04 0125*       call vdu_cls
042C3E             0126*   
042C3E 21 A8 2C 04 0127*       ld hl,ps_mode
042C42 CB 56       0128*       bit ps_mode_shuffle,(hl)
042C44 C2 61 2C 04 0129*       jp nz,@shuffling
042C48             0130*   
042C48 CD CA 23 04 0131*       call set_text_colours_inverse
042C4C 21 A8 2C 04 0132*       ld hl,ps_mode
042C50 CB D6       0133*       set ps_mode_shuffle,(hl)
042C52 CD 60 00 04 0134*       call printInline
042C56 4F 4E 00    0135*       asciz "ON"
042C59 CD BD 23 04 0136*       call set_text_colours_normal
042C5D C3 0E 2B 04 0137*       jp get_input
042C61             0138*   
042C61             0139*   @shuffling:
042C61 CB 96       0140*       res ps_mode_shuffle,(hl)
042C63 CD 60 00 04 0141*       call printInline
042C67 4F 46 46 00 0142*       asciz "OFF"
042C6B C3 0E 2B 04 0143*       jp get_input
042C6F             0144*   ; end ps_toggle_shuffle
042C6F             0145*   
042C6F             0146*   ps_toggle_loop:
042C6F CD A3 23 04 0147*       call vp_legend_loop
042C73 CD 3F 1B 04 0148*       call vdu_cls
042C77             0149*   
042C77 21 A8 2C 04 0150*       ld hl,ps_mode
042C7B CB 4E       0151*       bit ps_mode_loop,(hl)
042C7D C2 9A 2C 04 0152*       jp nz,@looping
042C81             0153*   
042C81 CD CA 23 04 0154*       call set_text_colours_inverse
042C85 21 A8 2C 04 0155*       ld hl,ps_mode
042C89 CB CE       0156*       set ps_mode_loop,(hl)
042C8B CD 60 00 04 0157*       call printInline
042C8F 4F 4E 00    0158*       asciz "ON"
042C92 CD BD 23 04 0159*       call set_text_colours_normal
042C96 C3 0E 2B 04 0160*       jp get_input
042C9A             0161*   
042C9A             0162*   @looping:
042C9A CB 8E       0163*       res ps_mode_loop,(hl)
042C9C CD 60 00 04 0164*       call printInline
042CA0 4F 46 46 00 0165*       asciz "OFF"
042CA4 C3 0E 2B 04 0166*       jp get_input
042CA8             0167*   ; end ps_toggle_loop
042CA8             0050        include "play.inc"
042CA8             0001*   ; stream a song from the SD card
042CA8             0002*   ; inputs: hl = pointer to filename
042CA8             0003*   ; requirements: the file must be 8-bit signed PCM mono
042CA8             0004*   ; uses: sound channels 0 and 1, buffers 0x3000 and 0x3001
042CA8             0005*   ; play_song constants
042CA8             0006*   ch0_buffer: equ 0x3000
042CA8             0007*   ch1_buffer: equ 0x3001
042CA8             0008*   cmd0_buffer: equ 0x3002
042CA8             0009*   cmd1_buffer: equ 0x3003
042CA8             0010*   
042CA8             0011*   ; ps_mode bits
042CA8             0012*   ps_mode_playing: equ 0 ; 0 = paused 1 = playing, p key toggles
042CA8             0013*   ps_mode_loop:    equ 1 ; 0 = no loop 1 = loop (overrides ps_mode_shuffle if on), l key toggles
042CA8             0014*   ps_mode_shuffle: equ 2 ; 0 = shuffle off 1 = on, s key toggles
042CA8             0015*   
042CA8             0016*   ; play_song state variables
042CA8             0017*   ; current active channel and bufferId's
042CA8 00          0018*   ps_mode: db 0 ; playback mode bitmask
042CA9 00          0019*   ps_channel: db 0 ; channel number
042CAA 00 00 00    0020*   ps_cmdId: dl 0 ; command bufferId
042CAD 00 00 00    0021*   ps_sampleId: dl 0 ; sample bufferId
042CB0 00 00 00    0022*   ps_dir_num_files: dl 0 ; number of files/directories in the directory (virtually unlimited)
042CB3 00 00 00    0023*   ps_dir_num_pages: dl 0 ; number of pages in the directory (virtually unlimited)
042CB6 00 00 00    0024*   ps_page_num_files: dl 0 ; number of files/directories in the current directory page (max 10)
042CB9 00 00 00    0025*   ps_pagelast_num_files: dl 0 ; mod(ps_dir_num_files,10)
042CBC 00 00 00    0026*   ps_page_cur: dl 0 ; current directory page number
042CBF 00          0027*   ps_song_idx_cur: db 0 ; current song index in the directory page
042CC0 00 00 00    0028*   ps_song_fn_cur: dl 0 ; pointer to current song filename
042CC3 00 00 00 00 0029*   ps_song_duration: blkb 5,0 ; duration of the current song in seconds (32-bit word plus a padding byte)
       00          
042CC8 00 00 00    0030*   ps_playhead: dl 0 ; current playhead position in the song in seconds from the start
042CCB 00 00 00 00 0031*   ps_page_fn_ptrs: blkb 10*3,0 ; list of filename pointers in the current directory page
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00       
042CE9 00 00 00 00 0032*   ps_dir_path:   blkb 256,0 ; path of the current directory
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042DE9             0033*   
042DE9             0034*   
042DE9             0035*   ; play_song file info
042DE9 00          0036*   ps_filehandle_cur: db 0 ; file handle
042DEA 00 00 00    0037*   ps_chunkpointer: dl 0 ; pointer to current chunk
042DED             0038*   
042DED             0039*   play_song:
042DED             0040*   ; save pointer to requested song file
042DED 22 C0 2C 04 0041*       ld (ps_song_fn_cur),hl
042DF1             0042*   ; stop the PRT timer and close any currently playing file
042DF1 CD F6 2E 04 0043*       call ps_close_file
042DF5 CD BB 32 04 0044*       call ps_prt_stop
042DF9             0045*   ; tell the user what they've won
042DF9 CD 2E 23 04 0046*       call vp_now_playing
042DFD CD 3F 1B 04 0047*       call vdu_cls
042E01 2A C0 2C 04 0048*       ld hl,(ps_song_fn_cur)
042E05 CD 60 00 04 0049*       call printInline
042E09 28 50 29 6C 0050*       asciz "(P)laying "
       61 79 69 6E 
       67 20 00    
042E14 2A C0 2C 04 0051*       ld hl,(ps_song_fn_cur)
042E18 CD 67 00 04 0052*       call printString ; print the song filename
042E1C             0053*   ; highlight the song being played
042E1C CD 9E 30 04 0054*       call ps_highlight_song
042E20             0055*   ; open the file in read mode
042E20             0056*   ; Open a file
042E20             0057*   ; HLU: Filename
042E20             0058*   ;   C: Mode
042E20             0059*   ; Returns:
042E20             0060*   ;   A: Filehandle, or 0 if couldn't open
042E20 2A C0 2C 04 0061*       ld hl,(ps_song_fn_cur)
042E24 0E 01       0062*   	ld c,fa_read
042E26             0063*       MOSCALL mos_fopen
                       M1 Args: function=mos_fopen 
042E26 3E 0A       0001*M1 			LD	A, function
042E28 5B CF       0002*M1 			RST.LIL	08h
042E2A 32 E9 2D 04 0064*       ld (ps_filehandle_cur),a
042E2E             0065*   ; read the .wav header data and copy it to the buffer
042E2E CD EF 31 04 0066*       call ps_read_wav_header
042E32             0067*   ; compute the song duration from the file size and sample rate and print it
042E32             0068*   ; technically we should account for the .wav header, but at 76 bytes it's negligible
042E32 CD 48 23 04 0069*       call vp_duration ; set viewport to duration window
042E36 3A D9 37 04 0070*       ld a,(ps_wav_header+wav_file_size+3) ; upper byte
042E3A DD 2A D6 37 0071*       ld ix,(ps_wav_header+wav_file_size+0) ; lower word
       04          
042E3F ED 5B EA 37 0072*       ld de,(ps_wav_header+wav_sample_rate)
       04          
042E44 CD A5 05 04 0073*       call udiv3223 ; auix = duration in seconds
042E48 DD 22 C3 2C 0074*       ld (ps_song_duration),ix ; duration low word
       04          
042E4D 32 C6 2C 04 0075*       ld (ps_song_duration+3),a ; duration high byte
042E51 2A C3 2C 04 0076*       ld hl,(ps_song_duration) ; ls 24 bits of duration is sufficient and all we're prepared for
042E55 CD 2B 18 04 0077*       call seconds_to_hhmmss ; hl pointer to string representation of HH:MM:SS
042E59 CD 67 00 04 0078*       call printString ; print the duration
042E5D             0079*   ; reset the playhead counter to zer0
042E5D 21 00 00 00 0080*       ld hl,0
042E61 22 C8 2C 04 0081*       ld (ps_playhead),hl
042E65             0082*   ; read the first block of data
042E65 CD 78 2E 04 0083*       call ps_read_file
042E69             0084*   ; set ps_mode_playing
042E69 21 A8 2C 04 0085*       ld hl,ps_mode
042E6D CB C6       0086*       set ps_mode_playing,(hl)
042E6F             0087*   ; enable interrupts and start the PRT timer
042E6F FB          0088*       ei
042E70 CD 9E 32 04 0089*       call ps_prt_start
042E74             0090*   ; jump to user input loop:
042E74             0091*   ; the play sample interrupt will return to there
042E74             0092*   ; and exit app will return to main from there as well
042E74 C3 0E 2B 04 0093*       jp get_input
042E78             0094*   ; end play_song
042E78             0095*   
042E78             0096*   ; read the next 1-second's worth of sound data from the file
042E78             0097*   ; and upload it to the sample buffer
042E78             0098*   ps_read_file:
042E78             0099*   ; disable interrupts so load is guaranteed to complete
042E78 F3          0100*       di
042E79             0101*   ; Read a block of data from a file
042E79             0102*   ;   C: Filehandle
042E79             0103*   ; HLU: Pointer to where to write the data to
042E79             0104*   ; DEU: Number of bytes to read
042E79             0105*   ; Returns:
042E79             0106*   ; DEU: Number of bytes read
042E79 3A E9 2D 04 0107*       ld a,(ps_filehandle_cur)
042E7D 4F          0108*       ld c,a
042E7E 21 00 00 05 0109*       ld hl,ps_wav_data_start
042E82 ED 5B EA 37 0110*       ld de,(ps_wav_header+wav_sample_rate)
       04          
042E87             0111*       MOSCALL mos_fread
                       M1 Args: function=mos_fread 
042E87 3E 1A       0001*M1 			LD	A, function
042E89 5B CF       0002*M1 			RST.LIL	08h
042E8B             0112*   ; test de for zero bytes read
042E8B 21 00 00 00 0113*       ld hl,0
042E8F AF          0114*       xor a ; clear carry
042E90 ED 52       0115*       sbc hl,de ; hl = 0-chunksize
042E92 C2 9E 2E 04 0116*       jp nz,@load ; we read some data
042E96             0117*   ; no data read so close file and play a random song
042E96 CD F6 2E 04 0118*       call ps_close_file
042E9A C3 45 31 04 0119*       jp ps_song_over
042E9E             0120*   ; load a vdu buffer from local memory
042E9E             0121*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
042E9E             0122*   @load:
042E9E 3A A9 2C 04 0123*       ld a,(ps_channel)
042EA2 3C          0124*       inc a
042EA3 E6 01       0125*       and 1
042EA5 32 A9 2C 04 0126*       ld (ps_channel),a
042EA9 21 00 30 00 0127*       ld hl,ch0_buffer
042EAD 6F          0128*       ld l,a
042EAE 22 AD 2C 04 0129*       ld (ps_sampleId),hl
042EB2 CD F9 1E 04 0130*       call vdu_clear_buffer
042EB6 2A AD 2C 04 0131*       ld hl,(ps_sampleId)
042EBA D5          0132*       push de ; chunksize
042EBB C1          0133*       pop bc ; how much data to load
042EBC 11 00 00 05 0134*       ld de,ps_wav_data_start ; pointer to data
042EC0 CD E4 1C 04 0135*       call vdu_load_buffer
042EC4             0136*   ; update the playhead counter and display the time elapsed
042EC4 CD 3B 23 04 0137*       call vp_elapsed
042EC8 2A C8 2C 04 0138*       ld hl,(ps_playhead)
042ECC 23          0139*       inc hl
042ECD 22 C8 2C 04 0140*       ld (ps_playhead),hl
042ED1 CD 2B 18 04 0141*       call seconds_to_hhmmss ; hl pointer to string representation of HH:MM:SS
042ED5 CD 67 00 04 0142*       call printString ; print the playhead position
042ED9             0143*   ; print a playing breadcrumb
042ED9 CD 55 23 04 0144*       call vp_playhead
042EDD 3E 2E       0145*       ld a,'.'
042EDF 5B D7       0146*       rst.lil 10h
042EE1 C9          0147*       ret
042EE2             0148*   ; end ps_read_file
042EE2             0149*   
042EE2             0150*   ; this is called by the PRT timer interrupt
042EE2             0151*   ps_play_sample:
042EE2             0152*   ; call the command buffer to play the sound
042EE2 2A AD 2C 04 0153*       ld hl,(ps_sampleId)
042EE6 2C          0154*       inc l
042EE7 2C          0155*       inc l
042EE8 22 AA 2C 04 0156*       ld (ps_cmdId),hl ; TODO: perhaps not needed
042EEC CD DE 1E 04 0157*       call vdu_call_buffer
042EF0             0158*   ; load the next chunk of data
042EF0 CD 78 2E 04 0159*       call ps_read_file
042EF4             0160*   ; reenable interrupts and return to the user input loop
042EF4 FB          0161*       ei
042EF5 C9          0162*       ret
042EF6             0163*   ; end ps_play_sample
042EF6             0164*   
042EF6             0165*   ; close the file
042EF6             0166*   ps_close_file:
042EF6 CD BB 32 04 0167*       call ps_prt_stop ; stop the PRT timer
042EFA 3A E9 2D 04 0168*       ld a,(ps_filehandle_cur)
042EFE             0169*       MOSCALL mos_fclose
                       M1 Args: function=mos_fclose 
042EFE 3E 0B       0001*M1 			LD	A, function
042F00 5B CF       0002*M1 			RST.LIL	08h
042F02 C9          0170*       ret
042F03             0171*   ; end ps_close_file
042F03             0172*   
042F03             0173*   ps_get_dir:
042F03             0174*   ; set text viewport to directory name and clear it
042F03 CD 6F 23 04 0175*       call vp_dir_name
042F07 CD 3F 1B 04 0176*       call vdu_cls
042F0B             0177*   ; reset filecounter
042F0B 21 00 00 00 0178*       ld hl,0
042F0F 22 B0 2C 04 0179*       ld (ps_dir_num_files),hl
042F13             0180*   ; reset the song index and page number to 0
042F13 AF          0181*       xor a
042F14 32 BF 2C 04 0182*       ld (ps_song_idx_cur),a
042F18 21 00 00 00 0183*       ld hl,0
042F1C 22 BC 2C 04 0184*       ld (ps_page_cur),hl
042F20             0185*   ; initialize pointers to store directory info and print directory name
042F20 21 E9 2C 04 0186*       ld hl,ps_dir_path  ; where to store result
042F24             0187*   ; note: setting bc has no apparent effect, but we leave it for consistency with docs
042F24             0188*   ; https://agonconsole8.github.io/agon-docs/MOS-API/#0x9e-ffs_getcwd
042F24 01 FF 00 00 0189*       ld bc,255          ; max length (final byte is zero terminator)
042F28             0190*       MOSCALL ffs_getcwd ; MOS api get current working directory
                       M1 Args: function=ffs_getcwd 
042F28 3E 9E       0001*M1 			LD	A, function
042F2A 5B CF       0002*M1 			RST.LIL	08h
042F2C             0191*   ; print the directory path (ffs_getcwd preserves hl)
042F2C CD 67 00 04 0192*       call printString
042F30             0193*   ; now get dir info
042F30 21 A4 37 04 0194*       ld hl,ps_dir_struct ; define where to store directory info
042F34 11 E9 2C 04 0195*       ld de,ps_dir_path   ; this is pointer to the path to the directory
042F38 AF          0196*       xor a               ; tell MOS to expect zero-terminated string
042F39             0197*       MOSCALL ffs_dopen   ; open dir
                       M1 Args: function=ffs_dopen 
042F39 3E 91       0001*M1 			LD	A, function
042F3B 5B CF       0002*M1 			RST.LIL	08h
042F3D             0198*   ; set up pointers
042F3D DD 21 00 00 0199*       ld ix,ps_dir_fil_list ; this is the pointer to the fileinfo table
       06          
042F42             0200*   @readFileInfo:               ; we will loop here until all files have been processed
042F42 21 A4 37 04 0201*       ld hl,ps_dir_struct      ; HL is where to get directory info
042F46 DD E5       0202*       push ix
042F48 D1          0203*       pop de ; where to store current file info
042F49             0204*       MOSCALL ffs_dread        ; read next item from dir
                       M1 Args: function=ffs_dread 
042F49 3E 93       0001*M1 			LD	A, function
042F4B 5B CF       0002*M1 			RST.LIL	08h
042F4D             0205*   
042F4D DD 7E 16    0206*       ld a,(ix+filinfo_fname)  ; get first char of file name
042F50 B7          0207*       or a                     ; if zero then we are at the end of the listing
042F51 CA 83 2F 04 0208*       jp z,@allDone
042F55             0209*   
042F55 DD 7E 08    0210*       ld a,(ix+filinfo_fattrib) ; get the file attribute
042F58 CB AF       0211*       res 5,a ; clear bit 5 (archive) see: https://discord.com/channels/1158535358624039014/1158536667670511726/1328466726098309173
042F5A B7          0212*       or a ; if zero this is a file
042F5B C2 64 2F 04 0213*       jp nz,@F ; not zero so this is some other file type
042F5F CB EF       0214*       set 5,a ; set bit 5 (archive) so will be consistent btw emulator and hardware
042F61 DD 77 08    0215*       ld (ix+filinfo_fattrib),a ; update so we don't have to do this every time downstream
042F64             0216*   
042F64             0217*   @@: ; skip over writing hidden and system files
042F64 E6 02       0218*       and AM_HID ; hidden file
042F66 C2 42 2F 04 0219*       jp nz,@readFileInfo
042F6A E6 04       0220*       and AM_SYS ; system file
042F6C C2 42 2F 04 0221*       jp nz,@readFileInfo
042F70             0222*   
042F70             0223*   ; valid file or directory
042F70 2A B0 2C 04 0224*       ld hl,(ps_dir_num_files) ; get the current file counter
042F74 23          0225*       inc hl                  ; increment the counter
042F75 22 B0 2C 04 0226*       ld (ps_dir_num_files),hl
042F79 11 16 01 00 0227*       ld de,filinfo_struct_size ; length of fileinfo record
042F7D DD 19       0228*       add ix,de ; point to next fileinfo record
042F7F             0229*   
042F7F C3 42 2F 04 0230*       jp @readFileInfo         ; loop around to check next entry
042F83             0231*   @allDone:
042F83             0232*   ; compute page statistics
042F83 2A B0 2C 04 0233*       ld hl,(ps_dir_num_files) ; get the number of files
042F87 11 0A 00 00 0234*       ld de,10 ; max files per page
042F8B CD 80 03 04 0235*       call udiv24 ; de = hl/10, hl = mod(hl,10)
042F8F             0236*       SIGN_HLU ; check remainder for zero
                       M1 Args: none
042F8F 19          0001*M1     add hl,de ; 1 cycle
042F90 B7          0002*M1     or a ; clear flags ; 1 cycle
042F91 ED 52       0003*M1     sbc hl,de ; 2 cycles
042F93             0004*M1     ; 4 cycles total
042F93 C2 9C 2F 04 0237*       jp nz,@F
042F97 21 0A 00 00 0238*       ld hl,10 ; if zero then we have exactly 10 files on the last page ...
042F9B 1B          0239*       dec de ; ... and we don't need an additional page for the remainder
042F9C             0240*   @@:
042F9C 22 B9 2C 04 0241*       ld (ps_pagelast_num_files),hl ; save the number of files on the last page
042FA0 13          0242*       inc de ; bump the page count
042FA1 ED 53 B3 2C 0243*       ld (ps_dir_num_pages),de ; save the number of pages
       04          
042FA6             0244*   ; reset the song index and page to zero
042FA6 AF          0245*       xor a
042FA7 32 BF 2C 04 0246*       ld (ps_song_idx_cur),a
042FAB 21 00 00 00 0247*       ld hl,0
042FAF 22 BC 2C 04 0248*       ld (ps_page_cur),hl
042FB3             0249*   ; and populate the page filename pointers and print the page
042FB3 CD C4 2F 04 0250*       call ps_fill_page_fn_ptrs
042FB7 CD 00 30 04 0251*       call ps_print_dir_page
042FBB             0252*   ; close the directory
042FBB 21 A4 37 04 0253*       ld hl,ps_dir_struct      ; load H: with address of the DIR struct
042FBF             0254*       MOSCALL ffs_dclose       ; close dir
                       M1 Args: function=ffs_dclose 
042FBF 3E 92       0001*M1 			LD	A, function
042FC1 5B CF       0002*M1 			RST.LIL	08h
042FC3 C9          0255*       ret
042FC4             0256*   ; end ps_get_dir
042FC4             0257*   
042FC4             0258*   ; populate the page filename pointers for the current directory page
042FC4             0259*   ; inputs: ps_page_cur
042FC4             0260*   ; prerequisites: ps_get_dir called on a valid directory
042FC4             0261*   ; outputs: a populated filename pointer list for the current page
042FC4             0262*   ; destroys: a, hl, bc, de, ix
042FC4             0263*   ps_fill_page_fn_ptrs:
042FC4 2A BC 2C 04 0264*       ld hl,(ps_page_cur) ; get the current page number
042FC8 11 DC 0A 00 0265*       ld de,10*filinfo_struct_size ; records/page * bytes/record
042FCC CD 67 03 04 0266*       call umul24 ; hl = offset into the fileinfo table
042FD0 11 00 00 06 0267*       ld de,ps_dir_fil_list ; base address of fileinfo table
042FD4 19          0268*       add hl,de ; add the offset to the base address
042FD5 DD 21 CB 2C 0269*       ld ix,ps_page_fn_ptrs ; get the address of the page fileinfo pointer table
       04          
042FDA 11 16 01 00 0270*       ld de,filinfo_struct_size ; bytes per filename record
042FDE 06 0A       0271*       ld b,10 ; number of files per page
042FE0             0272*   @loop:
042FE0 DD 2F 00    0273*       ld (ix),hl ; store the filename pointer
042FE3 ED 32 03    0274*       lea ix,ix+3 ; bump the index pointer
042FE6 19          0275*       add hl,de ; add the record size to the filename pointer
042FE7 10 F7       0276*       djnz @loop
042FE9 C9          0277*       ret
042FEA             0278*   ; end ps_fill_page_fn_ptrs
042FEA             0279*   
042FEA             0280*   ps_get_page_num_files:
042FEA             0281*   ; check whether we're at last page
042FEA 2A BC 2C 04 0282*       ld hl,(ps_page_cur)
042FEE ED 5B B3 2C 0283*       ld de,(ps_dir_num_pages)
       04          
042FF3 1B          0284*       dec de ; zero-based
042FF4 B7          0285*       or a ; clear carry
042FF5 ED 52       0286*       sbc hl,de
042FF7 06 0A       0287*       ld b,10 ; b = default number of files per page
042FF9 C0          0288*       ret nz ; not the last page
042FFA 3A B9 2C 04 0289*       ld a,(ps_pagelast_num_files) ; get the number of files on the last page
042FFE 47          0290*       ld b,a ; b = number of files on the last page
042FFF C9          0291*       ret
043000             0292*   ; end ps_get_page_num_files
043000             0293*   
043000             0294*   ps_print_dir_page:
043000             0295*   ; set text viewport for directory listing
043000 CD 7C 23 04 0296*       call vp_dir
043004 CD 3F 1B 04 0297*       call vdu_cls
043008             0298*   ; loop through the fileinfo pointer table and print out the filenames
043008 CD EA 2F 04 0299*       call ps_get_page_num_files ; b = loop counter
04300C AF          0300*       xor a ; song index
04300D DD 21 CB 2C 0301*       ld ix,ps_page_fn_ptrs
       04          
043012             0302*   @loop:
043012 C5          0303*       push bc ; save loop counter
043013 F5          0304*       push af ; save song index
043014 CD 3C 33 04 0305*       call printHexA ; print the song index
043018             0306*   ; branch on the file attribute
043018 DD 27 00    0307*       ld hl,(ix) ; get the filename pointer
04301B 01 08 00 00 0308*       ld bc,filinfo_fattrib
04301F 09          0309*       add hl,bc ; hl points to the file attribute
043020 7E          0310*       ld a,(hl)
043021 FE 10       0311*       cp AM_DIR ; if zero, is directory
043023 C2 34 30 04 0312*       jp nz,@print_file ; not directory so just write filename
043027 E5          0313*       push hl
043028 CD 60 00 04 0314*       call printInline
04302C 3C 44 49 52 0315*       asciz "<DIR> "
       3E 20 00    
043033 E1          0316*       pop hl
043034             0317*   @print_file:
043034 01 0E 00 00 0318*       ld bc,filinfo_fname-filinfo_fattrib ; offset to the filename
043038 09          0319*       add hl,bc ; hl points to the filename
043039 CD 67 00 04 0320*       call printString ; print the filename
04303D             0321*   @bump_counters:
04303D ED 32 03    0322*       lea ix,ix+3 ; bump the filename pointer
043040 F1          0323*       pop af ; restore song index
043041 3C          0324*       inc a ; increment the song index
043042 C1          0325*       pop bc ; restore loop counter
043043 05          0326*       dec b
043044 C8          0327*       ret z ; if zero, we're done
043045 CD 7C 00 04 0328*       call printNewLine
043049 C3 12 30 04 0329*       jp @loop
04304D C9          0330*       ret
04304E             0331*   ; end ps_print_dir_page
04304E             0332*   
04304E             0333*   ps_print_dir:
04304E             0334*   ; test whether there are any files in the directory
04304E 2A B0 2C 04 0335*       ld hl,(ps_dir_num_files)
043052             0336*       SIGN_HLU
                       M1 Args: none
043052 19          0001*M1     add hl,de ; 1 cycle
043053 B7          0002*M1     or a ; clear flags ; 1 cycle
043054 ED 52       0003*M1     sbc hl,de ; 2 cycles
043056             0004*M1     ; 4 cycles total
043056 C8          0337*       ret z ; if zero, no files in the directory
043057             0338*   ; loop through the fileinfo table and print out the filenames
043057 DD 21 00 00 0339*       ld ix,ps_dir_fil_list
       06          
04305C 2A B0 2C 04 0340*       ld hl,(ps_dir_num_files)
043060             0341*   @print_loop:
043060 E5          0342*       push hl ; loop counter
043061             0343*   ; branch on the file attribute
043061 DD 7E 08    0344*       ld a,(ix+filinfo_fattrib)
043064 FE 10       0345*       cp AM_DIR ; if zero, is directory
043066 C2 75 30 04 0346*       jp nz,@print_file ; not directory so just write filename
04306A CD 60 00 04 0347*       call printInline
04306E 3C 44 49 52 0348*       asciz "<DIR> "
       3E 20 00    
043075             0349*   @print_file:
043075 ED 32 16    0350*       lea ix,ix+filinfo_fname ; point to filinfo_fname
043078 DD E5       0351*       push ix
04307A E1          0352*       pop hl ; get the address of the filename
04307B CD 67 00 04 0353*       call printString
04307F CD 7C 00 04 0354*       call printNewLine
043083 11 00 01 00 0355*       ld de,256 ; length of filename
043087 DD 19       0356*       add ix,de ; bump pointer to next filinfo record
043089             0357*   @dec_loop_counter:
043089 E1          0358*       pop hl
04308A 2B          0359*       dec hl ; decrement the loop counter
04308B             0360*       SIGN_HLU ; check for zero
                       M1 Args: none
04308B 19          0001*M1     add hl,de ; 1 cycle
04308C B7          0002*M1     or a ; clear flags ; 1 cycle
04308D ED 52       0003*M1     sbc hl,de ; 2 cycles
04308F             0004*M1     ; 4 cycles total
04308F C2 60 30 04 0361*       jp nz,@print_loop
043093 C9          0362*       ret
043094             0363*   @skip_file:
043094 11 16 01 00 0364*       ld de,filinfo_struct_size
043098 DD 19       0365*       add ix,de ; bump pointer to next filinfo record
04309A C3 89 30 04 0366*       jp @dec_loop_counter
04309E             0367*   ; end ps_print_dir
04309E             0368*   
04309E             0369*   ps_highlight_song:
04309E             0370*   ; refresh the directory listing
04309E CD 00 30 04 0371*       call ps_print_dir_page
0430A2             0372*   ; highlight the song being played in the directory listing
0430A2 3A BF 2C 04 0373*       ld a,(ps_song_idx_cur)
0430A6 16 17       0374*       ld d,vp_dir_top
0430A8 82          0375*       add a,d
0430A9 0E 00       0376*       ld c,text_left
0430AB 57          0377*       ld d,a
0430AC 1E 3F       0378*       ld e,text_right
0430AE 47          0379*       ld b,a
0430AF CD 98 1B 04 0380*       call vdu_set_txt_viewport
0430B3 CD B4 1A 04 0381*       call vdu_home_cursor
0430B7             0382*   ; set text colours to inverse
0430B7 CD CA 23 04 0383*       call set_text_colours_inverse
0430BB             0384*   ; print the index and song filename
0430BB 3A BF 2C 04 0385*       ld a,(ps_song_idx_cur)
0430BF CD 3C 33 04 0386*       call printHexA
0430C3 2A C0 2C 04 0387*       ld hl,(ps_song_fn_cur)
0430C7 CD 67 00 04 0388*       call printString
0430CB             0389*   ; set text colours to normal
0430CB CD BD 23 04 0390*       call set_text_colours_normal
0430CF C9          0391*       ret
0430D0             0392*   ; end ps_highlight_song
0430D0             0393*   
0430D0             0394*   ps_dir_next_page:
0430D0             0395*   ; advance the page number
0430D0 2A BC 2C 04 0396*       ld hl,(ps_page_cur) ; get the current page number
0430D4 23          0397*       inc hl ; increment the page number
0430D5 ED 5B B3 2C 0398*       ld de,(ps_dir_num_pages) ; get the number of pages
       04          
0430DA CD 80 03 04 0399*       call udiv24 ; hl = mod(ps_page_cur+1,ps_dir_num_pages)
0430DE 22 BC 2C 04 0400*       ld (ps_page_cur),hl ; save the new page number
0430E2             0401*   ; populate the page filename pointers
0430E2 CD C4 2F 04 0402*       call ps_fill_page_fn_ptrs
0430E6             0403*   ; print the new page
0430E6 CD 00 30 04 0404*       call ps_print_dir_page
0430EA             0405*   ; enable interrupts and jump back to the user input loop
0430EA FB          0406*       ei
0430EB C3 0E 2B 04 0407*       jp get_input
0430EF             0408*   ; end ps_dir_next_page
0430EF             0409*   
0430EF             0410*   ps_dir_prev_page:
0430EF             0411*   ; decrement the page number
0430EF 2A BC 2C 04 0412*       ld hl,(ps_page_cur) ; get the current page number
0430F3 2B          0413*       dec hl ; decrement the page number
0430F4             0414*       SIGN_HLU ; check for zero
                       M1 Args: none
0430F4 19          0001*M1     add hl,de ; 1 cycle
0430F5 B7          0002*M1     or a ; clear flags ; 1 cycle
0430F6 ED 52       0003*M1     sbc hl,de ; 2 cycles
0430F8             0004*M1     ; 4 cycles total
0430F8 F2 01 31 04 0415*       jp p,@F ; >= 0 so we're good
0430FC 2A B3 2C 04 0416*       ld hl,(ps_dir_num_pages) ; get the number of pages
043100 2B          0417*       dec hl ; zero-based
043101             0418*   @@:
043101 22 BC 2C 04 0419*       ld (ps_page_cur),hl ; save the new page number
043105             0420*   ; populate the page filename pointers
043105 CD C4 2F 04 0421*       call ps_fill_page_fn_ptrs
043109             0422*   ; print the new page and
043109 CD 00 30 04 0423*       call ps_print_dir_page
04310D             0424*   ; enable interrupts and jump back to the user input loop
04310D FB          0425*       ei
04310E C3 0E 2B 04 0426*       jp get_input
043112             0427*   ; end ps_dir_prev_page
043112             0428*   
043112             0429*   ; get the filename of the song at the current index
043112             0430*   ; inputs: a = song index
043112             0431*   ; returns: carry set if song index in range, new filemame in hl and ps_song_idx_cur, ps_song_fn_cur set to new index, a = file attribute
043112             0432*   ;          carry reset if song index out of range, current filename in hl, ps_song_idx_cur, ps_song_fn_cur unchanged, a = requested song index
043112             0433*   ; destroys: af, bc, de
043112             0434*   ps_get_song_fn_from_pg_idx:
043112 F5          0435*       push af ; save song index
043113 CD EA 2F 04 0436*       call ps_get_page_num_files ; b = number of files on the page
043117 F1          0437*       pop af ; restore song index
043118 B8          0438*       cp b ; compare song index to number of files on the page
043119 2A C0 2C 04 0439*       ld hl,(ps_song_fn_cur) ; get the current song filename
04311D D0          0440*       ret nc ; requested song index is out of range so return current filename and no carry
04311E 32 BF 2C 04 0441*       ld (ps_song_idx_cur),a ; save the song index
043122 DD 21 CB 2C 0442*       ld ix,ps_page_fn_ptrs ; get the address of the page fileinfo pointer table
       04          
043127 47          0443*       ld b,a ; song index
043128 0E 03       0444*       ld c,3 ; 3 bytes per filename pointer
04312A ED 4C       0445*       mlt bc ; index into the fileinfo pointer table
04312C DD 09       0446*       add ix,bc ; hl points to the fileinfo pointer
04312E             0447*   
04312E DD 27 00    0448*       ld hl,(ix) ; hl points to the fileinfo
043131 01 08 00 00 0449*       ld bc,filinfo_fattrib ; offset to the file attribute
043135 09          0450*       add hl,bc ; hl points to the file attribute
043136 7E          0451*       ld a,(hl) ; get the file attribute for determining file vs. directory
043137             0452*   
043137 DD 27 00    0453*       ld hl,(ix) ; hl points to the fileinfo
04313A 01 16 00 00 0454*       ld bc,filinfo_fname ; offset to the filename
04313E 09          0455*       add hl,bc ; hl points to the filename
04313F 22 C0 2C 04 0456*       ld (ps_song_fn_cur),hl ; save the new song filename
043143 37          0457*       scf ; set carry to indicate success
043144 C9          0458*       ret
043145             0459*   ; end ps_get_song_fn_from_pg_idx
043145             0460*   
043145             0461*   ps_song_over:
043145             0462*   ; get playback mode
043145 21 A8 2C 04 0463*       ld hl,ps_mode
043149             0464*   
043149             0465*   ; are we in loop mode?
043149 CB 4E       0466*       bit ps_mode_loop,(hl)
04314B CA 57 31 04 0467*       jp z,@F ; no so check next mode
04314F 2A C0 2C 04 0468*       ld hl,(ps_song_fn_cur) ; get current song filename
043153 C3 ED 2D 04 0469*       jp play_song ; and play it again, Sam
043157             0470*   
043157             0471*   @@: ; are we in shuffle mode?
043157 CB 56       0472*       bit ps_mode_shuffle,(hl)
043159 C2 C0 31 04 0473*       jp nz,ps_play_random ; yes so play a random song
04315D             0474*   
04315D             0475*   ; loop and shuffle are off so play next song
04315D C3 61 31 04 0476*       jp ps_play_next_song
043161             0477*   ; end ps_song_over
043161             0478*   
043161             0479*   ps_play_next_song:
043161 3A BF 2C 04 0480*       ld a,(ps_song_idx_cur) ; get the current song index
043165             0481*   @next_file:
043165 3C          0482*       inc a ; increment the song index
043166 32 8E 31 04 0483*       ld (@songIdx),a ; save the new song index
04316A CD 12 31 04 0484*       call ps_get_song_fn_from_pg_idx ; hl points to file, carry set indicates success, a has file attribute
04316E DA 78 31 04 0485*       jp c,@good_fname ; filename is valid
043172 3E FF       0486*       ld a,-1 ; invalid filename means we went past the end of the list, so reset ...
043174 C3 65 31 04 0487*       jp @next_file ; ... and try again
043178             0488*   
043178             0489*   @good_fname:
043178 FE 10       0490*       cp AM_DIR ; file attribute check for directory
04317A C2 82 31 04 0491*       jp nz,@is_file ; not a directory so check for valid .wav file
04317E C3 65 31 04 0492*       jp @next_file ; is a directory so try the next file
043182             0493*   
043182             0494*   @is_file:
043182 3A 8E 31 04 0495*       ld a,(@songIdx) ; get the new song index
043186 32 BF 2C 04 0496*       ld (ps_song_idx_cur),a ; save the new song index
04318A C3 ED 2D 04 0497*       jp play_song
04318E 00          0498*   @songIdx: db 0
04318F             0499*   ; end ps_play_next_song
04318F             0500*   
04318F             0501*   ps_play_prev_song:
04318F 3A BF 2C 04 0502*       ld a,(ps_song_idx_cur) ; get the current song index
043193             0503*   @prev_file:
043193 3D          0504*       dec a ; decrement the song index
043194 32 BF 31 04 0505*       ld (@songIdx),a ; save the new song index
043198 CD 12 31 04 0506*       call ps_get_song_fn_from_pg_idx ; hl points to file, carry set indicates success, a has file attribute
04319C DA A9 31 04 0507*       jp c,@good_fname ; filename is valid
0431A0 CD EA 2F 04 0508*       call ps_get_page_num_files ; invalid filename means we went past the beginning of the list,
0431A4 78          0509*       ld a,b ;  so reset ...
0431A5 C3 93 31 04 0510*       jp @prev_file ; ... and try again
0431A9             0511*   
0431A9             0512*   @good_fname:
0431A9 FE 10       0513*       cp AM_DIR ; file attribute check for directory
0431AB C2 B3 31 04 0514*       jp nz,@is_file ; not a directory so check for valid .wav file
0431AF C3 93 31 04 0515*       jp @prev_file ; is a directory so try the previous file
0431B3             0516*   
0431B3             0517*   @is_file:
0431B3 3A BF 31 04 0518*       ld a,(@songIdx) ; get the new song index
0431B7 32 BF 2C 04 0519*       ld (ps_song_idx_cur),a ; save the new song index
0431BB C3 ED 2D 04 0520*       jp play_song
0431BF             0521*   
0431BF 00          0522*   @songIdx: db 0
0431C0             0523*   ; end ps_play_prev_song
0431C0             0524*   
0431C0             0525*   ; queue a random song on the current page to play next
0431C0             0526*   ps_play_random:
0431C0             0527*   ; back up current song index
0431C0 2A C0 2C 04 0528*       ld hl,(ps_song_fn_cur)
0431C4 22 EC 31 04 0529*       ld (@songFn),hl
0431C8             0530*   ; get the number of songs in the current directory
0431C8 CD EA 2F 04 0531*       call ps_get_page_num_files
0431CC             0532*   ; get a random song index
0431CC CD 38 05 04 0533*       call rand_8 ; a = 0-255
0431D0 67          0534*       ld h,a
0431D1 2E 0A       0535*       ld l,10 ; modulo 10
0431D3 CD 74 05 04 0536*       call udiv8 ; a = mod(a,10)
0431D7 CD 12 31 04 0537*       call ps_get_song_fn_from_pg_idx
0431DB EB          0538*       ex de,hl ; setting up cp hl,de
0431DC 2A EC 31 04 0539*       ld hl,(@songFn) ; don't play the same song twice in a row
0431E0 B7          0540*       or a ; clear carry
0431E1 ED 52       0541*       sbc hl,de
0431E3 CA C0 31 04 0542*       jp z,ps_play_random ; same song, try again
0431E7 EB          0543*       ex de,hl ; pointer back to hl
0431E8 C3 ED 2D 04 0544*       jp play_song ; hit it
0431EC 00 00 00    0545*   @songFn: dl 0
0431EF             0546*   ; end ps_play_random
0431EF             0547*   
0431EF             0548*   ps_read_wav_header:
0431EF             0549*   ; Read a block of data from a file
0431EF             0550*   ;   C: Filehandle
0431EF             0551*   ; HLU: Pointer to where to write the data to
0431EF             0552*   ; DEU: Number of bytes to read
0431EF             0553*   ; Returns:
0431EF             0554*   ; DEU: Number of bytes read
0431EF 3A E9 2D 04 0555*       ld a,(ps_filehandle_cur)
0431F3 4F          0556*       ld c,a
0431F4 21 D2 37 04 0557*       ld hl,ps_wav_header
0431F8 11 4C 00 00 0558*       ld de,wav_header_size
0431FC             0559*       MOSCALL mos_fread
                       M1 Args: function=mos_fread 
0431FC 3E 1A       0001*M1 			LD	A, function
0431FE 5B CF       0002*M1 			RST.LIL	08h
043200             0560*   ; test de for zero bytes read
043200 21 00 00 00 0561*       ld hl,0
043204 AF          0562*       xor a ; clear carry
043205 ED 52       0563*       sbc hl,de ; hl = 0-chunksize
043207 C8          0564*       ret z ; no data read so return zero to caller
043208             0565*   ; test for valid .wav header
043208 CD 0B 33 04 0566*       call verify_wav
04320C CA 12 32 04 0567*       jp z,@F ; valid .wav header so continue
043210 AF          0568*       xor a ; invalid .wav header so return zero to caller
043211 C9          0569*       ret
043212             0570*   ; data read so initialize song variables
043212             0571*   ; load play sample command buffers (namely the sample rate for now)
043212             0572*   @@:
043212 CD 17 32 04 0573*       call ps_load_command_buffers
043216 C9          0574*       ret
043217             0575*   ; end ps_read_wav_header
043217             0576*   
043217             0577*   ps_load_command_buffers:
043217 21 02 30 00 0578*       ld hl,cmd0_buffer
04321B CD F9 1E 04 0579*       call vdu_clear_buffer
04321F 2A EA 37 04 0580*       ld hl,(ps_wav_header+wav_sample_rate)
043223 22 6D 32 04 0581*       ld (ps_sr0),hl
043227 3E 17       0582*       ld a,23
043229 32 6F 32 04 0583*       ld (ps_sr0+2),a
04322D 21 02 30 00 0584*       ld hl,cmd0_buffer
043231 01 1D 00 00 0585*       ld bc,ps_cmd0_end-ps_cmd0
043235 11 64 32 04 0586*       ld de,ps_cmd0
043239 CD B6 1E 04 0587*       call vdu_write_block_to_buffer
04323D             0588*   
04323D 21 03 30 00 0589*       ld hl,cmd1_buffer
043241 CD F9 1E 04 0590*       call vdu_clear_buffer
043245 2A EA 37 04 0591*       ld hl,(ps_wav_header+wav_sample_rate)
043249 22 8A 32 04 0592*       ld (ps_sr1),hl
04324D 3E 17       0593*       ld a,23
04324F 32 8C 32 04 0594*       ld (ps_sr1+2),a
043253 21 03 30 00 0595*       ld hl,cmd1_buffer
043257 01 1D 00 00 0596*       ld bc,ps_cmd1_end-ps_cmd1
04325B 11 81 32 04 0597*       ld de,ps_cmd1
04325F CD B6 1E 04 0598*       call vdu_write_block_to_buffer
043263 C9          0599*       ret
043264             0600*   ps_cmd0:
043264             0601*   ; vdu_buffer_to_sound command string
043264             0602*   ; Command 5: Buffer to sound
043264             0603*   ; VDU 23, 0, &85, channel (ignored), 5, 2, bufferId; format, [sampleRate;]
043264 17 00 85    0604*       db 23,0,0x85 ; vdu sound command header
043267 00          0605*       db 0x00 ; channel (ignored)
043268 05          0606*       db 0x05 ; buffer to sound command
043269 02          0607*       db 0x02 ; command 2 create sample
04326A 00 30       0608*       dw ch0_buffer
04326C 09          0609*       db 1+8 ; 8-bit unsigned PCM mono, 8 = sample rate argument follows
04326D             0610*   ps_sr0:
04326D 00 00       0611*       dw 0x0000 ; sample rate Hz
04326F             0612*   ; vdu_play_sfx command string
04326F             0613*   ; Command 4: Set waveform
04326F             0614*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
04326F 17 00 85    0615*       db 23,0,$85 ; vdu sound command header
043272 00          0616*       db 0 ; channel
043273 04          0617*       db 4 ; set waveform command
043274 08          0618*       db 8 ; waveform 8 = sample
043275 00 30       0619*       dw ch0_buffer ; sample bufferId
043277             0620*   ; Command 0: Play note
043277             0621*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
043277 17 00 85    0622*       db 23,0,$85 ; vdu sound command header
04327A 00          0623*       db 0 ; channel
04327B 00          0624*       db 0 ; play note command
04327C 7F          0625*       db 127  ; volume 127 = max
04327D 00 00       0626*       dw 0 ; frequency (relevant only for tuneable samples)
04327F 00 00       0627*       dw 0 ; duration (ms), zero means play one time in full
043281             0628*   ps_cmd0_end:
043281             0629*   
043281             0630*   ps_cmd1:
043281             0631*   ; vdu_buffer_to_sound command string
043281             0632*   ; Command 5: Buffer to sound
043281             0633*   ; VDU 23, 0, &85, channel (ignored), 5, 2, bufferId; format, [sampleRate;]
043281 17 00 85    0634*       db 23,0,0x85 ; vdu sound command header
043284 00          0635*       db 0x00 ; channel (ignored)
043285 05          0636*       db 0x05 ; buffer to sound command
043286 02          0637*       db 0x02 ; command 2 create sample
043287 01 30       0638*       dw ch1_buffer
043289 09          0639*       db 1+8 ; 8-bit unsigned PCM mono, 8 = sample rate argument follows
04328A             0640*   ps_sr1:
04328A 00 00       0641*       dw 0x0000 ; sample rate Hz
04328C             0642*   ; vdu_play_sfx command string
04328C             0643*   ; Command 4: Set waveform
04328C             0644*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
04328C 17 00 85    0645*       db 23,0,$85 ; vdu sound command header
04328F 01          0646*       db 1 ; channel
043290 04          0647*       db 4 ; set waveform command
043291 08          0648*       db 8 ; waveform 8 = sample
043292 01 30       0649*       dw ch1_buffer ; sample bufferId
043294             0650*   ; Command 0: Play note
043294             0651*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
043294 17 00 85    0652*       db 23,0,$85 ; vdu sound command header
043297 01          0653*       db 1 ; channel
043298 00          0654*       db 0 ; play note command
043299 7F          0655*       db 127  ; volume 127 = max
04329A 00 00       0656*       dw 0 ; frequency (relevant only for tuneable samples)
04329C 00 00       0657*       dw 0 ; duration (ms), zero means play one time in full
04329E             0658*   ps_cmd1_end:
04329E             0659*   ; end ps_load_command_buffers
04329E             0051        include "timer_jukebox.inc"
04329E             0001*   ps_prt_reload: equ [72000/2] ; 36000 = 2 ticks per second at 18.432 MHz with a 256 clock divider
04329E             0002*   
04329E             0003*   ; start PRT timer
04329E             0004*   ps_prt_start:
04329E 21 00 00 00 0005*       ld hl,0
0432A2 22 DD 32 04 0006*       ld (ps_prt_irq_counter),hl
0432A6 21 A0 8C 00 0007*       ld hl,ps_prt_reload
0432AA ED 29 84    0008*       out0 (TMR1_CTL+TMR_RES_LOW),l
0432AD ED 21 85    0009*   	out0 (TMR1_CTL+TMR_RES_HIGH),h
0432B0             0010*   ; disable timer (in effect, reset it)
0432B0 3E 0E       0011*       ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_256 | RST_EN_1 | PRT_EN_0
0432B2 ED 39 83    0012*   	out0 (TMR1_CTL+TMR_REG_CTL),a
0432B5             0013*   ; enable timer,with interrupt and CONTINUOUS mode,clock divider 256
0432B5 3E 5F       0014*       ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_256 | RST_EN_1 | PRT_EN_1
0432B7 ED 39 83    0015*   	out0 (TMR1_CTL+TMR_REG_CTL),a
0432BA C9          0016*       ret
0432BB             0017*   
0432BB             0018*   ; stop PRT timer
0432BB             0019*   ps_prt_stop:
0432BB 3E 0E       0020*       ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_256 | RST_EN_1 | PRT_EN_0
0432BD ED 39 83    0021*   	out0 (TMR1_CTL+TMR_REG_CTL),a
0432C0 C9          0022*       ret
0432C1             0023*   
0432C1             0024*   ; ===============================================
0432C1             0025*   ; PRT Timer Interrupt Handling
0432C1             0026*   ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.asm
0432C1             0027*   ; -----------------------------------------------
0432C1             0028*   ps_prt_irq_init:
0432C1             0029*       ; set up interrupt vector table 2
0432C1 21 00 00 00 0030*   	ld hl,0
0432C5 3A 0C 01 00 0031*   	ld a,($10c)
0432C9 6F          0032*   	ld l,a
0432CA 3A 0D 01 00 0033*   	ld a,($10d)
0432CE 67          0034*   	ld h,a
0432CF             0035*   
0432CF             0036*   	; skip over CALL ($c3)
0432CF 23          0037*   	inc hl
0432D0             0038*   	; load address of jump into vector table 2 (in ram)
0432D0 ED 27       0039*   	ld hl,(hl)
0432D2             0040*   
0432D2             0041*   	; write CALL ps_prt_irq_handler to vector table 2
0432D2 3E C3       0042*   	ld a,$c3
0432D4 77          0043*   	ld (hl),a
0432D5 23          0044*   	inc hl
0432D6 11 DE 32 04 0045*   	ld de,ps_prt_irq_handler
0432DA ED 1F       0046*   	ld (hl),de
0432DC             0047*   
0432DC C9          0048*       ret
0432DD             0049*   ; end ps_prt_irq_init
0432DD             0050*   
0432DD             0051*   ; interrupt routine for playing the next sample
0432DD             0052*   ps_prt_irq_counter:
0432DD 00          0053*   	db 0
0432DE             0054*   ps_prt_irq_handler:
0432DE F3          0055*       di
0432DF 08          0056*       ex af,af'
0432E0 D9          0057*       exx
0432E1             0058*   ; clear sysvar_keyascii
0432E1             0059*   	MOSCALL mos_sysvars
                       M1 Args: function=mos_sysvars 
0432E1 3E 08       0001*M1 			LD	A, function
0432E3 5B CF       0002*M1 			RST.LIL	08h
0432E5 AF          0060*   	xor a
0432E6 DD 77 05    0061*   	ld (IX+sysvar_keyascii),a
0432E9             0062*   ; read the timer interrupt and bump the counter
0432E9 ED 38 83    0063*       in0 a,(TMR1_CTL+TMR_REG_CTL)
0432EC 3A DD 32 04 0064*       ld a,(ps_prt_irq_counter)
0432F0 3C          0065*       inc a
0432F1 E6 01       0066*       and 1 ; modulo 2
0432F3 32 DD 32 04 0067*       ld (ps_prt_irq_counter),a
0432F7             0068*   ; if counter zero, play the next sample
0432F7 C2 05 33 04 0069*       jp nz,@F
0432FB 21 A8 2C 04 0070*       ld hl,ps_mode
0432FF CB 46       0071*       bit ps_mode_playing,(hl)
043301 C4 E2 2E 04 0072*       call nz,ps_play_sample
043305             0073*   @@:
043305 D9          0074*       exx
043306 08          0075*       ex af,af'
043307 FB          0076*       ei
043308 5B ED 4D    0077*       reti.l
04330B             0078*   ; end ps_prt_irq_handler
04330B             0052        include "wav.inc"
04330B             0001*   ; WAV File Structure Offsets and Descriptions
04330B             0002*   wav_riff:          EQU 0    ; 4 bytes: "RIFF" identifier
04330B             0003*   wav_file_size:     EQU 4    ; 4 bytes: Total file size minus 8 bytes for RIFF header
04330B             0004*   wav_wave:          EQU 8    ; 4 bytes: "WAVE" identifier
04330B             0005*   wav_fmt_marker:    EQU 12   ; 4 bytes: "fmt " subchunk marker
04330B             0006*   wav_fmt_size:      EQU 16   ; 4 bytes: Format chunk size (16 for PCM)
04330B             0007*   wav_audio_format:  EQU 20   ; 2 bytes: Audio format (1 = PCM)
04330B             0008*   wav_num_channels:  EQU 22   ; 2 bytes: Number of channels (1 = mono, 2 = stereo)
04330B             0009*   wav_sample_rate:   EQU 24   ; 4 bytes: Sample rate in Hz (e.g., 32768)
04330B             0010*   wav_byte_rate:     EQU 28   ; 4 bytes: Bytes per second (SampleRate * NumChannels * BitsPerSample / 8)
04330B             0011*   wav_block_align:   EQU 32   ; 2 bytes: Bytes per sample block (NumChannels * BitsPerSample / 8)
04330B             0012*   wav_bits_per_sample: EQU 34 ; 2 bytes: Bits per sample (e.g., 8 or 16)
04330B             0013*   
04330B             0014*   ; LIST Chunk (Extra Metadata)
04330B             0015*   wav_list_marker:   EQU 36   ; 4 bytes: "LIST" marker
04330B             0016*   wav_list_size:     EQU 40   ; 4 bytes: Size of the LIST chunk (e.g., 26)
04330B             0017*   wav_info_marker:   EQU 44   ; 4 bytes: "INFO" marker
04330B             0018*   wav_isft_marker:   EQU 48   ; 4 bytes: "ISFT" marker (software identifier)
04330B             0019*   wav_isft_data:     EQU 52   ; 14 bytes: Software info string (e.g., "Lavf59.27.100")
04330B             0020*   wav_isft_padding:  EQU 66   ; 2 bytes: Padding/NULL terminator for alignment
04330B             0021*   
04330B             0022*   ; Data Chunk
04330B             0023*   wav_data_marker:   EQU 68   ; 4 bytes: "data" subchunk marker
04330B             0024*   wav_data_size:     EQU 72   ; 4 bytes: Size of the audio data in bytes
04330B             0025*   wav_data_start:    EQU 76   ; Start of audio data
04330B             0026*   wav_header_size:   EQU wav_data_start ; Total Header Size: 76 bytes
04330B             0027*   
04330B             0028*   ; verify that the file is a .wav file
04330B             0029*   ; inputs: none
04330B             0030*   ; prerequisites: ps_read_wav_header called
04330B             0031*   ; returns: zero flag set if not a .wav file we can read
04330B             0032*   ; clobbered: af, hl, de, ix
04330B             0033*   verify_wav:
04330B DD 21 D2 37 0034*       ld ix,ps_wav_header
       04          
043310             0035*   
043310 DD 27 00    0036*       ld hl,(ix+wav_riff)
043313 11 52 49 46 0037*       ld de, 0x464952  ; ascii for "RIF" in little-endian order
043317 B7          0038*       or a ; clear carry
043318 ED 52       0039*       sbc hl,de
04331A C0          0040*       ret nz ; not a .wav file
04331B             0041*   
04331B DD 27 08    0042*       ld hl,(ix+wav_wave)
04331E 11 57 41 56 0043*       ld de, 0x564157  ; ascii for "WAV" in little-endian order
043322 B7          0044*       or a ; clear carry
043323 ED 52       0045*       sbc hl,de
043325 C0          0046*       ret nz ; not a .wav file
043326             0047*   
043326 DD 27 0C    0048*       ld hl,(ix+wav_fmt_marker)
043329 11 66 6D 74 0049*       ld de, 0x746D66  ; ascii for "fmt" in little-endian order
04332D B7          0050*       or a ; clear carry
04332E ED 52       0051*       sbc hl,de
043330 C0          0052*       ret nz ; not a .wav file
043331             0053*   
043331 DD 27 14    0054*       ld hl,(ix+wav_audio_format)
043334 11 01 00 01 0055*       ld de, 0x010001  ; PCM format, 1-channel
043338 B7          0056*       or a ; clear carry
043339 ED 52       0057*       sbc hl,de ; if not zero, not a .wav file we can read
04333B             0058*   
04333B C9          0059*       ret
04333C             0060*   ; end verify_wav
04333C             0053        include "debug.inc"
04333C             0001*   printHexA:
04333C F5          0002*       push af
04333D C5          0003*       push bc
04333E CD AE 00 04 0004*       call printHex8
043342 3E 20       0005*       ld a,' '
043344 5B D7       0006*       rst.lil 10h
043346 C1          0007*       pop bc
043347 F1          0008*       pop af
043348 C9          0009*       ret
043349             0010*   
043349             0011*   printHexHL:
043349 F5          0012*       push af
04334A C5          0013*       push bc
04334B CD A8 00 04 0014*       call printHex16
04334F 3E 20       0015*       ld a,' '
043351 5B D7       0016*       rst.lil 10h
043353 C1          0017*       pop bc
043354 F1          0018*       pop af
043355 C9          0019*       ret
043356             0020*   
043356             0021*   printHexUHL:
043356 F5          0022*       push af
043357 C5          0023*       push bc
043358 CD A0 00 04 0024*       call printHex24
04335C 3E 20       0025*       ld a,' '
04335E 5B D7       0026*       rst.lil 10h
043360 C1          0027*       pop bc
043361 F1          0028*       pop af
043362 C9          0029*       ret
043363             0030*   
043363             0031*   printHexAUHL:
043363 F5          0032*       push af
043364 C5          0033*       push bc
043365 CD AE 00 04 0034*       call printHex8
043369 3E 2E       0035*       ld a,'.'
04336B 5B D7       0036*       rst.lil 10h
04336D CD A0 00 04 0037*       call printHex24
043371 3E 20       0038*       ld a,' '
043373 5B D7       0039*       rst.lil 10h
043375 C1          0040*       pop bc
043376 F1          0041*       pop af
043377 C9          0042*       ret
043378             0043*   
043378             0044*   printHexABHL:
043378             0045*   ; preserve registers
043378 C5          0046*       push bc ; b will be ok c will not
043379 F5          0047*       push af ; will get totally destroyed
04337A             0048*   ; print a
04337A CD AE 00 04 0049*       call printHex8
04337E             0050*   ; print b
04337E 78          0051*       ld a,b
04337F CD AE 00 04 0052*       call printHex8
043383             0053*   ; print hl
043383 CD A8 00 04 0054*       call printHex16
043387             0055*   ; restore registers
043387 F1          0056*       pop af
043388 C1          0057*       pop bc
043389 C9          0058*       ret
04338A             0059*   
04338A             0060*   printHexBHL:
04338A             0061*   ; preserve registers
04338A C5          0062*       push bc ; b will be ok c will not
04338B F5          0063*       push af ; will get totally destroyed
04338C             0064*   ; print b
04338C 78          0065*       ld a,b
04338D CD AE 00 04 0066*       call printHex8
043391             0067*   ; print hl
043391 CD A8 00 04 0068*       call printHex16
043395             0069*   ; restore registers
043395 F1          0070*       pop af
043396 C1          0071*       pop bc
043397 C9          0072*       ret
043398             0073*   
043398             0074*   printHexCDE:
043398             0075*   ; preserve registers
043398 C5          0076*       push bc ; b will be ok c will not
043399 F5          0077*       push af ; will get totally destroyed
04339A             0078*   ; print c
04339A 79          0079*       ld a,c
04339B CD AE 00 04 0080*       call printHex8
04339F             0081*   ; print de
04339F EB          0082*       ex de,hl
0433A0 CD A8 00 04 0083*       call printHex16
0433A4 EB          0084*       ex de,hl
0433A5             0085*   ; restore registers
0433A5 F1          0086*       pop af
0433A6 C1          0087*       pop bc
0433A7 C9          0088*       ret
0433A8             0089*   
0433A8             0090*   printHexUIX:
0433A8             0091*   ; store everything in scratch
0433A8 22 35 03 04 0092*       ld (uhl),hl
0433AC ED 43 38 03 0093*       ld (ubc),bc
       04          
0433B1 ED 53 3B 03 0094*       ld (ude),de
       04          
0433B6 DD 22 3E 03 0095*       ld (uix),ix
       04          
0433BB FD 22 41 03 0096*       ld (uiy),iy
       04          
0433C0 F5          0097*       push af ; fml
0433C1             0098*   
0433C1 21 CC 02 04 0099*       ld hl,str_ixu
0433C5 CD 67 00 04 0100*       call printString
0433C9 2A 3E 03 04 0101*       ld hl,(uix)
0433CD CD A0 00 04 0102*       call printHex24
0433D1 CD 7C 00 04 0103*       call printNewLine
0433D5             0104*   
0433D5             0105*   ; restore everything
0433D5 2A 35 03 04 0106*       ld hl, (uhl)
0433D9 ED 4B 38 03 0107*       ld bc, (ubc)
       04          
0433DE ED 5B 3B 03 0108*       ld de, (ude)
       04          
0433E3 DD 2A 3E 03 0109*       ld ix, (uix)
       04          
0433E8 FD 2A 41 03 0110*       ld iy, (uiy)
       04          
0433ED F1          0111*       pop af
0433EE             0112*   ; all done
0433EE C9          0113*       ret
0433EF             0114*   
0433EF             0115*   
0433EF             0116*   ; print registers to screen in hexidecimal format
0433EF             0117*   ; inputs: none
0433EF             0118*   ; outputs: values of every register printed to screen
0433EF             0119*   ;    values of each register in global scratch memory
0433EF             0120*   ; destroys: nothing
0433EF             0121*   stepRegistersHex:
0433EF             0122*   ; store everything in scratch
0433EF 22 35 03 04 0123*       ld (uhl),hl
0433F3 ED 43 38 03 0124*       ld (ubc),bc
       04          
0433F8 ED 53 3B 03 0125*       ld (ude),de
       04          
0433FD DD 22 3E 03 0126*       ld (uix),ix
       04          
043402 FD 22 41 03 0127*       ld (uiy),iy
       04          
043407 F5          0128*       push af ; fml
043408 E1          0129*       pop hl ; thanks, zilog
043409 22 32 03 04 0130*       ld (uaf),hl
04340D F5          0131*       push af ; dammit
04340E             0132*   
04340E             0133*   ; home the cursor
04340E             0134*       ; call vdu_home_cursor
04340E             0135*   
04340E             0136*   ; print each register
04340E 21 B8 02 04 0137*       ld hl,str_afu
043412 CD 67 00 04 0138*       call printString
043416 2A 32 03 04 0139*       ld hl,(uaf)
04341A CD A0 00 04 0140*       call printHex24
04341E CD 7C 00 04 0141*       call printNewLine
043422             0142*   
043422 21 BD 02 04 0143*       ld hl,str_hlu
043426 CD 67 00 04 0144*       call printString
04342A 2A 35 03 04 0145*       ld hl,(uhl)
04342E CD A0 00 04 0146*       call printHex24
043432 CD 7C 00 04 0147*       call printNewLine
043436             0148*   
043436 21 C2 02 04 0149*       ld hl,str_bcu
04343A CD 67 00 04 0150*       call printString
04343E 2A 38 03 04 0151*       ld hl,(ubc)
043442 CD A0 00 04 0152*       call printHex24
043446 CD 7C 00 04 0153*       call printNewLine
04344A             0154*   
04344A 21 C7 02 04 0155*       ld hl,str_deu
04344E CD 67 00 04 0156*       call printString
043452 2A 3B 03 04 0157*       ld hl,(ude)
043456 CD A0 00 04 0158*       call printHex24
04345A CD 7C 00 04 0159*       call printNewLine
04345E             0160*   
04345E 21 CC 02 04 0161*       ld hl,str_ixu
043462 CD 67 00 04 0162*       call printString
043466 2A 3E 03 04 0163*       ld hl,(uix)
04346A CD A0 00 04 0164*       call printHex24
04346E CD 7C 00 04 0165*       call printNewLine
043472             0166*   
043472 21 D1 02 04 0167*       ld hl,str_iyu
043476 CD 67 00 04 0168*       call printString
04347A 2A 41 03 04 0169*       ld hl,(uiy)
04347E CD A0 00 04 0170*       call printHex24
043482 CD 7C 00 04 0171*       call printNewLine
043486             0172*   
043486             0173*       ; call vsync
043486             0174*   
043486 CD 7C 00 04 0175*       call printNewLine
04348A             0176*   
04348A             0177*   ; check for right shift key and quit if pressed
04348A             0178*       MOSCALL mos_getkbmap
                       M1 Args: function=mos_getkbmap 
04348A 3E 1E       0001*M1 			LD	A, function
04348C 5B CF       0002*M1 			RST.LIL	08h
04348E             0179*   @stayhere:
04348E             0180*   ; 7 RightShift
04348E DD CB 00 76 0181*       bit 6,(ix+0)
043492 20 02       0182*       jr nz,@RightShift
043494 18 F8       0183*       jr @stayhere
043496             0184*   @RightShift:
043496 DD CB 0E 86 0185*       res 0,(ix+14) ; debounce the key (hopefully)
04349A 3E 80       0186*       ld a,%10000000
04349C             0187*       ; call multiPurposeDelay
04349C             0188*   
04349C             0189*   ; restore everything
04349C 2A 35 03 04 0190*       ld hl, (uhl)
0434A0 ED 4B 38 03 0191*       ld bc, (ubc)
       04          
0434A5 ED 5B 3B 03 0192*       ld de, (ude)
       04          
0434AA DD 2A 3E 03 0193*       ld ix, (uix)
       04          
0434AF FD 2A 41 03 0194*       ld iy, (uiy)
       04          
0434B4 F1          0195*       pop af
0434B5             0196*   ; all done
0434B5 C9          0197*       ret
0434B6             0198*   
0434B6             0199*   ; print registers to screen in hexidecimal format
0434B6             0200*   ; inputs: none
0434B6             0201*   ; outputs: values of every register printed to screen
0434B6             0202*   ;    values of each register in global scratch memory
0434B6             0203*   ; destroys: nothing
0434B6             0204*   dumpRegistersHex:
0434B6             0205*   ; store everything in scratch
0434B6 22 35 03 04 0206*       ld (uhl),hl
0434BA ED 43 38 03 0207*       ld (ubc),bc
       04          
0434BF ED 53 3B 03 0208*       ld (ude),de
       04          
0434C4 DD 22 3E 03 0209*       ld (uix),ix
       04          
0434C9 FD 22 41 03 0210*       ld (uiy),iy
       04          
0434CE F5          0211*       push af ; fml
0434CF E1          0212*       pop hl ; thanks, zilog
0434D0 22 32 03 04 0213*       ld (uaf),hl
0434D4 F5          0214*       push af ; dammit
0434D5             0215*   
0434D5             0216*   ; home the cursor
0434D5             0217*       ; call vdu_home_cursor
0434D5             0218*       ; call printNewLine
0434D5             0219*   
0434D5             0220*   ; print each register
0434D5 21 B8 02 04 0221*       ld hl,str_afu
0434D9 CD 67 00 04 0222*       call printString
0434DD 2A 32 03 04 0223*       ld hl,(uaf)
0434E1 CD A0 00 04 0224*       call printHex24
0434E5 CD 7C 00 04 0225*       call printNewLine
0434E9             0226*   
0434E9 21 BD 02 04 0227*       ld hl,str_hlu
0434ED CD 67 00 04 0228*       call printString
0434F1 2A 35 03 04 0229*       ld hl,(uhl)
0434F5 CD A0 00 04 0230*       call printHex24
0434F9 CD 7C 00 04 0231*       call printNewLine
0434FD             0232*   
0434FD 21 C2 02 04 0233*       ld hl,str_bcu
043501 CD 67 00 04 0234*       call printString
043505 2A 38 03 04 0235*       ld hl,(ubc)
043509 CD A0 00 04 0236*       call printHex24
04350D CD 7C 00 04 0237*       call printNewLine
043511             0238*   
043511 21 C7 02 04 0239*       ld hl,str_deu
043515 CD 67 00 04 0240*       call printString
043519 2A 3B 03 04 0241*       ld hl,(ude)
04351D CD A0 00 04 0242*       call printHex24
043521 CD 7C 00 04 0243*       call printNewLine
043525             0244*   
043525 21 CC 02 04 0245*       ld hl,str_ixu
043529 CD 67 00 04 0246*       call printString
04352D 2A 3E 03 04 0247*       ld hl,(uix)
043531 CD A0 00 04 0248*       call printHex24
043535 CD 7C 00 04 0249*       call printNewLine
043539             0250*   
043539 21 D1 02 04 0251*       ld hl,str_iyu
04353D CD 67 00 04 0252*       call printString
043541 2A 41 03 04 0253*       ld hl,(uiy)
043545 CD A0 00 04 0254*       call printHex24
043549             0255*   
043549 CD 7C 00 04 0256*       call printNewLine
04354D CD 7C 00 04 0257*       call printNewLine
043551             0258*   ; restore everything
043551 2A 35 03 04 0259*       ld hl, (uhl)
043555 ED 4B 38 03 0260*       ld bc, (ubc)
       04          
04355A ED 5B 3B 03 0261*       ld de, (ude)
       04          
04355F DD 2A 3E 03 0262*       ld ix, (uix)
       04          
043564 FD 2A 41 03 0263*       ld iy, (uiy)
       04          
043569 F1          0264*       pop af
04356A             0265*   ; all done
04356A C9          0266*       ret
04356B             0267*   
04356B             0268*   dumpRegistersHexPrime:
04356B D9          0269*       exx
04356C 08          0270*       ex af,af'
04356D CD B6 34 04 0271*       call dumpRegistersHex
043571 08          0272*       ex af,af'
043572 D9          0273*       exx
043573 C9          0274*       ret
043574             0275*   
043574             0276*   ; additionally dump prime registers
043574             0277*   ; inputs: none
043574             0278*   ; outputs: values of every register printed to screen
043574             0279*   ; destroys: nothing
043574             0280*   dumpRegistersHexAll:
043574 CD B6 34 04 0281*       call dumpRegistersHex
043578 08          0282*       ex af,af'
043579 D9          0283*       exx
04357A CD B6 34 04 0284*       call dumpRegistersHex
04357E 08          0285*       ex af,af'
04357F D9          0286*       exx
043580 C9          0287*       ret
043581             0288*   
043581             0289*   ; print hlu to screen in hexidecimal format
043581             0290*   ; inputs: none
043581             0291*   ; destroys: nothing
043581             0292*   print_hex_hl:
043581 F5          0293*       push af
043582 E5          0294*       push hl
043583 21 BD 02 04 0295*       ld hl,str_hlu
043587 CD 67 00 04 0296*       call printString
04358B E1          0297*       pop hl
04358C E5          0298*       push hl
04358D CD A0 00 04 0299*       call printHex24
043591 3E 20       0300*       ld a,' '
043593 5B D7       0301*       rst.lil 10h
043595 E1          0302*       pop hl
043596 F1          0303*       pop af
043597 C9          0304*       ret
043598             0305*   
043598             0306*   ; print bcu to screen in hexidecimal format
043598             0307*   ; inputs: none
043598             0308*   ; destroys: nothing
043598             0309*   print_hex_bc:
043598 F5          0310*       push af
043599 E5          0311*       push hl
04359A C5          0312*       push bc
04359B 21 C2 02 04 0313*       ld hl,str_bcu
04359F CD 67 00 04 0314*       call printString
0435A3 E1          0315*       pop hl
0435A4 E5          0316*       push hl
0435A5 CD A0 00 04 0317*       call printHex24
0435A9 3E 20       0318*       ld a,' '
0435AB 5B D7       0319*       rst.lil 10h
0435AD C1          0320*       pop bc
0435AE E1          0321*       pop hl
0435AF F1          0322*       pop af
0435B0 C9          0323*       ret
0435B1             0324*   
0435B1             0325*   ; print deu to screen in hexidecimal format
0435B1             0326*   ; inputs: none
0435B1             0327*   ; destroys: nothing
0435B1             0328*   print_hex_de:
0435B1 F5          0329*       push af
0435B2 E5          0330*       push hl
0435B3 D5          0331*       push de
0435B4 21 C7 02 04 0332*       ld hl,str_deu
0435B8 CD 67 00 04 0333*       call printString
0435BC E1          0334*       pop hl
0435BD E5          0335*       push hl
0435BE CD A0 00 04 0336*       call printHex24
0435C2 3E 20       0337*       ld a,' '
0435C4 5B D7       0338*       rst.lil 10h
0435C6 D1          0339*       pop de
0435C7 E1          0340*       pop hl
0435C8 F1          0341*       pop af
0435C9 C9          0342*       ret
0435CA             0343*   
0435CA             0344*   
0435CA             0345*   ; inputs: whatever is in the flags register
0435CA             0346*   ; outputs: binary representation of flags
0435CA             0347*   ;          with a header so we know which is what
0435CA             0348*   ; destroys: nothing
0435CA             0349*   ; preserves: everything
0435CA             0350*   dumpFlags:
0435CA             0351*   ; first we curse zilog for not giving direct access to flags
0435CA F5          0352*       push af ; this is so we can send it back unharmed
0435CB F5          0353*       push af ; this is so we can pop it to hl
0435CC             0354*   ; store everything in scratch
0435CC 22 35 03 04 0355*       ld (uhl),hl
0435D0 ED 43 38 03 0356*       ld (ubc),bc
       04          
0435D5 ED 53 3B 03 0357*       ld (ude),de
       04          
0435DA DD 22 3E 03 0358*       ld (uix),ix
       04          
0435DF FD 22 41 03 0359*       ld (uiy),iy
       04          
0435E4             0360*   ; next we print the header
0435E4 21 10 36 04 0361*       ld hl,@header
0435E8 CD 67 00 04 0362*       call printString
0435EC E1          0363*       pop hl ; flags are now in l
0435ED 7D          0364*       ld a,l ; flags are now in a
0435EE CD 6E 02 04 0365*       call printBin8
0435F2 CD 7C 00 04 0366*       call printNewLine
0435F6             0367*   ; restore everything
0435F6 2A 35 03 04 0368*       ld hl, (uhl)
0435FA ED 4B 38 03 0369*       ld bc, (ubc)
       04          
0435FF ED 5B 3B 03 0370*       ld de, (ude)
       04          
043604 DD 2A 3E 03 0371*       ld ix, (uix)
       04          
043609 FD 2A 41 03 0372*       ld iy, (uiy)
       04          
04360E F1          0373*       pop af ; send her home the way she came
04360F C9          0374*       ret
043610             0375*   ; Bit 7 (S): Sign flag
043610             0376*   ; Bit 6 (Z): Zero flag
043610             0377*   ; Bit 5 (5): Reserved (copy of bit 5 of the result)
043610             0378*   ; Bit 4 (H): Half Carry flag
043610             0379*   ; Bit 3 (3): Reserved (copy of bit 3 of the result)
043610             0380*   ; Bit 2 (PV): Parity/Overflow flag
043610             0381*   ; Bit 1 (N): Subtract flag
043610             0382*   ; Bit 0 (C): Carry flag
043610 53 5A 78 48 0383*   @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
04361B             0384*   
04361B             0385*   
04361B             0386*   ; print bytes from an address to the screen in hexidecimal format
04361B             0387*   ; inputs: hl = address of first byte to print, a = number of bytes to print
04361B             0388*   ; outputs: values of each byte printed to screen separated by spaces
04361B             0389*   ; destroys: nothing
04361B             0390*   dumpMemoryHex:
04361B             0391*   ; save registers to the stack
04361B C5          0392*       push bc
04361C E5          0393*       push hl
04361D F5          0394*       push af
04361E             0395*   
04361E             0396*   ; print the address and separator
04361E CD A0 00 04 0397*       call printHex24
043622 3E 3A       0398*       ld a,':'
043624 5B D7       0399*       rst.lil 10h
043626 3E 20       0400*       ld a,' '
043628 5B D7       0401*       rst.lil 10h
04362A             0402*   
04362A             0403*   ; set b to be our loop counter
04362A F1          0404*       pop af
04362B 47          0405*       ld b,a
04362C E1          0406*       pop hl
04362D E5          0407*       push hl
04362E F5          0408*       push af
04362F             0409*   @loop:
04362F             0410*   ; print the byte
04362F 7E          0411*       ld a,(hl)
043630 CD AE 00 04 0412*       call printHex8
043634             0413*   ; print a space
043634 3E 20       0414*       ld a,' '
043636 5B D7       0415*       rst.lil 10h
043638 23          0416*       inc hl
043639 10 F4       0417*       djnz @loop
04363B             0418*       ; call printNewLine
04363B             0419*   
04363B             0420*   ; restore everything
04363B F1          0421*       pop af
04363C E1          0422*       pop hl
04363D C1          0423*       pop bc
04363E             0424*   
04363E             0425*   ; all done
04363E C9          0426*       ret
04363F             0427*   
04363F             0428*   
04363F             0429*   ; print bytes from an address to the screen in binary format
04363F             0430*   ; inputs: hl = address of first byte to print, a = number of bytes to print
04363F             0431*   ; outputs: values of each byte printed to screen separated by spaces
04363F             0432*   ; destroys: nothing
04363F             0433*   dumpMemoryBin:
04363F             0434*   ; save all registers to the stack
04363F F5          0435*       push af
043640 C5          0436*       push bc
043641 D5          0437*       push de
043642 E5          0438*       push hl
043643 DD E5       0439*       push ix
043645 FD E5       0440*       push iy
043647             0441*   
043647             0442*   ; set b to be our loop counter
043647 47          0443*       ld b,a
043648             0444*   @loop:
043648             0445*   ; print the byte
043648 7E          0446*       ld a,(hl)
043649 E5          0447*       push hl
04364A C5          0448*       push bc
04364B CD 6E 02 04 0449*       call printBin8
04364F C1          0450*       pop bc
043650             0451*   ; print a space
043650 3E 20       0452*       ld a,' '
043652 5B D7       0453*       rst.lil 10h
043654 E1          0454*       pop hl
043655 23          0455*       inc hl
043656 10 F0       0456*       djnz @loop
043658 CD 7C 00 04 0457*       call printNewLine
04365C             0458*   
04365C             0459*   ; restore everything
04365C FD E1       0460*       pop iy
04365E DD E1       0461*       pop ix
043660 E1          0462*       pop hl
043661 D1          0463*       pop de
043662 C1          0464*       pop bc
043663 F1          0465*       pop af
043664             0466*   ; all done
043664 C9          0467*       ret
043665             0468*   
043665             0469*   ; print bytes from an address to the screen in binary format
043665             0470*   ; with the bits of each byte in reverse order (lsb first)
043665             0471*   ; inputs: hl = address of first byte to print, a = number of bytes to print
043665             0472*   ; outputs: values of each byte printed to screen separated by spaces
043665             0473*   ; destroys: nothing
043665             0474*   dumpMemoryBinRev:
043665             0475*   ; save all registers to the stack
043665 F5          0476*       push af
043666 C5          0477*       push bc
043667 D5          0478*       push de
043668 E5          0479*       push hl
043669 DD E5       0480*       push ix
04366B FD E5       0481*       push iy
04366D             0482*   
04366D             0483*   ; set b to be our loop counter
04366D 47          0484*       ld b,a
04366E             0485*   @loop:
04366E             0486*   ; print the byte
04366E 7E          0487*       ld a,(hl)
04366F E5          0488*       push hl
043670 C5          0489*       push bc
043671 CD 93 02 04 0490*       call printBin8Rev
043675 C1          0491*       pop bc
043676             0492*   ; print a space
043676 3E 20       0493*       ld a,' '
043678 5B D7       0494*       rst.lil 10h
04367A E1          0495*       pop hl
04367B 23          0496*       inc hl
04367C 10 F0       0497*       djnz @loop
04367E CD 7C 00 04 0498*       call printNewLine
043682             0499*   
043682             0500*   ; restore everything
043682 FD E1       0501*       pop iy
043684 DD E1       0502*       pop ix
043686 E1          0503*       pop hl
043687 D1          0504*       pop de
043688 C1          0505*       pop bc
043689 F1          0506*       pop af
04368A             0507*   ; all done
04368A C9          0508*       ret
04368B             0509*   
04368B             0510*   DEBUG_PRINT:
04368B             0511*       PUSH_ALL
                       M1 Args: none
04368B 08          0001*M1     ex af,af'
04368C D9          0002*M1     exx
04368D F5          0003*M1     push af
04368E E5          0004*M1     push hl
04368F C5          0005*M1     push bc
043690 D5          0006*M1     push de
043691             0007*M1 
043691 08          0008*M1     ex af,af'
043692 D9          0009*M1     exx
043693 F5          0010*M1     push af
043694 E5          0011*M1     push hl
043695 C5          0012*M1     push bc
043696 D5          0013*M1     push de
043697 DD E5       0014*M1     push ix
043699 FD E5       0015*M1     push iy
04369B             0512*       ; ld c,0 ; X
04369B             0513*       ; ld b,0 ; Y
04369B             0514*       ; call vdu_move_cursor
04369B CD 7C 00 04 0515*       call printNewLine
04369F             0516*       POP_ALL
                       M1 Args: none
04369F FD E1       0001*M1     pop iy
0436A1 DD E1       0002*M1     pop ix
0436A3 D1          0003*M1     pop de
0436A4 C1          0004*M1     pop bc
0436A5 E1          0005*M1     pop hl
0436A6 F1          0006*M1     pop af
0436A7 08          0007*M1     ex af,af'
0436A8 D9          0008*M1     exx
0436A9             0009*M1 
0436A9 D1          0010*M1     pop de
0436AA C1          0011*M1     pop bc
0436AB E1          0012*M1     pop hl
0436AC F1          0013*M1     pop af
0436AD 08          0014*M1     ex af,af'
0436AE D9          0015*M1     exx
0436AF             0517*       PUSH_ALL
                       M1 Args: none
0436AF 08          0001*M1     ex af,af'
0436B0 D9          0002*M1     exx
0436B1 F5          0003*M1     push af
0436B2 E5          0004*M1     push hl
0436B3 C5          0005*M1     push bc
0436B4 D5          0006*M1     push de
0436B5             0007*M1 
0436B5 08          0008*M1     ex af,af'
0436B6 D9          0009*M1     exx
0436B7 F5          0010*M1     push af
0436B8 E5          0011*M1     push hl
0436B9 C5          0012*M1     push bc
0436BA D5          0013*M1     push de
0436BB DD E5       0014*M1     push ix
0436BD FD E5       0015*M1     push iy
0436BF CD CA 35 04 0518*       call dumpFlags
0436C3             0519*       POP_ALL
                       M1 Args: none
0436C3 FD E1       0001*M1     pop iy
0436C5 DD E1       0002*M1     pop ix
0436C7 D1          0003*M1     pop de
0436C8 C1          0004*M1     pop bc
0436C9 E1          0005*M1     pop hl
0436CA F1          0006*M1     pop af
0436CB 08          0007*M1     ex af,af'
0436CC D9          0008*M1     exx
0436CD             0009*M1 
0436CD D1          0010*M1     pop de
0436CE C1          0011*M1     pop bc
0436CF E1          0012*M1     pop hl
0436D0 F1          0013*M1     pop af
0436D1 08          0014*M1     ex af,af'
0436D2 D9          0015*M1     exx
0436D3             0520*       PUSH_ALL
                       M1 Args: none
0436D3 08          0001*M1     ex af,af'
0436D4 D9          0002*M1     exx
0436D5 F5          0003*M1     push af
0436D6 E5          0004*M1     push hl
0436D7 C5          0005*M1     push bc
0436D8 D5          0006*M1     push de
0436D9             0007*M1 
0436D9 08          0008*M1     ex af,af'
0436DA D9          0009*M1     exx
0436DB F5          0010*M1     push af
0436DC E5          0011*M1     push hl
0436DD C5          0012*M1     push bc
0436DE D5          0013*M1     push de
0436DF DD E5       0014*M1     push ix
0436E1 FD E5       0015*M1     push iy
0436E3 CD B6 34 04 0521*       call dumpRegistersHex
0436E7             0522*       ; call waitKeypress
0436E7 CD 7C 00 04 0523*       call printNewLine
0436EB             0524*       POP_ALL
                       M1 Args: none
0436EB FD E1       0001*M1     pop iy
0436ED DD E1       0002*M1     pop ix
0436EF D1          0003*M1     pop de
0436F0 C1          0004*M1     pop bc
0436F1 E1          0005*M1     pop hl
0436F2 F1          0006*M1     pop af
0436F3 08          0007*M1     ex af,af'
0436F4 D9          0008*M1     exx
0436F5             0009*M1 
0436F5 D1          0010*M1     pop de
0436F6 C1          0011*M1     pop bc
0436F7 E1          0012*M1     pop hl
0436F8 F1          0013*M1     pop af
0436F9 08          0014*M1     ex af,af'
0436FA D9          0015*M1     exx
0436FB C9          0525*       ret
0436FC             0526*   DEBUG_WAITKEYPRESS:
0436FC             0527*       PUSH_ALL
                       M1 Args: none
0436FC 08          0001*M1     ex af,af'
0436FD D9          0002*M1     exx
0436FE F5          0003*M1     push af
0436FF E5          0004*M1     push hl
043700 C5          0005*M1     push bc
043701 D5          0006*M1     push de
043702             0007*M1 
043702 08          0008*M1     ex af,af'
043703 D9          0009*M1     exx
043704 F5          0010*M1     push af
043705 E5          0011*M1     push hl
043706 C5          0012*M1     push bc
043707 D5          0013*M1     push de
043708 DD E5       0014*M1     push ix
04370A FD E5       0015*M1     push iy
04370C CD 5A 03 04 0528*       call waitKeypress
043710             0529*       POP_ALL
                       M1 Args: none
043710 FD E1       0001*M1     pop iy
043712 DD E1       0002*M1     pop ix
043714 D1          0003*M1     pop de
043715 C1          0004*M1     pop bc
043716 E1          0005*M1     pop hl
043717 F1          0006*M1     pop af
043718 08          0007*M1     ex af,af'
043719 D9          0008*M1     exx
04371A             0009*M1 
04371A D1          0010*M1     pop de
04371B C1          0011*M1     pop bc
04371C E1          0012*M1     pop hl
04371D F1          0013*M1     pop af
04371E 08          0014*M1     ex af,af'
04371F D9          0015*M1     exx
043720 C9          0530*       RET
043721             0531*   
043721             0532*   dumpVduCmdStr:
043721             0533*       PUSH_ALL
                       M1 Args: none
043721 08          0001*M1     ex af,af'
043722 D9          0002*M1     exx
043723 F5          0003*M1     push af
043724 E5          0004*M1     push hl
043725 C5          0005*M1     push bc
043726 D5          0006*M1     push de
043727             0007*M1 
043727 08          0008*M1     ex af,af'
043728 D9          0009*M1     exx
043729 F5          0010*M1     push af
04372A E5          0011*M1     push hl
04372B C5          0012*M1     push bc
04372C D5          0013*M1     push de
04372D DD E5       0014*M1     push ix
04372F FD E5       0015*M1     push iy
043731 79          0534*       ld a,c
043732 CD 1B 36 04 0535*       call dumpMemoryHex
043736 CD 5A 03 04 0536*       call waitKeypress
04373A             0537*       POP_ALL
                       M1 Args: none
04373A FD E1       0001*M1     pop iy
04373C DD E1       0002*M1     pop ix
04373E D1          0003*M1     pop de
04373F C1          0004*M1     pop bc
043740 E1          0005*M1     pop hl
043741 F1          0006*M1     pop af
043742 08          0007*M1     ex af,af'
043743 D9          0008*M1     exx
043744             0009*M1 
043744 D1          0010*M1     pop de
043745 C1          0011*M1     pop bc
043746 E1          0012*M1     pop hl
043747 F1          0013*M1     pop af
043748 08          0014*M1     ex af,af'
043749 D9          0015*M1     exx
04374A C9          0538*       ret
04374B             0539*   ; end dumpVduCmdStr
04374B             0054    
04374B             0055    ; --- MAIN PROGRAM FILE ---
04374B             0056    init:
04374B CD D7 23 04 0057        call ui_init
04374F CD 03 2F 04 0058        call ps_get_dir
043753 CD C1 32 04 0059        call ps_prt_irq_init
043757 C9          0060        ret
043758             0061    ; end init
043758             0062    main:
043758             0063    ; call the change directory routine and jp to user input
043758 CD 03 2F 04 0064        call ps_get_dir
04375C CD 0E 2B 04 0065        call get_input
043760             0066    
043760             0067    ; we come back here when user wants to quit app
043760             0068    ; shut down everytyhing and gracefully exit to MOS
043760 CD BB 32 04 0069        call ps_prt_stop ; stop the PRT timer
043764 FB          0070        ei ; interrupts were disabled by get_input
043765             0071    ; restore original screen mode
043765 3A AB 22 04 0072        ld a,(original_screen_mode)
043769 CD 0D 1C 04 0073        call vdu_set_screen_mode
04376D CD 08 1C 04 0074        call vdu_reset_viewports
043771 CD 3F 1B 04 0075        call vdu_cls
043775             0076    ; print thanks for playing message
043775 CD 60 00 04 0077        call printInline
043779 54 68 61 6E 0078        asciz "Thank you for using\r\n"
       6B 20 79 6F 
       75 20 66 6F 
       72 20 75 73 
       69 6E 67 0D 
       0A 00       
04378F 21 5B 25 04 0079        ld hl,agon_jukebox_ascii
043793 CD 67 00 04 0080        call printString
043797             0081    ; set cursor behaviuor
043797 CD B9 1A 04 0082        call vdu_cursor_on
04379B 26 10       0083        ld h,%00010000 ; bit 4 controls cursor scroll at bottom of screen
04379D 2E 00       0084        ld l,%00000000 ; bit 4 reset means cursor scrolls screen
04379F CD 2B 1B 04 0085        call vdu_cursor_behaviour
0437A3 C9          0086        ret ; back to MOS
0437A4             0087    ; end main
0437A4             0088    
0437A4             0089    ; must be final include in program so file data does not stomp on program code or other data
0437A4             0090        include "files.inc"
0437A4             0001*   ; THIS MUST BE LAST INCLUDE SO FILE DATA DOES NOT OVERWRITE OTHER CODE OR DATA
0437A4             0002*   
0437A4             0003*   ; buffer for loading files unrelated to audio
0437A4             0004*   ; e.g.: fonts, sprites, etc. (limited to 8k)
0437A4             0005*   filedata: equ 0xB7E000 ; address of onboard 8k sram
0437A4             0006*   
0437A4             0007*   ps_dir_struct: equ $ ; playing song directory info
0437A4             0008*   ps_wav_header: equ ps_dir_struct+dir_struct_size ; playing song .wav file header
0437A4             0009*   ps_wav_data_start: equ 0x050000 ; playing song .wav file data buffer
0437A4             0010*   
0437A4             0011*   ; this list can grow as large as necessary to hold all the files in the directory
0437A4             0012*   ; each entry will be 278 bytes (filinfo_struct_size)
0437A4             0013*   ps_dir_fil_list: equ ps_wav_data_start+65536 ; max file data we can load in one chunk is 64k
