PC     Output      Line
040000             0001        assume adl=1
040000             0002        org 0x040000
040000 C3 45 00 04 0003        jp start
040004 FF FF FF FF 0004        align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0005        db "MOS"
040043 00          0006        db 00h
040044 01          0007        db 01h
040045             0008    
040045             0009    start:
040045 F5          0010        push af
040046 C5          0011        push bc
040047 D5          0012        push de
040048 DD E5       0013        push ix
04004A FD E5       0014        push iy
04004C             0015    
04004C CD 32 27 04 0016        call init
040050 CD BD 27 04 0017        call main
040054             0018    
040054             0019    exit:
040054 FD E1       0020        pop iy
040056 DD E1       0021        pop ix
040058 D1          0022        pop de
040059 C1          0023        pop bc
04005A F1          0024        pop af
04005B 21 00 00 00 0025        ld hl,0
04005F             0026    
04005F C9          0027        ret
040060             0028    
040060             0029    ; API INCLUDES
040060             0030        include "mos_api.inc"
040060             0001*   ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.inc
040060             0002*   ; Title:	AGON MOS - API for user projects
040060             0003*   ; Author:	Dean Belfield
040060             0004*   ;			Adapted for agon-ez80asm by Jeroen Venema
040060             0005*   ;			Added MOS error codes for return in HL
040060             0006*   ; Created:	03/08/2022
040060             0007*   ; Last Updated:	10/08/2023
040060             0008*   ;
040060             0009*   ; Modinfo:
040060             0010*   ; 05/08/2022:	Added mos_feof
040060             0011*   ; 09/08/2022:	Added system variables: cursorX, cursorY
040060             0012*   ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040060             0013*   ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040060             0014*   ; 24/09/2022:	Added mos_getError, mos_mkdir
040060             0015*   ; 13/10/2022:	Added mos_oscli
040060             0016*   ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040060             0017*   ; 04/03/2023:	Added sysvar_scrpixelIndex
040060             0018*   ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040060             0019*   ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040060             0020*   ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040060             0021*   ; 22/03/2023:	The VDP commands are now indexed from 0x80
040060             0022*   ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040060             0023*   ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040060             0024*   ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040060             0025*   ; 19/05/2023:	Added sysvar_scrMode
040060             0026*   ; 05/06/2023:	Added sysvar_rtcEnable
040060             0027*   ; 03/08/2023:	Added mos_setkbvector
040060             0028*   ; 10/08/2023:	Added mos_getkbmap
040060             0029*   
040060             0030*   ; VDP control (VDU 23, 0, n)
040060             0031*   ;
040060             0032*   vdp_gp:				EQU 80h
040060             0033*   vdp_keycode:		EQU 81h
040060             0034*   vdp_cursor:			EQU	82h
040060             0035*   vdp_scrchar:		EQU	83h
040060             0036*   vdp_scrpixel:		EQU	84h
040060             0037*   vdp_audio:			EQU	85h
040060             0038*   vdp_mode:			EQU	86h
040060             0039*   vdp_rtc:			EQU	87h
040060             0040*   vdp_keystate:		EQU	88h
040060             0041*   vdp_logicalcoords:	EQU	C0h
040060             0042*   vdp_terminalmode:	EQU	FFh
040060             0043*   
040060             0044*   ; MOS high level functions
040060             0045*   ;
040060             0046*   mos_getkey:			EQU	00h
040060             0047*   mos_load:			EQU	01h
040060             0048*   mos_save:			EQU	02h
040060             0049*   mos_cd:				EQU	03h
040060             0050*   mos_dir:			EQU	04h
040060             0051*   mos_del:			EQU	05h
040060             0052*   mos_ren:			EQU	06h
040060             0053*   mos_mkdir:			EQU	07h
040060             0054*   mos_sysvars:		EQU	08h
040060             0055*   mos_editline:		EQU	09h
040060             0056*   mos_fopen:			EQU	0Ah
040060             0057*   mos_fclose:			EQU	0Bh
040060             0058*   mos_fgetc:			EQU	0Ch
040060             0059*   mos_fputc:			EQU	0Dh
040060             0060*   mos_feof:			EQU	0Eh
040060             0061*   mos_getError:		EQU	0Fh
040060             0062*   mos_oscli:			EQU	10h
040060             0063*   mos_copy:			EQU	11h
040060             0064*   mos_getrtc:			EQU	12h
040060             0065*   mos_setrtc:			EQU	13h
040060             0066*   mos_setintvector:	EQU	14h
040060             0067*   mos_uopen:			EQU	15h
040060             0068*   mos_uclose:			EQU	16h
040060             0069*   mos_ugetc:			EQU	17h
040060             0070*   mos_uputc:			EQU	18h
040060             0071*   mos_getfil:			EQU	19h
040060             0072*   mos_fread:			EQU	1Ah
040060             0073*   mos_fwrite:			EQU	1Bh
040060             0074*   mos_flseek:			EQU	1Ch
040060             0075*   mos_setkbvector:	EQU	1Dh
040060             0076*   mos_getkbmap:		EQU	1Eh
040060             0077*   
040060             0078*   ; MOS program exit codes
040060             0079*   ;
040060             0080*   EXIT_OK:				EQU  0;	"OK",
040060             0081*   EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
040060             0082*   EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
040060             0083*   EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
040060             0084*   EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
040060             0085*   EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
040060             0086*   EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
040060             0087*   EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
040060             0088*   EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
040060             0089*   EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
040060             0090*   EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
040060             0091*   EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
040060             0092*   EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
040060             0093*   EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
040060             0094*   EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
040060             0095*   EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
040060             0096*   EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
040060             0097*   EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
040060             0098*   EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
040060             0099*   EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
040060             0100*   EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
040060             0101*   EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
040060             0102*   ; FatFS file access functions
040060             0103*   ;
040060             0104*   ffs_fopen:			EQU	80h
040060             0105*   ffs_fclose:			EQU	81h
040060             0106*   ffs_fread:			EQU	82h
040060             0107*   ffs_fwrite:			EQU	83h
040060             0108*   ffs_flseek:			EQU	84h
040060             0109*   ffs_ftruncate:		EQU	85h
040060             0110*   ffs_fsync:			EQU	86h
040060             0111*   ffs_fforward:		EQU	87h
040060             0112*   ffs_fexpand:		EQU	88h
040060             0113*   ffs_fgets:			EQU	89h
040060             0114*   ffs_fputc:			EQU	8Ah
040060             0115*   ffs_fputs:			EQU	8Bh
040060             0116*   ffs_fprintf:		EQU	8Ch
040060             0117*   ffs_ftell:			EQU	8Dh
040060             0118*   ffs_feof:			EQU	8Eh
040060             0119*   ffs_fsize:			EQU	8Fh
040060             0120*   ffs_ferror:			EQU	90h
040060             0121*   
040060             0122*   ; FatFS directory access functions
040060             0123*   ;
040060             0124*   ffs_dopen:			EQU	91h
040060             0125*   ffs_dclose:			EQU	92h
040060             0126*   ffs_dread:			EQU	93h
040060             0127*   ffs_dfindfirst:		EQU	94h
040060             0128*   ffs_dfindnext:		EQU	95h
040060             0129*   
040060             0130*   ; FatFS file and directory management functions
040060             0131*   ;
040060             0132*   ffs_stat:			EQU	96h
040060             0133*   ffs_unlink:			EQU	97h
040060             0134*   ffs_rename:			EQU	98h
040060             0135*   ffs_chmod:			EQU	99h
040060             0136*   ffs_utime:			EQU	9Ah
040060             0137*   ffs_mkdir:			EQU	9Bh
040060             0138*   ffs_chdir:			EQU	9Ch
040060             0139*   ffs_chdrive:		EQU	9Dh
040060             0140*   ffs_getcwd:			EQU	9Eh
040060             0141*   
040060             0142*   ; FatFS volume management and system configuration functions
040060             0143*   ;
040060             0144*   ffs_mount:			EQU	9Fh
040060             0145*   ffs_mkfs:			EQU	A0h
040060             0146*   ffs_fdisk:			EQU	A1h
040060             0147*   ffs_getfree:		EQU	A2h
040060             0148*   ffs_getlabel:		EQU	A3h
040060             0149*   ffs_setlabel:		EQU	A4h
040060             0150*   ffs_setcp:			EQU	A5h
040060             0151*   
040060             0152*   ; File access modes
040060             0153*   ;
040060             0154*   fa_read:			EQU	01h
040060             0155*   fa_write:			EQU	02h
040060             0156*   fa_open_existing:	EQU	00h
040060             0157*   fa_create_new:		EQU	04h
040060             0158*   fa_create_always:	EQU	08h
040060             0159*   fa_open_always:		EQU	10h
040060             0160*   fa_open_append:		EQU	30h
040060             0161*   
040060             0162*   ; System variable indexes for api_sysvars
040060             0163*   ; Index into _sysvars in globals.inc
040060             0164*   ;
040060             0165*   sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040060             0166*   sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
040060             0167*   sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040060             0168*   sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
040060             0169*   sysvar_cursorX:			EQU	07h	; 1: Cursor X position
040060             0170*   sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
040060             0171*   sysvar_scrchar:			EQU	09h	; 1: Character read from screen
040060             0172*   sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040060             0173*   sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040060             0174*   sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040060             0175*   sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
040060             0176*   sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
040060             0177*   sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
040060             0178*   sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
040060             0179*   sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
040060             0180*   sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040060             0181*   sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
040060             0182*   sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040060             0183*   sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
040060             0184*   sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
040060             0185*   sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
040060             0186*   sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
040060             0187*   sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
040060             0188*   sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
040060             0189*   sysvar_scrMode:			EQU	27h	; 1: Screen mode
040060             0190*   sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040060             0191*   
040060             0192*   ; Flags for the VPD protocol
040060             0193*   ;
040060             0194*   vdp_pflag_cursor:		EQU	00000001b
040060             0195*   vdp_pflag_scrchar:		EQU	00000010b
040060             0196*   vdp_pflag_point:		EQU	00000100b
040060             0197*   vdp_pflag_audio:		EQU	00001000b
040060             0198*   vdp_pflag_mode:			EQU	00010000b
040060             0199*   vdp_pflag_rtc:			EQU	00100000b
040060             0200*   
040060             0201*   ;
040060             0202*   ; FatFS structures
040060             0203*   ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040060             0204*   ;
040060             0205*   ; Object ID and allocation information (FFOBJID)
040060             0206*   ;
040060             0207*   ; Indexes into FFOBJID structure
040060             0208*   ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
040060             0209*   ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
040060             0210*   ffobjid_attr:		EQU	5	; 1: Object attribute
040060             0211*   ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040060             0212*   ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
040060             0213*   ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
040060             0214*   ;
040060             0215*   ; File object structure (FIL)
040060             0216*   ;
040060             0217*   ; Indexes into FIL structure
040060             0218*   fil_obj:		EQU 0	; 15: Object identifier
040060             0219*   fil_flag:		EQU	15 	;  1: File status flags
040060             0220*   fil_err:		EQU	16	;  1: Abort flag (error code)
040060             0221*   fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
040060             0222*   fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
040060             0223*   fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
040060             0224*   fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
040060             0225*   fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
040060             0226*   ;
040060             0227*   ; Directory object structure (DIR)
040060             0228*   ; Indexes into DIR structure
040060             0229*   dir_obj:		EQU  0	; 15: Object identifier
040060             0230*   dir_dptr:		EQU	15	;  4: Current read/write offset
040060             0231*   dir_clust:		EQU	19	;  4: Current cluster
040060             0232*   dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
040060             0233*   dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
040060             0234*   dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
040060             0235*   dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040060             0236*   ;
040060             0237*   ; File information structure (FILINFO)
040060             0238*   ;
040060             0239*   ; Indexes into FILINFO structure
040060             0240*   filinfo_fsize:		EQU 0	;   4: File size
040060             0241*   filinfo_fdate:		EQU	4	;   2: Modified date
040060             0242*   filinfo_ftime:		EQU	6	;   2: Modified time
040060             0243*   filinfo_fattrib:	EQU	8	;   1: File attribute
040060             0244*   filinfo_altname:	EQU	9	;  13: Alternative file name
040060             0245*   filinfo_fname:		EQU	22	; 256: Primary file name
040060             0246*   ;
040060             0247*   ; Macro for calling the API
040060             0248*   ; Parameters:
040060             0249*   ; - function: One of the function numbers listed above
040060             0250*   ;
040060             0251*   	MACRO	MOSCALL	function
040060             0252*   			LD	A, function
040060             0253*   			RST.LIL	08h
040060             0254*   	ENDMACRO
040060             0031        include "macros.inc"
040060             0001*   
040060             0002*   ; test the sign of HL
040060             0003*   ; inputs: HL obviously
040060             0004*   ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
040060             0005*   ; destroys: flags
040060             0006*       MACRO SIGN_HLU
040060             0007*       add hl,de ; 1 cycle
040060             0008*       or a ; clear flags ; 1 cycle
040060             0009*       sbc hl,de ; 2 cycles
040060             0010*       ; 4 cycles total
040060             0011*       ENDMACRO
040060             0012*   
040060             0013*   ; put the value in A into HLU
040060             0014*   ; affects: HLU
040060             0015*   ; destroys: nothing
040060             0016*   ; note: $ instead of @@ b/c anon labels deprecated in ez80asm
040060             0017*       MACRO A_TO_HLU
040060             0018*       xor a ; 1 cycle
040060             0019*       ld ($+8+1),hl ; 7 cycles
040060             0020*       ld ($+4+3),a ; 5 cycles
040060             0021*       ld hl,0x000000 ; 4 cycles
040060             0022*       ; 17 cycles total
040060             0023*       ENDMACRO
040060             0024*   
040060             0025*   ; alternative: https://discord.com/channels/1158535358624039014/1282290921815408681/1318315567102300220
040060             0026*   ; one cycle less but burns flags
040060             0027*       MACRO A_TO_HLU_ALT
040060             0028*       push hl ; 4 cycles
040060             0029*       ld hl,2 ; 4 cycles
040060             0030*       add hl,sp ; 1 cycle
040060             0031*       ld (hl),a ; 2 cycles
040060             0032*       pop hl ; 4 cycles
040060             0033*       ; 15 cycles total
040060             0034*       ENDMACRO
040060             0035*   
040060             0036*       MACRO hlu_mul256
040060             0037*       add hl,hl ; * 2
040060             0038*       add hl,hl ; * 4
040060             0039*       add hl,hl ; * 8
040060             0040*       add hl,hl ; * 16
040060             0041*       add hl,hl ; * 32
040060             0042*       add hl,hl ; * 64
040060             0043*       add hl,hl ; * 128
040060             0044*       add hl,hl ; * 256
040060             0045*       ENDMACRO
040060             0046*   
040060             0047*   ; https://discord.com/channels/1158535358624039014/1282290921815408681/1317793870070812715
040060             0048*       MACRO SRL_UHL
040060             0049*       dec sp ; 1 cycle
040060             0050*       push hl ; 4 cycles
040060             0051*       inc sp ; 1 cycle
040060             0052*       pop hl ; 4 cycles
040060             0053*       inc hl ; 1 cycle
040060             0054*       dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
040060             0055*       ; 13 cycles total
040060             0056*       ENDMACRO
040060             0057*   
040060             0058*       MACRO printChar char
040060             0059*       LD A, char
040060             0060*       RST.LIL 10h
040060             0061*       ENDMACRO
040060             0062*   
040060             0063*   ; Simulated call to subroutine at HL
040060             0064*   ; inputs: HL pointing to the subroutine address plus whatever the called function expects
040060             0065*   ; outputs: whatever the subroutine does, including HL and BC
040060             0066*   ; destroys: only what the subroutine does, but always BC
040060             0067*       MACRO CALL_HL
040060             0068*       ld bc,$+6 ; Address of first instruction after the jump
040060             0069*       push bc ; which constitutes the return address
040060             0070*       jp (hl) ; Jump to the address in HL
040060             0071*       ENDMACRO
040060             0072*   
040060             0073*   ; Simulated call to subroutine at IX
040060             0074*   ; inputs: IX pointing to the subroutine address plus whatever the called function expects
040060             0075*   ; outputs: whatever the subroutine does, including IX and BC
040060             0076*   ; destroys: only what the subroutine does, but always BC
040060             0077*       MACRO CALL_IX
040060             0078*       ld bc,$+6 ; Address of first instruction after the jump
040060             0079*       push bc ; which constitutes the return address
040060             0080*       jp (ix) ; Jump to the address in IX
040060             0081*       ENDMACRO
040060             0082*   
040060             0083*   ; Simulated call to soubroutinte at IY
040060             0084*   ; inputs: IY pointing to the subroutine address plus whatever the called function expects
040060             0085*   ; outputs: whatever the subroutine does, including IY and BC
040060             0086*   ; destroys: only what the subroutine does, but always BC
040060             0087*       MACRO CALL_IY
040060             0088*       ld bc,$+6 ; Address of first instruction after the jump
040060             0089*       push bc ; which constitutes the return address
040060             0090*       jp (iy) ; Jump to the address in IY
040060             0091*       ENDMACRO
040060             0092*   
040060             0093*   ; put the value in HLU into A
040060             0094*   ; destroys: af
040060             0095*       MACRO HLU_TO_A
040060             0096*       dec sp ; 1 cycle
040060             0097*       push hl ; 4 cycles
040060             0098*       inc sp ; 1 cycle
040060             0099*       pop af ; 4 cycles
040060             0100*       ; 10 cycles total
040060             0101*       ENDMACRO
040060             0102*   
040060             0103*       MACRO PUSH_ALL
040060             0104*       ex af,af'
040060             0105*       exx
040060             0106*       push af
040060             0107*       push hl
040060             0108*       push bc
040060             0109*       push de
040060             0110*   
040060             0111*       ex af,af'
040060             0112*       exx
040060             0113*       push af
040060             0114*       push hl
040060             0115*       push bc
040060             0116*       push de
040060             0117*       push ix
040060             0118*       push iy
040060             0119*       ENDMACRO
040060             0120*   
040060             0121*       MACRO POP_ALL
040060             0122*       pop iy
040060             0123*       pop ix
040060             0124*       pop de
040060             0125*       pop bc
040060             0126*       pop hl
040060             0127*       pop af
040060             0128*       ex af,af'
040060             0129*       exx
040060             0130*   
040060             0131*       pop de
040060             0132*       pop bc
040060             0133*       pop hl
040060             0134*       pop af
040060             0135*       ex af,af'
040060             0136*       exx
040060             0137*       ENDMACRO
040060             0032        include "functions.inc"
040060             0001*   ; Print a zero-terminated string inline with code, e.g.:
040060             0002*   ;
040060             0003*   ;    call printInline
040060             0004*   ;    ASCIZ "Hello, world!\r\n"
040060             0005*   ;
040060             0006*   ; Destroys: HL,AF
040060             0007*   printInline:
040060 E1          0008*       pop hl ; get the return address = pointer to start of string
040061 CD 67 00 04 0009*       call printString ; HL advances to end of string
040065 E5          0010*       push hl ; restore the return address = pointer to end of string
040066 C9          0011*       ret
040067             0012*   
040067             0013*   ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
040067             0014*   ; Print a zero-terminated string
040067             0015*   ; HL: Pointer to string
040067             0016*   printString:
040067 C5          0017*       PUSH BC
040068 01 00 00 00 0018*       LD BC,0
04006C 3E 00       0019*       LD A,0
04006E 5B DF       0020*       RST.LIL 18h
040070 C1          0021*       POP BC
040071 C9          0022*       RET
040072             0023*   ; print a VDU sequence
040072             0024*   ; HL: Pointer to VDU sequence - <1 byte length> <data>
040072             0025*   sendVDUsequence:
040072 C5          0026*       PUSH BC
040073 01 00 00 00 0027*       LD BC, 0
040077 4E          0028*       LD C, (HL)
040078 5B DF       0029*       RST.LIL 18h
04007A C1          0030*       POP BC
04007B C9          0031*       RET
04007C             0032*   ; Print Newline sequence to VDP
04007C             0033*   ; destroys bc
04007C             0034*   printNewLine:
04007C F5          0035*       push af ; for some reason rst.lil 10h sets carry flag
04007D 3E 0D       0036*       LD A, '\r'
04007F 5B D7       0037*       RST.LIL 10h
040081 3E 0A       0038*       LD A, '\n'
040083 5B D7       0039*       RST.LIL 10h
040085 F1          0040*       pop af
040086 C9          0041*       RET
040087             0042*   
040087             0043*   ; print a zero-terminated string at a graphics coordinate
040087             0044*   ; Inputs: HL Pointer to string, BC,DE x,y position (in pixels)
040087             0045*   printStringGfx:
040087 E5          0046*       push hl ; preserve string pointer
040088             0047*   ; move graphics cursor to x,y location
040088 3E 44       0048*       ld a,plot_pt+mv_abs
04008A CD 1A 19 04 0049*       call vdu_plot
04008E             0050*   ; print string
04008E E1          0051*       pop hl ; restore string pointer
04008F             0052*   @print_loop:
04008F 7E          0053*       ld a,(hl)
040090 B7          0054*       or a ; check for end of string
040091 C8          0055*       ret z ; if zero, we're done
040092 08          0056*       ex af,af' ; preserve character
040093 3E 05       0057*       ld a,5 ; VDU 5 char to gfx cursor
040095 5B D7       0058*       rst.lil 10h ; send it
040097 08          0059*       ex af,af' ; restore character
040098 5B D7       0060*       rst.lil 10h ; print character
04009A 23          0061*       inc hl
04009B C3 8F 00 04 0062*       jp @print_loop
04009F C9          0063*       ret
0400A0             0064*   ; end printStringGfx
0400A0             0065*   
0400A0             0066*   ; Print a 24-bit HEX number
0400A0             0067*   ; HLU: Number to print
0400A0             0068*   printHex24:
0400A0             0069*       HLU_TO_A
0400A0 3B          0001*M1     dec sp ; 1 cycle
0400A1 E5          0002*M1     push hl ; 4 cycles
0400A2 33          0003*M1     inc sp ; 1 cycle
0400A3 F1          0004*M1     pop af ; 4 cycles
0400A4             0005*M1     ; 10 cycles total
0400A4 CD AE 00 04 0070*       CALL printHex8
0400A8             0071*   ; Print a 16-bit HEX number
0400A8             0072*   ; HL: Number to print
0400A8             0073*   printHex16:
0400A8 7C          0074*       LD A,H
0400A9 CD AE 00 04 0075*       CALL printHex8
0400AD 7D          0076*       LD A,L
0400AE             0077*   ; Print an 8-bit HEX number
0400AE             0078*   ; A: Number to print
0400AE             0079*   printHex8:
0400AE 4F          0080*       LD C,A
0400AF 1F          0081*       RRA
0400B0 1F          0082*       RRA
0400B1 1F          0083*       RRA
0400B2 1F          0084*       RRA
0400B3 CD B8 00 04 0085*       CALL @F
0400B7 79          0086*       LD A,C
0400B8             0087*   @@:
0400B8 E6 0F       0088*       AND 0Fh
0400BA C6 90       0089*       ADD A,90h
0400BC 27          0090*       DAA
0400BD CE 40       0091*       ADC A,40h
0400BF 27          0092*       DAA
0400C0 5B D7       0093*       RST.LIL 10h
0400C2 C9          0094*       RET
0400C3             0095*   
0400C3             0096*   ; Print a 0x HEX prefix
0400C3             0097*   DisplayHexPrefix:
0400C3 3E 30       0098*       LD A, '0'
0400C5 5B D7       0099*       RST.LIL 10h
0400C7 3E 78       0100*       LD A, 'x'
0400C9 5B D7       0101*       RST.LIL 10h
0400CB C9          0102*       RET
0400CC             0103*   
0400CC             0104*       MACRO printDecBC
0400CC             0105*       push hl
0400CC             0106*       push bc
0400CC             0107*       pop hl
0400CC             0108*       call printDec
0400CC             0109*       pop hl
0400CC             0110*       ENDMACRO
0400CC             0111*   
0400CC             0112*       MACRO printDecDE
0400CC             0113*       push hl
0400CC             0114*       push de
0400CC             0115*       pop hl
0400CC             0116*       call printDec
0400CC             0117*       pop hl
0400CC             0118*       ENDMACRO
0400CC             0119*   
0400CC             0120*       MACRO printDecHL
0400CC             0121*       call printDec
0400CC             0122*       ENDMACRO
0400CC             0123*   
0400CC             0124*       MACRO printDecIX
0400CC             0125*       push hl
0400CC             0126*       push ix
0400CC             0127*       pop hl
0400CC             0128*       call printDec
0400CC             0129*       pop hl
0400CC             0130*       ENDMACRO
0400CC             0131*   
0400CC             0132*       MACRO printDecIY
0400CC             0133*       push hl
0400CC             0134*       push iy
0400CC             0135*       pop hl
0400CC             0136*       call printDec
0400CC             0137*       pop hl
0400CC             0138*       ENDMACRO
0400CC             0139*   
0400CC             0140*   
0400CC             0141*   ; Prints the right justified decimal value in HL without leading zeroes
0400CC             0142*   ; HL : Value to print
0400CC             0143*   ; preserves all registers and flags
0400CC             0144*   printDec:
0400CC             0145*   ; BEGIN MY CODE
0400CC             0146*   ; back up all the things
0400CC F5          0147*       push af
0400CD C5          0148*       push bc
0400CE D5          0149*       push de
0400CF E5          0150*       push hl
0400D0             0151*   ; END MY CODE
0400D0 11 F8 00 04 0152*       LD DE, _printDecBuffer
0400D4 CD 08 01 04 0153*       CALL u24_to_ascii
0400D8             0154*   ; BEGIN MY CODE
0400D8             0155*   ; replace leading zeroes with spaces
0400D8 21 F8 00 04 0156*       LD HL, _printDecBuffer
0400DC 06 07       0157*       ld B, 7 ; if HL was 0, we want to keep the final zero
0400DE             0158*   @loop:
0400DE 7E          0159*       LD A, (HL)
0400DF FE 30       0160*       CP '0'
0400E1 C2 EB 00 04 0161*       JP NZ, @done
0400E5 3E 20       0162*       LD A, ' '
0400E7 77          0163*       LD (HL), A
0400E8 23          0164*       INC HL
0400E9             0165*       ; CALL vdu_cursor_forward
0400E9 10 F3       0166*       DJNZ @loop
0400EB             0167*   @done:
0400EB             0168*   ; END MY CODE
0400EB 21 F8 00 04 0169*       LD HL, _printDecBuffer
0400EF CD 67 00 04 0170*       CALL printString
0400F3             0171*   ; BEGIN MY CODE
0400F3             0172*   ; restore all the things
0400F3 E1          0173*       pop hl
0400F4 D1          0174*       pop de
0400F5 C1          0175*       pop bc
0400F6 F1          0176*       pop af
0400F7             0177*   ; END MY CODE
0400F7 C9          0178*       RET
0400F8 00 00 00 00 0179*   _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040108             0180*   
040108             0181*   ; This routine converts the unsigned 24-bit value in HLU into its ASCII representation,
040108             0182*   ; starting to memory location pointing by DE, in decimal form and with leading zeroes
040108             0183*   ; so it will allways be 8 characters length
040108             0184*   ; HL : Value to convert to string
040108             0185*   ; DE : pointer to buffer, at least 8 byte + 0
040108             0186*   u24_to_ascii:
040108 01 80 69 67 0187*       LD BC,-10000000
04010C CD 3F 01 04 0188*       CALL @one_digit
040110 01 C0 BD F0 0189*       LD BC,-1000000
040114 CD 3F 01 04 0190*       CALL @one_digit
040118 01 60 79 FE 0191*       LD BC,-100000
04011C CD 3F 01 04 0192*       CALL @one_digit
040120 01 F0 D8 FF 0193*       LD BC,-10000
040124 CD 3F 01 04 0194*       CALL @one_digit
040128 01 18 FC FF 0195*       LD BC,-1000
04012C CD 3F 01 04 0196*       CALL @one_digit
040130 01 9C FF FF 0197*       LD BC,-100
040134 CD 3F 01 04 0198*       CALL @one_digit
040138 0E F6       0199*       LD C,-10
04013A CD 3F 01 04 0200*       CALL @one_digit
04013E 48          0201*       LD C,B
04013F             0202*   @one_digit:
04013F 3E 2F       0203*       LD A,'0'-1
040141             0204*   @divide_me:
040141 3C          0205*       INC A
040142 09          0206*       ADD HL,BC
040143 38 FC       0207*       JR C,@divide_me
040145 ED 42       0208*       SBC HL,BC
040147 12          0209*       LD (DE),A
040148 13          0210*       INC DE
040149 C9          0211*       RET
04014A             0212*   
04014A             0213*   print_u24:
04014A D5          0214*       push de
04014B E5          0215*       push hl
04014C 11 F8 00 04 0216*       ld de,_printDecBuffer
040150 CD 08 01 04 0217*       call u24_to_ascii
040154 21 F8 00 04 0218*       ld hl,_printDecBuffer
040158 CD 67 00 04 0219*       call printString
04015C 3E 20       0220*       ld a,' '
04015E 5B D7       0221*       rst.lil 10h
040160 E1          0222*       pop hl
040161 D1          0223*       pop de
040162 C9          0224*       ret
040163             0225*   
040163             0226*   ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
040163             0227*   ; HL : Value to convert to string (integer part in H, fractional part in L)
040163             0228*   ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
040163             0229*   u168_to_ascii:
040163             0230*   ; add a leading space to make room for sign flag if needed
040163 3E 20       0231*       ld a,' '
040165 12          0232*       ld (de),a
040166 13          0233*       inc de
040167             0234*   ; Convert integer part
040167 E5          0235*       push hl ; Save HL (weâ€™ll need the fractional part later)
040168             0236*       ; call hlu_udiv256 ; Shift to get integer portion in HL
040168             0237*       SRL_UHL ; Shift to get integer portion in HL
040168 3B          0001*M1     dec sp ; 1 cycle
040169 E5          0002*M1     push hl ; 4 cycles
04016A 33          0003*M1     inc sp ; 1 cycle
04016B E1          0004*M1     pop hl ; 4 cycles
04016C 23          0005*M1     inc hl ; 1 cycle
04016D 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
04016F             0007*M1     ; 13 cycles total
04016F 01 F0 D8 FF 0238*       ld bc, -10000
040173 CD 96 01 04 0239*       call @one_int
040177 01 18 FC FF 0240*       ld bc, -1000
04017B CD 96 01 04 0241*       call @one_int
04017F 01 9C FF FF 0242*       ld bc, -100
040183 CD 96 01 04 0243*       call @one_int
040187 0E F6       0244*       ld c, -10
040189 CD 96 01 04 0245*       call @one_int
04018D 48          0246*       ld c, b
04018E CD 96 01 04 0247*       call @one_int
040192 C3 A1 01 04 0248*       jp @frac ; Jump to fractional part conversion
040196             0249*   @one_int:
040196 3E 2F       0250*       ld a, '0' - 1 ; Start ASCII character at '0'
040198             0251*   @divide_me:
040198 3C          0252*       inc a
040199 09          0253*       add hl, bc ; Accumulate until overflow
04019A 38 FC       0254*       jr c, @divide_me
04019C ED 42       0255*       sbc hl, bc ; Remove excess after overflow
04019E 12          0256*       ld (de), a ; Store ASCII digit
04019F 13          0257*       inc de
0401A0 C9          0258*       ret
0401A1             0259*   ; Convert fractional part
0401A1             0260*   @frac:
0401A1 3E 2E       0261*       ld a, '.' ; Decimal point
0401A3 12          0262*       ld (de), a
0401A4 13          0263*       inc de
0401A5 E1          0264*       pop hl ; Restore HL with original fraction
0401A6 06 03       0265*       ld b, 3 ; Loop counter for 3 fractional digits
0401A8             0266*   @frac_loop:
0401A8 26 0A       0267*       ld h, 10 ; Load multiplier for fractional part
0401AA ED 6C       0268*       mlt hl ; Multiply by 10, result in HL (H holds the integer part)
0401AC 3E 30       0269*       ld a, '0'
0401AE 84          0270*       add a, h ; Convert integer part to ASCII
0401AF 12          0271*       ld (de), a
0401B0 13          0272*       inc de
0401B1 10 F5       0273*       djnz @frac_loop ; Repeat for each fractional digit
0401B3             0274*   ; Add null terminator
0401B3 AF          0275*       xor a ; Null terminator
0401B4 12          0276*       ld (de), a
0401B5 C9          0277*       ret
0401B6             0278*   
0401B6             0279*   print_u168:
0401B6 D5          0280*       push de
0401B7 E5          0281*       push hl
0401B8 11 F8 00 04 0282*       ld de,_printDecBuffer
0401BC CD 63 01 04 0283*       call u168_to_ascii
0401C0 21 F8 00 04 0284*       ld hl,_printDecBuffer
0401C4 CD 67 00 04 0285*       call printString
0401C8 E1          0286*       pop hl
0401C9 D1          0287*       pop de
0401CA C9          0288*       ret
0401CB             0289*   
0401CB             0290*   ; signed version of u168_to_ascii
0401CB             0291*   s168_to_ascii:
0401CB D5          0292*       push de ; save starting address of buffer
0401CC CD 70 04 04 0293*       call hlu_abs
0401D0 F5          0294*       push af ; save sign flag
0401D1 CD 63 01 04 0295*       call u168_to_ascii
0401D5 F1          0296*       pop af ; restore sign flag
0401D6 D1          0297*       pop de ; restore starting address of buffer
0401D7 F0          0298*       ret p ; hlu was positive so nothing to do
0401D8 3E 2D       0299*       ld a,'-'
0401DA 12          0300*       ld (de),a
0401DB C9          0301*       ret
0401DC             0302*   
0401DC             0303*   print_s168:
0401DC D5          0304*       push de
0401DD E5          0305*       push hl
0401DE 11 F8 00 04 0306*       ld de,_printDecBuffer
0401E2 CD CB 01 04 0307*       call s168_to_ascii
0401E6 21 F8 00 04 0308*       ld hl,_printDecBuffer
0401EA CD 67 00 04 0309*       call printString
0401EE E1          0310*       pop hl
0401EF D1          0311*       pop de
0401F0 C9          0312*       ret
0401F1             0313*   
0401F1             0314*   print_s168_hl:
0401F1 F5          0315*       push af
0401F2 E5          0316*       push hl
0401F3 CD DC 01 04 0317*       call print_s168
0401F7 3E 20       0318*       ld a,' '
0401F9 5B D7       0319*       rst.lil 10h
0401FB E1          0320*       pop hl
0401FC F1          0321*       pop af
0401FD C9          0322*       ret
0401FE             0323*   
0401FE             0324*   print_s168_bc:
0401FE F5          0325*       push af
0401FF C5          0326*       push bc
040200 E5          0327*       push hl
040201 C5          0328*       push bc
040202 E1          0329*       pop hl
040203 CD DC 01 04 0330*       call print_s168
040207 3E 20       0331*       ld a,' '
040209 5B D7       0332*       rst.lil 10h
04020B E1          0333*       pop hl
04020C C1          0334*       pop bc
04020D F1          0335*       pop af
04020E C9          0336*       ret
04020F             0337*   
04020F             0338*   print_s168_de:
04020F F5          0339*       push af
040210 D5          0340*       push de
040211 E5          0341*       push hl
040212 EB          0342*       ex de,hl
040213 CD DC 01 04 0343*       call print_s168
040217 3E 20       0344*       ld a,' '
040219 5B D7       0345*       rst.lil 10h
04021B E1          0346*       pop hl
04021C D1          0347*       pop de
04021D F1          0348*       pop af
04021E C9          0349*       ret
04021F             0350*   
04021F             0351*   print_s168_hl_bc_de:
04021F F5          0352*       push af
040220 C5          0353*       push bc
040221 D5          0354*       push de
040222 E5          0355*       push hl
040223 CD DC 01 04 0356*       call print_s168
040227 3E 20       0357*       ld a,' '
040229 5B D7       0358*       rst.lil 10h
04022B C5          0359*       push bc
04022C E1          0360*       pop hl
04022D CD DC 01 04 0361*       call print_s168
040231 3E 20       0362*       ld a,' '
040233 5B D7       0363*       rst.lil 10h
040235 EB          0364*       ex de,hl
040236 CD DC 01 04 0365*       call print_s168
04023A 3E 20       0366*       ld a,' '
04023C 5B D7       0367*       rst.lil 10h
04023E E1          0368*       pop hl
04023F D1          0369*       pop de
040240 C1          0370*       pop bc
040241 F1          0371*       pop af
040242 C9          0372*       ret
040243             0373*   
040243             0374*   print_s168_bc_de:
040243 F5          0375*       push af
040244 C5          0376*       push bc
040245 D5          0377*       push de
040246 C5          0378*       push bc
040247 E1          0379*       pop hl
040248 CD DC 01 04 0380*       call print_s168
04024C 3E 20       0381*       ld a,' '
04024E 5B D7       0382*       rst.lil 10h
040250 EB          0383*       ex de,hl
040251 CD DC 01 04 0384*       call print_s168
040255 3E 20       0385*       ld a,' '
040257 5B D7       0386*       rst.lil 10h
040259 E1          0387*       pop hl
04025A D1          0388*       pop de
04025B C1          0389*       pop bc
04025C F1          0390*       pop af
04025D C9          0391*       ret
04025E             0392*   
04025E             0393*   print_s168_a:
04025E F5          0394*       push af
04025F C5          0395*       push bc
040260 E5          0396*       push hl
040261 21 00 00 00 0397*       ld hl,0
040265 6F          0398*       ld l,a
040266 CD F1 01 04 0399*       call print_s168_hl
04026A E1          0400*       pop hl
04026B C1          0401*       pop bc
04026C F1          0402*       pop af
04026D C9          0403*       ret
04026E             0404*   
04026E             0405*   ; #### new functions added by Brandon R. Gates ####
04026E             0406*   
04026E             0407*   ; print the binary representation of the 8-bit value in a
04026E             0408*   ; destroys a, hl, bc
04026E             0409*   printBin8:
04026E 06 08       0410*       ld b,8 ; loop counter for 8 bits
040270 21 8B 02 04 0411*       ld hl,@cmd ; set hl to the low byte of the output string
040274             0412*       ; (which will be the high bit of the value in a)
040274             0413*   @loop:
040274 07          0414*       rlca ; put the next highest bit into carry
040275 38 04       0415*       jr c,@one
040277 36 30       0416*       ld (hl),'0'
040279 18 02       0417*       jr @next_bit
04027B             0418*   @one:
04027B 36 31       0419*       ld (hl),'1'
04027D             0420*   @next_bit:
04027D 23          0421*       inc hl
04027E 10 F4       0422*       djnz @loop
040280             0423*   ; print it
040280 21 8B 02 04 0424*       ld hl,@cmd
040284 01 08 00 00 0425*       ld bc,@end-@cmd
040288 5B DF       0426*       rst.lil $18
04028A C9          0427*       ret
04028B             0428*   @cmd: ds 8 ; eight bytes for eight bits
040293             0429*   @end:
040293             0430*   
040293             0431*   ; print the binary representation of the 8-bit value in a
040293             0432*   ; in reverse order (lsb first)
040293             0433*   ; destroys a, hl, bc
040293             0434*   printBin8Rev:
       FF FF FF FF 
       FF FF FF FF 
040293 06 08       0435*       ld b,8 ; loop counter for 8 bits
040295 21 B0 02 04 0436*       ld hl,@cmd ; set hl to the low byte of the output string
040299             0437*       ; (which will be the high bit of the value in a)
040299             0438*   @loop:
040299 0F          0439*       rrca ; put the next lowest bit into carry
04029A 38 04       0440*       jr c,@one
04029C 36 30       0441*       ld (hl),'0'
04029E 18 02       0442*       jr @next_bit
0402A0             0443*   @one:
0402A0 36 31       0444*       ld (hl),'1'
0402A2             0445*   @next_bit:
0402A2 23          0446*       inc hl
0402A3 10 F4       0447*       djnz @loop
0402A5             0448*   ; print it
0402A5 21 B0 02 04 0449*       ld hl,@cmd
0402A9 01 08 00 00 0450*       ld bc,@end-@cmd
0402AD 5B DF       0451*       rst.lil $18
0402AF C9          0452*       ret
0402B0             0453*   @cmd: ds 8 ; eight bytes for eight bits
0402B8             0454*   @end:
0402B8             0455*   
       FF FF FF FF 
       FF FF FF FF 
0402B8 20 61 66 3D 0456*   str_afu: db " af=",0
       00          
0402BD 20 68 6C 3D 0457*   str_hlu: db " hl=",0
       00          
0402C2 20 62 63 3D 0458*   str_bcu: db " bc=",0
       00          
0402C7 20 64 65 3D 0459*   str_deu: db " de=",0
       00          
0402CC 20 69 78 3D 0460*   str_ixu: db " ix=",0
       00          
0402D1 20 69 79 3D 0461*   str_iyu: db " iy=",0
       00          
0402D6             0462*   
0402D6             0463*   ; print udeuhl to screen in hexidecimal format
0402D6             0464*   ; inputs: none
0402D6             0465*   ; outputs: concatenated hexidecimal udeuhl
0402D6             0466*   ; destroys: nothing
0402D6             0467*   dumpUDEUHLHex:
0402D6             0468*   ; store everything in scratch
0402D6 22 35 03 04 0469*       ld (uhl),hl
0402DA ED 43 38 03 0470*       ld (ubc),bc
       04          
0402DF ED 53 3B 03 0471*       ld (ude),de
       04          
0402E4 DD 22 3E 03 0472*       ld (uix),ix
       04          
0402E9 FD 22 41 03 0473*       ld (uiy),iy
       04          
0402EE F5          0474*       push af
0402EF             0475*   
0402EF             0476*   ; print each register
0402EF             0477*   
0402EF 21 29 03 04 0478*       ld hl,str_udeuhl
0402F3 CD 67 00 04 0479*       call printString
0402F7 2A 3B 03 04 0480*       ld hl,(ude)
0402FB CD A0 00 04 0481*       call printHex24
0402FF 3E 2E       0482*       ld a,'.' ; print a dot to separate the values
040301 5B D7       0483*       rst.lil 10h
040303 2A 35 03 04 0484*       ld hl,(uhl)
040307 CD A0 00 04 0485*       call printHex24
04030B CD 7C 00 04 0486*       call printNewLine
04030F             0487*   
04030F             0488*   ; restore everything
04030F 2A 35 03 04 0489*       ld hl, (uhl)
040313 ED 4B 38 03 0490*       ld bc, (ubc)
       04          
040318 ED 5B 3B 03 0491*       ld de, (ude)
       04          
04031D DD 2A 3E 03 0492*       ld ix, (uix)
       04          
040322 FD 2A 41 03 0493*       ld iy, (uiy)
       04          
040327 F1          0494*       pop af
040328             0495*   ; all done
040328 C9          0496*       ret
040329             0497*   
040329 75 64 65 2E 0498*   str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
040332             0499*   
040332             0500*   ; global scratch memory for registers
040332 00 00 00    0501*   uaf: dl 0
040335 00 00 00    0502*   uhl: dl 0
040338 00 00 00    0503*   ubc: dl 0
04033B 00 00 00    0504*   ude: dl 0
04033E 00 00 00    0505*   uix: dl 0
040341 00 00 00    0506*   uiy: dl 0
040344 00 00 00    0507*   usp: dl 0
040347 00 00 00    0508*   upc: dl 0
04034A             0509*   
04034A             0510*   
04034A             0511*   ; set all the bits in the flag register
04034A             0512*   ; more of an academic exercise than anything useful
04034A             0513*   ; inputs; none
04034A             0514*   ; outputs; a=0,f=255
04034A             0515*   ; destroys: flags, hl
04034A             0516*   ; preserves: a, because why not
04034A             0517*   setAllFlags:
04034A 21 FF 00 00 0518*       ld hl,255
04034E 67          0519*       ld h,a ; four cycles to preserve a is cheap
04034F E5          0520*       push hl
040350 F1          0521*       pop af
040351 C9          0522*       ret
040352             0523*   
040352             0524*   ; reset all the bits in the flag register
040352             0525*   ; unlike its inverse counterpart, this may actually be useful
040352             0526*   ; inputs; none
040352             0527*   ; outputs; a=0,f=0
040352             0528*   ; destroys: flags, hl
040352             0529*   ; preserves: a, because why not
040352             0530*   resetAllFlags:
040352 21 00 00 00 0531*       ld hl,0
040356 67          0532*       ld h,a ; four cycles to preserve a is cheap
040357 E5          0533*       push hl
040358 F1          0534*       pop af
040359 C9          0535*       ret
04035A             0536*   
04035A             0537*   ; wait until user presses a key
04035A             0538*   ; inputs: none
04035A             0539*   ; outputs: ascii code of key pressed in a
04035A             0540*   ; destroys: af,ix
04035A             0541*   waitKeypress:
04035A             0542*       MOSCALL mos_getkey
04035A 3E 00       0001*M1 			LD	A, function
04035C 5B CF       0002*M1 			RST.LIL	08h
04035E C9          0543*       ret
04035F             0544*   
04035F             0545*   ; clear a block of memory by writing a prescribed value to each byte in the range
04035F             0546*   ; inputs: a = value to write, hl = address of first byte, bc = number of bytes
04035F             0547*   ; outputs: memory block is cleared
04035F             0548*   ; destroys: hl, de
04035F             0549*   clear_mem:
04035F 0B          0550*       dec bc ; we do this because we will increment de before writing the first byte
040360 77          0551*       ld (hl),a
040361 E5          0552*       push hl
040362 D1          0553*       pop de
040363 13          0554*       inc de ; target address
040364 ED B0       0555*       ldir
040366 C9          0556*       ret
040367             0033        include "arith24.inc"
040367             0001*   ;------------------------------------------------------------------------
040367             0002*   ;  arith24.asm
040367             0003*   ;  24-bit ez80 arithmetic routines
040367             0004*   ;  Copyright (c) Shawn Sijnstra 2024
040367             0005*   ;  MIT license
040367             0006*   ;
040367             0007*   ;  This library was created as a tool to help make ez80
040367             0008*   ;  24-bit native assembly routines for simple mathematical problems
040367             0009*   ;  more widely available.
040367             0010*   ;
040367             0011*   ;------------------------------------------------------------------------
040367             0012*   
040367             0013*   ;------------------------------------------------------------------------
040367             0014*   ; umul24:	HL = HL*DE (unsigned)
040367             0015*   ; Preserves AF, BC, DE
040367             0016*   ; Uses a fast multiply routine.
040367             0017*   ;------------------------------------------------------------------------
040367             0018*   umul24:
040367 D5          0019*   	push	DE
040368 C5          0020*   	push	BC
040369 F5          0021*   	push	AF
04036A E5          0022*   	push	HL
04036B C1          0023*   	pop		BC
04036C 3E 18       0024*       ld	 	a, 24 ; No. of bits to process
04036E 21 00 00 00 0025*       ld	 	hl, 0 ; Result
040372             0026*   umul24_lp:
040372 29          0027*   	add	hl,hl
040373 EB          0028*   	ex	de,hl
040374 29          0029*   	add	hl,hl
040375 EB          0030*   	ex	de,hl
040376 30 01       0031*   	jr	nc,umul24_nc
040378 09          0032*   	add	hl,bc
040379             0033*   umul24_nc:
040379 3D          0034*   	dec	a
04037A 20 F6       0035*   	jr	nz,umul24_lp
04037C F1          0036*   	pop	af
04037D C1          0037*   	pop	bc
04037E D1          0038*   	pop	de
04037F C9          0039*   	ret
040380             0040*   
040380             0041*   
040380             0042*   ;------------------------------------------------------------------------
040380             0043*   ; udiv24
040380             0044*   ; Unsigned 24-bit division
040380             0045*   ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
040380             0046*   ;
040380             0047*   ; Uses AF BC DE HL
040380             0048*   ; Uses Restoring Division algorithm
040380             0049*   ;------------------------------------------------------------------------
040380             0050*   
040380             0051*   udiv24:
040380 E5          0052*   	push	hl
040381 C1          0053*   	pop		bc	;move dividend to BCU
040382 21 00 00 00 0054*   	ld		hl,0	;result
040386 A7          0055*   	and		a
040387 ED 52       0056*   	sbc		hl,de	;test for div by 0
040389 C8          0057*   	ret		z		;it's zero, carry flag is clear
04038A 19          0058*   	add		hl,de	;HL is 0 again
04038B 3E 18       0059*   	ld		a,24	;number of loops through.
04038D             0060*   udiv1:
04038D C5          0061*   	push	bc	;complicated way of doing this because of lack of access to top bits
04038E E3          0062*   	ex		(sp),hl
04038F 37          0063*   	scf
040390 ED 6A       0064*   	adc	hl,hl
040392 E3          0065*   	ex	(sp),hl
040393 C1          0066*   	pop	bc		;we now have bc = (bc * 2) + 1
040394             0067*   
040394 ED 6A       0068*   	adc	hl,hl
040396 A7          0069*   	and	a		;is this the bug
040397 ED 52       0070*   	sbc	hl,de
040399 30 02       0071*   	jr	nc,udiv2
04039B 19          0072*   	add	hl,de
04039C             0073*   ;	dec	c
04039C 0B          0074*   	dec	bc
04039D             0075*   udiv2:
04039D 3D          0076*   	dec	a
04039E 20 ED       0077*   	jr	nz,udiv1
0403A0 37          0078*   	scf		;flag used for div0 error
0403A1 C5          0079*   	push	bc
0403A2 D1          0080*   	pop		de	;remainder
0403A3 C9          0081*   	ret
0403A4             0082*   
0403A4             0083*   
0403A4             0084*   
0403A4             0085*   ;------------------------------------------------------------------------
0403A4             0086*   ; neg24
0403A4             0087*   ; Returns: HLU = 0-HLU
0403A4             0088*   ; preserves all other registers
0403A4             0089*   ;------------------------------------------------------------------------
0403A4             0090*   neg24:
0403A4 D5          0091*   	push	de
0403A5 EB          0092*   	ex		de,hl
0403A6 21 00 00 00 0093*   	ld		hl,0
0403AA B7          0094*   	or		a
0403AB ED 52       0095*   	sbc		hl,de
0403AD D1          0096*   	pop		de
0403AE C9          0097*   	ret
0403AF             0098*   
0403AF             0099*   ;------------------------------------------------------------------------
0403AF             0100*   ; or_hlu_deu: 24 bit bitwise OR
0403AF             0101*   ; Returns: hlu = hlu OR deu
0403AF             0102*   ; preserves all other registers
0403AF             0103*   ;------------------------------------------------------------------------
0403AF             0104*   or_hlu_deu:
0403AF 22 38 04 04 0105*   	ld	(bitbuf1),hl
0403B3 ED 53 3B 04 0106*   	ld	(bitbuf2),de
       04          
0403B8 D5          0107*   	push	de	;preserve DEU
0403B9 C5          0108*   	push	bc	;preserve BCU
0403BA 06 03       0109*   	ld		b,3
0403BC 21 38 04 04 0110*   	ld	hl,bitbuf1
0403C0 11 38 04 04 0111*   	ld	de,bitbuf1
0403C4             0112*   orloop_24:
0403C4 1A          0113*   	ld	a,(de)
0403C5 B6          0114*   	or	(hl)
0403C6 12          0115*   	ld	(de),a
0403C7 13          0116*   	inc	de
0403C8 23          0117*   	inc	hl
0403C9 10 F9       0118*   	djnz	orloop_24
0403CB 2A 3B 04 04 0119*   	ld	hl,(bitbuf2)
0403CF C1          0120*   	pop		bc	;restore BC
0403D0 D1          0121*   	pop		de	;restore DE
0403D1             0122*   
0403D1             0123*   ;------------------------------------------------------------------------
0403D1             0124*   ; and_hlu_deu: 24 bit bitwise AND
0403D1             0125*   ; Returns: hlu = hlu AND deu
0403D1             0126*   ; preserves all other registers
0403D1             0127*   ;------------------------------------------------------------------------
0403D1             0128*   and_hlu_deu:
0403D1 22 38 04 04 0129*   	ld	(bitbuf1),hl
0403D5 ED 53 3B 04 0130*   	ld	(bitbuf2),de
       04          
0403DA D5          0131*   	push	de	;preserve DEU
0403DB C5          0132*   	push	bc	;preserve BCU
0403DC 06 03       0133*   	ld		b,3
0403DE 21 38 04 04 0134*   	ld	hl,bitbuf1
0403E2 11 38 04 04 0135*   	ld	de,bitbuf1
0403E6             0136*   andloop_24:
0403E6 1A          0137*   	ld	a,(de)
0403E7 A6          0138*   	and	(hl)
0403E8 12          0139*   	ld	(de),a
0403E9 13          0140*   	inc	de
0403EA 23          0141*   	inc	hl
0403EB 10 F9       0142*   	djnz	andloop_24
0403ED 2A 3B 04 04 0143*   	ld	hl,(bitbuf2)
0403F1 C1          0144*   	pop		bc	;restore BC
0403F2 D1          0145*   	pop		de	;restore DE
0403F3             0146*   
0403F3             0147*   ;------------------------------------------------------------------------
0403F3             0148*   ; xor_hlu_deu: 24 bit bitwise XOR
0403F3             0149*   ; Returns: hlu = hlu XOR deu
0403F3             0150*   ; preserves all other registers
0403F3             0151*   ;------------------------------------------------------------------------
0403F3             0152*   xor_hlu_deu:
0403F3 22 38 04 04 0153*   	ld	(bitbuf1),hl
0403F7 ED 53 3B 04 0154*   	ld	(bitbuf2),de
       04          
0403FC D5          0155*   	push	de	;preserve DEU
0403FD C5          0156*   	push	bc	;preserve BCU
0403FE 06 03       0157*   	ld		b,3
040400 21 38 04 04 0158*   	ld	hl,bitbuf1
040404 11 38 04 04 0159*   	ld	de,bitbuf1
040408             0160*   xorloop_24:
040408 1A          0161*   	ld	a,(de)
040409 AE          0162*   	xor	(hl)
04040A 12          0163*   	ld	(de),a
04040B 13          0164*   	inc	de
04040C 23          0165*   	inc	hl
04040D 10 F9       0166*   	djnz	xorloop_24
04040F 2A 3B 04 04 0167*   	ld	hl,(bitbuf2)
040413 C1          0168*   	pop		bc	;restore BC
040414 D1          0169*   	pop		de	;restore DE
040415             0170*   
040415             0171*   ;------------------------------------------------------------------------
040415             0172*   ; shl_hlu: 24 bit shift left hlu by a positions
040415             0173*   ; Returns: hlu = hlu << a
040415             0174*   ;		   a = 0
040415             0175*   ; NOTE: only considers a up to 16 bits.
040415             0176*   ; preserves all other registers
040415             0177*   ; modified by Brandon R. Gates to use a instead of de
040415             0178*   ;------------------------------------------------------------------------
040415             0179*   shl_hlu:
040415 B7          0180*   	or a
040416 C8          0181*   	ret		z		;we're done
040417 29          0182*   	add		hl,hl	;shift HLU left
040418 3D          0183*   	dec a
040419 18 FA       0184*   	jr		shl_hlu
04041B             0185*   
04041B             0186*   ;------------------------------------------------------------------------
04041B             0187*   ; shr_hlu: 24 bit shift right hlu by a positions
04041B             0188*   ; Returns: hlu = hlu >> a
04041B             0189*   ;		   a = 0
04041B             0190*   ; NOTE: only considers a up to 16 bits.
04041B             0191*   ; preserves all other registers
04041B             0192*   ; modified by Brandon R. Gates to use a instead of de
04041B             0193*   ;------------------------------------------------------------------------
04041B             0194*   shr_hlu:
04041B 22 38 04 04 0195*   	ld		(bitbuf1),hl
04041F 21 3A 04 04 0196*   	ld		hl,bitbuf1+2
040423             0197*   @shr_loop:
040423 B7          0198*   	or a
040424 28 0D       0199*   	jr		z,@shr_done		;we're done
040426             0200*   ;carry is clear from or instruction
040426 CB 1E       0201*   	rr		(hl)
040428 2B          0202*   	dec		hl
040429 CB 1E       0203*   	rr		(hl)
04042B 2B          0204*   	dec		hl
04042C CB 1E       0205*   	rr		(hl)
04042E 23          0206*   	inc		hl
04042F 23          0207*   	inc		hl
040430 3D          0208*   	dec a
040431 18 F0       0209*   	jr		@shr_loop
040433             0210*   @shr_done:
040433 2A 38 04 04 0211*   	ld		hl,(bitbuf1)	;collect result
040437 C9          0212*   	ret
040438             0213*   
040438             0214*   ;------------------------------------------------------------------------
040438             0215*   ; Scratch area for calculations
040438             0216*   ;------------------------------------------------------------------------
040438 00 00 00    0217*   bitbuf1:	dw24	0	;bit manipulation buffer 1
04043B 00 00 00    0218*   bitbuf2:	dw24	0	;bit manipulation buffer 2
04043E             0219*   
04043E             0220*   ; -----------------------------------------------------------------------
04043E             0221*   ; Functions added by Brandon R. Gates
04043E             0222*   ; -----------------------------------------------------------------------
04043E             0223*   
04043E             0224*   ;------------------------------------------------------------------------
04043E             0225*   ; shr_hlu_div: Quick division by powers of two based on log2 of A
04043E             0226*   ;              Determines the LSB of A and shifts HLU accordingly.
04043E             0227*   ;              HLU = HLU >> LSB(A)
04043E             0228*   ; Returns: HLU = HLU >> LSB(A)
04043E             0229*   ; Destroys: af
04043E             0230*   ;------------------------------------------------------------------------
04043E             0231*   shr_hlu_log2a:
04043E B7          0232*   	or a    ; check for zero
04043F C8          0233*   	ret z   ; nothing to shift so we're done
040440 C5          0234*   	push 	bc ; preserve
040441 06 00       0235*   	ld		b,0 ; clear b
040443             0236*   @find_bit:
040443 0F          0237*   	rrca ; bit 0 to carry
040444 DA 4D 04 04 0238*   	jp c,@found_bit
040448 04          0239*   	inc b ; next bit
040449 C3 43 04 04 0240*   	jp @find_bit
04044D             0241*   @found_bit:
04044D 78          0242*   	ld a,b
04044E CD 1B 04 04 0243*   	call shr_hlu
040452 C1          0244*   	pop 	bc ; restore
040453 C9          0245*   	ret
040454             0246*   ; end shr_hlu_log2a
040454             0247*   
040454             0248*   ;------------------------------------------------------------------------
040454             0249*   ; shl_hlu_log2a: Quick multiplication by powers of two based on log2 of A
040454             0250*   ;                Determines the LSB of A and shifts HLU accordingly.
040454             0251*   ;                HLU = HLU << LSB(A)
040454             0252*   ; Returns: HLU = HLU << LSB(A)
040454             0253*   ; Destroys: af
040454             0254*   ;------------------------------------------------------------------------
040454             0255*   shl_hlu_log2a:
040454 B7          0256*   	or a    ; check for zero
040455 C8          0257*   	ret z   ; nothing to shift so we're done
040456 C5          0258*   	push 	bc ; preserve
040457 06 00       0259*   	ld		b,0 ; clear b
040459             0260*   @find_bit:
040459 0F          0261*   	rrca ; bit 0 to carry
04045A DA 63 04 04 0262*   	jp c,@found_bit
04045E 04          0263*   	inc b ; next bit
04045F C3 59 04 04 0264*   	jp @find_bit
040463             0265*   @found_bit:
040463 78          0266*   	ld a,b
040464 CD 15 04 04 0267*   	call shl_hlu
040468 C1          0268*   	pop 	bc ; restore
040469 C9          0269*   	ret
04046A             0270*   ; end shl_hlu_log2a
04046A             0034        include "maths.inc"
04046A             0001*   ;------------------------------------------------------------------------
04046A             0002*   ; Scratch area for calculations
04046A             0003*   ;------------------------------------------------------------------------
04046A 00 00 00    0004*   scratch1: dw24 0 ;bit manipulation buffer 1
04046D 00 00 00    0005*   scratch2: dw24 0 ;bit manipulation buffer 2
040470             0006*   
040470             0007*   ; absolute value of hlu
040470             0008*   ; returns: abs(hlu), flags set according to the incoming sign of hlu:
040470             0009*   ;         s1,z0,pv0,n1,c0 if hlu was negative
040470             0010*   ;         s0,z1,pv0,n1,c0 if hlu was zero
040470             0011*   ;         s0,z0,pv0,n1,c0 if hlu was positive
040470             0012*   ; destroys: a
040470             0013*   hlu_abs:
040470 19          0014*       add hl,de
040471 B7          0015*       or a
040472 ED 52       0016*       sbc hl,de
040474 FA 79 04 04 0017*       jp m,@is_neg
040478 C9          0018*       ret ; hlu is positive or zero so we're done
040479             0019*   @is_neg:
040479 F5          0020*       push af ; otherwise, save current flags for return
04047A CD 80 04 04 0021*       call neg_hlu ; negate hlu
04047E F1          0022*       pop af ; get back flags
04047F C9          0023*       ret
040480             0024*   
040480             0025*   ; flip the sign of hlu
040480             0026*   ; inputs: hlu
040480             0027*   ; returns: 0-hlu, flags set appropriately for the result:
040480             0028*   ;         s1,z0,pv0,n1,c1 if result is negative
040480             0029*   ;         s0,z1,pv0,n1,c0 if result is zero
040480             0030*   ;         s0,z0,pv0,n1,c1 if result is positive
040480             0031*   ; destroys a
040480             0032*   neg_hlu:
040480 D5          0033*       push de ; save de
040481 EB          0034*       ex de,hl ; put hl into de
040482 21 00 00 00 0035*       ld hl,0 ; clear hl
040486 AF          0036*       xor a ; clear carry
040487 ED 52       0037*       sbc hl,de ; 0-hlu = -hlu
040489 D1          0038*       pop de ; get de back
04048A C9          0039*       ret ; easy peasy
04048B             0040*   
04048B             0041*   ;------------------------------------------------------------------------
04048B             0042*   ; divide hlu by 2, inspired by above
04048B             0043*   ;------------------------------------------------------------------------
04048B             0044*   hlu_div2:
04048B 22 6A 04 04 0045*       ld (scratch1),hl
04048F 21 6C 04 04 0046*       ld hl,scratch1+2
040493 CB 1E       0047*       rr (hl)
040495 2B          0048*       dec hl
040496 CB 1E       0049*       rr (hl)
040498 2B          0050*       dec hl
040499 CB 1E       0051*       rr (hl)
04049B 23          0052*       inc hl
04049C 23          0053*       inc hl
04049D 2A 6A 04 04 0054*       ld hl,(scratch1)
0404A1 C9          0055*       ret
0404A2             0056*   
0404A2             0057*   ; this is my little hack to divide by 16
0404A2             0058*   hlu_div16:
0404A2 AF          0059*       xor a
0404A3 29          0060*       add hl,hl
0404A4 17          0061*       rla
0404A5 29          0062*       add hl,hl
0404A6 17          0063*       rla
0404A7 29          0064*       add hl,hl
0404A8 17          0065*       rla
0404A9 29          0066*       add hl,hl
0404AA 17          0067*       rla
0404AB 22 B8 04 04 0068*       ld (@scratch),hl
0404AF 32 BB 04 04 0069*       ld (@scratch+3),a
0404B3 2A B9 04 04 0070*       ld hl,(@scratch+1)
0404B7 C9          0071*       ret
0404B8             0072*   @scratch: ds 4
0404BC             0073*   
0404BC             0074*   ; hlu signed division by 256
0404BC             0075*   ; returns: hlu / 256
0404BC             0076*   ; destroys: af
0404BC             0077*   hlu_sdiv256:
       FF FF FF FF 
0404BC AF          0078*       xor a ; assume hl is positive
0404BD 22 D3 04 04 0079*       ld (@buffer),hl
0404C1             0080*       SIGN_HLU
0404C1 19          0001*M1     add hl,de ; 1 cycle
0404C2 B7          0002*M1     or a ; clear flags ; 1 cycle
0404C3 ED 52       0003*M1     sbc hl,de ; 2 cycles
0404C5             0004*M1     ; 4 cycles total
0404C5 F2 CA 04 04 0081*       jp p,@hl_pos
0404C9 3D          0082*       dec a
0404CA             0083*   @hl_pos:
0404CA 32 D6 04 04 0084*       ld (@buffer+3),a
0404CE 2A D4 04 04 0085*       ld hl,(@buffer+1)
0404D2 C9          0086*       ret
0404D3             0087*   @buffer: ds 4
0404D7             0088*   
0404D7             0089*   ; hlu 1 byte right shift, unsigned
0404D7             0090*   ; returns: hlu / 256, fractional portion in a
0404D7             0091*   ; destroys: af
0404D7             0092*   hlu_udiv256:
       FF FF FF FF 
0404D7 AF          0093*       xor a
0404D8 32 E9 04 04 0094*       ld (@buffer+3),a
0404DC 7D          0095*       ld a,l ; save the fractional portion
0404DD 22 E6 04 04 0096*       ld (@buffer),hl
0404E1 2A E7 04 04 0097*       ld hl,(@buffer+1)
0404E5 C9          0098*       ret
0404E6             0099*   @buffer: ds 4
0404EA             0100*   
       FF FF FF FF 
0404EA 00 00 00 00 0101*   add_bcd_arg1: db #00,#00,#00,#00
0404EE 00 00 00 00 0102*   add_bcd_arg2: db #00,#00,#00,#00
0404F2             0103*   
0404F2             0104*   ; set bcd values in a scratch memory address from registers bcde
0404F2             0105*   ; input: hl; scratch address,bcde; 8-place bcd number
0404F2             0106*   ; destroys ; hl
0404F2             0107*   set_bcd:
0404F2 73          0108*       ld (hl),e
0404F3 23          0109*       inc hl
0404F4 72          0110*       ld (hl),d
0404F5 23          0111*       inc hl
0404F6 71          0112*       ld (hl),c
0404F7 23          0113*       inc hl
0404F8 70          0114*       ld (hl),b
0404F9 C9          0115*       ret
0404FA             0116*   
0404FA             0117*   ; load bcd values from a scratch memory address to bcde
0404FA             0118*   ; input: hl; scratch address
0404FA             0119*   ; output: bcde; 8-place bcd number
0404FA             0120*   ; destroys: hl
0404FA             0121*   get_bcd:
0404FA 5E          0122*       ld e,(hl)
0404FB 23          0123*       inc hl
0404FC 56          0124*       ld d,(hl)
0404FD 23          0125*       inc hl
0404FE 4E          0126*       ld c,(hl)
0404FF 23          0127*       inc hl
040500 46          0128*       ld b,(hl)
040501 C9          0129*       ret
040502             0130*   
040502             0131*   ; BCD addition
040502             0132*   ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
040502             0133*   ;       a is the number of bytes holding each number (number of places/2)
040502             0134*   ; outputs: (hl) + (de) --> (hl)
040502             0135*   ; destroys: a,b,de,hl
040502             0136*   add_bcd:
040502 47          0137*       ld b,a ; loop counter
040503 AF          0138*       xor a ; reset a, clear carry flag
040504             0139*   adcec:
040504 1A          0140*       ld a,(de) ; addend to acc
040505 8E          0141*       adc a,(hl) ; add (hl) to acc
040506 27          0142*       daa ; adjust result to bcd
040507 77          0143*       ld (hl),a ; store result
040508 23          0144*       inc hl ; advance memory pointers
040509 13          0145*       inc de
04050A 10 F8       0146*       djnz adcec ; loop until b == 0
04050C C9          0147*       ret
04050D             0148*   
04050D             0149*   ; BCD subtraction
04050D             0150*   ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
04050D             0151*   ;       a is the number of bytes holding each number (number of places/2)
04050D             0152*   ; outputs: (hl) - (de) --> (hl)
04050D             0153*   ; destroys: a,b,de,hl
04050D             0154*   sub_bcd:
04050D 47          0155*       ld b,a ; loop counter
04050E AF          0156*       xor a ; reset a,clear carry flag
04050F             0157*   subdec:
04050F 1A          0158*       ld a,(de) ; subtrahend to acc
040510 9E          0159*       sbc a,(hl) ; subtract (hl) from acc
040511 27          0160*       daa ; adjust result to bcd
040512 77          0161*       ld (hl),a ; store result
040513 23          0162*       inc hl ; advance memory pointers
040514 13          0163*       inc de
040515 10 F8       0164*       djnz subdec ; loop until b == 0
040517 C9          0165*       ret
040518             0166*   
040518             0167*   ; http://www.z80.info/pseudo-random.txt
040518             0168*   rand_8:
040518 C5          0169*       push bc
040519 3A 2C 05 04 0170*       ld a,(r_seed)
04051D 4F          0171*       ld c,a
04051E             0172*   
04051E 0F          0173*       rrca ; multiply by 32
04051F 0F          0174*       rrca
040520 0F          0175*       rrca
040521 EE 1F       0176*       xor 0x1f
040523             0177*   
040523 81          0178*       add a,c
040524 DE FF       0179*       sbc a,255 ; carry
040526             0180*   
040526 32 2C 05 04 0181*       ld (r_seed),a
04052A C1          0182*       pop bc
04052B C9          0183*       ret
04052C 50          0184*   r_seed: defb $50
04052D             0185*   
04052D             0186*   ; https://www.omnimaga.org/asm-language/ez80-optimized-routines/msg399325/#msg399325
04052D             0187*   prng24:
04052D             0188*   ;;Expects ADL mode.
04052D             0189*   ;;Output: HL
04052D             0190*   ;;50cc
04052D             0191*   ;;33 bytes
04052D             0192*   ;;cycle length: 281,474,959,933,440 (about 2.8 trillion)
04052D ED 5B 4E 05 0193*       ld de,(seed1)
       04          
040532 B7          0194*       or a
040533 ED 62       0195*       sbc hl,hl
040535 19          0196*       add hl,de
040536 29          0197*       add hl,hl
040537 29          0198*       add hl,hl
040538 2C          0199*       inc l
040539 19          0200*       add hl,de
04053A 22 4E 05 04 0201*       ld (seed1),hl
04053E 2A 51 05 04 0202*       ld hl,(seed2)
040542 29          0203*       add hl,hl
040543 9F          0204*       sbc a,a
040544 E6 1B       0205*       and %00011011
040546 AD          0206*       xor l
040547 6F          0207*       ld l,a
040548 22 51 05 04 0208*       ld (seed2),hl
04054C 19          0209*       add hl,de
04054D C9          0210*       ret
04054E 00 00 00    0211*   seed1: dl 0
040551 00 00 00    0212*   seed2: dl 0
040554             0035        include "files.inc"
040554             0001*   ; load to onboard 8k sram
040554             0002*   filedata: equ 0xB7E000
040554             0036        include "fonts.inc"
040554             0001*   fonts_load:
040554 DD 21 85 05 0002*       ld ix,font_list ; pointer to font list lookup
       04          
040559 06 0D       0003*       ld b,num_fonts ; loop counter
04055B             0004*   
04055B             0005*   @load_loop:
04055B C5          0006*       push bc ; save loop counter
04055C             0007*   
04055C             0008*   ; load font into a buffer
04055C DD 27 06    0009*       ld hl,(ix+font_list_bufferId)
04055F DD 31 09    0010*       ld iy,(ix+font_list_filename)
040562 CD 4E 16 04 0011*       call vdu_load_buffer_from_file
040566             0012*   
040566             0013*   ; create font from buffer
040566 DD 27 06    0014*       ld hl,(ix+font_list_bufferId)
040569 DD 5E 00    0015*       ld e,(ix+font_list_width)
04056C DD 56 03    0016*       ld d,(ix+font_list_height)
04056F 3E 00       0017*       ld a,0 ; flags
040571 CD A1 18 04 0018*       call vdu_font_create
040575             0019*   
040575             0020*   ; select font
040575 DD 27 06    0021*       ld hl,(ix+font_list_bufferId)
040578 3E 01       0022*       ld a,1 ; flags
04057A CD 87 18 04 0023*       call vdu_font_select
04057E             0024*   
04057E             0025*   ; ; debug print filename
04057E             0026*   ;     call printNewLine
04057E             0027*   ;     ld hl,(ix+font_list_filename)
04057E             0028*   ;     call printString
04057E             0029*   
04057E             0030*   ; advance font_list pointer to next record
04057E ED 32 0C    0031*       lea ix,ix+font_list_record_size
040581             0032*   
040581             0033*   ; restore loop counter
040581 C1          0034*       pop bc
040582 10 D7       0035*       djnz @load_loop
040584             0036*   
040584             0037*   ; all done
040584 C9          0038*       ret
040585             0037        include "fonts_list.inc"
040585             0001*   ; Generated by asm_config_editor.py
040585             0002*   font_list_record_size: equ 12
040585             0003*   font_list_width: equ 0
040585             0004*   font_list_height: equ 3
040585             0005*   font_list_bufferId: equ 6
040585             0006*   font_list_filename: equ 9
040585             0007*   
040585             0008*   num_fonts: equ 13
040585             0009*   
040585             0010*   ; Index list:
040585             0011*   amiga_forever_8x8: equ 64000
040585             0012*   computer_pixel_7_8x12: equ 64001
040585             0013*   computer_pixel_7_8x16: equ 64002
040585             0014*   dopecre_8x8: equ 64003
040585             0015*   gamer_2_8x8: equ 64004
040585             0016*   Lat15_VGA8_8x8: equ 64005
040585             0017*   Lat2_VGA8_8x8: equ 64006
040585             0018*   Lat38_VGA8_8x8: equ 64007
040585             0019*   Lat7_VGA8_8x8: equ 64008
040585             0020*   planetary_contact_8x8: equ 64009
040585             0021*   Squarewave_Bold_8x12: equ 64010
040585             0022*   super_mario_bros_2_8x8: equ 64011
040585             0023*   wendy_neue_6x6: equ 64012
040585             0024*   
040585             0025*   font_list: ; width; height; bufferId; filename;:
040585 08 00 00 08 0026*   	dl 8, 8, 64000, fn_amiga_forever_8x8
       00 00 00 FA 
       00 21 06 04 
040591 08 00 00 0C 0027*   	dl 8, 12, 64001, fn_computer_pixel_7_8x12
       00 00 01 FA 
       00 3E 06 04 
04059D 08 00 00 10 0028*   	dl 8, 16, 64002, fn_computer_pixel_7_8x16
       00 00 02 FA 
       00 5F 06 04 
0405A9 08 00 00 08 0029*   	dl 8, 8, 64003, fn_dopecre_8x8
       00 00 03 FA 
       00 80 06 04 
0405B5 08 00 00 08 0030*   	dl 8, 8, 64004, fn_gamer_2_8x8
       00 00 04 FA 
       00 97 06 04 
0405C1 08 00 00 08 0031*   	dl 8, 8, 64005, fn_Lat15_VGA8_8x8
       00 00 05 FA 
       00 AE 06 04 
0405CD 08 00 00 08 0032*   	dl 8, 8, 64006, fn_Lat2_VGA8_8x8
       00 00 06 FA 
       00 C8 06 04 
0405D9 08 00 00 08 0033*   	dl 8, 8, 64007, fn_Lat38_VGA8_8x8
       00 00 07 FA 
       00 E1 06 04 
0405E5 08 00 00 08 0034*   	dl 8, 8, 64008, fn_Lat7_VGA8_8x8
       00 00 08 FA 
       00 FB 06 04 
0405F1 08 00 00 08 0035*   	dl 8, 8, 64009, fn_planetary_contact_8x8
       00 00 09 FA 
       00 14 07 04 
0405FD 08 00 00 0C 0036*   	dl 8, 12, 64010, fn_Squarewave_Bold_8x12
       00 00 0A FA 
       00 35 07 04 
040609 08 00 00 08 0037*   	dl 8, 8, 64011, fn_super_mario_bros_2_8x8
       00 00 0B FA 
       00 55 07 04 
040615 06 00 00 06 0038*   	dl 6, 6, 64012, fn_wendy_neue_6x6
       00 00 0C FA 
       00 77 07 04 
040621             0039*   
040621             0040*   ; files_list: ; filename:
040621 66 6F 6E 74 0041*   fn_amiga_forever_8x8: db "fonts/amiga_forever_8x8.font",0
       73 2F 61 6D 
       69 67 61 5F 
       66 6F 72 65 
       76 65 72 5F 
       38 78 38 2E 
       66 6F 6E 74 
       00          
04063E 66 6F 6E 74 0042*   fn_computer_pixel_7_8x12: db "fonts/computer_pixel_7_8x12.font",0
       73 2F 63 6F 
       6D 70 75 74 
       65 72 5F 70 
       69 78 65 6C 
       5F 37 5F 38 
       78 31 32 2E 
       66 6F 6E 74 
       00          
04065F 66 6F 6E 74 0043*   fn_computer_pixel_7_8x16: db "fonts/computer_pixel_7_8x16.font",0
       73 2F 63 6F 
       6D 70 75 74 
       65 72 5F 70 
       69 78 65 6C 
       5F 37 5F 38 
       78 31 36 2E 
       66 6F 6E 74 
       00          
040680 66 6F 6E 74 0044*   fn_dopecre_8x8: db "fonts/dopecre_8x8.font",0
       73 2F 64 6F 
       70 65 63 72 
       65 5F 38 78 
       38 2E 66 6F 
       6E 74 00    
040697 66 6F 6E 74 0045*   fn_gamer_2_8x8: db "fonts/gamer_2_8x8.font",0
       73 2F 67 61 
       6D 65 72 5F 
       32 5F 38 78 
       38 2E 66 6F 
       6E 74 00    
0406AE 66 6F 6E 74 0046*   fn_Lat15_VGA8_8x8: db "fonts/Lat15-VGA8_8x8.font",0
       73 2F 4C 61 
       74 31 35 2D 
       56 47 41 38 
       5F 38 78 38 
       2E 66 6F 6E 
       74 00       
0406C8 66 6F 6E 74 0047*   fn_Lat2_VGA8_8x8: db "fonts/Lat2-VGA8_8x8.font",0
       73 2F 4C 61 
       74 32 2D 56 
       47 41 38 5F 
       38 78 38 2E 
       66 6F 6E 74 
       00          
0406E1 66 6F 6E 74 0048*   fn_Lat38_VGA8_8x8: db "fonts/Lat38-VGA8_8x8.font",0
       73 2F 4C 61 
       74 33 38 2D 
       56 47 41 38 
       5F 38 78 38 
       2E 66 6F 6E 
       74 00       
0406FB 66 6F 6E 74 0049*   fn_Lat7_VGA8_8x8: db "fonts/Lat7-VGA8_8x8.font",0
       73 2F 4C 61 
       74 37 2D 56 
       47 41 38 5F 
       38 78 38 2E 
       66 6F 6E 74 
       00          
040714 66 6F 6E 74 0050*   fn_planetary_contact_8x8: db "fonts/planetary_contact_8x8.font",0
       73 2F 70 6C 
       61 6E 65 74 
       61 72 79 5F 
       63 6F 6E 74 
       61 63 74 5F 
       38 78 38 2E 
       66 6F 6E 74 
       00          
040735 66 6F 6E 74 0051*   fn_Squarewave_Bold_8x12: db "fonts/Squarewave_Bold_8x12.font",0
       73 2F 53 71 
       75 61 72 65 
       77 61 76 65 
       5F 42 6F 6C 
       64 5F 38 78 
       31 32 2E 66 
       6F 6E 74 00 
040755 66 6F 6E 74 0052*   fn_super_mario_bros_2_8x8: db "fonts/super_mario_bros_2_8x8.font",0
       73 2F 73 75 
       70 65 72 5F 
       6D 61 72 69 
       6F 5F 62 72 
       6F 73 5F 32 
       5F 38 78 38 
       2E 66 6F 6E 
       74 00       
040777 66 6F 6E 74 0053*   fn_wendy_neue_6x6: db "fonts/wendy_neue_6x6.font",0
       73 2F 77 65 
       6E 64 79 5F 
       6E 65 75 65 
       5F 36 78 36 
       2E 66 6F 6E 
       74 00       
040791             0038        include "fixed168.inc"
040791             0001*   ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
040791             0002*   ; uses EZ80 MLT instruction for speed
040791             0003*   ; operation: UHL * A --> UHL
040791             0004*   ; destroys: AF, HL
040791             0005*   smul24x8:
040791             0006*   ; make hl positive and store sign flag
040791 CD 70 04 04 0007*       call hlu_abs
040795 F5          0008*       push af
040796             0009*   ; do the division
040796 CD A1 07 04 0010*       call mul24x8 ; hl = product
04079A             0011*   ; adjust sign of result
04079A F1          0012*       pop af ; sign de
04079B F0          0013*       ret p ; hl was positive, nothing to do
04079C CD 80 04 04 0014*       call neg_hlu ; result is negative
0407A0 C9          0015*       ret
0407A1             0016*   
0407A1             0017*   ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
0407A1             0018*   ; uses EZ80 MLT instruction for speed
0407A1             0019*   ; operation: UHL * A --> AUHL
0407A1             0020*   ; destroys: AF, HL
0407A1             0021*   mul24x8:
0407A1 D5          0022*       push de ; preserve de
0407A2             0023*   ; low byte
0407A2 5D          0024*       ld e,l
0407A3 57          0025*       ld d,a
0407A4 ED 5C       0026*       mlt de
0407A6 6B          0027*       ld l,e ; product low byte
0407A7 08          0028*       ex af,af' ; save multiplier
0407A8 7A          0029*       ld a,d ; carry
0407A9 08          0030*       ex af,af' ; save carry, restore multiplier
0407AA             0031*   ; high byte
0407AA 5C          0032*       ld e,h
0407AB 57          0033*       ld d,a
0407AC ED 5C       0034*       mlt de
0407AE 08          0035*       ex af,af' ; save multiplier, restore carry
0407AF 83          0036*       add a,e ; add carry
0407B0 67          0037*       ld h,a ; product middle byte
0407B1 7A          0038*       ld a,d ; carry
0407B2 08          0039*       ex af,af' ; save carry, restore multiplier
0407B3             0040*   ; upper byte
0407B3 22 CE 07 04 0041*       ld (@scratch),hl ; 7 cycles
0407B7 5F          0042*       ld e,a
0407B8 3A D0 07 04 0043*       ld a,(@scratch+2)
0407BC 57          0044*       ld d,a
0407BD ED 5C       0045*       mlt de
0407BF 08          0046*       ex af,af' ; restore carry
0407C0 8B          0047*       adc a,e ; add carry
0407C1 32 D0 07 04 0048*       ld (@scratch+2),a ; 5 cycles
0407C5 2A CE 07 04 0049*       ld hl,(@scratch) ; 7 cycles
0407C9             0050*   ; highest byte
0407C9 3E 00       0051*       ld a,0 ; preserve carry flag
0407CB 8A          0052*       adc a,d ; product highest byte
0407CC D1          0053*       pop de ; restore de
0407CD C9          0054*       ret
0407CE             0055*   @scratch: ds 3
0407D1             0056*   
       FF FF FF 
0407D1 00 00 00 00 0057*   mul24out: blkb 6,0
       00 00       
0407D7             0058*   
0407D7             0059*   ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
0407D7             0060*   ; operation: UHL * UDE --> mul24out
0407D7             0061*   mul24:
0407D7 DD E5       0062*       push ix ; preserve
0407D9             0063*   ; point to output buffer and clear it
0407D9 DD 21 D1 07 0064*       ld ix,mul24out
       04          
0407DE C5          0065*       push bc
0407DF 01 00 00 00 0066*       ld bc,0
0407E3 DD 0F 00    0067*       ld (ix),bc
0407E6 DD 0F 03    0068*       ld (ix+3),bc
0407E9 C1          0069*       pop bc
0407EA             0070*   ; STEP 1: UHL * E
0407EA 7B          0071*       ld a,e
0407EB E5          0072*       push hl
0407EC CD A1 07 04 0073*       call mul24x8
0407F0 DD 2F 00    0074*       ld (ix+0),hl
0407F3 DD 77 03    0075*       ld (ix+3),a
0407F6             0076*   ; STEP 2: UHL * D
0407F6 E1          0077*       pop hl
0407F7 E5          0078*       push hl
0407F8 7A          0079*       ld a,d
0407F9 CD A1 07 04 0080*       call mul24x8
0407FD CD 16 08 04 0081*       call @accumulate
040801             0082*   ; STEP 3: UHL * DEU
040801 E1          0083*       pop hl
040802 ED 53 46 08 0084*       ld (@de),de
       04          
040807 3A 48 08 04 0085*       ld a,(@de+2)
04080B CD A1 07 04 0086*       call mul24x8
04080F CD 16 08 04 0087*       call @accumulate
040813             0088*   ; all done
040813 DD E1       0089*       pop ix ; restore
040815 C9          0090*       ret
040816             0091*   @accumulate:
040816 DD 23       0092*       inc ix
040818             0093*   ; highest byte of product to carry
040818 DD 77 03    0094*       ld (ix+3),a
04081B             0095*   ; low byte of product
04081B 7D          0096*       ld a,l
04081C DD 86 00    0097*       add a,(ix+0)
04081F DD 77 00    0098*       ld (ix+0),a
040822             0099*   ; high byte of product
040822 7C          0100*       ld a,h
040823 DD 8E 01    0101*       adc a,(ix+1)
040826 DD 77 01    0102*       ld (ix+1),a
040829             0103*   ; uppper byte of product
040829 22 43 08 04 0104*       ld (@hl),hl
04082D 3A 45 08 04 0105*       ld a,(@hl+2)
040831 DD 8E 02    0106*       adc a,(ix+2)
040834 DD 77 02    0107*       ld (ix+2),a
040837             0108*   ; carry
040837 3E 00       0109*       ld a,0 ; preserve flags
040839 DD 8E 03    0110*       adc a,(ix+3)
04083C DD 77 03    0111*       ld (ix+3),a
04083F C9          0112*       ret
040840             0113*   
040840 00 00 00    0114*   @ix: dl 0
040843 00 00 00    0115*   @hl: dl 0
040846 00 00 00    0116*   @de: dl 0
040849             0117*   
040849             0118*   ; ; UHL * UDE --> UHL (unsigned)
040849             0119*   ; umul24:
040849             0120*   ;     call mul24
040849             0121*   ;     ld hl,(mul24out)
040849             0122*   ;     ret
040849             0123*   
040849             0124*   ; UH.L = UH.L*UD.E (unsigned)
040849             0125*   umul168:
040849 CD D7 07 04 0126*       call mul24
04084D 2A D2 07 04 0127*       ld hl,(mul24out+1)
040851 C9          0128*       ret
040852             0129*   
040852             0130*   ; UH.L * UD.E --> UH.L (signed)
040852             0131*   smul168:
040852             0132*   ; make everything positive and store sign flags
040852 CD 70 04 04 0133*       call hlu_abs
040856 F5          0134*       push af
040857 EB          0135*       ex de,hl
040858 CD 70 04 04 0136*       call hlu_abs
04085C EB          0137*       ex de,hl
04085D F5          0138*       push af
04085E             0139*   ; do the division
04085E CD 49 08 04 0140*       call umul168 ; hl = product
040862             0141*   ; adjust sign of result
040862 F1          0142*       pop af ; sign de
040863 FA 6E 08 04 0143*       jp m,@de_neg
040867 F1          0144*       pop af ; sign hl
040868 F0          0145*       ret p ; both positive, nothing to do
040869             0146*   @hl_neg:
040869 CD 80 04 04 0147*       call neg_hlu ; de pos, hl neg, result is negative
04086D C9          0148*       ret
04086E             0149*   @de_neg:
04086E F1          0150*       pop af
04086F F8          0151*       ret m ; both negative, nothing to do
040870 CD 80 04 04 0152*       call neg_hlu ; result is negative
040874 C9          0153*       ret
040875             0154*   
040875             0155*   ; UH.L / UD.E --> UD.E rem UHL (unsigned)
040875             0156*   ; perform unsigned division of 16.8 fixed place values
040875             0157*   ; with an unsigned 16.8 fixed place result and 24-bit remainder
040875             0158*   udiv168:
040875             0159*   ; back up divisor
040875 ED 53 AC 08 0160*       ld (@ude),de
       04          
04087A             0161*   ; get the 16-bit integer part of the quotient
04087A CD 80 03 04 0162*       call udiv24 ; de = quotient, hl = remainder
04087E             0163*   ; load quotient to upper three bytes of output
04087E ED 53 B3 08 0164*       ld (div168_out+1),de
       04          
040883             0165*   @div256:
040883             0166*   ; multiply remainder by 256
040883             0167*       hlu_mul256
040883 29          0001*M1     add hl,hl ; * 2
040884 29          0002*M1     add hl,hl ; * 4
040885 29          0003*M1     add hl,hl ; * 8
040886 29          0004*M1     add hl,hl ; * 16
040887 29          0005*M1     add hl,hl ; * 32
040888 29          0006*M1     add hl,hl ; * 64
040889 29          0007*M1     add hl,hl ; * 128
04088A 29          0008*M1     add hl,hl ; * 256
04088B             0168*   ; skip fractional computation if remainder is zero
04088B             0169*       SIGN_HLU
04088B 19          0001*M1     add hl,de ; 1 cycle
04088C B7          0002*M1     or a ; clear flags ; 1 cycle
04088D ED 52       0003*M1     sbc hl,de ; 2 cycles
04088F             0004*M1     ; 4 cycles total
04088F 20 03       0170*       jr nz,@div_frac
040891 AF          0171*       xor a
040892 18 0A       0172*       jr @write_frac
040894             0173*   ; now divide the shifted remainder by the divisor
040894             0174*   @div_frac:
040894 ED 5B AC 08 0175*       ld de,(@ude) ; get back divisor
       04          
040899 CD 80 03 04 0176*       call udiv24 ; de = quotient, hl = remainder
04089D             0177*   ; load low byte of quotient to low byte of output
04089D 7B          0178*       ld a,e
04089E             0179*   @write_frac:
04089E 32 B2 08 04 0180*       ld (div168_out),a
0408A2             0181*   ; load de with return value
0408A2 ED 5B B2 08 0182*       ld de,(div168_out)
       04          
0408A7             0183*   ; load a with any overflow
0408A7 3A B5 08 04 0184*       ld a,(div168_out+3)
0408AB C9          0185*       ret ; ud.e is the 16.8 result
0408AC             0186*   @ude: ds 6
0408B2             0187*   div168_out: ds 4 ; the extra byte is for overflow
0408B6             0188*   
0408B6             0189*   ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
0408B6             0190*   ; perform signed division of 16.8 fixed place values
0408B6             0191*   ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
0408B6             0192*   sdiv168:
0408B6             0193*   ; make everything positive and store sign flags
       FF FF FF FF 
       FF FF FF FF 
       FF FF 
0408B6 CD 70 04 04 0194*       call hlu_abs
0408BA F5          0195*       push af
0408BB EB          0196*       ex de,hl
0408BC CD 70 04 04 0197*       call hlu_abs
0408C0 EB          0198*       ex de,hl
0408C1 F5          0199*       push af
0408C2             0200*   ; do the division
0408C2 CD 75 08 04 0201*       call udiv168 ; de = quotient, hl = remainder
0408C6             0202*   ; adjust sign of result
0408C6 F1          0203*       pop af ; sign de
0408C7 FA D4 08 04 0204*       jp m,@de_neg
0408CB F1          0205*       pop af ; sign hl
0408CC F0          0206*       ret p ; both positive, nothing to do
0408CD             0207*   @hl_neg:
0408CD EB          0208*       ex de,hl ; hl = quotient, de = remainder
0408CE CD 80 04 04 0209*       call neg_hlu ; de pos, hl neg, result is negative
0408D2 EB          0210*       ex de,hl ; de = negated quotient, hl = remainder
0408D3 C9          0211*       ret
0408D4             0212*   @de_neg:
0408D4 F1          0213*       pop af
0408D5 F8          0214*       ret m ; both negative, nothing to do
0408D6 EB          0215*       ex de,hl ; hl = quotient, de = remainder
0408D7 CD 80 04 04 0216*       call neg_hlu ; result is negative
0408DB EB          0217*       ex de,hl ; de = negated quotient, hl = remainder
0408DC C9          0218*       ret
0408DD             0219*   
0408DD             0220*   ; convert signed angles from a 360 to 256 degree circle
0408DD             0221*   ; inputs: uh.l is the angle360 in 16.8 fixed format
0408DD             0222*   ; outputs: uh.l is the angle256 in 16.8 fixed format
0408DD             0223*   ; destroys: TODO
0408DD             0224*   deg_360_to_256:
0408DD D5          0225*       push de ; preserve de
0408DE             0226*   ; make angle positive and store sign flag
0408DE CD 70 04 04 0227*       call hlu_abs
0408E2 F5          0228*       push af
0408E3             0229*   ; multiply by coversion factor of 256/360
0408E3 11 B6 00 00 0230*       ld de,0x0000B6 ; 0.711
0408E7 CD 49 08 04 0231*       call umul168 ; uh.l = uh.l * 0.711
0408EB             0232*   ; restore sign flag and adjust output accordingly
0408EB F1          0233*       pop af
0408EC F2 F4 08 04 0234*       jp p,@pos ; positive number
0408F0 CD 80 04 04 0235*       call neg_hlu
0408F4             0236*   @pos:
0408F4             0237*   ; restore de and return uh.l as the result
0408F4 D1          0238*       pop de
0408F5 C9          0239*       ret
0408F6             0240*   
0408F6             0241*   ; convert signed angles from a 256 to 360 degree circle
0408F6             0242*   ; inputs: uh.l is the angle256 in 16.8 fixed format
0408F6             0243*   ; outputs: uh.l is the angle360 in 16.8 fixed format
0408F6             0244*   ; destroys: TODO
0408F6             0245*   deg_256_to_360:
0408F6 D5          0246*       push de ; preserve de
0408F7             0247*   ; make angle positive and store sign flag
0408F7 CD 70 04 04 0248*       call hlu_abs
0408FB F5          0249*       push af
0408FC             0250*   ; multiply by coversion factor of 360/256
0408FC 11 68 01 00 0251*       ld de,0x000168 ; 1.406
040900 CD 49 08 04 0252*       call umul168 ; uh.l = uh.l * 1.406
040904             0253*   ; restore sign flag and adjust output accordingly
040904 F1          0254*       pop af
040905 F2 0D 09 04 0255*       jp p,@pos ; positive number
040909 CD 80 04 04 0256*       call neg_hlu
04090D             0257*   @pos:
04090D             0258*   ; restore de and return uh.l as the result
04090D D1          0259*       pop de
04090E C9          0260*       ret
04090F             0261*   
04090F             0262*   ; fixed 16.8 routine
04090F             0263*   ; cos(uh.l) --> uh.l
04090F             0264*   ; destroys: f, hl
04090F             0265*   cos168:
04090F D5          0266*       push de ; preserve de
040910             0267*   ; for cos we simply increment the angle by 90 degrees
040910             0268*   ; or 0x004000 in 16.8 degrees256
040910             0269*   ; which makes it a sin problem
040910 11 00 40 00 0270*       ld de,0x004000
040914 19          0271*       add hl,de ; modulo 256 happens below
040915 D1          0272*       pop de ; restore de
040916             0273*   ; fall through to sin168
040916             0274*   
040916             0275*   ; ---------------------
040916             0276*   ; fixed 16.8 routine
040916             0277*   ; sin(uh.l) --> uh.l
040916             0278*   ; destroys: f, hl
040916             0279*   sin168:
040916 D5          0280*       push de
040917             0281*   ; handle negative angles appropriately
040917 CD 70 04 04 0282*       call hlu_abs
04091B F2 24 09 04 0283*       jp p,@F
04091F 11 00 00 FF 0284*       ld de,-256*256
040923 19          0285*       add hl,de
040924             0286*   @@:
040924 2E 03       0287*       ld l,3 ; multiply by 3 to get our lookup index
040926 ED 6C       0288*       mlt hl
040928 11 DC 0B 04 0289*       ld de,sin_lut_168 ; grab the lut address
04092C 19          0290*       add hl,de ; bump hl by the index
04092D ED 27       0291*       ld hl,(hl) ; don't try this on a z80!
04092F D1          0292*       pop de
040930 C9          0293*       ret
040931             0294*   
040931             0295*   ; 16.8 fixed inputs / outputs
040931             0296*   ; takes: uh.l as angle in degrees 256
040931             0297*   ;        ud.e as radius
040931             0298*   ; returns ub.c as dx, ud.e as dy, uh.l as radius
040931             0299*   ;        displacements from origin (0,0)
040931             0300*   ; destroys: everything except indexes
040931             0301*   polar_to_cartesian:
040931             0302*   ; back up input parameters
040931 22 60 09 04 0303*       ld (@angle), hl
040935 ED 53 63 09 0304*       ld (@radius), de
       04          
04093A             0305*   ; compute dx = sin(uh.l) * ud.e
04093A CD 16 09 04 0306*       call sin168 ; uh.l = sin(uh.l)
04093E ED 5B 63 09 0307*       ld de,(@radius)
       04          
040943 CD 52 08 04 0308*       call smul168 ; uh.l = dx
040947 E5          0309*       push hl
040948             0310*   ; compute dy = -cos(uh.l) * ud.e
040948 2A 60 09 04 0311*       ld hl,(@angle)
04094C CD 0F 09 04 0312*       call cos168 ; uh.l = cos(uh.l)
040950 ED 5B 63 09 0313*       ld de,(@radius)
       04          
040955 CD 52 08 04 0314*       call smul168 ; uh.l = dy
040959 CD 80 04 04 0315*       call neg_hlu ; invert dy for screen coords convention
04095D EB          0316*       ex de,hl ; de = dy for output
04095E C1          0317*       pop bc ; bc = dx for output
04095F             0318*   ; and out
04095F C9          0319*       ret
040960             0320*   @angle: ds 3
040963             0321*   @radius: ds 3
040966             0322*   
040966             0323*   ; 16.8 fixed inputs / outputs
040966             0324*   ; inputs: ub.c as dx, ud.e as dy
040966             0325*   ;        displacements from origin (0,0)
040966             0326*   ; returns: uh.l as angle in degrees 256
040966             0327*   ;        ud.e as radius
040966             0328*   ; destroys: everything except indexes
040966             0329*   cartesian_to_polar:
       FF FF FF FF 
       FF FF 
040966 ED 43 BF 09 0330*       ld (dx168),bc ; dx argument for distance168
       04          
04096B ED 53 C5 09 0331*       ld (dy168),de ; dy argument for distance168
       04          
040970             0332*   ; compute radius
040970 CD CB 09 04 0333*       call distance168 ; uh.l = radius
040974 E5          0334*       push hl ; save radius
040975             0335*   ; compute angle
040975 ED 4B BF 09 0336*       ld bc,(dx168) ; dx argument for atan2_168fast
       04          
04097A ED 5B C5 09 0337*       ld de,(dy168) ; dy argument for atan2_168fast
       04          
04097F CD 2B 0A 04 0338*       call atan2_168fast ; uh.l = angle
040983             0339*   ; return result
040983 D1          0340*       pop de ; de = radius (was hl)
040984 C9          0341*       ret
040985             0342*   ; end cartesian_to_polar
040985             0343*   
040985             0344*   ; 16.8 fixed inputs / outputs
040985             0345*   ; inputs: ub.c as dx, ud.e as dy
040985             0346*   ;        displacements from origin (0,0)
040985             0347*   ; returns: uh.l as angle in degrees 256
040985             0348*   ;        ud.e as radius
040985             0349*   ; destroys: everything except indexes
040985             0350*   ; note: uses distance168sm which is more accurate for small deltas
040985             0351*   cartesian_to_polar_sm:
040985 ED 43 BF 09 0352*       ld (dx168),bc ; dx argument for distance168
       04          
04098A ED 53 C5 09 0353*       ld (dy168),de ; dy argument for distance168
       04          
04098F             0354*   ; compute radius
04098F CD 06 0A 04 0355*       call distance168sm ; uh.l = radius
040993 E5          0356*       push hl ; save radius
040994             0357*   ; compute angle
040994 ED 4B BF 09 0358*       ld bc,(dx168) ; dx argument for atan2_168fast
       04          
040999 ED 5B C5 09 0359*       ld de,(dy168) ; dy argument for atan2_168fast
       04          
04099E CD 2B 0A 04 0360*       call atan2_168fast ; uh.l = angle
0409A2             0361*   ; return result
0409A2 D1          0362*       pop de ; de = radius (was hl)
0409A3 C9          0363*       ret
0409A4             0364*   ; end cartesian_to_polar
0409A4             0365*   
0409A4             0366*   ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0409A4             0367*   ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0409A4             0368*   ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
0409A4             0369*   ;         also populates scratch locations dx168 and dy168
0409A4             0370*   ; destroys: a,hl,bc,de
0409A4             0371*   dxy168:
0409A4             0372*   ; compute dx = x1-x0
0409A4 AF          0373*       xor a ; clear carry
0409A5 DD E5       0374*       push ix ; move ix to hl via the stack
0409A7 E1          0375*       pop hl ; hl = x1
0409A8 ED 42       0376*       sbc hl,bc ; hl = dx
0409AA 22 BF 09 04 0377*       ld (dx168),hl ; dx to scratch
0409AE             0378*   ; compute dy = y1-y0
0409AE AF          0379*       xor a ; clear carry
0409AF FD E5       0380*       push iy ; move iy to hl via the stack
0409B1 E1          0381*       pop hl ; hl = y1
0409B2 ED 52       0382*       sbc hl,de ; hl = dy
0409B4 22 C5 09 04 0383*       ld (dy168),hl ; dy to scratch
0409B8             0384*   ; populate output registers and return
0409B8 EB          0385*       ex de,hl ; ud.e = dy
0409B9 ED 4B BF 09 0386*       ld bc,(dx168) ; ub.c = dx
       04          
0409BE C9          0387*       ret
0409BF 00 00 00 00 0388*   dx168: blkb 6,0
       00 00       
0409C5 00 00 00 00 0389*   dy168: blkb 6,0
       00 00       
0409CB             0390*   
0409CB             0391*   ; compute the euclidian distance between two cartesian coordinates
0409CB             0392*   ; using the formula d = sqrt(dx^2+dy^2)
0409CB             0393*   ; inputs: dx168 and dy168 are dx and dy in 16.8 fixed format
0409CB             0394*   ; output; uh.l is the 16.8 fixed format distance
0409CB             0395*   ;         also populates scratch locations dx168 and dy168
0409CB             0396*   ; destroys: a,hl,bc,de
0409CB             0397*   ; NOTE: rounds both deltas down to the nearest integer to avoid overflow when squaring,
0409CB             0398*   ;       thus the result will always be an integer, albeit in 16.8 format
0409CB             0399*   distance168:
0409CB             0400*   ; compute dy^2
0409CB 2A C5 09 04 0401*       ld hl,(dy168)
0409CF CD 70 04 04 0402*       call hlu_abs
0409D3             0403*       ; call hlu_udiv256 ; make integer to avoid overflow
0409D3             0404*       SRL_UHL ; make integer to avoid overflow
0409D3 3B          0001*M1     dec sp ; 1 cycle
0409D4 E5          0002*M1     push hl ; 4 cycles
0409D5 33          0003*M1     inc sp ; 1 cycle
0409D6 E1          0004*M1     pop hl ; 4 cycles
0409D7 23          0005*M1     inc hl ; 1 cycle
0409D8 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
0409DA             0007*M1     ; 13 cycles total
0409DA E5          0405*       push hl
0409DB D1          0406*       pop de
0409DC CD 67 03 04 0407*       call umul24 ; hl = dy^2
0409E0 E5          0408*       push hl ; save dy^2
0409E1             0409*   ; compute dx^2
0409E1 2A BF 09 04 0410*       ld hl,(dx168)
0409E5 CD 70 04 04 0411*       call hlu_abs
0409E9             0412*       ; call hlu_udiv256 ; make integer to avoid overflow
0409E9             0413*       SRL_UHL ; make integer to avoid overflow
0409E9 3B          0001*M1     dec sp ; 1 cycle
0409EA E5          0002*M1     push hl ; 4 cycles
0409EB 33          0003*M1     inc sp ; 1 cycle
0409EC E1          0004*M1     pop hl ; 4 cycles
0409ED 23          0005*M1     inc hl ; 1 cycle
0409EE 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
0409F0             0007*M1     ; 13 cycles total
0409F0 E5          0414*       push hl
0409F1 D1          0415*       pop de
0409F2 CD 67 03 04 0416*       call umul24 ; hl = dx^2
0409F6             0417*   ; add dx^2 and dy^2
0409F6 D1          0418*       pop de ; de = dy^2 (was hl)
0409F7 19          0419*       add hl,de ; hl = dx^2 + dy^2
0409F8             0420*   ; compute the square root
0409F8 CD F6 0A 04 0421*       call sqrt24 ; de = sqrt(dx^2 + dy^2)
0409FC EB          0422*       ex de,hl ; hl = distance
0409FD             0423*       hlu_mul256 ; convert back to 16.8 fixed
0409FD 29          0001*M1     add hl,hl ; * 2
0409FE 29          0002*M1     add hl,hl ; * 4
0409FF 29          0003*M1     add hl,hl ; * 8
040A00 29          0004*M1     add hl,hl ; * 16
040A01 29          0005*M1     add hl,hl ; * 32
040A02 29          0006*M1     add hl,hl ; * 64
040A03 29          0007*M1     add hl,hl ; * 128
040A04 29          0008*M1     add hl,hl ; * 256
040A05 C9          0424*       ret
040A06             0425*   
040A06             0426*   ; compute the euclidian distance between two cartesian coordinates
040A06             0427*   ; using the formula d = sqrt(dx^2+dy^2)
040A06             0428*   ; inputs: dx168 and dy168 are dx and dy in 16.8 fixed format
040A06             0429*   ; output; uh.l is the 16.8 fixed format distance
040A06             0430*   ;         also populates scratch locations dx168 and dy168
040A06             0431*   ; destroys: a,hl,bc,de
040A06             0432*   ; NOTE: sm means 'small' because it doesn't round down the deltas
040A06             0433*   ;       making it more accurate for small deltas,
040A06             0434*   ;       but will overflow if used for screen-sized deltas
040A06             0435*   distance168sm:
040A06             0436*   ; compute dy^2
040A06 2A C5 09 04 0437*       ld hl,(dy168)
040A0A CD 70 04 04 0438*       call hlu_abs
040A0E E5          0439*       push hl
040A0F D1          0440*       pop de
040A10 CD 67 03 04 0441*       call umul24 ; hl = dy^2
040A14 E5          0442*       push hl ; save dy^2
040A15             0443*   ; compute dx^2
040A15 2A BF 09 04 0444*       ld hl,(dx168)
040A19 CD 70 04 04 0445*       call hlu_abs
040A1D E5          0446*       push hl
040A1E D1          0447*       pop de
040A1F CD 67 03 04 0448*       call umul24 ; hl = dx^2
040A23             0449*   ; add dx^2 and dy^2
040A23 D1          0450*       pop de ; de = dy^2 (was hl)
040A24 19          0451*       add hl,de ; hl = dx^2 + dy^2
040A25             0452*   ; compute the square root
040A25 CD F6 0A 04 0453*       call sqrt24 ; de = sqrt(dx^2 + dy^2)
040A29 EB          0454*       ex de,hl ; hl = distance
040A2A C9          0455*       ret
040A2B             0456*   
040A2B             0457*   ; atan2_(ub.c,ud.e) --> uh.l
040A2B             0458*   ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040A2B             0459*   ;   whether inputs are integers or fractional doesn't matter
040A2B             0460*   ;   so long as the sign bit of the upper byte is correct
040A2B             0461*   ; output: uh.l is the 16.8 fixed angle in degrees 256
040A2B             0462*   ; angles are COMPASS HEADINGS based on
040A2B             0463*   ; screen coordinate conventions,where the y axis is flipped
040A2B             0464*   ; #E0 224      0       32 #20
040A2B             0465*   ;        -x,-y | +x,-y
040A2B             0466*   ; #C0 192------+------ 64 #40
040A2B             0467*   ;        -x,+y | +x,+y
040A2B             0468*   ; #A0 160   128 #80   96 #60
040A2B             0469*   atan2_168fast:
040A2B             0470*   ; get signs and make everything positive
040A2B             0471*   ; get abs(x) and store its original sign
040A2B C5          0472*       push bc
040A2C E1          0473*       pop hl
040A2D CD 70 04 04 0474*       call hlu_abs ; if x was negative this also sets the sign flag
040A31 E5          0475*       push hl ; store abs(x)
040A32 C1          0476*       pop bc ; bc = abs(x)
040A33 F5          0477*       push af ; store sign of x
040A34             0478*   ; get abs(y) and store its original sign
040A34 EB          0479*       ex de,hl ; hl = y
040A35 CD 70 04 04 0480*       call hlu_abs ; if y was negative this also sets the sign flag
040A39 EB          0481*       ex de,hl ; de = abs(y)
040A3A F5          0482*       push af ; store sign of y
040A3B             0483*   ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
040A3B             0484*   ; this ensures that our lookup value is between 0 and 1 inclusive
040A3B AF          0485*       xor a ; clear the carry flag
040A3C D5          0486*       push de
040A3D E1          0487*       pop hl
040A3E ED 42       0488*       sbc hl,bc
040A40 F5          0489*       push af ; save sign of de - bc
040A41 F2 4A 0A 04 0490*       jp p,@1 ; bc <= de, so we skip ahead
040A45             0491*   ; otherwise we swap bc and de
040A45 C5          0492*       push bc
040A46 E1          0493*       pop hl
040A47 EB          0494*       ex de,hl
040A48 E5          0495*       push hl
040A49 C1          0496*       pop bc
040A4A             0497*   @1:
040A4A             0498*   ; now we're ready to snag our preliminary result
040A4A C5          0499*       push bc
040A4B E1          0500*       pop hl
040A4C CD BA 0A 04 0501*       call atan_168fast ; uh.l comes back with prelim result
040A50             0502*   ; now we adjust uh.l based on sign of de - bc
040A50 F1          0503*       pop af
040A51 F2 5D 0A 04 0504*       jp p,@2 ; bc <= de,so we skip ahead
040A55 EB          0505*       ex de,hl
040A56 21 00 40 00 0506*       ld hl,64*256 ; subtract from 64 (90) degrees
040A5A AF          0507*       xor a ; clear the carry flag
040A5B ED 52       0508*       sbc hl,de
040A5D             0509*   @2:
040A5D             0510*   ; adjust the result based on quadrant
040A5D             0511*   ; #E0 224      0       32 #20
040A5D             0512*   ;        -x,-y | +x,-y
040A5D             0513*   ; #C0 192------+------ 64 #40
040A5D             0514*   ;        -x,+y | +x,+y
040A5D             0515*   ; #A0 160   128 #80   96 #60
040A5D F1          0516*       pop af ; sign of y
040A5E CA 9B 0A 04 0517*       jp z,@y_zero
040A62 F2 7B 0A 04 0518*       jp p,@y_pos
040A66             0519*   ; y neg,check x
040A66 F1          0520*       pop af ; sign of x
040A67 CA 75 0A 04 0521*       jp z,@y_neg_x_zero
040A6B F2 7A 0A 04 0522*       jp p,@y_neg_x_pos
040A6F             0523*   ; y neg,x neg
040A6F             0524*   ; angle is 128 to 256 (270 to 360)
040A6F             0525*   ; negating the intermediate does the trick
040A6F CD 80 04 04 0526*       call neg_hlu
040A73 18 31       0527*       jr @zero_hlu
040A75             0528*   
040A75             0529*   @y_neg_x_zero:
040A75             0530*   ; y neg,x zero
040A75             0531*   ; angle is 0
040A75 21 00 00 00 0532*       ld hl,0
040A79 C9          0533*       ret
040A7A             0534*   @y_neg_x_pos:
040A7A             0535*   ; y neg,x pos
040A7A             0536*   ; angle is 0 to 64 (0 to 90)
040A7A             0537*   ; so we're good
040A7A C9          0538*       ret
040A7B             0539*   
040A7B             0540*   @y_pos:
040A7B F1          0541*       pop af ; sign of x
040A7C CA 8B 0A 04 0542*       jp z,@y_pos_x_zero
040A80 F2 90 0A 04 0543*       jp p,@y_pos_x_pos
040A84             0544*   ; y pos,x neg
040A84             0545*   ; angle is 128 to 192 (180-270)
040A84             0546*   ; so we add 128 to intermediate
040A84 11 00 80 00 0547*       ld de,128*256
040A88 19          0548*       add hl,de
040A89 18 1B       0549*       jr @zero_hlu
040A8B             0550*   @y_pos_x_zero:
040A8B             0551*   ; y pos,x zero
040A8B             0552*   ; angle is 128 (180)
040A8B 21 00 80 00 0553*       ld hl,128*256
040A8F C9          0554*       ret
040A90             0555*   @y_pos_x_pos:
040A90             0556*   ; y pos,x pos
040A90             0557*   ; angle is 64 to 128 (90 to 180)
040A90             0558*   ; neg the intermediate and add 180 degrees
040A90 CD 80 04 04 0559*       call neg_hlu
040A94 11 00 80 00 0560*       ld de,128*256
040A98 19          0561*       add hl,de
040A99 18 0B       0562*       jr @zero_hlu
040A9B             0563*   
040A9B             0564*   @y_zero:
040A9B F1          0565*       pop af ; sign of x
040A9C FA A1 0A 04 0566*       jp m,@y_zero_x_neg
040AA0             0567*   ; y zero,x pos
040AA0             0568*   ; angle is 64 (90),nothing to do
040AA0 C9          0569*       ret
040AA1             0570*   @y_zero_x_neg:
040AA1             0571*   ; y zero ,x neg
040AA1             0572*   ; angle is 192 (270)
040AA1 21 00 C0 00 0573*       ld hl,192*256
040AA5 C9          0574*       ret
040AA6             0575*   @zero_hlu:
040AA6 AF          0576*       xor a
040AA7 22 B4 0A 04 0577*       ld (@scratch),hl
040AAB 32 B6 0A 04 0578*       ld (@scratch+2),a
040AAF 2A B4 0A 04 0579*       ld hl,(@scratch)
040AB3 C9          0580*       ret
040AB4             0581*   @scratch: ds 6
040ABA             0582*   
040ABA             0583*   ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040ABA             0584*   ; output: uh.l is the 16.8 fixed format angle in degrees 256
040ABA             0585*   ; destroys: a,hl,bc,de
040ABA             0586*   ; note: only works for angles from 0 to 32 (45) degrees
040ABA             0587*   ;   use atan2_168fast (which calls this proc) to handle the full 256 (360) degrees
040ABA             0588*   atan_168fast:
040ABA             0589*   ; because we use compass headings instead of geometric angles
040ABA             0590*   ; we compute dx/dy which is 1/tan(theta) in the maths world
040ABA             0591*   ; we can do faster unsigned division here because we know dx and dy are positive
       FF FF FF FF 
       FF FF 
040ABA CD 75 08 04 0592*       call udiv168 ; ud.e = dx/dy
040ABE EB          0593*       ex de,hl ; uh.l = dx/dy
040ABF             0594*   ; test uh.l for 0
040ABF 19          0595*       add hl,de
040AC0 B7          0596*       or a
040AC1 ED 52       0597*       sbc hl,de
040AC3 28 22       0598*       jr z,@is_zero
040AC5             0599*   ; test uh.l for 1
040AC5 AF          0600*       xor a ; clear carry
040AC6 EB          0601*       ex de,hl
040AC7 21 00 01 00 0602*       ld hl,1*256 ; 1 in 16.8 fixed format
040ACB ED 52       0603*       sbc hl,de
040ACD 28 13       0604*       jr z,@is_45
040ACF EB          0605*       ex de,hl
040AD0             0606*   ; no special cases so we move on
040AD0             0607*   ; l contains the fractional portion of tan(uh.l)
040AD0             0608*   ; we multiply it by three to get our lookup table index
040AD0 26 03       0609*       ld h,3
040AD2 ED 6C       0610*       mlt hl ; index into lut
040AD4 11 00 00 00 0611*       ld de,0 ; clear deu
040AD8 54          0612*       ld d,h ; copy hl to de
040AD9 5D          0613*       ld e,l ; de contains our index
040ADA 21 DF 0E 04 0614*       ld hl,atan_lut_168 ; grab the lut address
040ADE 19          0615*       add hl,de ; bump hl by the index
040ADF ED 27       0616*       ld hl,(hl) ; don't try this on a z80!
040AE1 C9          0617*       ret ; and out
040AE2             0618*   @is_45:
040AE2 21 00 20 00 0619*       ld hl,32*256
040AE6 C9          0620*       ret
040AE7             0621*   ; for the case tan(0)
040AE7             0622*   @is_zero:
040AE7 21 00 00 00 0623*       ld hl,0*256
040AEB C9          0624*       ret
040AEC             0625*   
040AEC             0626*   ; Expects  ADL mode
040AEC             0627*   ; Inputs:  UH.L
040AEC             0628*   ; Outputs: UH.L is the 16.8 square root
040AEC             0629*   ;          UDE is the integer difference inputHL-DE^2
040AEC             0630*   sqrt168:
040AEC CD F6 0A 04 0631*       call sqrt24
040AF0 EB          0632*       ex de,hl
040AF1 29          0633*       add hl,hl
040AF2 29          0634*       add hl,hl
040AF3 29          0635*       add hl,hl
040AF4 29          0636*       add hl,hl
040AF5 C9          0637*       ret
040AF6             0638*   
040AF6             0639*   ; credit: xeda112358
040AF6             0640*   ; https://www.cemetech.net/forum/viewtopic.php?t=11178&postdays=0&postorder=asc&start=0
040AF6             0641*   sqrt24:
040AF6             0642*   ; Expects ADL mode
040AF6             0643*   ; Inputs: HL
040AF6             0644*   ; Outputs: DE is the integer square root
040AF6             0645*   ;  HL is the difference inputHL-DE^2
040AF6             0646*   ;  c flag reset
040AF6 01 00 00 00 0647*       ld bc,0 ; clear bcu
040AFA 11 00 00 00 0648*       ld de,0 ; clear deu
040AFE AF          0649*       xor a
040AFF 45          0650*       ld b,l
040B00 C5          0651*       push bc
040B01 47          0652*       ld b,a
040B02 6F          0653*       ld l,a
040B03             0654*   ; Iteration 1
040B03 29          0655*       add hl,hl
040B04 CB 11       0656*       rl c
040B06 29          0657*       add hl,hl
040B07 CB 11       0658*       rl c
040B09 91          0659*       sub c
040B0A 30 04       0660*       jr nc,$+6
040B0C 1C          0661*       inc e
040B0D 1C          0662*       inc e
040B0E 2F          0663*       cpl
040B0F 4F          0664*       ld c,a
040B10             0665*   ; Iteration 2
040B10 29          0666*       add hl,hl
040B11 CB 11       0667*       rl c
040B13 29          0668*       add hl,hl
040B14 CB 11       0669*       rl c
040B16 CB 13       0670*       rl e
040B18 7B          0671*       ld a,e
040B19 91          0672*       sub c
040B1A 30 04       0673*       jr nc,$+6
040B1C 1C          0674*       inc e
040B1D 1C          0675*       inc e
040B1E 2F          0676*       cpl
040B1F 4F          0677*       ld c,a
040B20             0678*   ; Iteration 3
040B20 29          0679*       add hl,hl
040B21 CB 11       0680*       rl c
040B23 29          0681*       add hl,hl
040B24 CB 11       0682*       rl c
040B26 CB 13       0683*       rl e
040B28 7B          0684*       ld a,e
040B29 91          0685*       sub c
040B2A 30 04       0686*       jr nc,$+6
040B2C 1C          0687*       inc e
040B2D 1C          0688*       inc e
040B2E 2F          0689*       cpl
040B2F 4F          0690*       ld c,a
040B30             0691*   ; Iteration 4
040B30 29          0692*       add hl,hl
040B31 CB 11       0693*       rl c
040B33 29          0694*       add hl,hl
040B34 CB 11       0695*       rl c
040B36 CB 13       0696*       rl e
040B38 7B          0697*       ld a,e
040B39 91          0698*       sub c
040B3A 30 04       0699*       jr nc,$+6
040B3C 1C          0700*       inc e
040B3D 1C          0701*       inc e
040B3E 2F          0702*       cpl
040B3F 4F          0703*       ld c,a
040B40             0704*   ; Iteration 5
040B40 29          0705*       add hl,hl
040B41 CB 11       0706*       rl c
040B43 29          0707*       add hl,hl
040B44 CB 11       0708*       rl c
040B46 CB 13       0709*       rl e
040B48 7B          0710*       ld a,e
040B49 91          0711*       sub c
040B4A 30 04       0712*       jr nc,$+6
040B4C 1C          0713*       inc e
040B4D 1C          0714*       inc e
040B4E 2F          0715*       cpl
040B4F 4F          0716*       ld c,a
040B50             0717*   ; Iteration 6
040B50 29          0718*       add hl,hl
040B51 CB 11       0719*       rl c
040B53 29          0720*       add hl,hl
040B54 CB 11       0721*       rl c
040B56 CB 13       0722*       rl e
040B58 7B          0723*       ld a,e
040B59 91          0724*       sub c
040B5A 30 04       0725*       jr nc,$+6
040B5C 1C          0726*       inc e
040B5D 1C          0727*       inc e
040B5E 2F          0728*       cpl
040B5F 4F          0729*       ld c,a
040B60             0730*   ; Iteration 7
040B60 29          0731*       add hl,hl
040B61 CB 11       0732*       rl c
040B63 29          0733*       add hl,hl
040B64 CB 11       0734*       rl c
040B66 CB 10       0735*       rl b
040B68 EB          0736*       ex de,hl
040B69 29          0737*       add hl,hl
040B6A E5          0738*       push hl
040B6B ED 42       0739*       sbc hl,bc
040B6D 30 06       0740*       jr nc,$+8
040B6F 7C          0741*       ld a,h
040B70 2F          0742*       cpl
040B71 47          0743*       ld b,a
040B72 7D          0744*       ld a,l
040B73 2F          0745*       cpl
040B74 4F          0746*       ld c,a
040B75 E1          0747*       pop hl
040B76 30 02       0748*       jr nc,$+4
040B78 23          0749*       inc hl
040B79 23          0750*       inc hl
040B7A EB          0751*       ex de,hl
040B7B             0752*   ; Iteration 8
040B7B 29          0753*       add hl,hl
040B7C 69          0754*       ld l,c
040B7D 60          0755*       ld h,b
040B7E ED 6A       0756*       adc hl,hl
040B80 ED 6A       0757*       adc hl,hl
040B82 EB          0758*       ex de,hl
040B83 29          0759*       add hl,hl
040B84 ED 52       0760*       sbc hl,de
040B86 19          0761*       add hl,de
040B87 EB          0762*       ex de,hl
040B88 30 04       0763*       jr nc,$+6
040B8A ED 52       0764*       sbc hl,de
040B8C 13          0765*       inc de
040B8D 13          0766*       inc de
040B8E             0767*   ; Iteration 9
040B8E F1          0768*       pop af
040B8F 17          0769*       rla
040B90 ED 6A       0770*       adc hl,hl
040B92 17          0771*       rla
040B93 ED 6A       0772*       adc hl,hl
040B95 EB          0773*       ex de,hl
040B96 29          0774*       add hl,hl
040B97 ED 52       0775*       sbc hl,de
040B99 19          0776*       add hl,de
040B9A EB          0777*       ex de,hl
040B9B 30 04       0778*       jr nc,$+6
040B9D ED 52       0779*       sbc hl,de
040B9F 13          0780*       inc de
040BA0 13          0781*       inc de
040BA1             0782*   ; Iteration 10
040BA1 17          0783*       rla
040BA2 ED 6A       0784*       adc hl,hl
040BA4 17          0785*       rla
040BA5 ED 6A       0786*       adc hl,hl
040BA7 EB          0787*       ex de,hl
040BA8 29          0788*       add hl,hl
040BA9 ED 52       0789*       sbc hl,de
040BAB 19          0790*       add hl,de
040BAC EB          0791*       ex de,hl
040BAD 30 04       0792*       jr nc,$+6
040BAF ED 52       0793*       sbc hl,de
040BB1 13          0794*       inc de
040BB2 13          0795*       inc de
040BB3             0796*   ; Iteration 11
040BB3 17          0797*       rla
040BB4 ED 6A       0798*       adc hl,hl
040BB6 17          0799*       rla
040BB7 ED 6A       0800*       adc hl,hl
040BB9 EB          0801*       ex de,hl
040BBA 29          0802*       add hl,hl
040BBB ED 52       0803*       sbc hl,de
040BBD 19          0804*       add hl,de
040BBE EB          0805*       ex de,hl
040BBF 30 04       0806*       jr nc,$+6
040BC1 ED 52       0807*       sbc hl,de
040BC3 13          0808*       inc de
040BC4 13          0809*       inc de
040BC5             0810*   ; Iteration 12
040BC5 17          0811*       rla
040BC6 ED 6A       0812*       adc hl,hl
040BC8 17          0813*       rla
040BC9 ED 6A       0814*       adc hl,hl
040BCB EB          0815*       ex de,hl
040BCC 29          0816*       add hl,hl
040BCD ED 52       0817*       sbc hl,de
040BCF 19          0818*       add hl,de
040BD0 EB          0819*       ex de,hl
040BD1 30 04       0820*       jr nc,$+6
040BD3 ED 52       0821*       sbc hl,de
040BD5 13          0822*       inc de
040BD6 13          0823*       inc de
040BD7 CB 1A       0824*       rr d
040BD9 CB 1B       0825*       rr e
040BDB C9          0826*       ret
040BDC             0827*   
040BDC             0828*   sin_lut_168:
040BDC 00 00 00    0829*       dl 0x000000 ; 0.000 00, 0.000
040BDF 06 00 00    0830*       dl 0x000006 ; 1.406 01, 0.025
040BE2 0C 00 00    0831*       dl 0x00000C ; 2.813 02, 0.049
040BE5 12 00 00    0832*       dl 0x000012 ; 4.219 03, 0.074
040BE8 19 00 00    0833*       dl 0x000019 ; 5.625 04, 0.098
040BEB 1F 00 00    0834*       dl 0x00001F ; 7.031 05, 0.122
040BEE 25 00 00    0835*       dl 0x000025 ; 8.438 06, 0.147
040BF1 2B 00 00    0836*       dl 0x00002B ; 9.844 07, 0.171
040BF4 31 00 00    0837*       dl 0x000031 ; 11.250 08, 0.195
040BF7 38 00 00    0838*       dl 0x000038 ; 12.656 09, 0.219
040BFA 3E 00 00    0839*       dl 0x00003E ; 14.063 0A, 0.243
040BFD 44 00 00    0840*       dl 0x000044 ; 15.469 0B, 0.267
040C00 4A 00 00    0841*       dl 0x00004A ; 16.875 0C, 0.290
040C03 50 00 00    0842*       dl 0x000050 ; 18.281 0D, 0.314
040C06 56 00 00    0843*       dl 0x000056 ; 19.688 0E, 0.337
040C09 5C 00 00    0844*       dl 0x00005C ; 21.094 0F, 0.360
040C0C 61 00 00    0845*       dl 0x000061 ; 22.500 10, 0.383
040C0F 67 00 00    0846*       dl 0x000067 ; 23.906 11, 0.405
040C12 6D 00 00    0847*       dl 0x00006D ; 25.313 12, 0.428
040C15 73 00 00    0848*       dl 0x000073 ; 26.719 13, 0.450
040C18 78 00 00    0849*       dl 0x000078 ; 28.125 14, 0.471
040C1B 7E 00 00    0850*       dl 0x00007E ; 29.531 15, 0.493
040C1E 83 00 00    0851*       dl 0x000083 ; 30.938 16, 0.514
040C21 88 00 00    0852*       dl 0x000088 ; 32.344 17, 0.535
040C24 8E 00 00    0853*       dl 0x00008E ; 33.750 18, 0.556
040C27 93 00 00    0854*       dl 0x000093 ; 35.156 19, 0.576
040C2A 98 00 00    0855*       dl 0x000098 ; 36.563 1A, 0.596
040C2D 9D 00 00    0856*       dl 0x00009D ; 37.969 1B, 0.615
040C30 A2 00 00    0857*       dl 0x0000A2 ; 39.375 1C, 0.634
040C33 A7 00 00    0858*       dl 0x0000A7 ; 40.781 1D, 0.653
040C36 AB 00 00    0859*       dl 0x0000AB ; 42.188 1E, 0.672
040C39 B0 00 00    0860*       dl 0x0000B0 ; 43.594 1F, 0.690
040C3C B5 00 00    0861*       dl 0x0000B5 ; 45.000 20, 0.707
040C3F B9 00 00    0862*       dl 0x0000B9 ; 46.406 21, 0.724
040C42 BD 00 00    0863*       dl 0x0000BD ; 47.813 22, 0.741
040C45 C1 00 00    0864*       dl 0x0000C1 ; 49.219 23, 0.757
040C48 C5 00 00    0865*       dl 0x0000C5 ; 50.625 24, 0.773
040C4B C9 00 00    0866*       dl 0x0000C9 ; 52.031 25, 0.788
040C4E CD 00 00    0867*       dl 0x0000CD ; 53.438 26, 0.803
040C51 D1 00 00    0868*       dl 0x0000D1 ; 54.844 27, 0.818
040C54 D4 00 00    0869*       dl 0x0000D4 ; 56.250 28, 0.831
040C57 D8 00 00    0870*       dl 0x0000D8 ; 57.656 29, 0.845
040C5A DB 00 00    0871*       dl 0x0000DB ; 59.063 2A, 0.858
040C5D DE 00 00    0872*       dl 0x0000DE ; 60.469 2B, 0.870
040C60 E1 00 00    0873*       dl 0x0000E1 ; 61.875 2C, 0.882
040C63 E4 00 00    0874*       dl 0x0000E4 ; 63.281 2D, 0.893
040C66 E7 00 00    0875*       dl 0x0000E7 ; 64.688 2E, 0.904
040C69 EA 00 00    0876*       dl 0x0000EA ; 66.094 2F, 0.914
040C6C EC 00 00    0877*       dl 0x0000EC ; 67.500 30, 0.924
040C6F EE 00 00    0878*       dl 0x0000EE ; 68.906 31, 0.933
040C72 F1 00 00    0879*       dl 0x0000F1 ; 70.313 32, 0.942
040C75 F3 00 00    0880*       dl 0x0000F3 ; 71.719 33, 0.950
040C78 F4 00 00    0881*       dl 0x0000F4 ; 73.125 34, 0.957
040C7B F6 00 00    0882*       dl 0x0000F6 ; 74.531 35, 0.964
040C7E F8 00 00    0883*       dl 0x0000F8 ; 75.938 36, 0.970
040C81 F9 00 00    0884*       dl 0x0000F9 ; 77.344 37, 0.976
040C84 FB 00 00    0885*       dl 0x0000FB ; 78.750 38, 0.981
040C87 FC 00 00    0886*       dl 0x0000FC ; 80.156 39, 0.985
040C8A FD 00 00    0887*       dl 0x0000FD ; 81.563 3A, 0.989
040C8D FE 00 00    0888*       dl 0x0000FE ; 82.969 3B, 0.992
040C90 FE 00 00    0889*       dl 0x0000FE ; 84.375 3C, 0.995
040C93 FF 00 00    0890*       dl 0x0000FF ; 85.781 3D, 0.997
040C96 FF 00 00    0891*       dl 0x0000FF ; 87.188 3E, 0.999
040C99 FF 00 00    0892*       dl 0x0000FF ; 88.594 3F, 1.000
040C9C 00 01 00    0893*       dl 0x000100 ; 90.000 40, 1.000
040C9F FF 00 00    0894*       dl 0x0000FF ; 91.406 41, 1.000
040CA2 FF 00 00    0895*       dl 0x0000FF ; 92.813 42, 0.999
040CA5 FF 00 00    0896*       dl 0x0000FF ; 94.219 43, 0.997
040CA8 FE 00 00    0897*       dl 0x0000FE ; 95.625 44, 0.995
040CAB FE 00 00    0898*       dl 0x0000FE ; 97.031 45, 0.992
040CAE FD 00 00    0899*       dl 0x0000FD ; 98.438 46, 0.989
040CB1 FC 00 00    0900*       dl 0x0000FC ; 99.844 47, 0.985
040CB4 FB 00 00    0901*       dl 0x0000FB ; 101.250 48, 0.981
040CB7 F9 00 00    0902*       dl 0x0000F9 ; 102.656 49, 0.976
040CBA F8 00 00    0903*       dl 0x0000F8 ; 104.063 4A, 0.970
040CBD F6 00 00    0904*       dl 0x0000F6 ; 105.469 4B, 0.964
040CC0 F4 00 00    0905*       dl 0x0000F4 ; 106.875 4C, 0.957
040CC3 F3 00 00    0906*       dl 0x0000F3 ; 108.281 4D, 0.950
040CC6 F1 00 00    0907*       dl 0x0000F1 ; 109.688 4E, 0.942
040CC9 EE 00 00    0908*       dl 0x0000EE ; 111.094 4F, 0.933
040CCC EC 00 00    0909*       dl 0x0000EC ; 112.500 50, 0.924
040CCF EA 00 00    0910*       dl 0x0000EA ; 113.906 51, 0.914
040CD2 E7 00 00    0911*       dl 0x0000E7 ; 115.313 52, 0.904
040CD5 E4 00 00    0912*       dl 0x0000E4 ; 116.719 53, 0.893
040CD8 E1 00 00    0913*       dl 0x0000E1 ; 118.125 54, 0.882
040CDB DE 00 00    0914*       dl 0x0000DE ; 119.531 55, 0.870
040CDE DB 00 00    0915*       dl 0x0000DB ; 120.938 56, 0.858
040CE1 D8 00 00    0916*       dl 0x0000D8 ; 122.344 57, 0.845
040CE4 D4 00 00    0917*       dl 0x0000D4 ; 123.750 58, 0.831
040CE7 D1 00 00    0918*       dl 0x0000D1 ; 125.156 59, 0.818
040CEA CD 00 00    0919*       dl 0x0000CD ; 126.563 5A, 0.803
040CED C9 00 00    0920*       dl 0x0000C9 ; 127.969 5B, 0.788
040CF0 C5 00 00    0921*       dl 0x0000C5 ; 129.375 5C, 0.773
040CF3 C1 00 00    0922*       dl 0x0000C1 ; 130.781 5D, 0.757
040CF6 BD 00 00    0923*       dl 0x0000BD ; 132.188 5E, 0.741
040CF9 B9 00 00    0924*       dl 0x0000B9 ; 133.594 5F, 0.724
040CFC B5 00 00    0925*       dl 0x0000B5 ; 135.000 60, 0.707
040CFF B0 00 00    0926*       dl 0x0000B0 ; 136.406 61, 0.690
040D02 AB 00 00    0927*       dl 0x0000AB ; 137.813 62, 0.672
040D05 A7 00 00    0928*       dl 0x0000A7 ; 139.219 63, 0.653
040D08 A2 00 00    0929*       dl 0x0000A2 ; 140.625 64, 0.634
040D0B 9D 00 00    0930*       dl 0x00009D ; 142.031 65, 0.615
040D0E 98 00 00    0931*       dl 0x000098 ; 143.438 66, 0.596
040D11 93 00 00    0932*       dl 0x000093 ; 144.844 67, 0.576
040D14 8E 00 00    0933*       dl 0x00008E ; 146.250 68, 0.556
040D17 88 00 00    0934*       dl 0x000088 ; 147.656 69, 0.535
040D1A 83 00 00    0935*       dl 0x000083 ; 149.063 6A, 0.514
040D1D 7E 00 00    0936*       dl 0x00007E ; 150.469 6B, 0.493
040D20 78 00 00    0937*       dl 0x000078 ; 151.875 6C, 0.471
040D23 73 00 00    0938*       dl 0x000073 ; 153.281 6D, 0.450
040D26 6D 00 00    0939*       dl 0x00006D ; 154.688 6E, 0.428
040D29 67 00 00    0940*       dl 0x000067 ; 156.094 6F, 0.405
040D2C 61 00 00    0941*       dl 0x000061 ; 157.500 70, 0.383
040D2F 5C 00 00    0942*       dl 0x00005C ; 158.906 71, 0.360
040D32 56 00 00    0943*       dl 0x000056 ; 160.313 72, 0.337
040D35 50 00 00    0944*       dl 0x000050 ; 161.719 73, 0.314
040D38 4A 00 00    0945*       dl 0x00004A ; 163.125 74, 0.290
040D3B 44 00 00    0946*       dl 0x000044 ; 164.531 75, 0.267
040D3E 3E 00 00    0947*       dl 0x00003E ; 165.938 76, 0.243
040D41 38 00 00    0948*       dl 0x000038 ; 167.344 77, 0.219
040D44 31 00 00    0949*       dl 0x000031 ; 168.750 78, 0.195
040D47 2B 00 00    0950*       dl 0x00002B ; 170.156 79, 0.171
040D4A 25 00 00    0951*       dl 0x000025 ; 171.563 7A, 0.147
040D4D 1F 00 00    0952*       dl 0x00001F ; 172.969 7B, 0.122
040D50 19 00 00    0953*       dl 0x000019 ; 174.375 7C, 0.098
040D53 12 00 00    0954*       dl 0x000012 ; 175.781 7D, 0.074
040D56 0C 00 00    0955*       dl 0x00000C ; 177.188 7E, 0.049
040D59 06 00 00    0956*       dl 0x000006 ; 178.594 7F, 0.025
040D5C 00 00 00    0957*       dl 0x000000 ; 180.000 80, 0.000
040D5F FA FF FF    0958*       dl 0xFFFFFA ; 181.406 81, -0.025
040D62 F4 FF FF    0959*       dl 0xFFFFF4 ; 182.813 82, -0.049
040D65 EE FF FF    0960*       dl 0xFFFFEE ; 184.219 83, -0.074
040D68 E7 FF FF    0961*       dl 0xFFFFE7 ; 185.625 84, -0.098
040D6B E1 FF FF    0962*       dl 0xFFFFE1 ; 187.031 85, -0.122
040D6E DB FF FF    0963*       dl 0xFFFFDB ; 188.438 86, -0.147
040D71 D5 FF FF    0964*       dl 0xFFFFD5 ; 189.844 87, -0.171
040D74 CF FF FF    0965*       dl 0xFFFFCF ; 191.250 88, -0.195
040D77 C8 FF FF    0966*       dl 0xFFFFC8 ; 192.656 89, -0.219
040D7A C2 FF FF    0967*       dl 0xFFFFC2 ; 194.063 8A, -0.243
040D7D BC FF FF    0968*       dl 0xFFFFBC ; 195.469 8B, -0.267
040D80 B6 FF FF    0969*       dl 0xFFFFB6 ; 196.875 8C, -0.290
040D83 B0 FF FF    0970*       dl 0xFFFFB0 ; 198.281 8D, -0.314
040D86 AA FF FF    0971*       dl 0xFFFFAA ; 199.688 8E, -0.337
040D89 A4 FF FF    0972*       dl 0xFFFFA4 ; 201.094 8F, -0.360
040D8C 9F FF FF    0973*       dl 0xFFFF9F ; 202.500 90, -0.383
040D8F 99 FF FF    0974*       dl 0xFFFF99 ; 203.906 91, -0.405
040D92 93 FF FF    0975*       dl 0xFFFF93 ; 205.313 92, -0.428
040D95 8D FF FF    0976*       dl 0xFFFF8D ; 206.719 93, -0.450
040D98 88 FF FF    0977*       dl 0xFFFF88 ; 208.125 94, -0.471
040D9B 82 FF FF    0978*       dl 0xFFFF82 ; 209.531 95, -0.493
040D9E 7D FF FF    0979*       dl 0xFFFF7D ; 210.938 96, -0.514
040DA1 78 FF FF    0980*       dl 0xFFFF78 ; 212.344 97, -0.535
040DA4 72 FF FF    0981*       dl 0xFFFF72 ; 213.750 98, -0.556
040DA7 6D FF FF    0982*       dl 0xFFFF6D ; 215.156 99, -0.576
040DAA 68 FF FF    0983*       dl 0xFFFF68 ; 216.563 9A, -0.596
040DAD 63 FF FF    0984*       dl 0xFFFF63 ; 217.969 9B, -0.615
040DB0 5E FF FF    0985*       dl 0xFFFF5E ; 219.375 9C, -0.634
040DB3 59 FF FF    0986*       dl 0xFFFF59 ; 220.781 9D, -0.653
040DB6 55 FF FF    0987*       dl 0xFFFF55 ; 222.188 9E, -0.672
040DB9 50 FF FF    0988*       dl 0xFFFF50 ; 223.594 9F, -0.690
040DBC 4B FF FF    0989*       dl 0xFFFF4B ; 225.000 A0, -0.707
040DBF 47 FF FF    0990*       dl 0xFFFF47 ; 226.406 A1, -0.724
040DC2 43 FF FF    0991*       dl 0xFFFF43 ; 227.813 A2, -0.741
040DC5 3F FF FF    0992*       dl 0xFFFF3F ; 229.219 A3, -0.757
040DC8 3B FF FF    0993*       dl 0xFFFF3B ; 230.625 A4, -0.773
040DCB 37 FF FF    0994*       dl 0xFFFF37 ; 232.031 A5, -0.788
040DCE 33 FF FF    0995*       dl 0xFFFF33 ; 233.438 A6, -0.803
040DD1 2F FF FF    0996*       dl 0xFFFF2F ; 234.844 A7, -0.818
040DD4 2C FF FF    0997*       dl 0xFFFF2C ; 236.250 A8, -0.831
040DD7 28 FF FF    0998*       dl 0xFFFF28 ; 237.656 A9, -0.845
040DDA 25 FF FF    0999*       dl 0xFFFF25 ; 239.063 AA, -0.858
040DDD 22 FF FF    1000*       dl 0xFFFF22 ; 240.469 AB, -0.870
040DE0 1F FF FF    1001*       dl 0xFFFF1F ; 241.875 AC, -0.882
040DE3 1C FF FF    1002*       dl 0xFFFF1C ; 243.281 AD, -0.893
040DE6 19 FF FF    1003*       dl 0xFFFF19 ; 244.688 AE, -0.904
040DE9 16 FF FF    1004*       dl 0xFFFF16 ; 246.094 AF, -0.914
040DEC 14 FF FF    1005*       dl 0xFFFF14 ; 247.500 B0, -0.924
040DEF 12 FF FF    1006*       dl 0xFFFF12 ; 248.906 B1, -0.933
040DF2 0F FF FF    1007*       dl 0xFFFF0F ; 250.313 B2, -0.942
040DF5 0D FF FF    1008*       dl 0xFFFF0D ; 251.719 B3, -0.950
040DF8 0C FF FF    1009*       dl 0xFFFF0C ; 253.125 B4, -0.957
040DFB 0A FF FF    1010*       dl 0xFFFF0A ; 254.531 B5, -0.964
040DFE 08 FF FF    1011*       dl 0xFFFF08 ; 255.938 B6, -0.970
040E01 07 FF FF    1012*       dl 0xFFFF07 ; 257.344 B7, -0.976
040E04 05 FF FF    1013*       dl 0xFFFF05 ; 258.750 B8, -0.981
040E07 04 FF FF    1014*       dl 0xFFFF04 ; 260.156 B9, -0.985
040E0A 03 FF FF    1015*       dl 0xFFFF03 ; 261.563 BA, -0.989
040E0D 02 FF FF    1016*       dl 0xFFFF02 ; 262.969 BB, -0.992
040E10 02 FF FF    1017*       dl 0xFFFF02 ; 264.375 BC, -0.995
040E13 01 FF FF    1018*       dl 0xFFFF01 ; 265.781 BD, -0.997
040E16 01 FF FF    1019*       dl 0xFFFF01 ; 267.188 BE, -0.999
040E19 01 FF FF    1020*       dl 0xFFFF01 ; 268.594 BF, -1.000
040E1C 00 FF FF    1021*       dl 0xFFFF00 ; 270.000 C0, -1.000
040E1F 01 FF FF    1022*       dl 0xFFFF01 ; 271.406 C1, -1.000
040E22 01 FF FF    1023*       dl 0xFFFF01 ; 272.813 C2, -0.999
040E25 01 FF FF    1024*       dl 0xFFFF01 ; 274.219 C3, -0.997
040E28 02 FF FF    1025*       dl 0xFFFF02 ; 275.625 C4, -0.995
040E2B 02 FF FF    1026*       dl 0xFFFF02 ; 277.031 C5, -0.992
040E2E 03 FF FF    1027*       dl 0xFFFF03 ; 278.438 C6, -0.989
040E31 04 FF FF    1028*       dl 0xFFFF04 ; 279.844 C7, -0.985
040E34 05 FF FF    1029*       dl 0xFFFF05 ; 281.250 C8, -0.981
040E37 07 FF FF    1030*       dl 0xFFFF07 ; 282.656 C9, -0.976
040E3A 08 FF FF    1031*       dl 0xFFFF08 ; 284.063 CA, -0.970
040E3D 0A FF FF    1032*       dl 0xFFFF0A ; 285.469 CB, -0.964
040E40 0C FF FF    1033*       dl 0xFFFF0C ; 286.875 CC, -0.957
040E43 0D FF FF    1034*       dl 0xFFFF0D ; 288.281 CD, -0.950
040E46 0F FF FF    1035*       dl 0xFFFF0F ; 289.688 CE, -0.942
040E49 12 FF FF    1036*       dl 0xFFFF12 ; 291.094 CF, -0.933
040E4C 14 FF FF    1037*       dl 0xFFFF14 ; 292.500 D0, -0.924
040E4F 16 FF FF    1038*       dl 0xFFFF16 ; 293.906 D1, -0.914
040E52 19 FF FF    1039*       dl 0xFFFF19 ; 295.313 D2, -0.904
040E55 1C FF FF    1040*       dl 0xFFFF1C ; 296.719 D3, -0.893
040E58 1F FF FF    1041*       dl 0xFFFF1F ; 298.125 D4, -0.882
040E5B 22 FF FF    1042*       dl 0xFFFF22 ; 299.531 D5, -0.870
040E5E 25 FF FF    1043*       dl 0xFFFF25 ; 300.938 D6, -0.858
040E61 28 FF FF    1044*       dl 0xFFFF28 ; 302.344 D7, -0.845
040E64 2C FF FF    1045*       dl 0xFFFF2C ; 303.750 D8, -0.831
040E67 2F FF FF    1046*       dl 0xFFFF2F ; 305.156 D9, -0.818
040E6A 33 FF FF    1047*       dl 0xFFFF33 ; 306.563 DA, -0.803
040E6D 37 FF FF    1048*       dl 0xFFFF37 ; 307.969 DB, -0.788
040E70 3B FF FF    1049*       dl 0xFFFF3B ; 309.375 DC, -0.773
040E73 3F FF FF    1050*       dl 0xFFFF3F ; 310.781 DD, -0.757
040E76 43 FF FF    1051*       dl 0xFFFF43 ; 312.188 DE, -0.741
040E79 47 FF FF    1052*       dl 0xFFFF47 ; 313.594 DF, -0.724
040E7C 4B FF FF    1053*       dl 0xFFFF4B ; 315.000 E0, -0.707
040E7F 50 FF FF    1054*       dl 0xFFFF50 ; 316.406 E1, -0.690
040E82 55 FF FF    1055*       dl 0xFFFF55 ; 317.813 E2, -0.672
040E85 59 FF FF    1056*       dl 0xFFFF59 ; 319.219 E3, -0.653
040E88 5E FF FF    1057*       dl 0xFFFF5E ; 320.625 E4, -0.634
040E8B 63 FF FF    1058*       dl 0xFFFF63 ; 322.031 E5, -0.615
040E8E 68 FF FF    1059*       dl 0xFFFF68 ; 323.438 E6, -0.596
040E91 6D FF FF    1060*       dl 0xFFFF6D ; 324.844 E7, -0.576
040E94 72 FF FF    1061*       dl 0xFFFF72 ; 326.250 E8, -0.556
040E97 78 FF FF    1062*       dl 0xFFFF78 ; 327.656 E9, -0.535
040E9A 7D FF FF    1063*       dl 0xFFFF7D ; 329.063 EA, -0.514
040E9D 82 FF FF    1064*       dl 0xFFFF82 ; 330.469 EB, -0.493
040EA0 88 FF FF    1065*       dl 0xFFFF88 ; 331.875 EC, -0.471
040EA3 8D FF FF    1066*       dl 0xFFFF8D ; 333.281 ED, -0.450
040EA6 93 FF FF    1067*       dl 0xFFFF93 ; 334.688 EE, -0.428
040EA9 99 FF FF    1068*       dl 0xFFFF99 ; 336.094 EF, -0.405
040EAC 9F FF FF    1069*       dl 0xFFFF9F ; 337.500 F0, -0.383
040EAF A4 FF FF    1070*       dl 0xFFFFA4 ; 338.906 F1, -0.360
040EB2 AA FF FF    1071*       dl 0xFFFFAA ; 340.313 F2, -0.337
040EB5 B0 FF FF    1072*       dl 0xFFFFB0 ; 341.719 F3, -0.314
040EB8 B6 FF FF    1073*       dl 0xFFFFB6 ; 343.125 F4, -0.290
040EBB BC FF FF    1074*       dl 0xFFFFBC ; 344.531 F5, -0.267
040EBE C2 FF FF    1075*       dl 0xFFFFC2 ; 345.938 F6, -0.243
040EC1 C8 FF FF    1076*       dl 0xFFFFC8 ; 347.344 F7, -0.219
040EC4 CF FF FF    1077*       dl 0xFFFFCF ; 348.750 F8, -0.195
040EC7 D5 FF FF    1078*       dl 0xFFFFD5 ; 350.156 F9, -0.171
040ECA DB FF FF    1079*       dl 0xFFFFDB ; 351.563 FA, -0.147
040ECD E1 FF FF    1080*       dl 0xFFFFE1 ; 352.969 FB, -0.122
040ED0 E7 FF FF    1081*       dl 0xFFFFE7 ; 354.375 FC, -0.098
040ED3 EE FF FF    1082*       dl 0xFFFFEE ; 355.781 FD, -0.074
040ED6 F4 FF FF    1083*       dl 0xFFFFF4 ; 357.188 FE, -0.049
040ED9 FA FF FF    1084*       dl 0xFFFFFA ; 358.594 FF, -0.025
040EDC 00 00 00    1085*       dl 0x000000 ; 0.000 00, 0.000 for interpolation
040EDF             1086*   
040EDF             1087*   atan_lut_168:
040EDF 00 00 00    1088*       dl 0x000000 ; 000000, 0.000
040EE2 28 00 00    1089*       dl 0x000028 ; 000001, 0.224
040EE5 51 00 00    1090*       dl 0x000051 ; 000002, 0.448
040EE8 7A 00 00    1091*       dl 0x00007A ; 000003, 0.671
040EEB A2 00 00    1092*       dl 0x0000A2 ; 000004, 0.895
040EEE CB 00 00    1093*       dl 0x0000CB ; 000005, 1.119
040EF1 F4 00 00    1094*       dl 0x0000F4 ; 000006, 1.343
040EF4 1D 01 00    1095*       dl 0x00011D ; 000007, 1.566
040EF7 45 01 00    1096*       dl 0x000145 ; 000008, 1.790
040EFA 6E 01 00    1097*       dl 0x00016E ; 000009, 2.013
040EFD 97 01 00    1098*       dl 0x000197 ; 00000A, 2.237
040F00 BF 01 00    1099*       dl 0x0001BF ; 00000B, 2.460
040F03 E8 01 00    1100*       dl 0x0001E8 ; 00000C, 2.684
040F06 11 02 00    1101*       dl 0x000211 ; 00000D, 2.907
040F09 39 02 00    1102*       dl 0x000239 ; 00000E, 3.130
040F0C 62 02 00    1103*       dl 0x000262 ; 00000F, 3.353
040F0F 8B 02 00    1104*       dl 0x00028B ; 000010, 3.576
040F12 B3 02 00    1105*       dl 0x0002B3 ; 000011, 3.799
040F15 DC 02 00    1106*       dl 0x0002DC ; 000012, 4.022
040F18 04 03 00    1107*       dl 0x000304 ; 000013, 4.245
040F1B 2D 03 00    1108*       dl 0x00032D ; 000014, 4.467
040F1E 55 03 00    1109*       dl 0x000355 ; 000015, 4.690
040F21 7E 03 00    1110*       dl 0x00037E ; 000016, 4.912
040F24 A6 03 00    1111*       dl 0x0003A6 ; 000017, 5.134
040F27 CE 03 00    1112*       dl 0x0003CE ; 000018, 5.356
040F2A F7 03 00    1113*       dl 0x0003F7 ; 000019, 5.578
040F2D 1F 04 00    1114*       dl 0x00041F ; 00001A, 5.799
040F30 48 04 00    1115*       dl 0x000448 ; 00001B, 6.021
040F33 70 04 00    1116*       dl 0x000470 ; 00001C, 6.242
040F36 98 04 00    1117*       dl 0x000498 ; 00001D, 6.463
040F39 C0 04 00    1118*       dl 0x0004C0 ; 00001E, 6.684
040F3C E8 04 00    1119*       dl 0x0004E8 ; 00001F, 6.905
040F3F 11 05 00    1120*       dl 0x000511 ; 000020, 7.125
040F42 39 05 00    1121*       dl 0x000539 ; 000021, 7.345
040F45 61 05 00    1122*       dl 0x000561 ; 000022, 7.565
040F48 89 05 00    1123*       dl 0x000589 ; 000023, 7.785
040F4B B1 05 00    1124*       dl 0x0005B1 ; 000024, 8.005
040F4E D9 05 00    1125*       dl 0x0005D9 ; 000025, 8.224
040F51 01 06 00    1126*       dl 0x000601 ; 000026, 8.443
040F54 28 06 00    1127*       dl 0x000628 ; 000027, 8.662
040F57 50 06 00    1128*       dl 0x000650 ; 000028, 8.881
040F5A 78 06 00    1129*       dl 0x000678 ; 000029, 9.099
040F5D A0 06 00    1130*       dl 0x0006A0 ; 00002A, 9.317
040F60 C7 06 00    1131*       dl 0x0006C7 ; 00002B, 9.535
040F63 EF 06 00    1132*       dl 0x0006EF ; 00002C, 9.752
040F66 16 07 00    1133*       dl 0x000716 ; 00002D, 9.970
040F69 3E 07 00    1134*       dl 0x00073E ; 00002E, 10.187
040F6C 65 07 00    1135*       dl 0x000765 ; 00002F, 10.403
040F6F 8D 07 00    1136*       dl 0x00078D ; 000030, 10.620
040F72 B4 07 00    1137*       dl 0x0007B4 ; 000031, 10.836
040F75 DB 07 00    1138*       dl 0x0007DB ; 000032, 11.051
040F78 03 08 00    1139*       dl 0x000803 ; 000033, 11.267
040F7B 2A 08 00    1140*       dl 0x00082A ; 000034, 11.482
040F7E 51 08 00    1141*       dl 0x000851 ; 000035, 11.697
040F81 78 08 00    1142*       dl 0x000878 ; 000036, 11.911
040F84 9F 08 00    1143*       dl 0x00089F ; 000037, 12.125
040F87 C6 08 00    1144*       dl 0x0008C6 ; 000038, 12.339
040F8A ED 08 00    1145*       dl 0x0008ED ; 000039, 12.553
040F8D 13 09 00    1146*       dl 0x000913 ; 00003A, 12.766
040F90 3A 09 00    1147*       dl 0x00093A ; 00003B, 12.978
040F93 61 09 00    1148*       dl 0x000961 ; 00003C, 13.191
040F96 87 09 00    1149*       dl 0x000987 ; 00003D, 13.403
040F99 AE 09 00    1150*       dl 0x0009AE ; 00003E, 13.614
040F9C D4 09 00    1151*       dl 0x0009D4 ; 00003F, 13.825
040F9F FB 09 00    1152*       dl 0x0009FB ; 000040, 14.036
040FA2 21 0A 00    1153*       dl 0x000A21 ; 000041, 14.247
040FA5 47 0A 00    1154*       dl 0x000A47 ; 000042, 14.457
040FA8 6D 0A 00    1155*       dl 0x000A6D ; 000043, 14.666
040FAB 94 0A 00    1156*       dl 0x000A94 ; 000044, 14.876
040FAE BA 0A 00    1157*       dl 0x000ABA ; 000045, 15.085
040FB1 E0 0A 00    1158*       dl 0x000AE0 ; 000046, 15.293
040FB4 05 0B 00    1159*       dl 0x000B05 ; 000047, 15.501
040FB7 2B 0B 00    1160*       dl 0x000B2B ; 000048, 15.709
040FBA 51 0B 00    1161*       dl 0x000B51 ; 000049, 15.916
040FBD 77 0B 00    1162*       dl 0x000B77 ; 00004A, 16.123
040FC0 9C 0B 00    1163*       dl 0x000B9C ; 00004B, 16.329
040FC3 C2 0B 00    1164*       dl 0x000BC2 ; 00004C, 16.535
040FC6 E7 0B 00    1165*       dl 0x000BE7 ; 00004D, 16.740
040FC9 0C 0C 00    1166*       dl 0x000C0C ; 00004E, 16.945
040FCC 32 0C 00    1167*       dl 0x000C32 ; 00004F, 17.150
040FCF 57 0C 00    1168*       dl 0x000C57 ; 000050, 17.354
040FD2 7C 0C 00    1169*       dl 0x000C7C ; 000051, 17.558
040FD5 A1 0C 00    1170*       dl 0x000CA1 ; 000052, 17.761
040FD8 C6 0C 00    1171*       dl 0x000CC6 ; 000053, 17.964
040FDB EB 0C 00    1172*       dl 0x000CEB ; 000054, 18.166
040FDE 0F 0D 00    1173*       dl 0x000D0F ; 000055, 18.368
040FE1 34 0D 00    1174*       dl 0x000D34 ; 000056, 18.569
040FE4 58 0D 00    1175*       dl 0x000D58 ; 000057, 18.770
040FE7 7D 0D 00    1176*       dl 0x000D7D ; 000058, 18.970
040FEA A1 0D 00    1177*       dl 0x000DA1 ; 000059, 19.170
040FED C6 0D 00    1178*       dl 0x000DC6 ; 00005A, 19.370
040FF0 EA 0D 00    1179*       dl 0x000DEA ; 00005B, 19.569
040FF3 0E 0E 00    1180*       dl 0x000E0E ; 00005C, 19.767
040FF6 32 0E 00    1181*       dl 0x000E32 ; 00005D, 19.965
040FF9 56 0E 00    1182*       dl 0x000E56 ; 00005E, 20.163
040FFC 7A 0E 00    1183*       dl 0x000E7A ; 00005F, 20.360
040FFF 9E 0E 00    1184*       dl 0x000E9E ; 000060, 20.556
041002 C1 0E 00    1185*       dl 0x000EC1 ; 000061, 20.752
041005 E5 0E 00    1186*       dl 0x000EE5 ; 000062, 20.947
041008 08 0F 00    1187*       dl 0x000F08 ; 000063, 21.142
04100B 2C 0F 00    1188*       dl 0x000F2C ; 000064, 21.337
04100E 4F 0F 00    1189*       dl 0x000F4F ; 000065, 21.531
041011 72 0F 00    1190*       dl 0x000F72 ; 000066, 21.724
041014 95 0F 00    1191*       dl 0x000F95 ; 000067, 21.917
041017 B8 0F 00    1192*       dl 0x000FB8 ; 000068, 22.109
04101A DB 0F 00    1193*       dl 0x000FDB ; 000069, 22.301
04101D FE 0F 00    1194*       dl 0x000FFE ; 00006A, 22.493
041020 21 10 00    1195*       dl 0x001021 ; 00006B, 22.683
041023 44 10 00    1196*       dl 0x001044 ; 00006C, 22.874
041026 66 10 00    1197*       dl 0x001066 ; 00006D, 23.063
041029 89 10 00    1198*       dl 0x001089 ; 00006E, 23.253
04102C AB 10 00    1199*       dl 0x0010AB ; 00006F, 23.441
04102F CD 10 00    1200*       dl 0x0010CD ; 000070, 23.629
041032 EF 10 00    1201*       dl 0x0010EF ; 000071, 23.817
041035 11 11 00    1202*       dl 0x001111 ; 000072, 24.004
041038 33 11 00    1203*       dl 0x001133 ; 000073, 24.191
04103B 55 11 00    1204*       dl 0x001155 ; 000074, 24.376
04103E 77 11 00    1205*       dl 0x001177 ; 000075, 24.562
041041 99 11 00    1206*       dl 0x001199 ; 000076, 24.747
041044 BA 11 00    1207*       dl 0x0011BA ; 000077, 24.931
041047 DC 11 00    1208*       dl 0x0011DC ; 000078, 25.115
04104A FD 11 00    1209*       dl 0x0011FD ; 000079, 25.298
04104D 1E 12 00    1210*       dl 0x00121E ; 00007A, 25.481
041050 3F 12 00    1211*       dl 0x00123F ; 00007B, 25.663
041053 60 12 00    1212*       dl 0x001260 ; 00007C, 25.844
041056 81 12 00    1213*       dl 0x001281 ; 00007D, 26.025
041059 A2 12 00    1214*       dl 0x0012A2 ; 00007E, 26.206
04105C C3 12 00    1215*       dl 0x0012C3 ; 00007F, 26.386
04105F E4 12 00    1216*       dl 0x0012E4 ; 000080, 26.565
041062 04 13 00    1217*       dl 0x001304 ; 000081, 26.744
041065 25 13 00    1218*       dl 0x001325 ; 000082, 26.922
041068 45 13 00    1219*       dl 0x001345 ; 000083, 27.100
04106B 65 13 00    1220*       dl 0x001365 ; 000084, 27.277
04106E 85 13 00    1221*       dl 0x001385 ; 000085, 27.453
041071 A5 13 00    1222*       dl 0x0013A5 ; 000086, 27.629
041074 C5 13 00    1223*       dl 0x0013C5 ; 000087, 27.805
041077 E5 13 00    1224*       dl 0x0013E5 ; 000088, 27.979
04107A 05 14 00    1225*       dl 0x001405 ; 000089, 28.154
04107D 24 14 00    1226*       dl 0x001424 ; 00008A, 28.327
041080 44 14 00    1227*       dl 0x001444 ; 00008B, 28.501
041083 63 14 00    1228*       dl 0x001463 ; 00008C, 28.673
041086 83 14 00    1229*       dl 0x001483 ; 00008D, 28.845
041089 A2 14 00    1230*       dl 0x0014A2 ; 00008E, 29.017
04108C C1 14 00    1231*       dl 0x0014C1 ; 00008F, 29.187
04108F E0 14 00    1232*       dl 0x0014E0 ; 000090, 29.358
041092 FF 14 00    1233*       dl 0x0014FF ; 000091, 29.527
041095 1E 15 00    1234*       dl 0x00151E ; 000092, 29.697
041098 3C 15 00    1235*       dl 0x00153C ; 000093, 29.865
04109B 5B 15 00    1236*       dl 0x00155B ; 000094, 30.033
04109E 79 15 00    1237*       dl 0x001579 ; 000095, 30.201
0410A1 98 15 00    1238*       dl 0x001598 ; 000096, 30.368
0410A4 B6 15 00    1239*       dl 0x0015B6 ; 000097, 30.534
0410A7 D4 15 00    1240*       dl 0x0015D4 ; 000098, 30.700
0410AA F2 15 00    1241*       dl 0x0015F2 ; 000099, 30.865
0410AD 10 16 00    1242*       dl 0x001610 ; 00009A, 31.030
0410B0 2E 16 00    1243*       dl 0x00162E ; 00009B, 31.194
0410B3 4C 16 00    1244*       dl 0x00164C ; 00009C, 31.357
0410B6 6A 16 00    1245*       dl 0x00166A ; 00009D, 31.520
0410B9 87 16 00    1246*       dl 0x001687 ; 00009E, 31.682
0410BC A5 16 00    1247*       dl 0x0016A5 ; 00009F, 31.844
0410BF C2 16 00    1248*       dl 0x0016C2 ; 0000A0, 32.005
0410C2 DF 16 00    1249*       dl 0x0016DF ; 0000A1, 32.166
0410C5 FC 16 00    1250*       dl 0x0016FC ; 0000A2, 32.326
0410C8 19 17 00    1251*       dl 0x001719 ; 0000A3, 32.486
0410CB 36 17 00    1252*       dl 0x001736 ; 0000A4, 32.645
0410CE 53 17 00    1253*       dl 0x001753 ; 0000A5, 32.803
0410D1 70 17 00    1254*       dl 0x001770 ; 0000A6, 32.961
0410D4 8C 17 00    1255*       dl 0x00178C ; 0000A7, 33.118
0410D7 A9 17 00    1256*       dl 0x0017A9 ; 0000A8, 33.275
0410DA C5 17 00    1257*       dl 0x0017C5 ; 0000A9, 33.431
0410DD E2 17 00    1258*       dl 0x0017E2 ; 0000AA, 33.587
0410E0 FE 17 00    1259*       dl 0x0017FE ; 0000AB, 33.742
0410E3 1A 18 00    1260*       dl 0x00181A ; 0000AC, 33.896
0410E6 36 18 00    1261*       dl 0x001836 ; 0000AD, 34.050
0410E9 52 18 00    1262*       dl 0x001852 ; 0000AE, 34.203
0410EC 6E 18 00    1263*       dl 0x00186E ; 0000AF, 34.356
0410EF 8A 18 00    1264*       dl 0x00188A ; 0000B0, 34.509
0410F2 A5 18 00    1265*       dl 0x0018A5 ; 0000B1, 34.660
0410F5 C1 18 00    1266*       dl 0x0018C1 ; 0000B2, 34.811
0410F8 DC 18 00    1267*       dl 0x0018DC ; 0000B3, 34.962
0410FB F7 18 00    1268*       dl 0x0018F7 ; 0000B4, 35.112
0410FE 13 19 00    1269*       dl 0x001913 ; 0000B5, 35.262
041101 2E 19 00    1270*       dl 0x00192E ; 0000B6, 35.410
041104 49 19 00    1271*       dl 0x001949 ; 0000B7, 35.559
041107 64 19 00    1272*       dl 0x001964 ; 0000B8, 35.707
04110A 7F 19 00    1273*       dl 0x00197F ; 0000B9, 35.854
04110D 99 19 00    1274*       dl 0x001999 ; 0000BA, 36.001
041110 B4 19 00    1275*       dl 0x0019B4 ; 0000BB, 36.147
041113 CE 19 00    1276*       dl 0x0019CE ; 0000BC, 36.293
041116 E9 19 00    1277*       dl 0x0019E9 ; 0000BD, 36.438
041119 03 1A 00    1278*       dl 0x001A03 ; 0000BE, 36.582
04111C 1D 1A 00    1279*       dl 0x001A1D ; 0000BF, 36.726
04111F 37 1A 00    1280*       dl 0x001A37 ; 0000C0, 36.870
041122 51 1A 00    1281*       dl 0x001A51 ; 0000C1, 37.013
041125 6B 1A 00    1282*       dl 0x001A6B ; 0000C2, 37.155
041128 85 1A 00    1283*       dl 0x001A85 ; 0000C3, 37.297
04112B 9F 1A 00    1284*       dl 0x001A9F ; 0000C4, 37.439
04112E B9 1A 00    1285*       dl 0x001AB9 ; 0000C5, 37.579
041131 D2 1A 00    1286*       dl 0x001AD2 ; 0000C6, 37.720
041134 EC 1A 00    1287*       dl 0x001AEC ; 0000C7, 37.859
041137 05 1B 00    1288*       dl 0x001B05 ; 0000C8, 37.999
04113A 1E 1B 00    1289*       dl 0x001B1E ; 0000C9, 38.137
04113D 37 1B 00    1290*       dl 0x001B37 ; 0000CA, 38.276
041140 50 1B 00    1291*       dl 0x001B50 ; 0000CB, 38.413
041143 69 1B 00    1292*       dl 0x001B69 ; 0000CC, 38.550
041146 82 1B 00    1293*       dl 0x001B82 ; 0000CD, 38.687
041149 9B 1B 00    1294*       dl 0x001B9B ; 0000CE, 38.823
04114C B4 1B 00    1295*       dl 0x001BB4 ; 0000CF, 38.959
04114F CC 1B 00    1296*       dl 0x001BCC ; 0000D0, 39.094
041152 E5 1B 00    1297*       dl 0x001BE5 ; 0000D1, 39.228
041155 FD 1B 00    1298*       dl 0x001BFD ; 0000D2, 39.362
041158 16 1C 00    1299*       dl 0x001C16 ; 0000D3, 39.496
04115B 2E 1C 00    1300*       dl 0x001C2E ; 0000D4, 39.629
04115E 46 1C 00    1301*       dl 0x001C46 ; 0000D5, 39.762
041161 5E 1C 00    1302*       dl 0x001C5E ; 0000D6, 39.894
041164 76 1C 00    1303*       dl 0x001C76 ; 0000D7, 40.025
041167 8E 1C 00    1304*       dl 0x001C8E ; 0000D8, 40.156
04116A A5 1C 00    1305*       dl 0x001CA5 ; 0000D9, 40.286
04116D BD 1C 00    1306*       dl 0x001CBD ; 0000DA, 40.416
041170 D5 1C 00    1307*       dl 0x001CD5 ; 0000DB, 40.546
041173 EC 1C 00    1308*       dl 0x001CEC ; 0000DC, 40.675
041176 04 1D 00    1309*       dl 0x001D04 ; 0000DD, 40.803
041179 1B 1D 00    1310*       dl 0x001D1B ; 0000DE, 40.931
04117C 32 1D 00    1311*       dl 0x001D32 ; 0000DF, 41.059
04117F 49 1D 00    1312*       dl 0x001D49 ; 0000E0, 41.186
041182 60 1D 00    1313*       dl 0x001D60 ; 0000E1, 41.312
041185 77 1D 00    1314*       dl 0x001D77 ; 0000E2, 41.438
041188 8E 1D 00    1315*       dl 0x001D8E ; 0000E3, 41.564
04118B A5 1D 00    1316*       dl 0x001DA5 ; 0000E4, 41.689
04118E BB 1D 00    1317*       dl 0x001DBB ; 0000E5, 41.814
041191 D2 1D 00    1318*       dl 0x001DD2 ; 0000E6, 41.938
041194 E9 1D 00    1319*       dl 0x001DE9 ; 0000E7, 42.061
041197 FF 1D 00    1320*       dl 0x001DFF ; 0000E8, 42.184
04119A 15 1E 00    1321*       dl 0x001E15 ; 0000E9, 42.307
04119D 2C 1E 00    1322*       dl 0x001E2C ; 0000EA, 42.429
0411A0 42 1E 00    1323*       dl 0x001E42 ; 0000EB, 42.551
0411A3 58 1E 00    1324*       dl 0x001E58 ; 0000EC, 42.672
0411A6 6E 1E 00    1325*       dl 0x001E6E ; 0000ED, 42.793
0411A9 84 1E 00    1326*       dl 0x001E84 ; 0000EE, 42.913
0411AC 99 1E 00    1327*       dl 0x001E99 ; 0000EF, 43.033
0411AF AF 1E 00    1328*       dl 0x001EAF ; 0000F0, 43.152
0411B2 C5 1E 00    1329*       dl 0x001EC5 ; 0000F1, 43.271
0411B5 DA 1E 00    1330*       dl 0x001EDA ; 0000F2, 43.390
0411B8 F0 1E 00    1331*       dl 0x001EF0 ; 0000F3, 43.508
0411BB 05 1F 00    1332*       dl 0x001F05 ; 0000F4, 43.625
0411BE 1B 1F 00    1333*       dl 0x001F1B ; 0000F5, 43.742
0411C1 30 1F 00    1334*       dl 0x001F30 ; 0000F6, 43.859
0411C4 45 1F 00    1335*       dl 0x001F45 ; 0000F7, 43.975
0411C7 5A 1F 00    1336*       dl 0x001F5A ; 0000F8, 44.091
0411CA 6F 1F 00    1337*       dl 0x001F6F ; 0000F9, 44.206
0411CD 84 1F 00    1338*       dl 0x001F84 ; 0000FA, 44.321
0411D0 99 1F 00    1339*       dl 0x001F99 ; 0000FB, 44.435
0411D3 AD 1F 00    1340*       dl 0x001FAD ; 0000FC, 44.549
0411D6 C2 1F 00    1341*       dl 0x001FC2 ; 0000FD, 44.662
0411D9 D7 1F 00    1342*       dl 0x001FD7 ; 0000FE, 44.775
0411DC EB 1F 00    1343*       dl 0x001FEB ; 0000FF, 44.888
0411DF 00 20 00    1344*       dl 0x002000 ; 000100, 45.000 only needed for interpolation
0411E2             0039        include "timer.inc"
0411E2             0001*   ; Table 32. Timer Control Registers
0411E2             0002*   TMR0_CTL: equ 80h
0411E2             0003*   TMR1_CTL: equ 83h
0411E2             0004*   TMR2_CTL: equ 86h
0411E2             0005*   TMR3_CTL: equ 89h
0411E2             0006*   TMR4_CTL: equ 8Ch
0411E2             0007*   TMR5_CTL: equ 8Fh
0411E2             0008*   
0411E2             0009*   ; each timer register takes three bytes:
0411E2             0010*   ;   0: control register
0411E2             0011*   ;   1: low byte of timer reset value
0411E2             0012*   ;   2: high byte of timer reset value
0411E2             0013*   ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
0411E2             0014*   ; which correctly force the high and upper bytes of the address bus to zero
0411E2             0015*   
0411E2             0016*   TMR_REG_CTL: equ 0
0411E2             0017*   TMR_RES_LOW: equ 1
0411E2             0018*   TMR_RES_HIGH: equ 2
0411E2             0019*   
0411E2             0020*   ; Timer Control Register Bit Definitions
0411E2             0021*   PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
0411E2             0022*                               ; This bit is reset to 0 every time the TMRx_CTL register is read.
0411E2             0023*   PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
0411E2             0024*                               ; an interrupt signal is sent to the CPU. This bit remains 1 until
0411E2             0025*                               ; the TMRx_CTL register is read.
0411E2             0026*   
0411E2             0027*   IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
0411E2             0028*   IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
0411E2             0029*   
0411E2             0030*   PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
0411E2             0031*                               ;  0,and counting stops when the end-of-count value is reached.
0411E2             0032*   PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
0411E2             0033*                               ; written to the counter when the end-of-count value is reached.
0411E2             0034*   
0411E2             0035*   ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
0411E2             0036*   CLK_DIV_256:  equ %00001100 ;
0411E2             0037*   CLK_DIV_64:   equ %00001000 ;
0411E2             0038*   CLK_DIV_16:   equ %00000100 ;
0411E2             0039*   CLK_DIV_4:    equ %00000000 ;
0411E2             0040*   
0411E2             0041*   RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
0411E2             0042*   RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
0411E2             0043*                               ; When a 1 is written to this bit,the values in the reload registers
0411E2             0044*                               ;  are loaded into the downcounter when the timer restarts. The
0411E2             0045*                               ; programmer must ensure that this bit is set to 1 each time
0411E2             0046*                               ; SINGLE-PASS mode is used.
0411E2             0047*   
0411E2             0048*   ; disable/enable the programmable reload timer
0411E2             0049*   PRT_EN_0:     equ %00000000 ;
0411E2             0050*   PRT_EN_1:     equ %00000001 ;
0411E2             0051*   
0411E2             0052*   ; Table 37. Timer Input Source Select Register
0411E2             0053*   ; Each of the 4 timers are allocated two bits of the 8-bit register
0411E2             0054*   ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
0411E2             0055*   ;   00: System clock / CLK_DIV
0411E2             0056*   ;   01: RTC / CLK_DIV
0411E2             0057*   ;   NOTE: these are the values given in the manual,but it may be a typo
0411E2             0058*   ;   10: GPIO port B pin 1.
0411E2             0059*   ;   11: GPIO port B pin 1.
0411E2             0060*   TMR_ISS:   equ 92h ; register address
0411E2             0061*   
0411E2             0062*   ; Table 51. Real-Time Clock Control Register
0411E2             0063*   RTC_CTRL: equ EDh ; register address
0411E2             0064*   
0411E2             0065*   ; alarm interrupt disable/enable
0411E2             0066*   RTC_ALARM_0:    equ %00000000
0411E2             0067*   RTC_ALARM_1:    equ %10000000
0411E2             0068*   
0411E2             0069*   ; interrupt on alarm disable/enable
0411E2             0070*   RTC_INT_ENT_0:  equ %00000000
0411E2             0071*   RTC_INT_ENT_1:  equ %01000000
0411E2             0072*   
0411E2             0073*   RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
0411E2             0074*   RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
0411E2             0075*   
0411E2             0076*   RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
0411E2             0077*                                   ; On-chip 32768 Hz oscillator is enabled.
0411E2             0078*   RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
0411E2             0079*                                   ; On-chip 32768 Hz oscillator is disabled.
0411E2             0080*   
0411E2             0081*   RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
0411E2             0082*   RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
0411E2             0083*   
0411E2             0084*   RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
0411E2             0085*   RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
0411E2             0086*   
0411E2             0087*   RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
0411E2             0088*                                   ; RTC counter is enabled.
0411E2             0089*   RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
0411E2             0090*                                   ; RTC counter is disabled.
0411E2             0091*   
0411E2             0092*   ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
0411E2             0093*   
0411E2             0094*   prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
0411E2             0095*   prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
0411E2 00 00 00    0096*   prt_reload: dl 0x000000
0411E5             0097*   
0411E5             0098*   ; returns: a = 0 if running on hardware,1 if running on emulator
0411E5             0099*   ;          de = number PRT interrupts during test interval
0411E5             0100*   prt_calibrate:
0411E5 CD B4 14 04 0101*       call vdu_vblank
0411E9             0102*   ; set a MOS timer
0411E9 21 78 00 00 0103*       ld hl,120*1 ; 1 second
0411ED FD 21 6D 13 0104*       ld iy,tmr_test
       04          
0411F2 CD 4B 13 04 0105*       call tmr_set
0411F6             0106*   ; set a PRT timer
0411F6             0107*       ; ld hl,prt_reload_hardware
0411F6             0108*       ; ld hl,prt_reload_emulator
0411F6 21 05 2D 00 0109*       ld hl,prt_reload_emulator + prt_reload_hardware / 2
0411FA 22 E2 11 04 0110*       ld (prt_reload),hl
0411FE CD 86 12 04 0111*       call prt_set
041202             0112*   @loop:
041202             0113*   ; check time remaining on MOS timer
041202 CD 59 13 04 0114*       call tmr_get
041206 CA 10 12 04 0115*       jp z,@done ; time expired,so quit
04120A FA 10 12 04 0116*       jp m,@done ; time past expiration (negative),so quit
04120E 18 F2       0117*       jr @loop
041210             0118*   @done:
041210 ED 5B D4 12 0119*       ld de,(prt_irq_counter)
       04          
041215 01 0C 2D 00 0120*       ld bc,prt_reload_hardware ; default value for running on hardware
041219 ED 43 E2 11 0121*       ld (prt_reload),bc
       04          
04121E 21 64 00 00 0122*       ld hl,100 ; halfway between 101 for real hardware and 99 for emulator
041222 AF          0123*       xor a ; clear carry,zero is default value for running on hardware
041223 32 45 12 04 0124*       ld (is_emulator),a
041227 ED 52       0125*       sbc hl,de
041229 21 46 12 04 0126*       ld hl,on_hardware ; default message for running on hardware
04122D CA E5 11 04 0127*       jp z,prt_calibrate ; zero result is indeterminate so we try again
041231 F8          0128*       ret m ; negative result means we're on hardware
041232 3C          0129*       inc a ; we're on emulator
041233 32 45 12 04 0130*       ld (is_emulator),a
041237 01 FF 2C 00 0131*       ld bc,prt_reload_emulator
04123B ED 43 E2 11 0132*       ld (prt_reload),bc
       04          
041240 21 5C 12 04 0133*       ld hl,on_emulator
041244 C9          0134*       ret
041245 00          0135*   is_emulator: db 0
041246 52 75 6E 6E 0136*   on_hardware: defb "Running on hardware\r\n",0
       69 6E 67 20 
       6F 6E 20 68 
       61 72 64 77 
       61 72 65 0D 
       0A 00       
04125C 52 75 6E 6E 0137*   on_emulator: defb "Running on emulator\r\n",0
       69 6E 67 20 
       6F 6E 20 65 
       6D 75 6C 61 
       74 6F 72 0D 
       0A 00       
041272             0138*   
041272 43 61 6C 69 0139*   calibrating_timer: defb "Calibrating timer\r\n",0
       62 72 61 74 
       69 6E 67 20 
       74 69 6D 65 
       72 0D 0A 00 
041286             0140*   
041286             0141*   ; set PRT timer
041286             0142*   prt_set:
041286 21 00 00 00 0143*       ld hl,0
04128A 22 D4 12 04 0144*       ld (prt_irq_counter),hl
04128E 2A E2 11 04 0145*       ld hl,(prt_reload)
041292 ED 29 84    0146*       out0 (TMR1_CTL+TMR_RES_LOW),l
041295 ED 21 85    0147*   	out0 (TMR1_CTL+TMR_RES_HIGH),h
041298             0148*   ; disable timer
041298 3E 06       0149*       ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
04129A ED 39 83    0150*   	out0 (TMR1_CTL+TMR_REG_CTL),a
04129D             0151*   ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
04129D 3E 57       0152*       ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
04129F ED 39 83    0153*   	out0 (TMR1_CTL+TMR_REG_CTL),a
0412A2 C9          0154*       ret
0412A3             0155*   
0412A3             0156*   ; ===============================================
0412A3             0157*   ; PRT Timer Interrupt Handling
0412A3             0158*   ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.asm
0412A3             0159*   ; -----------------------------------------------
0412A3             0160*   prt_irq_init:
0412A3             0161*       ; set up interrupt vector table 2
0412A3 21 00 00 00 0162*   	ld hl,0
0412A7 3A 0C 01 00 0163*   	ld a,($10c)
0412AB 6F          0164*   	ld l,a
0412AC 3A 0D 01 00 0165*   	ld a,($10d)
0412B0 67          0166*   	ld h,a
0412B1             0167*   
0412B1             0168*   	; skip over CALL ($c3)
0412B1 23          0169*   	inc hl
0412B2             0170*   	; load address of jump into vector table 2 (in ram)
0412B2 ED 27       0171*   	ld hl,(hl)
0412B4             0172*   
0412B4             0173*   	; write CALL prt_irq_handler to vector table 2
0412B4 3E C3       0174*   	ld a,$c3
0412B6 77          0175*   	ld (hl),a
0412B7 23          0176*   	inc hl
0412B8 11 BF 12 04 0177*   	ld de,prt_irq_handler
0412BC ED 1F       0178*   	ld (hl),de
0412BE             0179*   
0412BE C9          0180*       ret
0412BF             0181*   
0412BF             0182*   prt_irq_handler:
0412BF F3          0183*   	di
0412C0 F5          0184*   	push af
0412C1 E5          0185*       push hl
0412C2 ED 38 83    0186*   	in0 a,(TMR1_CTL+TMR_REG_CTL)
0412C5 2A D4 12 04 0187*   	ld hl,(prt_irq_counter)
0412C9 23          0188*   	inc hl
0412CA 22 D4 12 04 0189*   	ld (prt_irq_counter),hl
0412CE E1          0190*       pop hl
0412CF F1          0191*   	pop af
0412D0 FB          0192*   	ei
0412D1 5B ED 4D    0193*   	reti.l
0412D4             0194*   
0412D4             0195*   prt_irq_counter:
0412D4 00 00 00    0196*   	.dl 0
0412D7             0197*   prt_irq_counter_saved:
0412D7 00 00 00    0198*       .dl 0
0412DA             0199*   
0412DA             0200*   prt_loop_reset:
0412DA E5          0201*       push hl
0412DB 21 00 00 00 0202*   	ld hl,0
0412DF 22 D4 12 04 0203*   	ld (prt_irq_counter),hl
0412E3 22 45 13 04 0204*       ld (prt_loop_counter),hl
0412E7 22 48 13 04 0205*       ld (prt_loops),hl
0412EB CD 86 12 04 0206*       call prt_set
0412EF E1          0207*       pop hl
0412F0 C9          0208*       ret
0412F1             0209*   
0412F1             0210*   prt_loop_start:
0412F1 E5          0211*       push hl
0412F2 21 00 00 00 0212*   	ld hl,0
0412F6 22 D4 12 04 0213*   	ld (prt_irq_counter),hl
0412FA E1          0214*       pop hl
0412FB C9          0215*       ret
0412FC             0216*   
0412FC             0217*   prt_loop_stop:
0412FC E5          0218*       push hl
0412FD D5          0219*       push de
0412FE 2A D4 12 04 0220*       ld hl,(prt_irq_counter)
041302 ED 5B 45 13 0221*       ld de,(prt_loop_counter)
       04          
041307 19          0222*       add hl,de
041308 22 45 13 04 0223*       ld (prt_loop_counter),hl
04130C 21 00 00 00 0224*       ld hl,0
041310 22 D4 12 04 0225*       ld (prt_irq_counter),hl
041314 2A 48 13 04 0226*       ld hl,(prt_loops)
041318 23          0227*       inc hl
041319 22 48 13 04 0228*       ld (prt_loops),hl
04131D D1          0229*       pop de
04131E E1          0230*       pop hl
04131F C9          0231*       ret
041320             0232*   
041320             0233*   ; inputs: bc = y,x text coordinates to print
041320             0234*   prt_loop_print:
041320 F5          0235*       push af
041321 E5          0236*       push hl
041322 C5          0237*       push bc
041323 D5          0238*       push de
041324 DD E5       0239*       push ix
041326 FD E5       0240*       push iy
041328 CD 2C 14 04 0241*       call vdu_move_cursor
04132C             0242*   
04132C 2A 45 13 04 0243*       ld hl,(prt_loop_counter)
041330 CD CC 00 04 0244*       call printDec
041334             0245*   
041334 2A 48 13 04 0246*       ld hl,(prt_loops)
041338 CD CC 00 04 0247*       call printDec
04133C             0248*   
04133C FD E1       0249*       pop iy
04133E DD E1       0250*       pop ix
041340 D1          0251*       pop de
041341 C1          0252*       pop bc
041342 E1          0253*       pop hl
041343 F1          0254*       pop af
041344 C9          0255*       ret
041345             0256*   
041345             0257*   prt_loop_counter:
041345 00 00 00    0258*       .dl 0
041348             0259*   prt_loops:
041348 00 00 00    0260*       .dl 0
04134B             0261*   
04134B             0262*   ; ===============================================
04134B             0263*   ; Timer functions
04134B             0264*   ; -----------------------------------------------
04134B             0265*   ; set a countdown timer
04134B             0266*   ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
04134B             0267*   ; returns: hl = current time
04134B             0268*   tmr_set:
04134B FD 2F 03    0269*       ld (iy+3),hl            ; set time remaining
04134E             0270*       MOSCALL mos_sysvars     ; ix points to syvars table
04134E 3E 08       0001*M1 			LD	A, function
041350 5B CF       0002*M1 			RST.LIL	08h
041352 DD 27 00    0271*       ld hl,(ix+sysvar_time)  ; get current time
041355 FD 2F 00    0272*       ld (iy+0),hl            ; set start time
041358 C9          0273*       ret
041359             0274*   
041359             0275*   ; gets time remaining on a countdown timer
041359             0276*   ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
041359             0277*   ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
041359             0278*   ;          sign flags: pos = time not expired,zero or neg = time expired
041359             0279*   tmr_get:
041359             0280*       MOSCALL mos_sysvars     ; ix points to syvars table
041359 3E 08       0001*M1 			LD	A, function
04135B 5B CF       0002*M1 			RST.LIL	08h
04135D DD 17 00    0281*       ld de,(ix+sysvar_time)  ; get current time
041360 FD 27 00    0282*       ld hl,(iy+0)            ; get start time
041363 AF          0283*       xor a                   ; clear carry
041364 ED 52       0284*       sbc hl,de               ; hl = time elapsed (will always be zero or negative)
041366 FD 17 03    0285*       ld de,(iy+3)            ; get timer set value
041369 AF          0286*       xor a                   ; clear carry
04136A ED 5A       0287*       adc hl,de               ; hl = time remaining
04136C             0288*                               ; (we do adc because add hl,rr doesn't set sign or zero flags)
04136C C9          0289*       ret
04136D             0290*   
04136D             0291*   tmr_test: ds 6 ; example of a buffer to hold timer data
041373             0292*   
       FF FF FF FF 
       FF FF 
041373 00 00 00    0293*   timestamp_now: dl 0
041376 00 00 00    0294*   timestamp_old: dl 0
041379 00 00 00    0295*   timestamp_chg: dl 0
04137C             0296*   
04137C             0297*   ; update the global timestamp from the system clock
04137C             0298*   ; inputs: none
04137C             0299*   ; returns: hl = time elapsed in 1/120ths of a second
04137C             0300*   ;          de = current time
04137C             0301*   ;          ix = pointer to syvars table
04137C             0302*   ; destroys: af,hl,de,ix
04137C             0303*   timestamp_tick:
04137C ED 5B 73 13 0304*       ld de,(timestamp_now)   ; get previous time
       04          
041381 ED 53 76 13 0305*       ld (timestamp_old),de   ; save previous time
       04          
041386             0306*       MOSCALL mos_sysvars     ; ix points to syvars table
041386 3E 08       0001*M1 			LD	A, function
041388 5B CF       0002*M1 			RST.LIL	08h
04138A DD 27 00    0307*       ld hl,(ix+sysvar_time)  ; get current time
04138D 22 73 13 04 0308*       ld (timestamp_now),hl   ; save current time
041391 AF          0309*       xor a                   ; clear carry
041392 ED 52       0310*       sbc hl,de               ; hl = time elapsed
041394 22 79 13 04 0311*       ld (timestamp_chg),hl   ; save elapsed time
041398 C9          0312*       ret
041399             0313*   
041399             0314*   ; set a countdown timer
041399             0315*   ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
041399             0316*   ; requires: timestamp_tick to be called at least once before this function
041399             0317*   ; returns: hl = current time
041399             0318*   ; destroys: hl
041399             0319*   timestamp_tmr_set:
041399 FD 2F 03    0320*       ld (iy+3),hl            ; set time remaining
04139C 2A 73 13 04 0321*       ld hl,(timestamp_now)   ; get current timestamp
0413A0 FD 2F 00    0322*       ld (iy+0),hl            ; set start time
0413A3 C9          0323*       ret
0413A4             0324*   
0413A4             0325*   ; gets time remaining on a countdown timer following the global timestamp
0413A4             0326*   ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0413A4             0327*   ; requires: timestamp_tick to be called at least once before this function
0413A4             0328*   ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0413A4             0329*   ;          sign flags: pos = time not expired,zero or neg = time expired
0413A4             0330*   ; destroys: af,hl,de
0413A4             0331*   timestamp_tmr_get:
0413A4 ED 5B 73 13 0332*       ld de,(timestamp_now)   ; get current timestamp
       04          
0413A9 FD 27 00    0333*       ld hl,(iy+0)            ; get start time
0413AC AF          0334*       xor a                   ; clear carry
0413AD ED 52       0335*       sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0413AF FD 17 03    0336*       ld de,(iy+3)            ; get timer set value
0413B2 AF          0337*       xor a                   ; clear carry
0413B3 ED 5A       0338*       adc hl,de               ; hl = time remaining
0413B5             0339*                               ; (we do adc because add hl,rr doesn't set sign or zero flags)
0413B5 C9          0340*       ret
0413B6             0341*   
0413B6             0342*   ; set a stopwatch
0413B6             0343*   ; returns: hl = start time
0413B6             0344*   ; destroys: hl,ix
0413B6             0345*   stopwatch_set:
0413B6             0346*       MOSCALL mos_sysvars     ; ix points to syvars table
0413B6 3E 08       0001*M1 			LD	A, function
0413B8 5B CF       0002*M1 			RST.LIL	08h
0413BA DD 27 00    0347*       ld hl,(ix+sysvar_time)  ; get current time
0413BD 22 D2 13 04 0348*       ld (stopwatch_started),hl            ; set start time
0413C1 C9          0349*       ret
0413C2             0350*   
0413C2             0351*   ; gets time elapsed on a stopwatch
0413C2             0352*   ; returns: hl = time elapsed in 1/120ths of a second
0413C2             0353*   ; destroys: af,hl,de,ix
0413C2             0354*   stopwatch_get:
0413C2             0355*       MOSCALL mos_sysvars     ; ix points to syvars table
0413C2 3E 08       0001*M1 			LD	A, function
0413C4 5B CF       0002*M1 			RST.LIL	08h
0413C6 DD 27 00    0356*       ld hl,(ix+sysvar_time)  ; get current time
0413C9 ED 5B D2 13 0357*       ld de,(stopwatch_started)            ; get start time
       04          
0413CE AF          0358*       xor a                   ; clear carry
0413CF ED 52       0359*       sbc hl,de               ; hl = time elapsed (will always be zero or positive)
0413D1 C9          0360*       ret
0413D2             0361*   
0413D2             0362*   stopwatch_started: ds 3 ; buffer to hold stopwatch start time
0413D5             0363*   
0413D5             0364*   ; ------------------
0413D5             0365*   ; delay routine
0413D5             0366*   ; Author: Richard Turrnidge
0413D5             0367*   ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.asm
0413D5             0368*   ; routine waits a fixed time,then returns
0413D5             0369*   ; arrive with A =  the delay byte. One bit to be set only.
0413D5             0370*   ; eg. ld A,00000100b
0413D5             0371*   
0413D5             0372*   multiPurposeDelay:
       FF FF FF 
0413D5 F5          0373*       push af
0413D6 C5          0374*       push bc
0413D7 DD E5       0375*       push ix
0413D9 47          0376*       ld b,a
0413DA 3E 08       0377*       ld a,$08
0413DC 5B CF       0378*       RST.LIL	08h                 ; get IX pointer to sysvars
0413DE             0379*   
0413DE             0380*   waitLoop:
0413DE             0381*   
0413DE DD 7E 00    0382*       ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
0413E1             0383*   
0413E1             0384*                                   ;   we check if bit set is same as last time we checked.
0413E1             0385*                                   ;   bit 0 - don't use
0413E1             0386*                                   ;   bit 1 - changes 64 times per second
0413E1             0387*                                   ;   bit 2 - changes 32 times per second
0413E1             0388*                                   ;   bit 3 - changes 16 times per second
0413E1             0389*   
0413E1             0390*                                   ;   bit 4 - changes 8 times per second
0413E1             0391*                                   ;   bit 5 - changes 4 times per second
0413E1             0392*                                   ;   bit 6 - changes 2 times per second
0413E1             0393*                                   ;   bit 7 - changes 1 times per second
0413E1 A0          0394*       and b
0413E2 4F          0395*       ld c,a
0413E3 3A F4 13 04 0396*       ld a,(oldTimeStamp)
0413E7 B9          0397*       cp c                        ; is A same as last value?
0413E8 28 F4       0398*       jr z,waitLoop              ; loop here if it is
0413EA 79          0399*       ld a,c
0413EB 32 F4 13 04 0400*       ld (oldTimeStamp),a        ; set new value
0413EF             0401*   
0413EF DD E1       0402*       pop ix
0413F1 C1          0403*       pop bc
0413F2 F1          0404*       pop af
0413F3 C9          0405*       ret
0413F4             0406*   
0413F4 00          0407*   oldTimeStamp:   .db 00h
0413F5             0040        include "vdu.inc"
0413F5             0001*   ; VDU 30: Home cursor
0413F5             0002*   vdu_home_cursor:
0413F5 3E 1E       0003*       ld a,30
0413F7 5B D7       0004*   	rst.lil $10
0413F9 C9          0005*   	ret
0413FA             0006*   
0413FA             0007*   vdu_cursor_on:
0413FA 21 05 14 04 0008*   	ld hl,@cmd
0413FE 01 03 00 00 0009*   	ld bc,@end-@cmd
041402 5B DF       0010*   	rst.lil $18
041404 C9          0011*   	ret
041405             0012*   @cmd:
041405 17 01 01    0013*   	db 23,1,1
041408             0014*   @end:
041408             0015*   
041408             0016*   vdu_cursor_off:
041408 21 13 14 04 0017*   	ld hl,@cmd
04140C 01 03 00 00 0018*   	ld bc,@end-@cmd
041410 5B DF       0019*   	rst.lil $18
041412 C9          0020*   	ret
041413             0021*   @cmd:
041413 17 01 00    0022*   	db 23,1,0
041416             0023*   @end:
041416             0024*   
041416             0025*   ; VDU 5: Write text at graphics cursor
041416             0026*   ; inputs: a is the character to write to the screen
041416             0027*   ; prerequisites: the graphics cursor at the intended position on screen
041416             0028*   ; outputs: see the name of the function
041416             0029*   ; destroys: a, hl, bc
041416             0030*   vdu_char_to_gfx_cursor:
041416 32 26 14 04 0031*   	ld (@arg),a
04141A 21 25 14 04 0032*   	ld hl,@cmd
04141E 01 02 00 00 0033*   	ld bc,@end-@cmd
041422 5B DF       0034*   	rst.lil $18
041424 C9          0035*   	ret
041425 05          0036*   @cmd: db 5
041426 00          0037*   @arg: db 0
041427             0038*   @end:
041427             0039*   ; VDU 9: Move cursor forward one character
041427             0040*   vdu_cursor_forward:
041427 3E 09       0041*       ld a,9
041429 5B D7       0042*   	rst.lil $10
04142B C9          0043*   	ret
04142C             0044*   
04142C             0045*   ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
04142C             0046*   ; inputs: c=x, b=y 8-bit unsigned integers
04142C             0047*   vdu_move_cursor:
04142C ED 43 3D 14 0048*       ld (@x0),bc
       04          
041431 21 3C 14 04 0049*   	ld hl,@cmd
041435 01 03 00 00 0050*   	ld bc,@end-@cmd
041439 5B DF       0051*   	rst.lil $18
04143B C9          0052*   	ret
04143C 1F          0053*   @cmd: 	db 31
04143D 00          0054*   @x0:	db 0
04143E 00          0055*   @y0: 	db 0
04143F 00          0056*   @end: 	db 0 ; padding
041440             0057*   
041440             0058*   ; VDU 12: Clear text area (CLS)
041440             0059*   vdu_cls:
041440 3E 0C       0060*       ld a,12
041442 5B D7       0061*   	rst.lil $10
041444 C9          0062*   	ret
041445             0063*   
041445             0064*   vdu_flip:
041445 21 50 14 04 0065*   	ld hl,@cmd
041449 01 03 00 00 0066*   	ld bc,@end-@cmd
04144D 5B DF       0067*   	rst.lil $18
04144F C9          0068*   	ret
041450 17 00 C3    0069*   @cmd: db 23,0,0xC3
041453             0070*   @end:
041453             0071*   
041453             0072*   ; VDU 16: Clear graphics area (CLG)
041453             0073*   vdu_clg:
041453 3E 10       0074*       ld a,16
041455 5B D7       0075*   	rst.lil $10
041457 C9          0076*   	ret
041458             0077*   
041458             0078*   ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
041458             0079*   ; VDU 23, 7: Scrolling
041458             0080*   ;     VDU 23, 7, extent, direction, speed: Scroll the screen
041458             0081*   ; inputs: a, extent; l, direction; h; speed
041458             0082*   vdu_scroll_down:
041458 32 6D 14 04 0083*   	ld (@extent),a
04145C 22 6E 14 04 0084*   	ld (@dir),hl ; implicitly populates @speed
041460 21 6B 14 04 0085*   	ld hl,@cmd
041464 01 05 00 00 0086*   	ld bc,@end-@cmd
041468 5B DF       0087*   	rst.lil $18     ;; Sending command to VDP
04146A C9          0088*   	ret
04146B 17 07       0089*   @cmd:       db 23,7
04146D 00          0090*   @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
04146E 00          0091*   @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
04146F 00          0092*   @speed:     db 0x00 ; pixels
041470 00          0093*   @end:		db 0x00 ; padding
041471             0094*   
041471             0095*   ; COLOUR MODES
041471             0096*   ; Mode	Effect
041471             0097*   ; 0	Set on-screen pixel to target colour value
041471             0098*   ; 1	OR value with the on-screen pixel
041471             0099*   ; 2	AND value with the on-screen pixel
041471             0100*   ; 3	XOR value with the on-screen pixel
041471             0101*   ; 4	Invert the on-screen pixel
041471             0102*   ; 5	No operation
041471             0103*   ; 6	AND the inverse of the specified colour with the on-screen pixel
041471             0104*   ; 7	OR the inverse of the specified colour with the on-screen pixel
041471             0105*   
041471             0106*   ; VDU 17, colour: Define text colour (COLOUR)
041471             0107*   vdu_colour_text:
041471 32 81 14 04 0108*   	ld (@arg),a
041475 21 80 14 04 0109*   	ld hl,@cmd
041479 01 02 00 00 0110*   	ld bc,@end-@cmd
04147D 5B DF       0111*   	rst.lil $18
04147F C9          0112*   	ret
041480 11          0113*   @cmd: db 17
041481 00          0114*   @arg: db 0
041482             0115*   @end:
041482             0116*   
041482             0117*   ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
041482             0118*   ; inputs: a=mode, c=colour (add 128 to set background colour)
041482             0119*   vdu_gcol:
041482 32 97 14 04 0120*   	ld (@mode),a
041486 79          0121*       ld a,c
041487 32 98 14 04 0122*       ld (@col),a
04148B 21 96 14 04 0123*   	ld hl,@cmd
04148F 01 03 00 00 0124*   	ld bc,@end-@cmd
041493 5B DF       0125*   	rst.lil $18
041495 C9          0126*   	ret
041496 12          0127*   @cmd:  db 18
041497 00          0128*   @mode: db 0
041498 00          0129*   @col:  db 0
041499             0130*   @end:
041499             0131*   
041499             0132*   
041499             0133*   ; VDU 28, left, bottom, right, top: Set text viewport **
041499             0134*   ; MIND THE LITTLE-ENDIANESS
041499             0135*   ; inputs: c=left,b=bottom,e=right,d=top
041499             0136*   ; outputs; nothing
041499             0137*   ; destroys: a might make it out alive
041499             0138*   vdu_set_txt_viewport:
041499 ED 43 AF 14 0139*       ld (@lb),bc
       04          
04149E ED 53 B1 14 0140*   	ld (@rt),de
       04          
0414A3 21 AE 14 04 0141*   	ld hl,@cmd
0414A7 01 05 00 00 0142*   	ld bc,@end-@cmd
0414AB 5B DF       0143*   	rst.lil $18
0414AD C9          0144*   	ret
0414AE 1C          0145*   @cmd:   db 28 ; set text viewport command
0414AF 00 00       0146*   @lb: 	dw 0x0000 ; set by bc
0414B1 00 00       0147*   @rt: 	dw 0x0000 ; set by de
0414B3 00          0148*   @end:   db 0x00	  ; padding
0414B4             0149*   
0414B4             0150*   ; Wait for VBLANK interrupt
0414B4             0151*   vdu_vblank:
0414B4 DD E5       0152*       PUSH 	IX
0414B6             0153*   	MOSCALL	mos_sysvars
0414B6 3E 08       0001*M1 			LD	A, function
0414B8 5B CF       0002*M1 			RST.LIL	08h
0414BA DD 7E 00    0154*   	LD	A, (IX + sysvar_time + 0)
0414BD             0155*   @wait:
0414BD DD BE 00    0156*       CP 	A, (IX + sysvar_time + 0)
0414C0 28 FB       0157*       JR	Z, @wait
0414C2 DD E1       0158*       POP	IX
0414C4 C9          0159*       RET
0414C5             0160*   
0414C5             0161*   ; VDU 29, x; y;: Set graphics origin
0414C5             0162*   ; This command sets the graphics origin.
0414C5             0163*   ; The origin is the point on the screen where the coordinates (0,0) are located.
0414C5             0164*   ; inputs: bc=x0,de=y0
0414C5             0165*   ; outputs; nothing
0414C5             0166*   ; destroys: a might make it out alive
0414C5             0167*   vdu_set_gfx_origin:
0414C5 ED 43 DB 14 0168*       ld (@x0),bc
       04          
0414CA ED 53 DD 14 0169*       ld (@y0),de
       04          
0414CF 21 DA 14 04 0170*       ld hl,@cmd
0414D3 01 05 00 00 0171*       ld bc,@end-@cmd
0414D7 5B DF       0172*       rst.lil $18
0414D9 C9          0173*       ret
0414DA 1D          0174*   @cmd:   db 29 ; set graphics origin command
0414DB 00 00       0175*   @x0: 	dw 0x0000 ; set by bc
0414DD 00 00       0176*   @y0: 	dw 0x0000 ; set by de
0414DF 00          0177*   @end:   db 0x00	  ; padding
0414E0             0178*   
0414E0             0179*   ; VDU 24, left; bottom; right; top;: Set graphics viewport
0414E0             0180*   ; NOTE: the order of the y-coordinate parameters are inverted
0414E0             0181*   ; 	because we have turned off logical screen scaling
0414E0             0182*   ; NOTE: coordinates are relative to current gfx origin
0414E0             0183*   ; inputs: bc=x0,de=y0,ix=x1,iy=y1
0414E0             0184*   ; outputs; nothing
0414E0             0185*   ; destroys: a might make it out alive
0414E0             0186*   vdu_set_gfx_viewport:
0414E0 ED 43 00 15 0187*       ld (@x0),bc
       04          
0414E5 FD 22 02 15 0188*       ld (@y1),iy
       04          
0414EA DD 22 04 15 0189*   	ld (@x1),ix
       04          
0414EF ED 53 06 15 0190*   	ld (@y0),de
       04          
0414F4 21 FF 14 04 0191*   	ld hl,@cmd
0414F8 01 09 00 00 0192*   	ld bc,@end-@cmd
0414FC 5B DF       0193*   	rst.lil $18
0414FE C9          0194*   	ret
0414FF 18          0195*   @cmd:   db 24 ; set graphics viewport command
041500 00 00       0196*   @x0: 	dw 0x0000 ; set by bc
041502 00 00       0197*   @y1: 	dw 0x0000 ; set by iy
041504 00 00       0198*   @x1: 	dw 0x0000 ; set by ix
041506 00 00       0199*   @y0: 	dw 0x0000 ; set by de
041508 00          0200*   @end:   db 0x00	  ; padding
041509             0201*   
041509             0202*   ; VDU 26: Reset graphics and text viewports
041509             0203*   vdu_reset_viewports:
041509 3E 1A       0204*       ld a,26
04150B 5B D7       0205*       rst.lil $10
04150D C9          0206*       ret
04150E             0207*   
04150E             0208*   ; SCREEN MODES
04150E             0209*   ; ===============================
04150E             0210*   ; Mode  Horz  Vert  Cols  Refresh
04150E             0211*   ; ---   ----  ----  ----  -------
04150E             0212*   ; 11    320   240   2     60hz
04150E             0213*   ; 139   320   240   2     60hz
04150E             0214*   ; 23    512   384   2     60hz
04150E             0215*   ; 151   512   384   2     60hz
04150E             0216*   ; 6     640   240   2     60hz
04150E             0217*   ; 134   640   240   2     60hz
04150E             0218*   ; 2     640   480   2     60hz
04150E             0219*   ; 130   640   480   2     60hz
04150E             0220*   ; 17    800   600   2     60hz
04150E             0221*   ; 145   800   600   2     60hz
04150E             0222*   ; 18    1024  768   2     60hz
04150E             0223*   ; 146   1024  768   2     60hz
04150E             0224*   ; ---   ----  ----  ----  -------
04150E             0225*   ; 10    320   240   4     60hz
04150E             0226*   ; 138   320   240   4     60hz
04150E             0227*   ; 22    512   384   4     60hz
04150E             0228*   ; 150   512   384   4     60hz
04150E             0229*   ; 5     640   240   4     60hz
04150E             0230*   ; 133   640   240   4     60hz
04150E             0231*   ; 1     640   480   4     60hz
04150E             0232*   ; 129   640   480   4     60hz
04150E             0233*   ; 16    800   600   4     60hz
04150E             0234*   ; 19    1024  768   4     60hz
04150E             0235*   ; ---   ----  ----  ----  -------
04150E             0236*   ; 9     320   240   16    60hz
04150E             0237*   ; 137   320   240   16    60hz
04150E             0238*   ; 21    512   384   16    60hz
04150E             0239*   ; 149   512   384   16    60hz
04150E             0240*   ; 4     640   240   16    60hz
04150E             0241*   ; 132   640   240   16    60hz
04150E             0242*   ; 0     640   480   16    60hz
04150E             0243*   ; 7     n/a   n/a   16    60hz
04150E             0244*   ; ---   ----  ----  ----  -------
04150E             0245*   ; 8     320   240   64    60hz
04150E             0246*   ; 136   320   240   64    60hz
04150E             0247*   ; 20    512   384   64    60hz
04150E             0248*   ; 3     640   240   64    60hz
04150E             0249*   ; ---   ----  ----  ----  -------
04150E             0250*   vdu_set_screen_mode:
04150E 32 1E 15 04 0251*   	ld (@arg),a
041512 21 1D 15 04 0252*   	ld hl,@cmd
041516 01 02 00 00 0253*   	ld bc,@end-@cmd
04151A 5B DF       0254*   	rst.lil $18
04151C C9          0255*   	ret
04151D 16          0256*   @cmd: db 22 ; set screen mode
04151E 00          0257*   @arg: db 0  ; screen mode parameter
04151F             0258*   @end:
04151F             0259*   
04151F             0260*   ; get the current screen mode
04151F             0261*   ; inputs: none
04151F             0262*   ; outputs: a=screen mode
04151F             0263*   ; destroys: af, ix
04151F             0264*   vdu_get_screen_mode:
04151F             0265*       MOSCALL mos_sysvars
04151F 3E 08       0001*M1 			LD	A, function
041521 5B CF       0002*M1 			RST.LIL	08h
041523 DD 7E 27    0266*       ld a,(IX+sysvar_scrMode)
041526 C9          0267*       ret
041527             0268*   ; end vdu_get_screen_mode
041527             0269*   
041527             0270*   ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
041527             0271*   ; inputs: a is scaling mode, 1=on, 0=off
041527             0272*   ; note: default setting on boot is scaling ON
041527             0273*   vdu_set_scaling:
041527 32 39 15 04 0274*   	ld (@arg),a
04152B 21 36 15 04 0275*   	ld hl,@cmd
04152F 01 04 00 00 0276*   	ld bc,@end-@cmd
041533 5B DF       0277*   	rst.lil $18
041535 C9          0278*   	ret
041536 17 00 C0    0279*   @cmd: db 23,0,0xC0
041539 00          0280*   @arg: db 0  ; scaling on/off
04153A             0281*   @end:
04153A             0282*   
04153A             0283*   ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
04153A             0284*   ; inputs: hl=bufferId
04153A             0285*   vdu_buff_select:
04153A 22 4C 15 04 0286*   	ld (@bufferId),hl
04153E 21 49 15 04 0287*   	ld hl,@cmd
041542 01 05 00 00 0288*   	ld bc,@end-@cmd
041546 5B DF       0289*   	rst.lil $18
041548 C9          0290*   	ret
041549 17 1B 20    0291*   @cmd: db 23,27,0x20
04154C 00 00       0292*   @bufferId: dw 0x0000
04154E 00          0293*   @end: db 0x00 ; padding
04154F             0294*   
04154F             0295*   ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
04154F             0296*   ; inputs: a=format; bc=width; de=height
04154F             0297*   ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
04154F             0298*   ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
04154F             0299*   ; 0 	RGBA8888 (4-bytes per pixel)
04154F             0300*   ; 1 	RGBA2222 (1-bytes per pixel)
04154F             0301*   ; 2 	Mono/Mask (1-bit per pixel)
04154F             0302*   ; 3 	Reserved for internal use by VDP (â€œnativeâ€ format)
04154F             0303*   vdu_bmp_create:
04154F ED 43 6B 15 0304*       ld (@width),bc
       04          
041554 ED 53 6D 15 0305*       ld (@height),de
       04          
041559 32 6F 15 04 0306*       ld (@fmt),a
04155D 21 68 15 04 0307*   	ld hl,@cmd
041561 01 08 00 00 0308*   	ld bc,@end-@cmd
041565 5B DF       0309*   	rst.lil $18
041567 C9          0310*   	ret
041568 17 1B 21    0311*   @cmd:       db 23,27,0x21
04156B 00 00       0312*   @width:     dw 0x0000
04156D 00 00       0313*   @height:    dw 0x0000
04156F 00          0314*   @fmt:       db 0x00
041570             0315*   @end:
041570             0316*   
041570             0317*   ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
041570             0318*   ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
041570             0319*   vdu_load_img_rgba2_to_8:
041570             0320*   ; backup the target buffer id and image dimensions
041570 E5          0321*       push hl
041571 D5          0322*       push de
041572 C5          0323*       push bc
041573             0324*   ; load the rgba2 image to working buffer 65534
041573 21 FE FF 00 0325*       ld hl,65534 ; temporary working buffer id
041577 CD 4E 16 04 0326*   	call vdu_load_buffer_from_file
04157B             0327*   ; restore the image dimensions and target buffer id
04157B C1          0328*       pop bc
04157C D1          0329*       pop de
04157D E1          0330*       pop hl
04157E             0331*   ; fall through to vdu_rgba2_to_8
04157E             0332*   
04157E             0333*   ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
04157E             0334*   ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
04157E             0335*   ; the "expand bitmap" command is:
04157E             0336*   ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
04157E             0337*   ; and then to reverse the byte order to fix endian-ness:
04157E             0338*   ; VDU 23,0,&A0,targetBufferID%;24,4,4;
04157E             0339*   ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
04157E             0340*   ; VDU 23,27,&20,targetBufferID%;
04157E             0341*   ; VDU 23,27,&21,width%;height%;0
04157E             0342*   ; -------------------------------------------------------------------
04157E             0343*   ; inputs: bc,de image width,height ; hl = targetBufferId
04157E             0344*   ; prerequisites: rgba2 image data loaded into workingBufferId 65534
04157E             0345*   vdu_rgba2_to_8:
04157E             0346*   ; load the image dimensions and buffer id parameters
04157E ED 43 DA 15 0347*       ld (@width),bc
       04          
041583 ED 53 DC 15 0348*       ld (@height),de
       04          
041588 22 BF 15 04 0349*       ld (@bufferId0),hl
04158C 22 CC 15 04 0350*       ld (@bufferId2),hl
041590 22 D5 15 04 0351*       ld (@bufferId1),hl
041594             0352*   ; clean up bytes that got stomped on by the ID loads
041594 3E 48       0353*       ld a,0x48
041596 32 C1 15 04 0354*       ld (@bufferId0+2),a
04159A 3E 17       0355*       ld a,23
04159C 32 D7 15 04 0356*       ld (@bufferId1+2),a
0415A0 3E 18       0357*       ld a,24
0415A2 32 CE 15 04 0358*       ld (@bufferId2+2),a
0415A6 AF          0359*       xor a
0415A7 32 DE 15 04 0360*       ld (@height+2),a
0415AB             0361*   ; send the vdu command strings
0415AB 21 B6 15 04 0362*       ld hl,@beg
0415AF 01 29 00 00 0363*       ld bc,@end-@beg
0415B3 5B DF       0364*       rst.lil $18
0415B5 C9          0365*       ret
0415B6             0366*   @beg:
0415B6             0367*   ; Command 14: Consolidate blocks in a buffer
0415B6             0368*   ; VDU 23, 0, &A0, bufferId; 14
0415B6 17 00 A0    0369*       db 23,0,0xA0
0415B9 FE FF       0370*       dw 65534 ; workingBufferId
0415BB 0E          0371*       db 14 ; consolidate blocks
0415BC             0372*   ; the "expand bitmap" command is:
0415BC             0373*   ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0415BC 17 00 A0    0374*       db 23,0,0xA0
0415BF 00 00       0375*   @bufferId0: dw 0x0000 ; targetBufferId
0415C1 48          0376*       db 0x48 ; given as decimal command 72 in the docs
0415C2 02          0377*       db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
0415C3 FE FF       0378*       dw 65534 ; sourceBufferId
0415C5 00 7F BF FF 0379*       db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
0415C9             0380*   ; reverse the byte order to fix endian-ness:
0415C9             0381*   ; Command 24: Reverse the order of data of blocks within a buffer
0415C9             0382*   ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
0415C9             0383*   ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0415C9 17 00 A0    0384*       db 23,0,0xA0
0415CC 00 00       0385*   @bufferId2:    dw 0x0000 ; targetBufferId
0415CE 18          0386*       db 24 ; reverse byte order
0415CF 04          0387*       db 4 ; option: Reverse data of the value size within chunk of data of the specified size
0415D0 04 00       0388*       dw 4 ; size (4 bytes)
0415D2             0389*   ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0415D2             0390*   ; VDU 23,27,&20,targetBufferID%;
0415D2 17 1B 20    0391*       db 23,27,0x20 ; select bitmap
0415D5 00 00       0392*   @bufferId1: dw 0x0000 ; targetBufferId
0415D7             0393*   ; VDU 23,27,&21,width%;height%;0
0415D7 17 1B 21    0394*       db 23,27,0x21 ; create bitmap from buffer
0415DA 00 00       0395*   @width: dw 0x0000
0415DC 00 00       0396*   @height: dw 0x0000
0415DE 00          0397*       db 0x00 ; rgba8888 format
0415DF             0398*   @end:
0415DF             0399*   
0415DF             0400*   ; scratch variables
0415DF 00 00 00    0401*   bufferId0: dl 0x000000
0415E2 00 00 00    0402*   bufferId1: dl 0x000000
0415E5             0403*   
0415E5             0404*   ; load a vdu buffer from local memory
0415E5             0405*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0415E5             0406*   vdu_load_buffer:
0415E5 ED 43 0E 16 0407*       ld (@length),bc
       04          
0415EA D5          0408*       push de ; save data pointer
0415EB             0409*   ; send the vdu command string
0415EB 7D          0410*       ld a,l
0415EC 32 0B 16 04 0411*       ld (@bufferId),a
0415F0 7C          0412*       ld a,h
0415F1 32 0C 16 04 0413*       ld (@bufferId+1),a
0415F5 21 08 16 04 0414*       ld hl,@cmd
0415F9 01 08 00 00 0415*       ld bc,@end-@cmd
0415FD 5B DF       0416*       rst.lil $18
0415FF             0417*   ; send the buffer data
0415FF E1          0418*       pop hl ; pointer to data
041600 ED 4B 0E 16 0419*       ld bc,(@length)
       04          
041605 5B DF       0420*       rst.lil $18 ; send it
041607 C9          0421*       ret
041608             0422*   ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041608 17 00 A0    0423*   @cmd:       db 23,0,0xA0
04160B 00 00       0424*   @bufferId:	dw 0x0000
04160D 00          0425*   		    db 0 ; load buffer
04160E 00 00       0426*   @length:	dw 0x0000
041610 00          0427*   @end: db 0 ; padding
041611             0428*   
041611             0429*   ; Command 14: Consolidate blocks in a buffer
041611             0430*   vdu_consolidate_buffer:
041611             0431*   ; set parameters for vdu call
041611 7D          0432*       ld a,l
041612 32 29 16 04 0433*       ld (@bufferId),a
041616 7C          0434*       ld a,h
041617 32 2A 16 04 0435*       ld (@bufferId+1),a
04161B 21 26 16 04 0436*       ld hl,@beg
04161F 01 06 00 00 0437*       ld bc,@end-@beg
041623 5B DF       0438*       rst.lil $18
041625 C9          0439*       ret
041626             0440*   ; VDU 23, 0, &A0, bufferId; 14
041626 17 00 A0    0441*   @beg: db 23,0,0xA0
041629 00 00       0442*   @bufferId: dw 0x0000
04162B 0E          0443*              db 14
04162C             0444*   @end:
04162C             0445*   
04162C             0446*   ; load an image file to a buffer and make it a bitmap
04162C             0447*   ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
04162C             0448*   vdu_load_img:
04162C             0449*   ; back up image type and dimension parameters
04162C 22 DF 15 04 0450*       ld (bufferId0),hl
041630 F5          0451*       push af
041631 C5          0452*   	push bc
041632 D5          0453*   	push de
041633             0454*   ; load the image
041633 CD 4E 16 04 0455*   	call vdu_load_buffer_from_file
041637             0456*   ; now make it a bitmap
041637 2A DF 15 04 0457*       ld hl,(bufferId0)
04163B CD 11 16 04 0458*       call vdu_consolidate_buffer
04163F 2A DF 15 04 0459*       ld hl,(bufferId0)
041643 CD 3A 15 04 0460*       call vdu_buff_select
041647 D1          0461*   	pop de ; image height
041648 C1          0462*   	pop bc ; image width
041649 F1          0463*   	pop af ; image type
04164A C3 4F 15 04 0464*   	jp vdu_bmp_create ; will return to caller from there
04164E             0465*   
04164E             0466*   ; inputs: hl = bufferId; iy = pointer to filename
04164E             0467*   vdu_load_buffer_from_file:
04164E 22 DF 15 04 0468*       ld (bufferId0),hl
041652             0469*   
041652             0470*   ; clear target buffer
041652 CD FA 17 04 0471*       call vdu_clear_buffer
041656             0472*   
041656             0473*   ; open the file in read mode
041656             0474*   ; Open a file
041656             0475*   ; HLU: Filename
041656             0476*   ;   C: Mode
041656             0477*   ; Returns:
041656             0478*   ;   A: Filehandle, or 0 if couldn't open
041656 FD E5       0479*   	push iy ; pointer to filename
041658 E1          0480*   	pop hl
041659 0E 01       0481*   	ld c,fa_read
04165B             0482*       MOSCALL mos_fopen
04165B 3E 0A       0001*M1 			LD	A, function
04165D 5B CF       0002*M1 			RST.LIL	08h
04165F 32 9A 16 04 0483*       ld (@filehandle),a
041663             0484*   
041663             0485*   @read_file:
041663             0486*   ; Read a block of data from a file
041663             0487*   ;   C: Filehandle
041663             0488*   ; HLU: Pointer to where to write the data to
041663             0489*   ; DEU: Number of bytes to read
041663             0490*   ; Returns:
041663             0491*   ; DEU: Number of bytes read
041663 3A 9A 16 04 0492*       ld a,(@filehandle)
041667 4F          0493*       ld c,a
041668 21 00 E0 B7 0494*       ld hl,filedata
04166C 11 00 20 00 0495*       ld de,8192 ; max we can read into onboard sram at one time
041670             0496*       MOSCALL mos_fread
041670 3E 1A       0001*M1 			LD	A, function
041672 5B CF       0002*M1 			RST.LIL	08h
041674             0497*   
041674             0498*   ; test de for zero bytes read
041674 21 00 00 00 0499*       ld hl,0
041678 AF          0500*       xor a ; clear carry
041679 ED 52       0501*       sbc hl,de
04167B CA 91 16 04 0502*       jp z,@close_file
04167F             0503*   
04167F             0504*   ; load a vdu buffer from local memory
04167F             0505*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
04167F 2A DF 15 04 0506*       ld hl,(bufferId0)
041683 D5          0507*       push de ; chunksize
041684 C1          0508*       pop bc
041685 11 00 E0 B7 0509*       ld de,filedata
041689 CD E5 15 04 0510*       call vdu_load_buffer
04168D             0511*   
04168D             0512*   ; read the next block
04168D C3 63 16 04 0513*       jp @read_file
041691             0514*   
041691             0515*   ; close the file
041691             0516*   @close_file:
041691 3A 9A 16 04 0517*       ld a,(@filehandle)
041695             0518*       MOSCALL mos_fclose
041695 3E 0B       0001*M1 			LD	A, function
041697 5B CF       0002*M1 			RST.LIL	08h
041699 C9          0519*       ret ; vdu_load_buffer_from_file
04169A             0520*   
04169A 00          0521*   @filehandle: db 0 ; file handle
04169B 00 00 00    0522*   @fil: dl 0 ; pointer to FIL struct
04169E             0523*   
04169E 00 00 00    0524*   @chunkpointer: dl 0 ; pointer to current chunk
0416A1             0525*   
0416A1             0526*   ; File information structure (FILINFO)
0416A1             0527*   @filinfo:
0416A1 00 00 00 00 0528*   @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
0416A5 00 00       0529*   @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
0416A7 00 00       0530*   @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
0416A9 00          0531*   @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
0416AA 00 00 00 00 0532*   @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
0416B7 00 00 00 00 0533*   @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0417B7             0041        include "vdu_buffered_api.inc"
0417B7             0001*   ; https://agonconsole8.github.io/agon-docs/vdp/Buffered-Commands-API/
0417B7             0002*   
0417B7             0003*   ; Command 0: Write block to a buffer
0417B7             0004*   ; VDU 23, 0, &A0, bufferId; 0, length; <buffer-data>
0417B7             0005*   ; inputs: hl = bufferId, bc = length of data, de = pointer to data
0417B7             0006*   vdu_write_block_to_buffer:
0417B7             0007*   ; back up input parameters
0417B7 D5          0008*       push de ; pointer to data
0417B8 C5          0009*       push bc ; length of data
0417B9             0010*   ; set up the vdu command string
0417B9 22 D9 17 04 0011*       ld (@bufferId),hl
0417BD ED 43 DC 17 0012*       ld (@length),bc
       04          
0417C2 AF          0013*       xor a ; load buffer
0417C3 32 DB 17 04 0014*       ld (@bufferId+2),a
0417C7 21 D6 17 04 0015*       ld hl,@cmd0
0417CB 01 08 00 00 0016*       ld bc,@end0-@cmd0
0417CF 5B DF       0017*       rst.lil $18
0417D1             0018*   ; send the buffer data
0417D1 C1          0019*       pop bc ; length of data
0417D2 E1          0020*       pop hl ; pointer to data (was de)
0417D3 5B DF       0021*       rst.lil $18 ; send it
0417D5 C9          0022*       ret
0417D6             0023*   ; command string data
0417D6 17 00 A0    0024*   @cmd0:      db 23,0,0xA0
0417D9 00 00       0025*   @bufferId:	dw 0x0000
0417DB 00          0026*               db 0 ; load buffer
0417DC 00 00       0027*   @length:	dw 0x0000
0417DE 00          0028*   @end0:      db 0x00 ; padding
0417DF             0029*   ; end vdu_write_block_to_buffer
0417DF             0030*   
0417DF             0031*   ; Command 1: Call a buffer
0417DF             0032*   ; VDU 23, 0, &A0, bufferId; 1
0417DF             0033*   ; inputs: hl = bufferId
0417DF             0034*   vdu_call_buffer:
0417DF 22 F7 17 04 0035*       ld (@bufferId),hl
0417E3 3E 01       0036*       ld a,1 ; call buffer
0417E5 32 F9 17 04 0037*       ld (@bufferId+2),a
0417E9 21 F4 17 04 0038*       ld hl,@cmd
0417ED 01 06 00 00 0039*       ld bc,@end-@cmd
0417F1 5B DF       0040*       rst.lil $18
0417F3 C9          0041*       ret
0417F4 17 00 A0    0042*   @cmd:     db 23,0,0xA0
0417F7 00 00       0043*   @bufferId: dw 0x0000
0417F9 01          0044*              db 1 ; call buffer
0417FA             0045*   @end:
0417FA             0046*   ; end vdu_call_buffer
0417FA             0047*   
0417FA             0048*   ; Command 2: Clear a buffer
0417FA             0049*   ; VDU 23, 0 &A0, bufferId; 2
0417FA             0050*   ; inputs: hl = bufferId
0417FA             0051*   vdu_clear_buffer:
0417FA 22 12 18 04 0052*       ld (@bufferId),hl
0417FE 3E 02       0053*       ld a,2 ; clear buffer
041800 32 14 18 04 0054*       ld (@bufferId+2),a
041804 21 0F 18 04 0055*       ld hl,@cmd
041808 01 06 00 00 0056*       ld bc,@end-@cmd
04180C 5B DF       0057*       rst.lil $18
04180E C9          0058*       ret
04180F 17 00 A0    0059*   @cmd:     db 23,0,0xA0
041812 00 00       0060*   @bufferId: dw 0x0000
041814 02          0061*              db 2 ; clear buffer
041815             0062*   @end:
041815             0063*   ; end vdu_clear_buffer
041815             0064*   
041815             0065*   ; Clear all buffers
041815             0066*   ; inputs: none
041815             0067*   vdu_clear_all_buffers:
041815             0068*   ; clear all buffers
041815 21 20 18 04 0069*       ld hl,@beg
041819 01 06 00 00 0070*       ld bc,@end-@beg
04181D 5B DF       0071*       rst.lil $18
04181F C9          0072*       ret
041820 17 00 A0    0073*   @beg: db 23,0,$A0
041823 FF FF       0074*         dw -1 ; bufferId -1 (65535) means clear all buffers
041825 02          0075*         db 2  ; command 2: clear a buffer
041826             0076*   @end:
041826             0077*   ; end vdu_clear_all_buffers
041826             0078*   
041826             0079*   ; Command 3: Create a writeable buffer
041826             0080*   ; VDU 23, 0 &A0, bufferId; 3, length;
041826             0081*   ; inputs: hl = bufferId, bc = length
041826             0082*   vdu_create_writeable_buffer:
041826 22 43 18 04 0083*       ld (@bufferId),hl
04182A ED 43 46 18 0084*       ld (@length),bc
       04          
04182F 3E 03       0085*       ld a,3 ; create writeable buffer
041831 32 45 18 04 0086*       ld (@bufferId+2),a
041835 21 40 18 04 0087*       ld hl,@cmd
041839 01 08 00 00 0088*       ld bc,@end-@cmd
04183D 5B DF       0089*       rst.lil $18
04183F C9          0090*       ret
041840 17 00 A0    0091*   @cmd:     db 23,0,0xA0
041843 00 00       0092*   @bufferId: dw 0x0000
041845 03          0093*              db 3 ; create writeable buffer
041846 00 00       0094*   @length: dw 0x0000
041848 00          0095*   @end:     db 0x00 ; padding
041849             0096*   ; end vdu_create_writeable_buffer
041849             0097*   
041849             0098*   ; Command 4: Set output stream to a buffer
041849             0099*   ; VDU 23, 0 &A0, bufferId; 4
041849             0100*   ; inputs: hl = bufferId
041849             0101*   vdu_set_output_stream_buffer:
041849 22 61 18 04 0102*       ld (@bufferId),hl
04184D 3E 04       0103*       ld a,4 ; set output stream to buffer
04184F 32 63 18 04 0104*       ld (@bufferId+2),a
041853 21 5E 18 04 0105*       ld hl,@cmd
041857 01 06 00 00 0106*       ld bc,@end-@cmd
04185B 5B DF       0107*       rst.lil $18
04185D C9          0108*       ret
04185E 17 00 A0    0109*   @cmd:     db 23,0,0xA0
041861 00 00       0110*   @bufferId: dw 0x0000
041863 04          0111*              db 4 ; set output stream to buffer
041864 00          0112*   @end:     db 0x00 ; padding
041865             0113*   ; end vdu_set_output_stream_buffer
041865             0114*   
041865             0115*   ; Command 5: Adjust buffer contents
041865             0116*   ; VDU 23, 0, &A0, bufferId; 5, operation, offset; [count;] <operand>, [arguments]
041865             0117*   vdu_adjust_buffer:
041865 C9          0118*       ret ; TODO: implement
041866             0119*   ; end vdu_adjust_buffer
041866             0120*   
041866             0121*   ; Command 6: Conditionally call a buffer
041866             0122*   ; VDU 23, 0, &A0, bufferId; 6, operation, checkBufferId; checkOffset; [arguments]
041866             0123*   vdu_call_buffer_conditional:
041866 C9          0124*       ret ; TODO: implement
041867             0125*   ; end vdu_call_buffer_conditional
041867             0126*   
041867             0127*   ; Command 7: Jump to a buffer
041867             0128*   ; VDU 23, 0, &A0, bufferId; 7
041867             0129*   ; inputs: hl = bufferId
041867             0130*   vdu_jump_to_buffer:
041867 22 7F 18 04 0131*       ld (@bufferId),hl
04186B 3E 07       0132*       ld a,7 ; jump to buffer
04186D 32 81 18 04 0133*       ld (@bufferId+2),a
041871 21 7C 18 04 0134*       ld hl,@cmd
041875 01 06 00 00 0135*       ld bc,@end-@cmd
041879 5B DF       0136*       rst.lil $18
04187B C9          0137*       ret
04187C 17 00 A0    0138*   @cmd:     db 23,0,0xA0
04187F 00 00       0139*   @bufferId: dw 0x0000
041881 07          0140*              db 7 ; jump to buffer
041882 00          0141*   @end:     db 0x00 ; padding
041883             0142*   ; end vdu_jump_to_buffer
041883             0143*   
041883             0144*   ; Command 8: Conditional Jump to a buffer
041883             0145*   ; VDU 23, 0, &A0, bufferId; 8, operation, checkBufferId; checkOffset; [arguments]
041883             0146*   vdu_jump_to_buffer_conditional:
041883 C9          0147*       ret ; TODO: implement
041884             0148*   ; end vdu_jump_to_buffer_conditional
041884             0149*   
041884             0150*   ; Command 9: Jump to an offset in a buffer
041884             0151*   ; VDU 23, 0, &A0, bufferId; 9, offset; offsetHighByte, [blockNumber;]
041884             0152*   vdu_jump_to_buffer_offset:
041884 C9          0153*       ret ; TODO: implement
041885             0154*   ; end vdu_jump_to_buffer_offset
041885             0155*   
041885             0156*   ; Command 10: Conditional jump to an offset in a buffer
041885             0157*   ; VDU 23, 0, &A0, bufferId; 10, offset; offsetHighByte, [blockNumber;] [arguments]
041885             0158*   vdu_jump_to_buffer_offset_conditional:
041885 C9          0159*       ret ; TODO: implement
041886             0160*   ; end vdu_jump_to_buffer_offset_conditional
041886             0161*   
041886             0162*   ; Command 11: Call buffer with an offset
041886             0163*   ; VDU 23, 0, &A0, bufferId; 11, offset; offsetHighByte, [blockNumber;]
041886             0164*   vdu_call_buffer_offset:
041886 C9          0165*       ret ; TODO: implement
041887             0166*   ; end vdu_call_buffer_offset
041887             0167*   
041887             0042        include "vdu_fonts.inc"
041887             0001*   ; select font
041887             0002*   ; inputs: hl = bufferId, a = font flags
041887             0003*   ; Flags:
041887             0004*   ; Bit	Description
041887             0005*   ; 0	Adjust cursor position to ensure text baseline is aligned
041887             0006*   ;   0: Do not adjust cursor position (best for changing font on a new line)
041887             0007*   ;   1: Adjust cursor position (best for changing font in the middle of a line)
041887             0008*   ; 1-7	Reserved for future use
041887             0009*   ; VDU 23, 0, &95, 0, bufferId; flags: Select font
041887             0010*   vdu_font_select:
041887 22 9E 18 04 0011*       ld (@bufferId),hl
04188B 32 A0 18 04 0012*       ld (@flags),a
04188F 21 9A 18 04 0013*       ld hl,@cmd
041893 01 07 00 00 0014*       ld bc,@end-@cmd
041897 5B DF       0015*       rst.lil $18
041899 C9          0016*       ret
04189A 17 00 95 00 0017*   @cmd: db 23, 0, 0x95, 0
04189E 00 00       0018*   @bufferId: dw 0x0000
0418A0 00          0019*   @flags: db 0x00
0418A1             0020*   @end:
0418A1             0021*   
0418A1             0022*   ; create font from buffer
0418A1             0023*   ; inputs: hl = bufferId, e = width, d = height, d = ascent, a = flags
0418A1             0024*   ; VDU 23, 0, &95, 1, bufferId; width, height, ascent, flags: Create font from buffer
0418A1             0025*   vdu_font_create:
0418A1 22 C6 18 04 0026*       ld (@bufferId),hl
0418A5 ED 53 C8 18 0027*       ld (@width),de ; also loads height
       04          
0418AA 32 CB 18 04 0028*       ld (@flags),a
0418AE 7A          0029*       ld a,d ; height
0418AF 32 CA 18 04 0030*       ld (@ascent),a ; ascent = height
0418B3             0031*   ; consolidate buffer
0418B3 CD 11 16 04 0032*       call vdu_consolidate_buffer
0418B7             0033*   ; create font
0418B7 21 C2 18 04 0034*       ld hl,@cmd
0418BB 01 0A 00 00 0035*       ld bc,@end-@cmd
0418BF 5B DF       0036*       rst.lil $18
0418C1 C9          0037*       ret
0418C2 17 00 95 01 0038*   @cmd: db 23, 0, 0x95, 1
0418C6 00 00       0039*   @bufferId: dw 0x0000
0418C8 00          0040*   @width: db 0x00
0418C9 00          0041*   @height: db 0x00
0418CA 00          0042*   @ascent: db 0x00
0418CB 00          0043*   @flags: db 0x00
0418CC             0044*   @end:
0418CC             0045*   
0418CC             0046*   ; set or adjust font property
0418CC             0047*   ; inputs: hl = bufferId, a = field, de = value
0418CC             0048*   ; VDU 23, 0, &95, 2, bufferId; field, value;: Set or adjust font property
0418CC             0049*   vdu_font_property:
0418CC 22 E8 18 04 0050*       ld (@bufferId),hl
0418D0 32 EA 18 04 0051*       ld (@field),a
0418D4 ED 53 EB 18 0052*       ld (@value),de
       04          
0418D9 21 E4 18 04 0053*       ld hl,@cmd
0418DD 01 09 00 00 0054*       ld bc,@end-@cmd
0418E1 5B DF       0055*       rst.lil $18
0418E3 C9          0056*       ret
0418E4 17 00 95 02 0057*   @cmd: db 23, 0, 0x95, 2
0418E8 00 00       0058*   @bufferId: dw 0x0000
0418EA 00          0059*   @field: db 0x00
0418EB 00 00       0060*   @value: dw 0x0000
0418ED 00          0061*   @end: db 0x00 ; padding
0418EE             0062*   
0418EE             0063*   ; VDU 23, 0, &95, 3, bufferId; [<args>]: Reserved
0418EE             0064*   
0418EE             0065*   ; Clear/Delete font
0418EE             0066*   ; inputs: hl = bufferId
0418EE             0067*   ; VDU 23, 0, &95, 4, bufferId;: Clear/Delete font
0418EE             0068*   vdu_font_clear:
0418EE 22 01 19 04 0069*       ld (@bufferId),hl
0418F2 21 FD 18 04 0070*       ld hl,@cmd
0418F6 01 06 00 00 0071*       ld bc,@end-@cmd
0418FA 5B DF       0072*       rst.lil $18
0418FC C9          0073*       ret
0418FD 17 00 95 04 0074*   @cmd: db 23, 0, 0x95, 4
041901 00 00       0075*   @bufferId: dw 0x0000
041903 00          0076*   @end: db 0x00 ; padding
041904             0077*   
041904             0078*   ; Copy system font to buffer
041904             0079*   ; inputs: hl = bufferId
041904             0080*   ; VDU 23, 0, &95, 5, bufferId;: Copy system font to buffer
041904             0081*   vdu_font_copy_system:
041904 22 17 19 04 0082*       ld (@bufferId),hl
041908 21 13 19 04 0083*       ld hl,@cmd
04190C 01 06 00 00 0084*       ld bc,@end-@cmd
041910 5B DF       0085*       rst.lil $18
041912 C9          0086*       ret
041913 17 00 95 05 0087*   @cmd: db 23, 0, 0x95, 5
041917 00 00       0088*   @bufferId: dw 0x0000
041919 00          0089*   @end: db 0x00 ; padding
04191A             0043        include "vdu_plot.inc"
04191A             0001*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
04191A             0002*   ; PLOT code 	(Decimal) 	Effect
04191A             0003*   ; &00-&07 	0-7 	Solid line, includes both ends
04191A             0004*   plot_sl_both: equ 0x00
04191A             0005*   
04191A             0006*   ; &08-&0F 	8-15 	Solid line, final point omitted
04191A             0007*   plot_sl_first: equ 0x08
04191A             0008*   
04191A             0009*   ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
04191A             0010*   ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
04191A             0011*   
04191A             0012*   ; &20-&27 	32-39 	Solid line, first point omitted
04191A             0013*   plot_sl_last: equ 0x20
04191A             0014*   
04191A             0015*   ; &28-&2F 	40-47 	Solid line, both points omitted
04191A             0016*   plot_sl_none: equ 0x28
04191A             0017*   
04191A             0018*   ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
04191A             0019*   ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
04191A             0020*   
04191A             0021*   ; &40-&47 	64-71 	Point plot
04191A             0022*   plot_pt: equ 0x40
04191A             0023*   
04191A             0024*   ; &48-&4F 	72-79 	Line fill left and right to non-background Â§Â§
04191A             0025*   plot_lf_lr_non_bg: equ 0x48
04191A             0026*   
04191A             0027*   ; &50-&57 	80-87 	Triangle fill
04191A             0028*   plot_tf: equ 0x50
04191A             0029*   
04191A             0030*   ; &58-&5F 	88-95 	Line fill right to background Â§Â§
04191A             0031*   plot_lf_r_bg: equ 0x58
04191A             0032*   
04191A             0033*   ; &60-&67 	96-103 	Rectangle fill
04191A             0034*   plot_rf: equ 0x60
04191A             0035*   
04191A             0036*   ; &68-&6F 	104-111 	Line fill left and right to foreground Â§Â§
04191A             0037*   plot_lf_lr_fg: equ 0x60
04191A             0038*   
04191A             0039*   ; &70-&77 	112-119 	Parallelogram fill
04191A             0040*   plot_pf: equ 0x70
04191A             0041*   
04191A             0042*   ; &78-&7F 	120-127 	Line fill right to non-foreground Â§Â§
04191A             0043*   plot_lf_r_non_fg: equ 0x78
04191A             0044*   
04191A             0045*   ; &80-&87 	128-135 	Not supported (Flood until non-background)
04191A             0046*   ; &88-&8F 	136-143 	Not supported (Flood until foreground)
04191A             0047*   
04191A             0048*   ; &90-&97 	144-151 	Circle outline
04191A             0049*   plot_co: equ 0x90
04191A             0050*   
04191A             0051*   ; &98-&9F 	152-159 	Circle fill
04191A             0052*   plot_cf: equ 0x98
04191A             0053*   
04191A             0054*   ; &A0-&A7 	160-167 	Not supported (Circular arc)
04191A             0055*   ; &A8-&AF 	168-175 	Not supported (Circular segment)
04191A             0056*   ; &B0-&B7 	176-183 	Not supported (Circular sector)
04191A             0057*   
04191A             0058*   ; &B8-&BF 	184-191 	Rectangle copy/move
04191A             0059*   plot_rcm: equ 0xB8
04191A             0060*   
04191A             0061*   ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
04191A             0062*   ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
04191A             0063*   ; &D0-&D7 	208-215 	Not defined
04191A             0064*   ; &D8-&DF 	216-223 	Not defined
04191A             0065*   ; &E0-&E7 	224-231 	Not defined
04191A             0066*   
04191A             0067*   ; &E8-&EF 	232-239 	Bitmap plot Â§
04191A             0068*   plot_bmp: equ 0xE8
04191A             0069*   
04191A             0070*   ; &F0-&F7 	240-247 	Not defined
04191A             0071*   ; &F8-&FF 	248-255 	Not defined
04191A             0072*   
04191A             0073*   ; Â§ Support added in Agon Console8 VDP 2.1.0 Â§Â§ Support added in
04191A             0074*   ; Agon Console8 VDP 2.2.0
04191A             0075*   
04191A             0076*   ; Within each group of eight plot codes, the effects are as follows:
04191A             0077*   ; Plot code 	Effect
04191A             0078*   ; 0 	Move relative
04191A             0079*   mv_rel: equ 0
04191A             0080*   
04191A             0081*   ; 1 	Plot relative in current foreground colour
04191A             0082*   dr_rel_fg: equ 1
04191A             0083*   
04191A             0084*   ; 2 	Not supported (Plot relative in logical inverse colour)
04191A             0085*   ; 3 	Plot relative in current background colour
04191A             0086*   dr_rel_bg: equ 3
04191A             0087*   
04191A             0088*   ; 4 	Move absolute
04191A             0089*   mv_abs: equ 4
04191A             0090*   
04191A             0091*   ; 5 	Plot absolute in current foreground colour
04191A             0092*   dr_abs_fg: equ 5
04191A             0093*   
04191A             0094*   ; 6 	Not supported (Plot absolute in logical inverse colour)
04191A             0095*   ; 7 	Plot absolute in current background colour
04191A             0096*   dr_abs_bg: equ 7
04191A             0097*   
04191A             0098*   ; Codes 0-3 use the position data provided as part of the command
04191A             0099*   ; as a relative position, adding the position given to the current
04191A             0100*   ; graphical cursor position. Codes 4-7 use the position data provided
04191A             0101*   ; as part of the command as an absolute position, setting the current
04191A             0102*   ; graphical cursor position to the position given.
04191A             0103*   
04191A             0104*   ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
04191A             0105*   ; current pixel colour. These operations cannot currently be supported
04191A             0106*   ; by the graphics system the Agon VDP uses, so these codes are not
04191A             0107*   ; supported. Support for these codes may be added in a future version
04191A             0108*   ; of the VDP firmware.
04191A             0109*   
04191A             0110*   ; 16 colour palette constants
04191A             0111*   c_black: equ 0
04191A             0112*   c_red_dk: equ 1
04191A             0113*   c_green_dk: equ 2
04191A             0114*   c_yellow_dk: equ 3
04191A             0115*   c_blue_dk: equ 4
04191A             0116*   c_magenta_dk: equ 5
04191A             0117*   c_cyan_dk: equ 6
04191A             0118*   c_grey: equ 7
04191A             0119*   c_grey_dk: equ 8
04191A             0120*   c_red: equ 9
04191A             0121*   c_green: equ 10
04191A             0122*   c_yellow: equ 11
04191A             0123*   c_blue: equ 12
04191A             0124*   c_magenta: equ 13
04191A             0125*   c_cyan: equ 14
04191A             0126*   c_white: equ 15
04191A             0127*   
04191A             0128*   ; VDU 25, mode, x; y;: PLOT command
04191A             0129*   ; inputs: a=mode, bc=x0, de=y0
04191A             0130*   vdu_plot:
04191A 32 34 19 04 0131*       ld (@mode),a
04191E ED 43 35 19 0132*       ld (@x0),bc
       04          
041923 ED 53 37 19 0133*       ld (@y0),de
       04          
041928 21 33 19 04 0134*   	ld hl,@cmd
04192C 01 06 00 00 0135*   	ld bc,@end-@cmd
041930 5B DF       0136*   	rst.lil $18
041932 C9          0137*   	ret
041933 19          0138*   @cmd:   db 25
041934 00          0139*   @mode:  db 0
041935 00 00       0140*   @x0: 	dw 0
041937 00 00       0141*   @y0: 	dw 0
041939 00          0142*   @end:   db 0 ; extra byte to soak up deu
04193A             0143*   
04193A             0144*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
04193A             0145*   ; &E8-&EF 	232-239 	Bitmap plot Â§
04193A             0146*   ; VDU 25, mode, x; y;: PLOT command
04193A             0147*   ; inputs: bc=x0, de=y0
04193A             0148*   ; prerequisites: vdu_buff_select
04193A             0149*   vdu_plot_bmp:
04193A ED 43 51 19 0150*       ld (@x0),bc
       04          
04193F ED 53 53 19 0151*       ld (@y0),de
       04          
041944 21 4F 19 04 0152*   	ld hl,@cmd
041948 01 06 00 00 0153*   	ld bc,@end-@cmd
04194C 5B DF       0154*   	rst.lil $18
04194E C9          0155*   	ret
04194F 19          0156*   @cmd:   db 25
041950 ED          0157*   @mode:  db plot_bmp+dr_abs_fg ; 0xED
041951 00 00       0158*   @x0: 	dw 0x0000
041953 00 00       0159*   @y0: 	dw 0x0000
041955 00          0160*   @end:   db 0x00 ; padding
041956             0161*   
041956             0162*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
041956             0163*   ; &E8-&EF 	232-239 	Bitmap plot Â§
041956             0164*   ; VDU 25, mode, x; y;: PLOT command
041956             0165*   ; inputs: bc=x0, de=y0
041956             0166*   ; USING 16.8 FIXED POINT COORDINATES
041956             0167*   ; inputs: ub.c is x coordinate, ud.e is y coordinate
041956             0168*   ;   the fractional portiion of the inputs are truncated
041956             0169*   ;   leaving only the 16-bit integer portion
041956             0170*   ; prerequisites: vdu_buff_select
041956             0171*   vdu_plot_bmp168:
041956             0172*   ; populate in the reverse of normal to keep the
041956             0173*   ; inputs from stomping on each other
041956 ED 53 74 19 0174*       ld (@y0-1),de
       04          
04195B ED 43 72 19 0175*       ld (@x0-1),bc
       04          
041960 3E ED       0176*       ld a,plot_bmp+dr_abs_fg ; 0xED
041962 32 72 19 04 0177*       ld (@mode),a ; restore the mode byte that got stomped on by bcu
041966 21 71 19 04 0178*   	ld hl,@cmd
04196A 01 06 00 00 0179*   	ld bc,@end-@cmd
04196E 5B DF       0180*   	rst.lil $18
041970 C9          0181*   	ret
041971 19          0182*   @cmd:   db 25
041972 ED          0183*   @mode:  db plot_bmp+dr_abs_fg ; 0xED
041973 00 00       0184*   @x0: 	dw 0x0000
041975 00 00       0185*   @y0: 	dw 0x0000
041977             0186*   @end:  ; no padding required b/c we shifted de right
041977             0187*   
041977             0188*   ; draw a filled rectangle
041977             0189*   vdu_plot_rf:
041977 ED 43 9E 19 0190*       ld (@x0),bc
       04          
04197C ED 53 A0 19 0191*       ld (@y0),de
       04          
041981 DD 22 A4 19 0192*       ld (@x1),ix
       04          
041986 FD 22 A6 19 0193*       ld (@y1),iy
       04          
04198B 3E 19       0194*       ld a,25 ; we have to reload the 2nd plot command
04198D 32 A2 19 04 0195*       ld (@cmd1),a ; because the 24-bit y0 load stomped on it
041991 21 9C 19 04 0196*   	ld hl,@cmd0
041995 01 0C 00 00 0197*   	ld bc,@end-@cmd0
041999 5B DF       0198*   	rst.lil $18
04199B C9          0199*       ret
04199C 19          0200*   @cmd0:  db 25 ; plot
04199D 04          0201*   @arg0:  db plot_sl_both+mv_abs
04199E 00 00       0202*   @x0:    dw 0x0000
0419A0 00 00       0203*   @y0:    dw 0x0000
0419A2 19          0204*   @cmd1:  db 25 ; plot
0419A3 65          0205*   @arg1:  db plot_rf+dr_abs_fg
0419A4 00 00       0206*   @x1:    dw 0x0000
0419A6 00 00       0207*   @y1:    dw 0x0000
0419A8 00          0208*   @end:   db 0x00 ; padding
0419A9             0209*   
0419A9             0210*   ; draw a filled circle
0419A9             0211*   vdu_plot_cf:
0419A9 ED 43 D0 19 0212*       ld (@x0),bc
       04          
0419AE ED 53 D2 19 0213*       ld (@y0),de
       04          
0419B3 DD 22 D6 19 0214*       ld (@x1),ix
       04          
0419B8 FD 22 D8 19 0215*       ld (@y1),iy
       04          
0419BD 3E 19       0216*       ld a,25 ; we have to reload the 2nd plot command
0419BF 32 D4 19 04 0217*       ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0419C3 21 CE 19 04 0218*   	ld hl,@cmd0
0419C7 01 0C 00 00 0219*   	ld bc,@end-@cmd0
0419CB 5B DF       0220*   	rst.lil $18
0419CD C9          0221*       ret
0419CE 19          0222*   @cmd0:  db 25 ; plot
0419CF 04          0223*   @arg0:  db plot_sl_both+mv_abs
0419D0 00 00       0224*   @x0:    dw 0x0000
0419D2 00 00       0225*   @y0:    dw 0x0000
0419D4 19          0226*   @cmd1:  db 25 ; plot
0419D5 9D          0227*   @arg1:  db plot_cf+dr_abs_fg
0419D6 00 00       0228*   @x1:    dw 0x0000
0419D8 00 00       0229*   @y1:    dw 0x0000
0419DA 00          0230*   @end:   db 0x00 ; padding
0419DB             0044        include "vdu_sound.inc"
0419DB             0001*   ; enable enough additional channels so that total enabled = max_channels
0419DB             0002*   ; inputs: max_channels set
0419DB             0003*   ; returns: nothing
0419DB             0004*   ; destroys: af, bc, hl
0419DB             0005*   vdu_enable_channels:
0419DB 3E 01       0006*       ld a,max_channels
0419DD D6 03       0007*       sub 3 ; subtract number of default channels already enabled
0419DF F2 E6 19 04 0008*       jp p,@loop
0419E3 C9          0009*       ret
0419E4 3E 03       0010*       ld a,3 ; first non-default channel
0419E6             0011*   @loop:
0419E6 32 01 1A 04 0012*       ld (@channel),a
0419EA 21 FE 19 04 0013*       ld hl,@beg
0419EE 01 05 00 00 0014*       ld bc,@end-@beg
0419F2 F5          0015*       push af
0419F3 5B DF       0016*       rst.lil $18
0419F5 F1          0017*       pop af
0419F6 3C          0018*       inc a
0419F7 FE 01       0019*       cp max_channels
0419F9 C2 E6 19 04 0020*       jp nz,@loop
0419FD C9          0021*       ret
0419FE             0022*   @beg:
0419FE 17 00 85    0023*               db 23, 0, $85
041A01 00          0024*   @channel:   db 0
041A02 08          0025*               db 8 ; command 8: enable channel
041A03             0026*   @end:
041A03             0027*   
041A03             0028*   ; disable all but the three default sound channels
041A03             0029*   ; inputs: max_channels set
041A03             0030*   ; outputs: none
041A03             0031*   ; destroys: ah,hl,bc
041A03             0032*   vdu_disable_channels:
041A03 3E 01       0033*       ld a,max_channels
041A05 D6 03       0034*       sub 3 ; subtract number of default channels already enabled
041A07 F2 0E 1A 04 0035*       jp p,@loop
041A0B C9          0036*       ret
041A0C 3E 03       0037*       ld a,3 ; first non-default channel
041A0E             0038*   @loop:
041A0E 32 29 1A 04 0039*       ld (@channel),a
041A12 21 26 1A 04 0040*       ld hl,@beg
041A16 01 05 00 00 0041*       ld bc,@end-@beg
041A1A F5          0042*       push af
041A1B 5B DF       0043*       rst.lil $18
041A1D F1          0044*       pop af
041A1E 3C          0045*       inc a
041A1F FE 01       0046*       cp max_channels
041A21 C2 0E 1A 04 0047*       jp nz,@loop
041A25 C9          0048*       ret
041A26             0049*   @beg:
041A26 17 00 85    0050*       db 23, 0, $85
041A29 00          0051*   @channel: db 0
041A2A 09          0052*       db 9 ; command 9: disable channel
041A2B             0053*   @end:
041A2B             0054*   
041A2B             0055*   
041A2B             0056*   ; ############################################################
041A2B             0057*   ; VDU SOUND API
041A2B             0058*   ; ############################################################
041A2B             0059*   ; Command 0: Play note
041A2B             0060*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
041A2B             0061*       MACRO PLAY_NOTE channel, volume, frequency, duration
041A2B             0062*       ld hl, @PLAY_NOTE_CMD        ; Start of command block
041A2B             0063*       ld bc, @PLAY_NOTE_END - @PLAY_NOTE_CMD  ; Command block size
041A2B             0064*       rst.lil $18
041A2B             0065*       jr @PLAY_NOTE_END
041A2B             0066*   @PLAY_NOTE_CMD:  db 23, 0, 0x85               ; Command header
041A2B             0067*                    db channel                  ; Channel, 0 (commented out)
041A2B             0068*                    db 0                        ; Play note command
041A2B             0069*                    db volume                   ; Volume
041A2B             0070*                    dw frequency                ; Frequency
041A2B             0071*                    dw duration                 ; Duration
041A2B             0072*   @PLAY_NOTE_END:
041A2B             0073*       ENDMACRO
041A2B             0074*   
041A2B             0075*       MACRO MUTE_CHANNEL channel
041A2B             0076*       ld hl, @MUTE_CHANNEL_CMD     ; Start of command block
041A2B             0077*       ld bc, @MUTE_CHANNEL_END - @MUTE_CHANNEL_CMD  ; Command block size
041A2B             0078*       rst.lil $18
041A2B             0079*       jr @MUTE_CHANNEL_END
041A2B             0080*   @MUTE_CHANNEL_CMD: db 23, 0, 0x85             ; Command header
041A2B             0081*                      db channel                ; Channel, 0 (commented out)
041A2B             0082*                      db 2                      ; Set volume command
041A2B             0083*                      db 0                      ; Volume (mute)
041A2B             0084*   @MUTE_CHANNEL_END:
041A2B             0085*       ENDMACRO
041A2B             0086*   
041A2B             0087*   ; inputs: c = channel, b = volume, hl = frequency; de = duration;
041A2B             0088*   vdu_play_note:
041A2B 79          0089*       ld a,c
041A2C 32 4C 1A 04 0090*       ld (@channel),a
041A30 78          0091*       ld a,b
041A31 32 4E 1A 04 0092*       ld (@volume),a
041A35 22 4F 1A 04 0093*       ld (@frequency),hl
041A39 ED 53 51 1A 0094*       ld (@duration),de
       04          
041A3E 21 49 1A 04 0095*       ld hl,@cmd
041A42 01 0A 00 00 0096*       ld bc,@end-@cmd
041A46 5B DF       0097*       rst.lil $18
041A48 C9          0098*       ret
041A49 17 00 85    0099*   @cmd:       db 23, 0, 0x85
041A4C 00          0100*   @channel:   db 0x00
041A4D 00          0101*               db 0x00 ; play note command
041A4E 00          0102*   @volume:    db 0x00
041A4F 00 00       0103*   @frequency: dw 0x0000
041A51 00 00       0104*   @duration:  dw 0x0000
041A53 00          0105*   @end:       db 0x00 ; padding
041A54             0106*   
041A54             0107*   ; Command 1: Status
041A54             0108*   ; VDU 23, 0, &85, channel, 1
041A54             0109*   ; inputs: a = channel
041A54             0110*   ; Returns a bit mask indicating the status of the specified channel, or 255 if the channel is not valid, or has been disabled. The bit mask is as follows:
041A54             0111*   ; Bit 	Name 	Meaning
041A54             0112*   ; 0 	Active 	When set this indicates the channel is in use (has an active waveform)
041A54             0113*   ; 1 	Playing 	Indicates the channel is actively playing a note, and thus will reject calls to play a new note
041A54             0114*   ; 2 	Indefinite 	Set if the channel is playing an indefinite duration note
041A54             0115*   ; 3 	Has Volume Envelope 	Set if the channel has a volume envelope
041A54             0116*   ; 4 	Has Frequency Envelope 	Set if the channel has a frequency envelope
041A54             0117*   
041A54             0118*   ; Bits 5-7 are reserved for future use and, for enabled channels, will currently always be zero.
041A54             0119*   vdu_channel_status:
041A54 32 66 1A 04 0120*       ld (@channel),a
041A58 21 63 1A 04 0121*       ld hl,@cmd
041A5C 01 05 00 00 0122*       ld bc,@end-@cmd
041A60 5B DF       0123*       rst.lil $18
041A62 C9          0124*       ret
041A63 17 00 85    0125*   @cmd:       db 23, 0, 0x85
041A66 00          0126*   @channel:   db 0x00
041A67 01          0127*               db 0x01 ; get channel status command
041A68             0128*   @end:
041A68             0129*   
041A68             0130*   ; VDU 23, 0, &85, channel, 2, volume
041A68             0131*   ; inputs: c = channel, b = volume
041A68             0132*   ; Sets the volume of the specified channel. The volume is a value from 0 to 127, where 0 is silent and 127 is full volume. Values over 127 will be treated as 127 (with one exception described later).
041A68             0133*   
041A68             0134*   ; Specifying a channel of -1 (or 255) will set the global sound system volume level. (Requires Console8 VDP 2.5.0 or later.)
041A68             0135*   
041A68             0136*   ; Using this command provides more direct control over a channel than the play note command. It can be used to adjust the volume of a channel that is already playing a note.
041A68             0137*   vdu_channel_volume:
041A68 79          0138*       ld a,c
041A69 32 80 1A 04 0139*       ld (@channel),a
041A6D 78          0140*       ld a,b
041A6E 32 82 1A 04 0141*       ld (@volume),a
041A72 21 7D 1A 04 0142*       ld hl,@cmd
041A76 01 06 00 00 0143*       ld bc,@end-@cmd
041A7A 5B DF       0144*       rst.lil $18
041A7C C9          0145*       ret
041A7D 17 00 85    0146*   @cmd:       db 23, 0, 0x85
041A80 00          0147*   @channel:   db 0x00
041A81 02          0148*               db 0x02 ; set volume command
041A82 00          0149*   @volume:    db 0x00
041A83             0150*   @end:
041A83             0151*   
041A83             0152*   ; VDU 23, 0, &85, channel, 3, frequency;
041A83             0153*   
041A83             0154*   ; Sets the frequency of the specified channel. The frequency is a 16-bit value specifying in Hz the frequency of the note to be played.
041A83             0155*   
041A83             0156*   ; Using this command provides more direct control over a channel than the play note command. It can be used to adjust the frequency of a channel that is already playing a note.
041A83             0157*   
041A83             0158*   ; Returns 1 on success, 0 for failure.
041A83             0159*   vdu_channel_frequency:
041A83 79          0160*       ld a,c
041A84 32 9B 1A 04 0161*       ld (@channel),a
041A88 ED 53 9D 1A 0162*       ld (@frequency),de
       04          
041A8D 21 98 1A 04 0163*       ld hl,@cmd
041A91 01 07 00 00 0164*       ld bc,@end-@cmd
041A95 5B DF       0165*       rst.lil $18
041A97 C9          0166*       ret
041A98 17 00 85    0167*   @cmd:       db 23, 0, 0x85
041A9B 00          0168*   @channel:   db 0x00
041A9C 03          0169*               db 0x03 ; set frequency command
041A9D 00 00       0170*   @frequency: dw 0x0000
041A9F 00          0171*   @end:       db 0x00 ; padding
041AA0             0172*   
041AA0             0173*   
041AA0             0174*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
041AA0             0175*   ; inputs: c = channel, b = waveformOrSample, [hl = bufferId]
041AA0             0176*   ; Sets the waveform type for a channel to use. The waveformOrSample value is a single byte treated as a signed value.
041AA0             0177*   
041AA0             0178*   ; Using a negative value for the waveform indicates that a sample should be used instead. For more information see the documentation for the sample command.
041AA0             0179*   
041AA0             0180*   ; By default a channel is set to use waveform 0 (square wave).
041AA0             0181*   
041AA0             0182*   ; Valid waveform values are as follows:
041AA0             0183*   ; Value 	Waveform
041AA0             0184*   ; 0 	Square wave
041AA0             0185*   ; 1 	Triangle wave
041AA0             0186*   ; 2 	Sawtooth wave
041AA0             0187*   ; 3 	Sine wave
041AA0             0188*   ; 4 	Noise (simple white noise with no frequency support)
041AA0             0189*   ; 5 	VIC Noise (emulates a VIC6561; supports frequency)
041AA0             0190*   ; 8 	Sample (specifying a 16-bit buffer ID for sample data)
041AA0             0191*   
041AA0             0192*   vdu_channel_waveform:
041AA0 79          0193*       ld a,c
041AA1 32 C6 1A 04 0194*       ld (@channel),a
041AA5 78          0195*       ld a,b
041AA6 32 C8 1A 04 0196*       ld (@waveform),a
041AAA FE 08       0197*       cp 8 ; check if the waveform is a sample
041AAC 28 06       0198*       jr z, @sample
041AAE 01 06 00 00 0199*       ld bc,@bufferId-@cmd
041AB2 18 08       0200*       jr @sendToVdu
041AB4             0201*   @sample:
041AB4 22 C9 1A 04 0202*       ld (@bufferId),hl
041AB8 01 08 00 00 0203*       ld bc,@end-@cmd
041ABC             0204*   @sendToVdu:
041ABC 21 C3 1A 04 0205*       ld hl,@cmd
041AC0 5B DF       0206*       rst.lil $18
041AC2 C9          0207*       ret
041AC3 17 00 85    0208*   @cmd:       db 23, 0, 0x85
041AC6 00          0209*   @channel:   db 0x00
041AC7 04          0210*               db 0x04 ; set waveform command
041AC8 00          0211*   @waveform:  db 0x00
041AC9 00 00       0212*   @bufferId:  dw 0x0000
041ACB 00          0213*   @end:       db 0x00 ; padding
041ACC             0214*   
041ACC             0215*   ; VDU 23, 0, &85, channel (ignored), 5, 2, bufferId; format, [sampleRate;]
041ACC             0216*   ; inputs: hl = bufferId; a = format, de = sample rate in Hz
041ACC             0217*   ; The format is a single byte giving the format of the sample data. The following formats are supported:
041ACC             0218*   ; Value	Description
041ACC             0219*   ; 0	8-bit signed
041ACC             0220*   ; 1	8-bit unsigned
041ACC             0221*   ; The format value can also have modifier bits set to modify the behaviour of the sample. The following modifier bits are supported:
041ACC             0222*   ; Value	Description
041ACC             0223*   ; 8	sample rate is sent in the next 16-bits
041ACC             0224*   ; 16	sample is tuneable
041ACC             0225*   ; The default sample rate for samples on the VDP is 16kHz (actually 16.384kHz to be precise).
041ACC             0226*   vdu_buffer_to_sound:
041ACC 22 EC 1A 04 0227*       ld (@bufferId),hl
041AD0 C6 08       0228*       add a,8 ; modify format byte to indicate sample rate argument is given
041AD2 32 EE 1A 04 0229*       ld (@format),a
041AD6 ED 53 EF 1A 0230*       ld (@sampleRate),de
       04          
041ADB 21 E6 1A 04 0231*       ld hl,@cmd
041ADF 01 0B 00 00 0232*       ld bc,@end-@cmd
041AE3 5B DF       0233*       rst.lil $18
041AE5 C9          0234*       ret
041AE6 17 00 85    0235*   @cmd:       db 23, 0, 0x85
041AE9 00          0236*   @channel:   db 0x00 ; ignored
041AEA 05          0237*               db 0x05 ; buffer to sound command
041AEB 02          0238*               db 0x02 ; command 2 create sample
041AEC 00 00       0239*   @bufferId:  dw 0x0000
041AEE 00          0240*   @format:    db 0x00
041AEF 00 00       0241*   @sampleRate: dw 0x0000
041AF1 00          0242*   @end:       db 0x00 ; padding
041AF2             0243*   
041AF2             0244*   ; Command 13: Set sample rate
041AF2             0245*   ; VDU 23, 0, &85, channel, 13, sampleRate;
041AF2             0246*   ; inputs: c = channel, hl = sampleRate (Hz)
041AF2             0247*   vdu_set_sample_rate:
041AF2 79          0248*       ld a,c
041AF3 32 09 1B 04 0249*       ld (@channel),a
041AF7 22 0B 1B 04 0250*       ld (@sampleRate),hl
041AFB 21 06 1B 04 0251*       ld hl,@cmd
041AFF 01 07 00 00 0252*       ld bc,@end-@cmd
041B03 5B DF       0253*       rst.lil $18
041B05 C9          0254*       ret
041B06 17 00 85    0255*   @cmd:       db 23, 0, 0x85
041B09 00          0256*   @channel:   db 0x00
041B0A 0D          0257*               db 13 ; set sample rate command
041B0B 00 00       0258*   @sampleRate: dw 0x0000
041B0D 00          0259*   @end:       db 0x00 ; padding
041B0E             0260*   
041B0E             0261*   ; load a sound file to a buffer
041B0E             0262*   ; inputs: hl = bufferId ; de = sampleRate in Hz ; iy = pointer to filename
041B0E             0263*   vdu_load_sfx:
041B0E             0264*   ; back up input parameters
041B0E E5          0265*       push hl ; bufferId
041B0F D5          0266*       push de ; sample rate
041B10             0267*   ; load the sound
041B10 CD 4E 16 04 0268*       call vdu_load_buffer_from_file
041B14             0269*   ; now make the buffer a sound sample
041B14 D1          0270*       pop de ; sample rate
041B15 E1          0271*       pop hl ; bufferId
041B16 AF          0272*       xor a ; zero is the magic number for mono 8-bit signed PCM
041B17 CD CC 1A 04 0273*       call vdu_buffer_to_sound
041B1B C9          0274*       ret
041B1C             0275*   
041B1C             0276*   
041B1C 00          0277*   last_channel: db 0
041B1D             0278*   max_channels: equ 1
041B1D             0279*   
041B1D             0280*   ; play a sound effect from an already loaded buffer
041B1D             0281*   ; inputs: hl = bufferId ; bc = duration in milliseconds
041B1D             0282*   vdu_play_sfx:
041B1D 22 55 1B 04 0283*       ld (@bufferId),hl
041B21 ED 43 5F 1B 0284*       ld (@duration),bc
       04          
041B26 3E 17       0285*       ld a,23
041B28 32 57 1B 04 0286*       ld (@bufferId+2),a
041B2C 3A 1C 1B 04 0287*       ld a,(last_channel)
041B30 3C          0288*       inc a
041B31             0289*       ; and 31 ; modulo 32
041B31 FE 01       0290*       cp max_channels
041B33 C2 38 1B 04 0291*       jp nz,@load_channel
041B37 AF          0292*       xor a
041B38             0293*   @load_channel:
041B38 32 1C 1B 04 0294*       ld (last_channel),a
041B3C 32 52 1B 04 0295*       ld (@channel0),a
041B40 32 5A 1B 04 0296*       ld (@channel1),a
041B44 21 4F 1B 04 0297*       ld hl, @sample
041B48 01 12 00 00 0298*       ld bc, @sample_end - @sample
041B4C 5B DF       0299*       rst.lil $18
041B4E C9          0300*       ret
041B4F             0301*   @sample:
041B4F             0302*   ; Command 4: Set waveform
041B4F             0303*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
041B4F 17 00 85    0304*       .db 23,0,$85                        ; do sound
041B52             0305*   @channel0:
041B52 00 04 08    0306*       .db 0,4,8 ; channel, command, waveform
041B55             0307*   @bufferId:
041B55 00 00       0308*       .dw 0x0000
041B57             0309*   ; Command 0: Play note
041B57             0310*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
041B57 17 00 85    0311*       .db 23,0,$85                        ; do sound
041B5A             0312*   @channel1:
041B5A 00 00 7F    0313*       .db 0,0,127                ; channel, volume
041B5D 00 00       0314*       .dw 0
041B5F             0315*   @duration:                              ; freq (tuneable samples only)
041B5F 00 00       0316*       .dw 0x0000                        ; duration
041B61             0317*   @sample_end:
041B61 00          0318*       .db 0x00 ; padding
041B62             0319*   
041B62             0320*   ; inputs: c = channel, b = volume, de = sample rate; hl = bufferId;
041B62             0321*   vdu_play_sample:
041B62             0322*       ; populate input parameters
041B62 79          0323*       ld a,c
041B63 32 95 1B 04 0324*       ld (@channel0),a
041B67 32 9D 1B 04 0325*       ld (@channel1),a
041B6B 32 A4 1B 04 0326*       ld (@channel2),a
041B6F 78          0327*       ld a,b
041B70 32 A6 1B 04 0328*       ld (@volume),a
041B74 ED 53 9F 1B 0329*       ld (@sampleRate),de
       04          
041B79 22 98 1B 04 0330*       ld (@bufferId),hl
041B7D 3E 17       0331*       ld a,23
041B7F 32 9A 1B 04 0332*       ld (@cmd1),a
041B83 32 A1 1B 04 0333*       ld (@cmd2),a
041B87             0334*       ; prep the vdu command string
041B87 21 92 1B 04 0335*       ld hl, @cmd0
041B8B 01 19 00 00 0336*       ld bc, @end - @cmd0
041B8F 5B DF       0337*       rst.lil $18
041B91 C9          0338*       ret
041B92             0339*   ; set waveform command
041B92 17 00 85    0340*   @cmd0:       db 23, 0, 0x85
041B95 00          0341*   @channel0:   db 0x00
041B96 04          0342*                db 0x04 ; set waveform command
041B97 08          0343*   @waveform:   db 0x08 ; sample
041B98 00 00       0344*   @bufferId:   dw 0x0000
041B9A             0345*   ; set sample rate command
041B9A 17 00 85    0346*   @cmd1:       db 23, 0, 0x85
041B9D 00          0347*   @channel1:   db 0x00
041B9E 0D          0348*               db 13 ; set sample rate command
041B9F 00 00       0349*   @sampleRate: dw 0x0000
041BA1             0350*   ; play note command
041BA1 17 00 85    0351*   @cmd2:       db 23, 0, 0x85
041BA4 00          0352*   @channel2:   db 0x00
041BA5 00          0353*                db 0x00 ; play note command
041BA6 00          0354*   @volume:     db 0x00
041BA7 00 00       0355*   @frequency:  dw 0x00 ; no effect unless buffer has been set to tuneable sample
041BA9 00 00       0356*   @duration:   dw 0x0000 ; milliseconds: set to -1 to loop indefinitely, 0 to play full duration once
041BAB 00          0357*   @end:        db 0x00 ; padding
041BAC             0045    
041BAC             0046    ; APPLICATION INCLUDES
041BAC             0047        include "ascii.inc"
041BAC             0001*   agon_jukebox_ascii:
041BAC 20 20 20 5F 0002*       db 32,32,32,95,95,95,95,95,32,32,32,32,95,95,95,95,95,95,95,95,32,95,95,95,95,95,95,95,95,32,32,32,32,95,95,95,95,95,95,95,13,10
       5F 5F 5F 5F 
       20 20 20 20 
       5F 5F 5F 5F 
       5F 5F 5F 5F 
       20 5F 5F 5F 
       5F 5F 5F 5F 
       5F 20 20 20 
       20 5F 5F 5F 
       5F 5F 5F 5F 
       0D 0A       
041BD6 20 20 2F 20 0003*       db 32,32,47,32,32,95,32,32,92,32,32,47,32,32,95,95,95,95,95,47,32,92,95,95,95,95,95,32,32,92,32,32,32,92,32,32,32,32,32,32,92,13,10
       20 5F 20 20 
       5C 20 20 2F 
       20 20 5F 5F 
       5F 5F 5F 2F 
       20 5C 5F 5F 
       5F 5F 5F 20 
       20 5C 20 20 
       20 5C 20 20 
       20 20 20 20 
       5C 0D 0A    
041C01 20 2F 20 20 0004*       db 32,47,32,32,47,95,92,32,32,92,47,32,32,32,92,32,32,95,95,95,32,32,47,32,32,32,124,32,32,32,92,32,32,47,32,32,32,124,32,32,32,92,13,10
       2F 5F 5C 20 
       20 5C 2F 20 
       20 20 5C 20 
       20 5F 5F 5F 
       20 20 2F 20 
       20 20 7C 20 
       20 20 5C 20 
       20 2F 20 20 
       20 7C 20 20 
       20 5C 0D 0A 
041C2D 2F 20 20 20 0005*       db 47,32,32,32,32,124,32,32,32,32,92,32,32,32,32,92,95,92,32,32,92,47,32,32,32,32,124,32,32,32,32,92,47,32,32,32,32,124,32,32,32,32,92,13,10
       20 7C 20 20 
       20 20 5C 20 
       20 20 20 5C 
       5F 5C 20 20 
       5C 2F 20 20 
       20 20 7C 20 
       20 20 20 5C 
       2F 20 20 20 
       20 7C 20 20 
       20 20 5C 0D 
       0A          
041C5A 5C 5F 5F 5F 0006*       db 92,95,95,95,95,124,95,95,32,32,47,92,95,95,95,95,95,95,32,32,47,92,95,95,95,95,95,95,95,32,32,47,92,95,95,95,95,124,95,95,32,32,47,13,10
       5F 7C 5F 5F 
       20 20 2F 5C 
       5F 5F 5F 5F 
       5F 5F 20 20 
       2F 5C 5F 5F 
       5F 5F 5F 5F 
       5F 20 20 2F 
       5C 5F 5F 5F 
       5F 7C 5F 5F 
       20 20 2F 0D 
       0A          
041C87 20 20 20 20 0007*       db 32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,32,92,47,13,10
       20 20 20 20 
       5C 2F 20 20 
       20 20 20 20 
       20 20 5C 2F 
       20 20 20 20 
       20 20 20 20 
       20 5C 2F 20 
       20 20 20 20 
       20 20 20 20 
       5C 2F 0D 0A 
041CB3 20 20 20 20 0008*       db 32,32,32,32,32,95,95,95,95,32,95,95,95,95,32,95,95,95,32,95,95,95,95,32,32,95,95,32,95,95,95,95,95,95,95,95,95,95,95,13,10
       20 5F 5F 5F 
       5F 20 5F 5F 
       5F 5F 20 5F 
       5F 5F 20 5F 
       5F 5F 5F 20 
       20 5F 5F 20 
       5F 5F 5F 5F 
       5F 5F 5F 5F 
       5F 5F 5F 0D 
       0A          
041CDC 20 20 20 20 0009*       db 32,32,32,32,124,32,32,32,32,124,32,32,32,32,124,32,32,32,92,32,32,32,32,124,47,32,95,124,92,95,32,32,32,95,95,95,95,95,47,13,10
       7C 20 20 20 
       20 7C 20 20 
       20 20 7C 20 
       20 20 5C 20 
       20 20 20 7C 
       2F 20 5F 7C 
       5C 5F 20 20 
       20 5F 5F 5F 
       5F 5F 2F 0D 
       0A          
041D05 20 20 20 20 0010*       db 32,32,32,32,124,32,32,32,32,124,32,32,32,32,124,32,32,32,47,32,32,32,32,32,32,60,32,32,32,124,32,32,32,32,95,95,41,95,13,10
       7C 20 20 20 
       20 7C 20 20 
       20 20 7C 20 
       20 20 2F 20 
       20 20 20 20 
       20 3C 20 20 
       20 7C 20 20 
       20 20 5F 5F 
       29 5F 0D 0A 
041D2D 2F 5C 5F 5F 0011*       db 47,92,95,95,124,32,32,32,32,124,32,32,32,32,124,32,32,47,124,32,32,32,32,124,32,32,92,32,32,124,32,32,32,32,32,32,32,32,92,13,10
       7C 20 20 20 
       20 7C 20 20 
       20 20 7C 20 
       20 2F 7C 20 
       20 20 20 7C 
       20 20 5C 20 
       20 7C 20 20 
       20 20 20 20 
       20 20 5C 0D 
       0A          
041D56 5C 5F 5F 5F 0012*       db 92,95,95,95,95,95,95,95,95,124,95,95,95,95,95,95,47,32,124,95,95,95,95,124,95,95,32,92,47,95,95,95,95,95,95,95,32,32,47,13,10
       5F 5F 5F 5F 
       5F 7C 5F 5F 
       5F 5F 5F 5F 
       2F 20 7C 5F 
       5F 5F 5F 7C 
       5F 5F 20 5C 
       2F 5F 5F 5F 
       5F 5F 5F 5F 
       20 20 2F 0D 
       0A          
041D7F 20 20 20 20 0013*       db 32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,92,47,13,10
       20 20 20 20 
       20 20 20 20 
       20 20 20 20 
       20 20 20 20 
       20 20 20 20 
       20 20 5C 2F 
       20 20 20 20 
       20 20 20 20 
       5C 2F 0D 0A 
041DA7 20 20 20 20 0014*       db 32,32,32,32,95,95,95,95,95,95,95,95,95,95,32,95,95,95,95,95,95,95,95,32,32,95,95,95,95,32,32,95,95,95,13,10
       5F 5F 5F 5F 
       5F 5F 5F 5F 
       5F 5F 20 5F 
       5F 5F 5F 5F 
       5F 5F 5F 20 
       20 5F 5F 5F 
       5F 20 20 5F 
       5F 5F 0D 0A 
041DCB 20 20 20 20 0015*       db 32,32,32,32,92,95,95,95,95,95,95,32,32,32,92,92,95,95,95,95,95,32,32,92,32,92,32,32,32,92,47,32,32,47,13,10
       5C 5F 5F 5F 
       5F 5F 5F 20 
       20 20 5C 5C 
       5F 5F 5F 5F 
       5F 20 20 5C 
       20 5C 20 20 
       20 5C 2F 20 
       20 2F 0D 0A 
041DEF 20 20 20 20 0016*       db 32,32,32,32,32,124,32,32,32,32,124,32,32,95,47,32,47,32,32,32,124,32,32,32,92,32,92,32,32,32,32,32,47,13,10
       20 7C 20 20 
       20 20 7C 20 
       20 5F 2F 20 
       2F 20 20 20 
       7C 20 20 20 
       5C 20 5C 20 
       20 20 20 20 
       2F 0D 0A    
041E12 20 20 20 20 0017*       db 32,32,32,32,32,124,32,32,32,32,124,32,32,32,92,47,32,32,32,32,124,32,32,32,32,92,47,32,32,32,32,32,92,13,10
       20 7C 20 20 
       20 20 7C 20 
       20 20 5C 2F 
       20 20 20 20 
       7C 20 20 20 
       20 5C 2F 20 
       20 20 20 20 
       5C 0D 0A    
041E35 20 20 20 20 0018*       db 32,32,32,32,32,124,95,95,95,95,95,95,32,32,47,92,95,95,95,95,95,95,95,32,32,47,95,95,95,47,92,32,32,92,13,10
       20 7C 5F 5F 
       5F 5F 5F 5F 
       20 20 2F 5C 
       5F 5F 5F 5F 
       5F 5F 5F 20 
       20 2F 5F 5F 
       5F 2F 5C 20 
       20 5C 0D 0A 
041E59 20 20 20 20 0019*       db 32,32,32,32,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,92,95,47,13,10
       20 20 20 20 
       20 20 20 20 
       5C 2F 20 20 
       20 20 20 20 
       20 20 20 5C 
       2F 20 20 20 
       20 20 20 5C 
       5F 2F 0D 0A 
041E7D             0048        include "input.inc"
041E7D             0001*   get_input:
041E7D             0002*   @loop:
041E7D             0003*   ; wait for the user to push a button
041E7D             0004*       MOSCALL mos_getkey ; a = ascii code of key pressed
041E7D 3E 00       0001*M1 			LD	A, function
041E7F 5B CF       0002*M1 			RST.LIL	08h
041E81 F3          0005*       di ; disable interrupts
041E82             0006*       ; rst.lil 10h ; print the key pressed
041E82             0007*   ; app control commands
041E82 FE 1B       0008*       cp '\e' ; escape
041E84 C8          0009*       ret z ; returns to main, which re-enables interrupts and exits app
041E85             0010*   ; song playing commands
041E85 FE 30       0011*       cp '0'
041E87 DA AD 1E 04 0012*       jp c,@other ; not a song command
041E8B FE 3A       0013*       cp '9'+1
041E8D D2 AD 1E 04 0014*       jp nc,@other ; not a song command
041E91             0015*   ; new song requested so stop playing current one
041E91 F5          0016*       push af ; preserve keypress
041E92 CD C1 20 04 0017*       call ps_close_file
041E96 F1          0018*       pop af ; restore keypress
041E97             0019*   ; get pointer to song filename and play it
041E97 D6 30       0020*       sub '0' ; a = index into filename lut
041E99 57          0021*       ld d,a
041E9A 1E 03       0022*       ld e,3 ; three bytes per filename index
041E9C ED 5C       0023*       mlt de ; index into the filename table
041E9E 21 B2 1E 04 0024*       ld hl,SFX_filename_index
041EA2 19          0025*       add hl,de ; hl points to the filename index
041EA3 ED 27       0026*       ld hl,(hl) ; hl is pointer to song filename
041EA5 22 F7 1F 04 0027*       ld (current_song),hl ; save song request
041EA9 C3 FA 1F 04 0028*       jp play_song ; re-enables interrupts and jp's to get_input when finished
041EAD             0029*   @other: ; TODO: other commands
041EAD FB          0030*       ei ; reenable interrupts
041EAE C3 7D 1E 04 0031*       jp @loop ; no valid commmand so loop
041EB2             0032*   ; end get_input
041EB2             0049        include "music.inc"
041EB2             0001*   ; This file is created by build_98_asm_sfx.py, do not edit it!
041EB2             0002*   
041EB2             0003*   ; File name lookup index:
041EB2             0004*   SFX_filename_index:
041EB2 D3 1E 04    0005*   	dl FN_Abbey_Road
041EB5 E8 1E 04    0006*   	dl FN_Dire_Straits
041EB8 FF 1E 04    0007*   	dl FN_Electric
041EBB 12 1F 04    0008*   	dl FN_Goodbye_Yellow_Brick_Road_1
041EBE 38 1F 04    0009*   	dl FN_Goodbye_Yellow_Brick_Road_2
041EC1 5E 1F 04    0010*   	dl FN_Led_Zeppelin_I
041EC4 77 1F 04    0011*   	dl FN_Led_Zeppelin_Ii
041EC7 91 1F 04    0012*   	dl FN_Physical_Graffiti
041ECA AD 1F 04    0013*   	dl FN_Rumours
041ECD BF 1F 04    0014*   	dl FN_The_Dark_Side_Of_The_Moon
041ED0 E3 1F 04    0015*   	dl FN_Whos_Next
041ED3             0016*   
041ED3             0017*   ; File name lookups:
041ED3 6D 75 73 69 0018*   FN_Abbey_Road: db "music/Abbey_Road.wav",0
       63 2F 41 62 
       62 65 79 5F 
       52 6F 61 64 
       2E 77 61 76 
       00          
041EE8 6D 75 73 69 0019*   FN_Dire_Straits: db "music/Dire_Straits.wav",0
       63 2F 44 69 
       72 65 5F 53 
       74 72 61 69 
       74 73 2E 77 
       61 76 00    
041EFF 6D 75 73 69 0020*   FN_Electric: db "music/Electric.wav",0
       63 2F 45 6C 
       65 63 74 72 
       69 63 2E 77 
       61 76 00    
041F12 6D 75 73 69 0021*   FN_Goodbye_Yellow_Brick_Road_1: db "music/Goodbye_Yellow_Brick_Road_1.wav",0
       63 2F 47 6F 
       6F 64 62 79 
       65 5F 59 65 
       6C 6C 6F 77 
       5F 42 72 69 
       63 6B 5F 52 
       6F 61 64 5F 
       31 2E 77 61 
       76 00       
041F38 6D 75 73 69 0022*   FN_Goodbye_Yellow_Brick_Road_2: db "music/Goodbye_Yellow_Brick_Road_2.wav",0
       63 2F 47 6F 
       6F 64 62 79 
       65 5F 59 65 
       6C 6C 6F 77 
       5F 42 72 69 
       63 6B 5F 52 
       6F 61 64 5F 
       32 2E 77 61 
       76 00       
041F5E 6D 75 73 69 0023*   FN_Led_Zeppelin_I: db "music/Led_Zeppelin_I.wav",0
       63 2F 4C 65 
       64 5F 5A 65 
       70 70 65 6C 
       69 6E 5F 49 
       2E 77 61 76 
       00          
041F77 6D 75 73 69 0024*   FN_Led_Zeppelin_Ii: db "music/Led_Zeppelin_Ii.wav",0
       63 2F 4C 65 
       64 5F 5A 65 
       70 70 65 6C 
       69 6E 5F 49 
       69 2E 77 61 
       76 00       
041F91 6D 75 73 69 0025*   FN_Physical_Graffiti: db "music/Physical_Graffiti.wav",0
       63 2F 50 68 
       79 73 69 63 
       61 6C 5F 47 
       72 61 66 66 
       69 74 69 2E 
       77 61 76 00 
041FAD 6D 75 73 69 0026*   FN_Rumours: db "music/Rumours.wav",0
       63 2F 52 75 
       6D 6F 75 72 
       73 2E 77 61 
       76 00       
041FBF 6D 75 73 69 0027*   FN_The_Dark_Side_Of_The_Moon: db "music/The_Dark_Side_Of_The_Moon.wav",0
       63 2F 54 68 
       65 5F 44 61 
       72 6B 5F 53 
       69 64 65 5F 
       4F 66 5F 54 
       68 65 5F 4D 
       6F 6F 6E 2E 
       77 61 76 00 
041FE3 6D 75 73 69 0028*   FN_Whos_Next: db "music/Whos_Next.wav",0
       63 2F 57 68 
       6F 73 5F 4E 
       65 78 74 2E 
       77 61 76 00 
041FF7             0050        include "play.inc"
041FF7             0001*   ; stream a song from the SD card
041FF7             0002*   ; inputs: hl = pointer to filename
041FF7             0003*   ; requirements: the file must be 8-bit signed PCM mono
041FF7             0004*   ; uses: sound channels 0 and 1, buffers 0x3000 and 0x3001
041FF7             0005*   ch0_buffer: equ 0x3000
041FF7             0006*   ch1_buffer: equ 0x3001
041FF7             0007*   cmd0_buffer: equ 0x3002
041FF7             0008*   cmd1_buffer: equ 0x3003
041FF7 00 00 00    0009*   current_song: dl 0 ; pointer to current song filename
041FFA             0010*   play_song:
041FFA 22 F7 1F 04 0011*       ld (current_song),hl
041FFE             0012*   ; stop the PRT timer
041FFE CD D8 22 04 0013*       call ps_prt_stop
042002             0014*   ; tell the user what they've won
042002 0E 00       0015*       ld c,0 ; left
042004 16 00       0016*       ld d,0 ; top
042006 1E 3E       0017*       ld e,62 ; right
042008 06 01       0018*       ld b,1; bottom
04200A CD 99 14 04 0019*       call vdu_set_txt_viewport
04200E CD 40 14 04 0020*       call vdu_cls
042012 2A F7 1F 04 0021*       ld hl,(current_song)
042016 CD 60 00 04 0022*       call printInline
04201A 50 6C 61 79 0023*       asciz "Playing song: "
       69 6E 67 20 
       73 6F 6E 67 
       3A 20 00    
042029 2A F7 1F 04 0024*       ld hl,(current_song)
04202D CD 67 00 04 0025*       call printString ; print the song filename
042031             0026*   ; reset text viewport for playing breadcrumbs
042031 0E 00       0027*       ld c,0 ; left
042033 16 01       0028*       ld d,1 ; top
042035 1E 3E       0029*       ld e,62 ; right
042037 06 01       0030*       ld b,1; bottom
042039 CD 99 14 04 0031*       call vdu_set_txt_viewport
04203D             0032*   ; open the file in read mode
04203D             0033*   ; Open a file
04203D             0034*   ; HLU: Filename
04203D             0035*   ;   C: Mode
04203D             0036*   ; Returns:
04203D             0037*   ;   A: Filehandle, or 0 if couldn't open
04203D 2A F7 1F 04 0038*       ld hl,(current_song)
042041 0E 01       0039*   	ld c,fa_read
042043             0040*       MOSCALL mos_fopen
042043 3E 0A       0001*M1 			LD	A, function
042045 5B CF       0002*M1 			RST.LIL	08h
042047 32 17 21 04 0041*       ld (ps_filehandle),a
04204B             0042*   ; read the .wav header data and copy it to the buffer
04204B CD F2 20 04 0043*       call ps_read_wav_header
04204F             0044*   ; read the first block of data
04204F CD 5C 20 04 0045*       call ps_read_file
042053             0046*   ; enable interrupts and start the PRT timer
042053 FB          0047*       ei
042054 CD BB 22 04 0048*       call ps_prt_start
042058             0049*   ; jump to user input loop:
042058             0050*   ; the play sample interrupt will return to there
042058             0051*   ; and exit app will return to main from there as well
042058 C3 7D 1E 04 0052*       jp get_input
04205C             0053*   ; end play_song
04205C             0054*   
04205C             0055*   ; read the next 1-second's worth of sound data from the file
04205C             0056*   ; and upload it to the sample buffer
04205C             0057*   ps_read_file:
04205C             0058*   ; disable interrupts so load is guaranteed to complete
04205C F3          0059*       di
04205D             0060*   ; print a playing breadcrumb
04205D 3E 2E       0061*       ld a,'.'
04205F 5B D7       0062*       rst.lil 10h
042061             0063*   ; Read a block of data from a file
042061             0064*   ;   C: Filehandle
042061             0065*   ; HLU: Pointer to where to write the data to
042061             0066*   ; DEU: Number of bytes to read
042061             0067*   ; Returns:
042061             0068*   ; DEU: Number of bytes read
042061 3A 17 21 04 0069*       ld a,(ps_filehandle)
042065 4F          0070*       ld c,a
042066 21 49 28 04 0071*       ld hl,ps_wav_data_start
04206A ED 5B 15 28 0072*       ld de,(ps_wav_sample_rate)
       04          
04206F             0073*       MOSCALL mos_fread
04206F 3E 1A       0001*M1 			LD	A, function
042071 5B CF       0002*M1 			RST.LIL	08h
042073             0074*   ; test de for zero bytes read
042073 21 00 00 00 0075*       ld hl,0
042077 AF          0076*       xor a ; clear carry
042078 ED 52       0077*       sbc hl,de ; hl = 0-chunksize
04207A C2 86 20 04 0078*       jp nz,@load ; we read some data
04207E             0079*   ; no data read so close file and play a random song
04207E CD C1 20 04 0080*       call ps_close_file
042082 C3 CE 20 04 0081*       jp ps_play_random
042086             0082*   ; load a vdu buffer from local memory
042086             0083*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
042086             0084*   @load:
042086 3A 10 21 04 0085*       ld a,(ps_channel)
04208A 3C          0086*       inc a
04208B E6 01       0087*       and 1
04208D 32 10 21 04 0088*       ld (ps_channel),a
042091 21 00 30 00 0089*       ld hl,ch0_buffer
042095 6F          0090*       ld l,a
042096 22 14 21 04 0091*       ld (ps_sampleId),hl
04209A CD FA 17 04 0092*       call vdu_clear_buffer
04209E 2A 14 21 04 0093*       ld hl,(ps_sampleId)
0420A2 D5          0094*       push de ; chunksize
0420A3 C1          0095*       pop bc ; how much data to load
0420A4 11 49 28 04 0096*       ld de,ps_wav_data_start ; pointer to data
0420A8 CD E5 15 04 0097*       call vdu_load_buffer
0420AC C9          0098*       ret
0420AD             0099*   ; end ps_read_file
0420AD             0100*   
0420AD             0101*   ; this is called by the PRT timer interrupt
0420AD             0102*   ps_play_sample:
0420AD             0103*   ; call the command buffer to play the sound
0420AD 2A 14 21 04 0104*       ld hl,(ps_sampleId)
0420B1 2C          0105*       inc l
0420B2 2C          0106*       inc l
0420B3 22 11 21 04 0107*       ld (ps_cmdId),hl ; TODO: perhaps not needed
0420B7 CD DF 17 04 0108*       call vdu_call_buffer
0420BB             0109*   ; load the next chunk of data
0420BB CD 5C 20 04 0110*       call ps_read_file
0420BF             0111*   ; reenable interrupts and return to the user input loop
0420BF FB          0112*       ei
0420C0 C9          0113*       ret
0420C1             0114*   ; end ps_play_sample
0420C1             0115*   
0420C1             0116*   ; close the file
0420C1             0117*   ps_close_file:
0420C1 CD D8 22 04 0118*       call ps_prt_stop ; stop the PRT timer
0420C5 3A 17 21 04 0119*       ld a,(ps_filehandle)
0420C9             0120*       MOSCALL mos_fclose
0420C9 3E 0B       0001*M1 			LD	A, function
0420CB 5B CF       0002*M1 			RST.LIL	08h
0420CD C9          0121*       ret
0420CE             0122*   ; end ps_close_file
0420CE             0123*   
0420CE             0124*   ; queue a random song to play next
0420CE             0125*   ps_play_random:
0420CE CD 18 05 04 0126*       call rand_8 ; a = 0-255
0420D2 E6 07       0127*       and 7 ; mod 8
0420D4 57          0128*       ld d,a
0420D5 1E 03       0129*       ld e,3 ; three bytes per filename index
0420D7 ED 5C       0130*       mlt de ; index into the filename table
0420D9 21 B2 1E 04 0131*       ld hl,SFX_filename_index
0420DD 19          0132*       add hl,de ; hl points to the filename index
0420DE ED 27       0133*       ld hl,(hl) ; hl points to the filename
0420E0 EB          0134*       ex de,hl ; setting up cp hl,de
0420E1 2A F7 1F 04 0135*       ld hl,(current_song) ; don't play the same song twice in a row
0420E5 B7          0136*       or a ; clear carry
0420E6 ED 52       0137*       sbc hl,de
0420E8 CA CE 20 04 0138*       jp z,ps_play_random ; same song, try again
0420EC EB          0139*       ex de,hl ; pointer back to hl
0420ED CD FA 1F 04 0140*       call play_song ; hit it
0420F1 C9          0141*       ret
0420F2             0142*   ; end ps_play_random
0420F2             0143*   
0420F2             0144*   ps_read_wav_header:
0420F2             0145*   ; Read a block of data from a file
0420F2             0146*   ;   C: Filehandle
0420F2             0147*   ; HLU: Pointer to where to write the data to
0420F2             0148*   ; DEU: Number of bytes to read
0420F2             0149*   ; Returns:
0420F2             0150*   ; DEU: Number of bytes read
0420F2 3A 17 21 04 0151*       ld a,(ps_filehandle)
0420F6 4F          0152*       ld c,a
0420F7 21 FD 27 04 0153*       ld hl,ps_wav_header
0420FB 11 4C 00 00 0154*       ld de,wav_header_size
0420FF             0155*       MOSCALL mos_fread
0420FF 3E 1A       0001*M1 			LD	A, function
042101 5B CF       0002*M1 			RST.LIL	08h
042103             0156*   ; test de for zero bytes read
042103 21 00 00 00 0157*       ld hl,0
042107 AF          0158*       xor a ; clear carry
042108 ED 52       0159*       sbc hl,de ; hl = 0-chunksize
04210A C8          0160*       ret z ; no data read so return zero to caller
04210B             0161*   ; data read so initialize song variables
04210B             0162*   ; load play sample command buffers (namely the sample rate for now)
04210B CD 34 22 04 0163*       call load_command_buffers
04210F C9          0164*       ret
042110             0165*   ; end ps_read_wav_header
042110             0166*   
042110             0167*   ; current active channel and bufferId's
042110 00          0168*   ps_channel: db 0 ; channel number
042111 00 00 00    0169*   ps_cmdId: dl 0 ; command bufferId
042114 00 00 00    0170*   ps_sampleId: dl 0 ; sample bufferId
042117             0171*   
042117             0172*   ; song file info
042117 00          0173*   ps_filehandle: db 0 ; file handle
042118 00 00 00    0174*   ps_fil: dl 0 ; pointer to FIL struct
04211B 00 00 00    0175*   ps_chunkpointer: dl 0 ; pointer to current chunk
04211E             0176*   ; File information structure (FILINFO)
04211E             0177*   ps_filinfo:
04211E 00 00 00 00 0178*   ps_filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
042122 00 00       0179*   ps_filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
042124 00 00       0180*   ps_filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
042126 00          0181*   ps_filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
042127 00 00 00 00 0182*   ps_filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
042134 00 00 00 00 0183*   ps_filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042234             0184*   ; end play_song
042234             0185*   
042234             0186*   load_command_buffers:
042234 21 02 30 00 0187*       ld hl,cmd0_buffer
042238 CD FA 17 04 0188*       call vdu_clear_buffer
04223C 2A 15 28 04 0189*       ld hl,(ps_wav_sample_rate)
042240 22 8A 22 04 0190*       ld (ps_sr0),hl
042244 3E 17       0191*       ld a,23
042246 32 8C 22 04 0192*       ld (ps_sr0+2),a
04224A 21 02 30 00 0193*       ld hl,cmd0_buffer
04224E 01 1D 00 00 0194*       ld bc,ps_cmd0_end-ps_cmd0
042252 11 81 22 04 0195*       ld de,ps_cmd0
042256 CD B7 17 04 0196*       call vdu_write_block_to_buffer
04225A             0197*   
04225A 21 03 30 00 0198*       ld hl,cmd1_buffer
04225E CD FA 17 04 0199*       call vdu_clear_buffer
042262 2A 15 28 04 0200*       ld hl,(ps_wav_sample_rate)
042266 22 A7 22 04 0201*       ld (ps_sr1),hl
04226A 3E 17       0202*       ld a,23
04226C 32 A9 22 04 0203*       ld (ps_sr1+2),a
042270 21 03 30 00 0204*       ld hl,cmd1_buffer
042274 01 1D 00 00 0205*       ld bc,ps_cmd1_end-ps_cmd1
042278 11 9E 22 04 0206*       ld de,ps_cmd1
04227C CD B7 17 04 0207*       call vdu_write_block_to_buffer
042280 C9          0208*       ret
042281             0209*   ps_cmd0:
042281             0210*   ; vdu_buffer_to_sound command string
042281             0211*   ; Command 5: Buffer to sound
042281             0212*   ; VDU 23, 0, &85, channel (ignored), 5, 2, bufferId; format, [sampleRate;]
042281 17 00 85    0213*       db 23,0,0x85 ; vdu sound command header
042284 00          0214*       db 0x00 ; channel (ignored)
042285 05          0215*       db 0x05 ; buffer to sound command
042286 02          0216*       db 0x02 ; command 2 create sample
042287 00 30       0217*       dw ch0_buffer
042289 09          0218*       db 1+8 ; 8-bit unsigned PCM mono, 8 = sample rate argument follows
04228A             0219*   ps_sr0:
04228A 00 00       0220*       dw 0x0000 ; sample rate Hz
04228C             0221*   ; vdu_play_sfx command string
04228C             0222*   ; Command 4: Set waveform
04228C             0223*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
04228C 17 00 85    0224*       db 23,0,$85 ; vdu sound command header
04228F 00          0225*       db 0 ; channel
042290 04          0226*       db 4 ; set waveform command
042291 08          0227*       db 8 ; waveform 8 = sample
042292 00 30       0228*       dw ch0_buffer ; sample bufferId
042294             0229*   ; Command 0: Play note
042294             0230*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
042294 17 00 85    0231*       db 23,0,$85 ; vdu sound command header
042297 00          0232*       db 0 ; channel
042298 00          0233*       db 0 ; play note command
042299 7F          0234*       db 127  ; volume 127 = max
04229A 00 00       0235*       dw 0 ; frequency (relevant only for tuneable samples)
04229C 00 00       0236*       dw 0 ; duration (ms), zero means play one time in full
04229E             0237*   ps_cmd0_end:
04229E             0238*   
04229E             0239*   ps_cmd1:
04229E             0240*   ; vdu_buffer_to_sound command string
04229E             0241*   ; Command 5: Buffer to sound
04229E             0242*   ; VDU 23, 0, &85, channel (ignored), 5, 2, bufferId; format, [sampleRate;]
04229E 17 00 85    0243*       db 23,0,0x85 ; vdu sound command header
0422A1 00          0244*       db 0x00 ; channel (ignored)
0422A2 05          0245*       db 0x05 ; buffer to sound command
0422A3 02          0246*       db 0x02 ; command 2 create sample
0422A4 01 30       0247*       dw ch1_buffer
0422A6 09          0248*       db 1+8 ; 8-bit unsigned PCM mono, 8 = sample rate argument follows
0422A7             0249*   ps_sr1:
0422A7 00 00       0250*       dw 0x0000 ; sample rate Hz
0422A9             0251*   ; vdu_play_sfx command string
0422A9             0252*   ; Command 4: Set waveform
0422A9             0253*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
0422A9 17 00 85    0254*       db 23,0,$85 ; vdu sound command header
0422AC 01          0255*       db 1 ; channel
0422AD 04          0256*       db 4 ; set waveform command
0422AE 08          0257*       db 8 ; waveform 8 = sample
0422AF 01 30       0258*       dw ch1_buffer ; sample bufferId
0422B1             0259*   ; Command 0: Play note
0422B1             0260*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
0422B1 17 00 85    0261*       db 23,0,$85 ; vdu sound command header
0422B4 01          0262*       db 1 ; channel
0422B5 00          0263*       db 0 ; play note command
0422B6 7F          0264*       db 127  ; volume 127 = max
0422B7 00 00       0265*       dw 0 ; frequency (relevant only for tuneable samples)
0422B9 00 00       0266*       dw 0 ; duration (ms), zero means play one time in full
0422BB             0267*   ps_cmd1_end:
0422BB             0268*   ; end load_command_buffers
0422BB             0269*   
0422BB             0051        include "timer_jukebox.inc"
0422BB             0001*   ps_prt_reload: equ [72000/2]+1 ; 2 ticks per second at 18.432 MHz with a 256 clock divider
0422BB             0002*   
0422BB             0003*   ; start PRT timer
0422BB             0004*   ps_prt_start:
0422BB 21 00 00 00 0005*       ld hl,0
0422BF 22 FA 22 04 0006*       ld (ps_prt_irq_counter),hl
0422C3 21 A1 8C 00 0007*       ld hl,ps_prt_reload
0422C7 ED 29 84    0008*       out0 (TMR1_CTL+TMR_RES_LOW),l
0422CA ED 21 85    0009*   	out0 (TMR1_CTL+TMR_RES_HIGH),h
0422CD             0010*   ; disable timer (in effect, reset it)
0422CD 3E 0E       0011*       ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_256 | RST_EN_1 | PRT_EN_0
0422CF ED 39 83    0012*   	out0 (TMR1_CTL+TMR_REG_CTL),a
0422D2             0013*   ; enable timer,with interrupt and CONTINUOUS mode,clock divider 256
0422D2 3E 5F       0014*       ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_256 | RST_EN_1 | PRT_EN_1
0422D4 ED 39 83    0015*   	out0 (TMR1_CTL+TMR_REG_CTL),a
0422D7 C9          0016*       ret
0422D8             0017*   
0422D8             0018*   ; stop PRT timer
0422D8             0019*   ps_prt_stop:
0422D8 3E 0E       0020*       ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_256 | RST_EN_1 | PRT_EN_0
0422DA ED 39 83    0021*   	out0 (TMR1_CTL+TMR_REG_CTL),a
0422DD C9          0022*       ret
0422DE             0023*   
0422DE             0024*   ; ===============================================
0422DE             0025*   ; PRT Timer Interrupt Handling
0422DE             0026*   ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.asm
0422DE             0027*   ; -----------------------------------------------
0422DE             0028*   ps_prt_irq_init:
0422DE             0029*       ; set up interrupt vector table 2
0422DE 21 00 00 00 0030*   	ld hl,0
0422E2 3A 0C 01 00 0031*   	ld a,($10c)
0422E6 6F          0032*   	ld l,a
0422E7 3A 0D 01 00 0033*   	ld a,($10d)
0422EB 67          0034*   	ld h,a
0422EC             0035*   
0422EC             0036*   	; skip over CALL ($c3)
0422EC 23          0037*   	inc hl
0422ED             0038*   	; load address of jump into vector table 2 (in ram)
0422ED ED 27       0039*   	ld hl,(hl)
0422EF             0040*   
0422EF             0041*   	; write CALL ps_prt_irq_handler to vector table 2
0422EF 3E C3       0042*   	ld a,$c3
0422F1 77          0043*   	ld (hl),a
0422F2 23          0044*   	inc hl
0422F3 11 FB 22 04 0045*   	ld de,ps_prt_irq_handler
0422F7 ED 1F       0046*   	ld (hl),de
0422F9             0047*   
0422F9 C9          0048*       ret
0422FA             0049*   ; end ps_prt_irq_init
0422FA             0050*   
0422FA             0051*   ; interrupt routine for playing the next sample
0422FA             0052*   ps_prt_irq_counter:
0422FA 00          0053*   	db 0
0422FB             0054*   ps_prt_irq_handler:
0422FB F3          0055*       di
0422FC 08          0056*       ex af,af'
0422FD D9          0057*       exx
0422FE             0058*   ; clear sysvar_keyascii
0422FE             0059*   	MOSCALL mos_sysvars
0422FE 3E 08       0001*M1 			LD	A, function
042300 5B CF       0002*M1 			RST.LIL	08h
042302 AF          0060*   	xor a
042303 DD 77 05    0061*   	ld (IX+sysvar_keyascii),a
042306             0062*   ; read the timer interrupt and bump the counter
042306 ED 38 83    0063*       in0 a,(TMR1_CTL+TMR_REG_CTL)
042309 3A FA 22 04 0064*       ld a,(ps_prt_irq_counter)
04230D 3C          0065*       inc a
04230E E6 01       0066*       and 1 ; modulo 2
042310 32 FA 22 04 0067*       ld (ps_prt_irq_counter),a
042314             0068*   ; if counter zero, play the next sample
042314 CC AD 20 04 0069*       call z,ps_play_sample
042318 D9          0070*       exx
042319 08          0071*       ex af,af'
04231A FB          0072*       ei
04231B 5B ED 4D    0073*       reti.l
04231E             0074*   ; end ps_prt_irq_handler
04231E             0052        include "wav.inc"
04231E             0001*   ; WAV File Structure Offsets and Descriptions
04231E             0002*   wav_riff:          EQU 0    ; 4 bytes: "RIFF" identifier
04231E             0003*   wav_file_size:     EQU 4    ; 4 bytes: Total file size minus 8 bytes for RIFF header
04231E             0004*   wav_wave:          EQU 8    ; 4 bytes: "WAVE" identifier
04231E             0005*   wav_fmt_marker:    EQU 12   ; 4 bytes: "fmt " subchunk marker
04231E             0006*   wav_fmt_size:      EQU 16   ; 4 bytes: Format chunk size (16 for PCM)
04231E             0007*   wav_audio_format:  EQU 20   ; 2 bytes: Audio format (1 = PCM)
04231E             0008*   wav_num_channels:  EQU 22   ; 2 bytes: Number of channels (1 = mono, 2 = stereo)
04231E             0009*   wav_sample_rate:   EQU 24   ; 4 bytes: Sample rate in Hz (e.g., 32768)
04231E             0010*   wav_byte_rate:     EQU 28   ; 4 bytes: Bytes per second (SampleRate * NumChannels * BitsPerSample / 8)
04231E             0011*   wav_block_align:   EQU 32   ; 2 bytes: Bytes per sample block (NumChannels * BitsPerSample / 8)
04231E             0012*   wav_bits_per_sample: EQU 34 ; 2 bytes: Bits per sample (e.g., 8 or 16)
04231E             0013*   
04231E             0014*   ; LIST Chunk (Extra Metadata)
04231E             0015*   wav_list_marker:   EQU 36   ; 4 bytes: "LIST" marker
04231E             0016*   wav_list_size:     EQU 40   ; 4 bytes: Size of the LIST chunk (e.g., 26)
04231E             0017*   wav_info_marker:   EQU 44   ; 4 bytes: "INFO" marker
04231E             0018*   wav_isft_marker:   EQU 48   ; 4 bytes: "ISFT" marker (software identifier)
04231E             0019*   wav_isft_data:     EQU 52   ; 14 bytes: Software info string (e.g., "Lavf59.27.100")
04231E             0020*   wav_isft_padding:  EQU 66   ; 2 bytes: Padding/NULL terminator for alignment
04231E             0021*   
04231E             0022*   ; Data Chunk
04231E             0023*   wav_data_marker:   EQU 68   ; 4 bytes: "data" subchunk marker
04231E             0024*   wav_data_size:     EQU 72   ; 4 bytes: Size of the audio data in bytes
04231E             0025*   wav_data_start:    EQU 76   ; Start of audio data
04231E             0026*   wav_header_size:   EQU wav_data_start ; Total Header Size: 76 bytes
04231E             0053        include "debug.inc"
04231E             0001*   printHexA:
04231E F5          0002*       push af
04231F C5          0003*       push bc
042320 CD AE 00 04 0004*       call printHex8
042324 3E 20       0005*       ld a,' '
042326 5B D7       0006*       rst.lil 10h
042328 C1          0007*       pop bc
042329 F1          0008*       pop af
04232A C9          0009*       ret
04232B             0010*   
04232B             0011*   printHexHL:
04232B F5          0012*       push af
04232C C5          0013*       push bc
04232D CD A8 00 04 0014*       call printHex16
042331 3E 20       0015*       ld a,' '
042333 5B D7       0016*       rst.lil 10h
042335 C1          0017*       pop bc
042336 F1          0018*       pop af
042337 C9          0019*       ret
042338             0020*   
042338             0021*   printHexUHL:
042338 F5          0022*       push af
042339 C5          0023*       push bc
04233A CD A0 00 04 0024*       call printHex24
04233E 3E 20       0025*       ld a,' '
042340 5B D7       0026*       rst.lil 10h
042342 C1          0027*       pop bc
042343 F1          0028*       pop af
042344 C9          0029*       ret
042345             0030*   
042345             0031*   printHexAUHL:
042345 F5          0032*       push af
042346 C5          0033*       push bc
042347 CD AE 00 04 0034*       call printHex8
04234B 3E 2E       0035*       ld a,'.'
04234D 5B D7       0036*       rst.lil 10h
04234F CD A0 00 04 0037*       call printHex24
042353 3E 20       0038*       ld a,' '
042355 5B D7       0039*       rst.lil 10h
042357 C1          0040*       pop bc
042358 F1          0041*       pop af
042359 C9          0042*       ret
04235A             0043*   
04235A             0044*   printHexABHL:
04235A             0045*   ; preserve registers
04235A C5          0046*       push bc ; b will be ok c will not
04235B F5          0047*       push af ; will get totally destroyed
04235C             0048*   ; print a
04235C CD AE 00 04 0049*       call printHex8
042360             0050*   ; print b
042360 78          0051*       ld a,b
042361 CD AE 00 04 0052*       call printHex8
042365             0053*   ; print hl
042365 CD A8 00 04 0054*       call printHex16
042369             0055*   ; restore registers
042369 F1          0056*       pop af
04236A C1          0057*       pop bc
04236B C9          0058*       ret
04236C             0059*   
04236C             0060*   printHexBHL:
04236C             0061*   ; preserve registers
04236C C5          0062*       push bc ; b will be ok c will not
04236D F5          0063*       push af ; will get totally destroyed
04236E             0064*   ; print b
04236E 78          0065*       ld a,b
04236F CD AE 00 04 0066*       call printHex8
042373             0067*   ; print hl
042373 CD A8 00 04 0068*       call printHex16
042377             0069*   ; restore registers
042377 F1          0070*       pop af
042378 C1          0071*       pop bc
042379 C9          0072*       ret
04237A             0073*   
04237A             0074*   printHexCDE:
04237A             0075*   ; preserve registers
04237A C5          0076*       push bc ; b will be ok c will not
04237B F5          0077*       push af ; will get totally destroyed
04237C             0078*   ; print c
04237C 79          0079*       ld a,c
04237D CD AE 00 04 0080*       call printHex8
042381             0081*   ; print de
042381 EB          0082*       ex de,hl
042382 CD A8 00 04 0083*       call printHex16
042386 EB          0084*       ex de,hl
042387             0085*   ; restore registers
042387 F1          0086*       pop af
042388 C1          0087*       pop bc
042389 C9          0088*       ret
04238A             0089*   
04238A             0090*   printHexUIX:
04238A             0091*   ; store everything in scratch
04238A 22 35 03 04 0092*       ld (uhl),hl
04238E ED 43 38 03 0093*       ld (ubc),bc
       04          
042393 ED 53 3B 03 0094*       ld (ude),de
       04          
042398 DD 22 3E 03 0095*       ld (uix),ix
       04          
04239D FD 22 41 03 0096*       ld (uiy),iy
       04          
0423A2 F5          0097*       push af ; fml
0423A3             0098*   
0423A3 21 CC 02 04 0099*       ld hl,str_ixu
0423A7 CD 67 00 04 0100*       call printString
0423AB 2A 3E 03 04 0101*       ld hl,(uix)
0423AF CD A0 00 04 0102*       call printHex24
0423B3 CD 7C 00 04 0103*       call printNewLine
0423B7             0104*   
0423B7             0105*   ; restore everything
0423B7 2A 35 03 04 0106*       ld hl, (uhl)
0423BB ED 4B 38 03 0107*       ld bc, (ubc)
       04          
0423C0 ED 5B 3B 03 0108*       ld de, (ude)
       04          
0423C5 DD 2A 3E 03 0109*       ld ix, (uix)
       04          
0423CA FD 2A 41 03 0110*       ld iy, (uiy)
       04          
0423CF F1          0111*       pop af
0423D0             0112*   ; all done
0423D0 C9          0113*       ret
0423D1             0114*   
0423D1             0115*   
0423D1             0116*   ; print registers to screen in hexidecimal format
0423D1             0117*   ; inputs: none
0423D1             0118*   ; outputs: values of every register printed to screen
0423D1             0119*   ;    values of each register in global scratch memory
0423D1             0120*   ; destroys: nothing
0423D1             0121*   stepRegistersHex:
0423D1             0122*   ; store everything in scratch
0423D1 22 35 03 04 0123*       ld (uhl),hl
0423D5 ED 43 38 03 0124*       ld (ubc),bc
       04          
0423DA ED 53 3B 03 0125*       ld (ude),de
       04          
0423DF DD 22 3E 03 0126*       ld (uix),ix
       04          
0423E4 FD 22 41 03 0127*       ld (uiy),iy
       04          
0423E9 F5          0128*       push af ; fml
0423EA E1          0129*       pop hl ; thanks, zilog
0423EB 22 32 03 04 0130*       ld (uaf),hl
0423EF F5          0131*       push af ; dammit
0423F0             0132*   
0423F0             0133*   ; home the cursor
0423F0             0134*       ; call vdu_home_cursor
0423F0             0135*   
0423F0             0136*   ; print each register
0423F0 21 B8 02 04 0137*       ld hl,str_afu
0423F4 CD 67 00 04 0138*       call printString
0423F8 2A 32 03 04 0139*       ld hl,(uaf)
0423FC CD A0 00 04 0140*       call printHex24
042400 CD 7C 00 04 0141*       call printNewLine
042404             0142*   
042404 21 BD 02 04 0143*       ld hl,str_hlu
042408 CD 67 00 04 0144*       call printString
04240C 2A 35 03 04 0145*       ld hl,(uhl)
042410 CD A0 00 04 0146*       call printHex24
042414 CD 7C 00 04 0147*       call printNewLine
042418             0148*   
042418 21 C2 02 04 0149*       ld hl,str_bcu
04241C CD 67 00 04 0150*       call printString
042420 2A 38 03 04 0151*       ld hl,(ubc)
042424 CD A0 00 04 0152*       call printHex24
042428 CD 7C 00 04 0153*       call printNewLine
04242C             0154*   
04242C 21 C7 02 04 0155*       ld hl,str_deu
042430 CD 67 00 04 0156*       call printString
042434 2A 3B 03 04 0157*       ld hl,(ude)
042438 CD A0 00 04 0158*       call printHex24
04243C CD 7C 00 04 0159*       call printNewLine
042440             0160*   
042440 21 CC 02 04 0161*       ld hl,str_ixu
042444 CD 67 00 04 0162*       call printString
042448 2A 3E 03 04 0163*       ld hl,(uix)
04244C CD A0 00 04 0164*       call printHex24
042450 CD 7C 00 04 0165*       call printNewLine
042454             0166*   
042454 21 D1 02 04 0167*       ld hl,str_iyu
042458 CD 67 00 04 0168*       call printString
04245C 2A 41 03 04 0169*       ld hl,(uiy)
042460 CD A0 00 04 0170*       call printHex24
042464 CD 7C 00 04 0171*       call printNewLine
042468             0172*   
042468             0173*       ; call vsync
042468             0174*   
042468 CD 7C 00 04 0175*       call printNewLine
04246C             0176*   
04246C             0177*   ; check for right shift key and quit if pressed
04246C             0178*       MOSCALL mos_getkbmap
04246C 3E 1E       0001*M1 			LD	A, function
04246E 5B CF       0002*M1 			RST.LIL	08h
042470             0179*   @stayhere:
042470             0180*   ; 7 RightShift
042470 DD CB 00 76 0181*       bit 6,(ix+0)
042474 20 02       0182*       jr nz,@RightShift
042476 18 F8       0183*       jr @stayhere
042478             0184*   @RightShift:
042478 DD CB 0E 86 0185*       res 0,(ix+14) ; debounce the key (hopefully)
04247C 3E 80       0186*       ld a,%10000000
04247E             0187*       ; call multiPurposeDelay
04247E             0188*   
04247E             0189*   ; restore everything
04247E 2A 35 03 04 0190*       ld hl, (uhl)
042482 ED 4B 38 03 0191*       ld bc, (ubc)
       04          
042487 ED 5B 3B 03 0192*       ld de, (ude)
       04          
04248C DD 2A 3E 03 0193*       ld ix, (uix)
       04          
042491 FD 2A 41 03 0194*       ld iy, (uiy)
       04          
042496 F1          0195*       pop af
042497             0196*   ; all done
042497 C9          0197*       ret
042498             0198*   
042498             0199*   ; print registers to screen in hexidecimal format
042498             0200*   ; inputs: none
042498             0201*   ; outputs: values of every register printed to screen
042498             0202*   ;    values of each register in global scratch memory
042498             0203*   ; destroys: nothing
042498             0204*   dumpRegistersHex:
042498             0205*   ; store everything in scratch
042498 22 35 03 04 0206*       ld (uhl),hl
04249C ED 43 38 03 0207*       ld (ubc),bc
       04          
0424A1 ED 53 3B 03 0208*       ld (ude),de
       04          
0424A6 DD 22 3E 03 0209*       ld (uix),ix
       04          
0424AB FD 22 41 03 0210*       ld (uiy),iy
       04          
0424B0 F5          0211*       push af ; fml
0424B1 E1          0212*       pop hl ; thanks, zilog
0424B2 22 32 03 04 0213*       ld (uaf),hl
0424B6 F5          0214*       push af ; dammit
0424B7             0215*   
0424B7             0216*   ; home the cursor
0424B7             0217*       ; call vdu_home_cursor
0424B7             0218*       ; call printNewLine
0424B7             0219*   
0424B7             0220*   ; print each register
0424B7 21 B8 02 04 0221*       ld hl,str_afu
0424BB CD 67 00 04 0222*       call printString
0424BF 2A 32 03 04 0223*       ld hl,(uaf)
0424C3 CD A0 00 04 0224*       call printHex24
0424C7 CD 7C 00 04 0225*       call printNewLine
0424CB             0226*   
0424CB 21 BD 02 04 0227*       ld hl,str_hlu
0424CF CD 67 00 04 0228*       call printString
0424D3 2A 35 03 04 0229*       ld hl,(uhl)
0424D7 CD A0 00 04 0230*       call printHex24
0424DB CD 7C 00 04 0231*       call printNewLine
0424DF             0232*   
0424DF 21 C2 02 04 0233*       ld hl,str_bcu
0424E3 CD 67 00 04 0234*       call printString
0424E7 2A 38 03 04 0235*       ld hl,(ubc)
0424EB CD A0 00 04 0236*       call printHex24
0424EF CD 7C 00 04 0237*       call printNewLine
0424F3             0238*   
0424F3 21 C7 02 04 0239*       ld hl,str_deu
0424F7 CD 67 00 04 0240*       call printString
0424FB 2A 3B 03 04 0241*       ld hl,(ude)
0424FF CD A0 00 04 0242*       call printHex24
042503 CD 7C 00 04 0243*       call printNewLine
042507             0244*   
042507 21 CC 02 04 0245*       ld hl,str_ixu
04250B CD 67 00 04 0246*       call printString
04250F 2A 3E 03 04 0247*       ld hl,(uix)
042513 CD A0 00 04 0248*       call printHex24
042517 CD 7C 00 04 0249*       call printNewLine
04251B             0250*   
04251B 21 D1 02 04 0251*       ld hl,str_iyu
04251F CD 67 00 04 0252*       call printString
042523 2A 41 03 04 0253*       ld hl,(uiy)
042527 CD A0 00 04 0254*       call printHex24
04252B             0255*   
04252B CD 7C 00 04 0256*       call printNewLine
04252F CD 7C 00 04 0257*       call printNewLine
042533             0258*   ; restore everything
042533 2A 35 03 04 0259*       ld hl, (uhl)
042537 ED 4B 38 03 0260*       ld bc, (ubc)
       04          
04253C ED 5B 3B 03 0261*       ld de, (ude)
       04          
042541 DD 2A 3E 03 0262*       ld ix, (uix)
       04          
042546 FD 2A 41 03 0263*       ld iy, (uiy)
       04          
04254B F1          0264*       pop af
04254C             0265*   ; all done
04254C C9          0266*       ret
04254D             0267*   
04254D             0268*   dumpRegistersHexPrime:
04254D D9          0269*       exx
04254E 08          0270*       ex af,af'
04254F CD 98 24 04 0271*       call dumpRegistersHex
042553 08          0272*       ex af,af'
042554 D9          0273*       exx
042555 C9          0274*       ret
042556             0275*   
042556             0276*   ; additionally dump prime registers
042556             0277*   ; inputs: none
042556             0278*   ; outputs: values of every register printed to screen
042556             0279*   ; destroys: nothing
042556             0280*   dumpRegistersHexAll:
042556 CD 98 24 04 0281*       call dumpRegistersHex
04255A 08          0282*       ex af,af'
04255B D9          0283*       exx
04255C CD 98 24 04 0284*       call dumpRegistersHex
042560 08          0285*       ex af,af'
042561 D9          0286*       exx
042562 C9          0287*       ret
042563             0288*   
042563             0289*   ; print hlu to screen in hexidecimal format
042563             0290*   ; inputs: none
042563             0291*   ; destroys: nothing
042563             0292*   print_hex_hl:
042563 F5          0293*       push af
042564 E5          0294*       push hl
042565 21 BD 02 04 0295*       ld hl,str_hlu
042569 CD 67 00 04 0296*       call printString
04256D E1          0297*       pop hl
04256E E5          0298*       push hl
04256F CD A0 00 04 0299*       call printHex24
042573 3E 20       0300*       ld a,' '
042575 5B D7       0301*       rst.lil 10h
042577 E1          0302*       pop hl
042578 F1          0303*       pop af
042579 C9          0304*       ret
04257A             0305*   
04257A             0306*   ; print bcu to screen in hexidecimal format
04257A             0307*   ; inputs: none
04257A             0308*   ; destroys: nothing
04257A             0309*   print_hex_bc:
04257A F5          0310*       push af
04257B E5          0311*       push hl
04257C C5          0312*       push bc
04257D 21 C2 02 04 0313*       ld hl,str_bcu
042581 CD 67 00 04 0314*       call printString
042585 E1          0315*       pop hl
042586 E5          0316*       push hl
042587 CD A0 00 04 0317*       call printHex24
04258B 3E 20       0318*       ld a,' '
04258D 5B D7       0319*       rst.lil 10h
04258F C1          0320*       pop bc
042590 E1          0321*       pop hl
042591 F1          0322*       pop af
042592 C9          0323*       ret
042593             0324*   
042593             0325*   ; print deu to screen in hexidecimal format
042593             0326*   ; inputs: none
042593             0327*   ; destroys: nothing
042593             0328*   print_hex_de:
042593 F5          0329*       push af
042594 E5          0330*       push hl
042595 D5          0331*       push de
042596 21 C7 02 04 0332*       ld hl,str_deu
04259A CD 67 00 04 0333*       call printString
04259E E1          0334*       pop hl
04259F E5          0335*       push hl
0425A0 CD A0 00 04 0336*       call printHex24
0425A4 3E 20       0337*       ld a,' '
0425A6 5B D7       0338*       rst.lil 10h
0425A8 D1          0339*       pop de
0425A9 E1          0340*       pop hl
0425AA F1          0341*       pop af
0425AB C9          0342*       ret
0425AC             0343*   
0425AC             0344*   
0425AC             0345*   ; inputs: whatever is in the flags register
0425AC             0346*   ; outputs: binary representation of flags
0425AC             0347*   ;          with a header so we know which is what
0425AC             0348*   ; destroys: nothing
0425AC             0349*   ; preserves: everything
0425AC             0350*   dumpFlags:
0425AC             0351*   ; first we curse zilog for not giving direct access to flags
0425AC F5          0352*       push af ; this is so we can send it back unharmed
0425AD F5          0353*       push af ; this is so we can pop it to hl
0425AE             0354*   ; store everything in scratch
0425AE 22 35 03 04 0355*       ld (uhl),hl
0425B2 ED 43 38 03 0356*       ld (ubc),bc
       04          
0425B7 ED 53 3B 03 0357*       ld (ude),de
       04          
0425BC DD 22 3E 03 0358*       ld (uix),ix
       04          
0425C1 FD 22 41 03 0359*       ld (uiy),iy
       04          
0425C6             0360*   ; next we print the header
0425C6 21 F2 25 04 0361*       ld hl,@header
0425CA CD 67 00 04 0362*       call printString
0425CE E1          0363*       pop hl ; flags are now in l
0425CF 7D          0364*       ld a,l ; flags are now in a
0425D0 CD 6E 02 04 0365*       call printBin8
0425D4 CD 7C 00 04 0366*       call printNewLine
0425D8             0367*   ; restore everything
0425D8 2A 35 03 04 0368*       ld hl, (uhl)
0425DC ED 4B 38 03 0369*       ld bc, (ubc)
       04          
0425E1 ED 5B 3B 03 0370*       ld de, (ude)
       04          
0425E6 DD 2A 3E 03 0371*       ld ix, (uix)
       04          
0425EB FD 2A 41 03 0372*       ld iy, (uiy)
       04          
0425F0 F1          0373*       pop af ; send her home the way she came
0425F1 C9          0374*       ret
0425F2             0375*   ; Bit 7 (S): Sign flag
0425F2             0376*   ; Bit 6 (Z): Zero flag
0425F2             0377*   ; Bit 5 (5): Reserved (copy of bit 5 of the result)
0425F2             0378*   ; Bit 4 (H): Half Carry flag
0425F2             0379*   ; Bit 3 (3): Reserved (copy of bit 3 of the result)
0425F2             0380*   ; Bit 2 (PV): Parity/Overflow flag
0425F2             0381*   ; Bit 1 (N): Subtract flag
0425F2             0382*   ; Bit 0 (C): Carry flag
0425F2 53 5A 78 48 0383*   @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
0425FD             0384*   
0425FD             0385*   
0425FD             0386*   ; print bytes from an address to the screen in hexidecimal format
0425FD             0387*   ; inputs: hl = address of first byte to print, a = number of bytes to print
0425FD             0388*   ; outputs: values of each byte printed to screen separated by spaces
0425FD             0389*   ; destroys: nothing
0425FD             0390*   dumpMemoryHex:
0425FD             0391*   ; save registers to the stack
0425FD C5          0392*       push bc
0425FE E5          0393*       push hl
0425FF F5          0394*       push af
042600             0395*   
042600             0396*   ; print the address and separator
042600 CD A0 00 04 0397*       call printHex24
042604 3E 3A       0398*       ld a,':'
042606 5B D7       0399*       rst.lil 10h
042608 3E 20       0400*       ld a,' '
04260A 5B D7       0401*       rst.lil 10h
04260C             0402*   
04260C             0403*   ; set b to be our loop counter
04260C F1          0404*       pop af
04260D 47          0405*       ld b,a
04260E E1          0406*       pop hl
04260F E5          0407*       push hl
042610 F5          0408*       push af
042611             0409*   @loop:
042611             0410*   ; print the byte
042611 7E          0411*       ld a,(hl)
042612 CD AE 00 04 0412*       call printHex8
042616             0413*   ; print a space
042616 3E 20       0414*       ld a,' '
042618 5B D7       0415*       rst.lil 10h
04261A 23          0416*       inc hl
04261B 10 F4       0417*       djnz @loop
04261D CD 7C 00 04 0418*       call printNewLine
042621             0419*   
042621             0420*   ; restore everything
042621 F1          0421*       pop af
042622 E1          0422*       pop hl
042623 C1          0423*       pop bc
042624             0424*   
042624             0425*   ; all done
042624 C9          0426*       ret
042625             0427*   
042625             0428*   
042625             0429*   ; print bytes from an address to the screen in binary format
042625             0430*   ; inputs: hl = address of first byte to print, a = number of bytes to print
042625             0431*   ; outputs: values of each byte printed to screen separated by spaces
042625             0432*   ; destroys: nothing
042625             0433*   dumpMemoryBin:
042625             0434*   ; save all registers to the stack
042625 F5          0435*       push af
042626 C5          0436*       push bc
042627 D5          0437*       push de
042628 E5          0438*       push hl
042629 DD E5       0439*       push ix
04262B FD E5       0440*       push iy
04262D             0441*   
04262D             0442*   ; set b to be our loop counter
04262D 47          0443*       ld b,a
04262E             0444*   @loop:
04262E             0445*   ; print the byte
04262E 7E          0446*       ld a,(hl)
04262F E5          0447*       push hl
042630 C5          0448*       push bc
042631 CD 6E 02 04 0449*       call printBin8
042635 C1          0450*       pop bc
042636             0451*   ; print a space
042636 3E 20       0452*       ld a,' '
042638 5B D7       0453*       rst.lil 10h
04263A E1          0454*       pop hl
04263B 23          0455*       inc hl
04263C 10 F0       0456*       djnz @loop
04263E CD 7C 00 04 0457*       call printNewLine
042642             0458*   
042642             0459*   ; restore everything
042642 FD E1       0460*       pop iy
042644 DD E1       0461*       pop ix
042646 E1          0462*       pop hl
042647 D1          0463*       pop de
042648 C1          0464*       pop bc
042649 F1          0465*       pop af
04264A             0466*   ; all done
04264A C9          0467*       ret
04264B             0468*   
04264B             0469*   ; print bytes from an address to the screen in binary format
04264B             0470*   ; with the bits of each byte in reverse order (lsb first)
04264B             0471*   ; inputs: hl = address of first byte to print, a = number of bytes to print
04264B             0472*   ; outputs: values of each byte printed to screen separated by spaces
04264B             0473*   ; destroys: nothing
04264B             0474*   dumpMemoryBinRev:
04264B             0475*   ; save all registers to the stack
04264B F5          0476*       push af
04264C C5          0477*       push bc
04264D D5          0478*       push de
04264E E5          0479*       push hl
04264F DD E5       0480*       push ix
042651 FD E5       0481*       push iy
042653             0482*   
042653             0483*   ; set b to be our loop counter
042653 47          0484*       ld b,a
042654             0485*   @loop:
042654             0486*   ; print the byte
042654 7E          0487*       ld a,(hl)
042655 E5          0488*       push hl
042656 C5          0489*       push bc
042657 CD 93 02 04 0490*       call printBin8Rev
04265B C1          0491*       pop bc
04265C             0492*   ; print a space
04265C 3E 20       0493*       ld a,' '
04265E 5B D7       0494*       rst.lil 10h
042660 E1          0495*       pop hl
042661 23          0496*       inc hl
042662 10 F0       0497*       djnz @loop
042664 CD 7C 00 04 0498*       call printNewLine
042668             0499*   
042668             0500*   ; restore everything
042668 FD E1       0501*       pop iy
04266A DD E1       0502*       pop ix
04266C E1          0503*       pop hl
04266D D1          0504*       pop de
04266E C1          0505*       pop bc
04266F F1          0506*       pop af
042670             0507*   ; all done
042670 C9          0508*       ret
042671             0509*   
042671             0510*   DEBUG_PRINT:
042671             0511*       PUSH_ALL
042671 08          0001*M1     ex af,af'
042672 D9          0002*M1     exx
042673 F5          0003*M1     push af
042674 E5          0004*M1     push hl
042675 C5          0005*M1     push bc
042676 D5          0006*M1     push de
042677             0007*M1 
042677 08          0008*M1     ex af,af'
042678 D9          0009*M1     exx
042679 F5          0010*M1     push af
04267A E5          0011*M1     push hl
04267B C5          0012*M1     push bc
04267C D5          0013*M1     push de
04267D DD E5       0014*M1     push ix
04267F FD E5       0015*M1     push iy
042681             0512*       ; ld c,0 ; X
042681             0513*       ; ld b,0 ; Y
042681             0514*       ; call vdu_move_cursor
042681 CD 7C 00 04 0515*       call printNewLine
042685             0516*       POP_ALL
042685 FD E1       0001*M1     pop iy
042687 DD E1       0002*M1     pop ix
042689 D1          0003*M1     pop de
04268A C1          0004*M1     pop bc
04268B E1          0005*M1     pop hl
04268C F1          0006*M1     pop af
04268D 08          0007*M1     ex af,af'
04268E D9          0008*M1     exx
04268F             0009*M1 
04268F D1          0010*M1     pop de
042690 C1          0011*M1     pop bc
042691 E1          0012*M1     pop hl
042692 F1          0013*M1     pop af
042693 08          0014*M1     ex af,af'
042694 D9          0015*M1     exx
042695             0517*       PUSH_ALL
042695 08          0001*M1     ex af,af'
042696 D9          0002*M1     exx
042697 F5          0003*M1     push af
042698 E5          0004*M1     push hl
042699 C5          0005*M1     push bc
04269A D5          0006*M1     push de
04269B             0007*M1 
04269B 08          0008*M1     ex af,af'
04269C D9          0009*M1     exx
04269D F5          0010*M1     push af
04269E E5          0011*M1     push hl
04269F C5          0012*M1     push bc
0426A0 D5          0013*M1     push de
0426A1 DD E5       0014*M1     push ix
0426A3 FD E5       0015*M1     push iy
0426A5 CD AC 25 04 0518*       call dumpFlags
0426A9             0519*       POP_ALL
0426A9 FD E1       0001*M1     pop iy
0426AB DD E1       0002*M1     pop ix
0426AD D1          0003*M1     pop de
0426AE C1          0004*M1     pop bc
0426AF E1          0005*M1     pop hl
0426B0 F1          0006*M1     pop af
0426B1 08          0007*M1     ex af,af'
0426B2 D9          0008*M1     exx
0426B3             0009*M1 
0426B3 D1          0010*M1     pop de
0426B4 C1          0011*M1     pop bc
0426B5 E1          0012*M1     pop hl
0426B6 F1          0013*M1     pop af
0426B7 08          0014*M1     ex af,af'
0426B8 D9          0015*M1     exx
0426B9             0520*       PUSH_ALL
0426B9 08          0001*M1     ex af,af'
0426BA D9          0002*M1     exx
0426BB F5          0003*M1     push af
0426BC E5          0004*M1     push hl
0426BD C5          0005*M1     push bc
0426BE D5          0006*M1     push de
0426BF             0007*M1 
0426BF 08          0008*M1     ex af,af'
0426C0 D9          0009*M1     exx
0426C1 F5          0010*M1     push af
0426C2 E5          0011*M1     push hl
0426C3 C5          0012*M1     push bc
0426C4 D5          0013*M1     push de
0426C5 DD E5       0014*M1     push ix
0426C7 FD E5       0015*M1     push iy
0426C9 CD 98 24 04 0521*       call dumpRegistersHex
0426CD             0522*       ; call waitKeypress
0426CD CD 7C 00 04 0523*       call printNewLine
0426D1             0524*       POP_ALL
0426D1 FD E1       0001*M1     pop iy
0426D3 DD E1       0002*M1     pop ix
0426D5 D1          0003*M1     pop de
0426D6 C1          0004*M1     pop bc
0426D7 E1          0005*M1     pop hl
0426D8 F1          0006*M1     pop af
0426D9 08          0007*M1     ex af,af'
0426DA D9          0008*M1     exx
0426DB             0009*M1 
0426DB D1          0010*M1     pop de
0426DC C1          0011*M1     pop bc
0426DD E1          0012*M1     pop hl
0426DE F1          0013*M1     pop af
0426DF 08          0014*M1     ex af,af'
0426E0 D9          0015*M1     exx
0426E1 C9          0525*       ret
0426E2             0526*   DEBUG_WAITKEYPRESS:
0426E2             0527*       PUSH_ALL
0426E2 08          0001*M1     ex af,af'
0426E3 D9          0002*M1     exx
0426E4 F5          0003*M1     push af
0426E5 E5          0004*M1     push hl
0426E6 C5          0005*M1     push bc
0426E7 D5          0006*M1     push de
0426E8             0007*M1 
0426E8 08          0008*M1     ex af,af'
0426E9 D9          0009*M1     exx
0426EA F5          0010*M1     push af
0426EB E5          0011*M1     push hl
0426EC C5          0012*M1     push bc
0426ED D5          0013*M1     push de
0426EE DD E5       0014*M1     push ix
0426F0 FD E5       0015*M1     push iy
0426F2 CD 5A 03 04 0528*       call waitKeypress
0426F6             0529*       POP_ALL
0426F6 FD E1       0001*M1     pop iy
0426F8 DD E1       0002*M1     pop ix
0426FA D1          0003*M1     pop de
0426FB C1          0004*M1     pop bc
0426FC E1          0005*M1     pop hl
0426FD F1          0006*M1     pop af
0426FE 08          0007*M1     ex af,af'
0426FF D9          0008*M1     exx
042700             0009*M1 
042700 D1          0010*M1     pop de
042701 C1          0011*M1     pop bc
042702 E1          0012*M1     pop hl
042703 F1          0013*M1     pop af
042704 08          0014*M1     ex af,af'
042705 D9          0015*M1     exx
042706 C9          0530*       RET
042707             0531*   
042707             0532*   dumpVduCmdStr:
042707             0533*       PUSH_ALL
042707 08          0001*M1     ex af,af'
042708 D9          0002*M1     exx
042709 F5          0003*M1     push af
04270A E5          0004*M1     push hl
04270B C5          0005*M1     push bc
04270C D5          0006*M1     push de
04270D             0007*M1 
04270D 08          0008*M1     ex af,af'
04270E D9          0009*M1     exx
04270F F5          0010*M1     push af
042710 E5          0011*M1     push hl
042711 C5          0012*M1     push bc
042712 D5          0013*M1     push de
042713 DD E5       0014*M1     push ix
042715 FD E5       0015*M1     push iy
042717 79          0534*       ld a,c
042718 CD FD 25 04 0535*       call dumpMemoryHex
04271C CD 5A 03 04 0536*       call waitKeypress
042720             0537*       POP_ALL
042720 FD E1       0001*M1     pop iy
042722 DD E1       0002*M1     pop ix
042724 D1          0003*M1     pop de
042725 C1          0004*M1     pop bc
042726 E1          0005*M1     pop hl
042727 F1          0006*M1     pop af
042728 08          0007*M1     ex af,af'
042729 D9          0008*M1     exx
04272A             0009*M1 
04272A D1          0010*M1     pop de
04272B C1          0011*M1     pop bc
04272C E1          0012*M1     pop hl
04272D F1          0013*M1     pop af
04272E 08          0014*M1     ex af,af'
04272F D9          0015*M1     exx
042730 C9          0538*       ret
042731             0539*   ; end dumpVduCmdStr
042731             0054    
042731             0055    ; --- MAIN PROGRAM FILE ---
042731 00          0056    original_screen_mode: db 0
042732             0057    
042732             0058    init:
042732             0059    ; get current screen mode and save it so we can return to it on exit
042732 CD 1F 15 04 0060        call vdu_get_screen_mode
042736 32 31 27 04 0061        ld (original_screen_mode),a
04273A             0062    ; set up display for gameplay
04273A 3E 14       0063        ld a,20
04273C CD 0E 15 04 0064        call vdu_set_screen_mode
042740 AF          0065        xor a
042741 CD 27 15 04 0066        call vdu_set_scaling
042745             0067    ; set text background color
042745 3E 84       0068        ld a,c_blue_dk+128
042747 CD 71 14 04 0069        call vdu_colour_text
04274B             0070    ; set text foreground color
04274B 3E 0F       0071        ld a,c_white
04274D CD 71 14 04 0072        call vdu_colour_text
042751             0073    ; set the cursor off
042751 CD 08 14 04 0074        call vdu_cursor_off
042755             0075    ; clear the screen
042755 CD 40 14 04 0076        call vdu_cls
042759             0077    ; clear all buffers
042759 CD 15 18 04 0078        call vdu_clear_all_buffers
04275D             0079    ; load fonts
04275D CD 54 05 04 0080    	call fonts_load
042761             0081    ; select font
042761 21 06 FA 00 0082        ld hl,Lat2_VGA8_8x8
042765 3E 01       0083        ld a,1 ; flags
042767 CD 87 18 04 0084        call vdu_font_select
04276B             0085    ; print ascii art splash screen
04276B CD 40 14 04 0086        call vdu_cls
04276F 0E 00       0087        ld c,0 ; x
042771 06 04       0088        ld b,4 ; y
042773 CD 2C 14 04 0089        call vdu_move_cursor
042777 CD 60 00 04 0090        call printInline
04277B 57 65 6C 63 0091        asciz "Welcome to...\r\n"
       6F 6D 65 20 
       74 6F 2E 2E 
       2E 0D 0A 00 
04278B 21 AC 1B 04 0092        ld hl,agon_jukebox_ascii
04278F CD 67 00 04 0093        call printString
042793 CD 60 00 04 0094        call printInline
042797 50 72 65 73 0095        asciz "Press keys 0-9 to play a song.\r\n"
       73 20 6B 65 
       79 73 20 30 
       2D 39 20 74 
       6F 20 70 6C 
       61 79 20 61 
       20 73 6F 6E 
       67 2E 0D 0A 
       00          
0427B8             0096    ; initialize play sample timer interrupt handler
0427B8 CD DE 22 04 0097        call ps_prt_irq_init
0427BC C9          0098        ret
0427BD             0099    ; end init
0427BD             0100    
0427BD             0101    main:
0427BD             0102    ; call get_input to start player
0427BD CD 7D 1E 04 0103        call get_input
0427C1             0104    ; user pressed ESC to quit so shut down everytyhing and gracefully exit to MOS
0427C1 CD D8 22 04 0105        call ps_prt_stop ; stop the PRT timer
0427C5 FB          0106        ei ; interrupts were disabled by get_input
0427C6             0107    ; restore original screen mode
0427C6 3A 31 27 04 0108        ld a,(original_screen_mode)
0427CA CD 0E 15 04 0109        call vdu_set_screen_mode
0427CE CD 09 15 04 0110        call vdu_reset_viewports
0427D2 CD 40 14 04 0111        call vdu_cls
0427D6             0112    ; print thanks for playing message
0427D6 CD 60 00 04 0113        call printInline
0427DA 54 68 61 6E 0114        asciz "Thank you for using\r\n"
       6B 20 79 6F 
       75 20 66 6F 
       72 20 75 73 
       69 6E 67 0D 
       0A 00       
0427F0 21 AC 1B 04 0115        ld hl,agon_jukebox_ascii
0427F4 CD 67 00 04 0116        call printString
0427F8 CD FA 13 04 0117        call vdu_cursor_on
0427FC C9          0118        ret ; back to MOS
0427FD             0119    ; end main
0427FD             0120    
0427FD             0121    ps_wav_header: ; marker for top of the wav file header and song data
0427FD             0122    ; (must be last so buffer doesn't overwrite other program code or data)
0427FD             0123    ; .wav header data
0427FD             0124    ; WAV File Structure in Memory with LIST Chunk
0427FD 00 00 00 00 0125    ps_wav_riff:          blkb 4,0   ; 4 bytes: "RIFF" identifier
042801 00 00 00 00 0126    ps_wav_file_size:     blkb 4,0   ; 4 bytes: Total file size minus 8 bytes for RIFF header
042805 00 00 00 00 0127    ps_wav_wave:          blkb 4,0   ; 4 bytes: "WAVE" identifier
042809 00 00 00 00 0128    ps_wav_fmt_marker:    blkb 4,0   ; 4 bytes: "fmt " subchunk marker
04280D 00 00 00 00 0129    ps_wav_fmt_size:      blkb 4,0   ; 4 bytes: Format chunk size (16 for PCM)
042811 00 00       0130    ps_wav_audio_format:  blkb 2,0   ; 2 bytes: Audio format (1 = PCM)
042813 00 00       0131    ps_wav_num_channels:  blkb 2,0   ; 2 bytes: Number of channels (1 = mono, 2 = stereo)
042815 00 00 00 00 0132    ps_wav_sample_rate:   blkb 4,0   ; 4 bytes: Sample rate in Hz (e.g., 32768)
042819 00 00 00 00 0133    ps_wav_byte_rate:     blkb 4,0   ; 4 bytes: Bytes per second (SampleRate * NumChannels * BitsPerSample / 8)
04281D 00 00       0134    ps_wav_block_align:   blkb 2,0   ; 2 bytes: Bytes per sample block (NumChannels * BitsPerSample / 8)
04281F 00 00       0135    ps_wav_bits_per_sample: blkb 2,0 ; 2 bytes: Bits per sample (e.g., 8 or 16)
042821             0136    
042821             0137    ; LIST Chunk (Extra Metadata)
042821 00 00 00 00 0138    ps_wav_list_marker:   blkb 4,0   ; 4 bytes: "LIST" marker
042825 00 00 00 00 0139    ps_wav_list_size:     blkb 4,0   ; 4 bytes: Size of the LIST chunk (e.g., 26)
042829 00 00 00 00 0140    ps_wav_info_marker:   blkb 4,0   ; 4 bytes: "INFO" marker
04282D 00 00 00 00 0141    ps_wav_isft_marker:   blkb 4,0   ; 4 bytes: "ISFT" marker (software identifier)
042831 00 00 00 00 0142    ps_wav_isft_data:     blkb 14,0  ; 14 bytes: Software info string (e.g., "Lavf59.27.100")
       00 00 00 00 
       00 00 00 00 
       00 00       
04283F 00 00       0143    ps_wav_isft_padding:  blkb 2,0   ; 2 bytes: Padding/NULL terminator for alignment
042841             0144    
042841             0145    ; Data Chunk
042841 00 00 00 00 0146    ps_wav_data_marker:   blkb 4,0   ; 4 bytes: "data" subchunk marker
042845 00 00 00 00 0147    ps_wav_data_size:     blkb 4,0   ; 4 bytes: Size of the audio data in bytes
042849             0148    ; Total Header Size: 76 bytes
042849             0149    ;
042849             0150    ; buffer for sound data
042849             0151    ps_wav_data_start:    blkb 0,0   ; Start of audio data
