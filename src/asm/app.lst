PC     Output      Line
040000             0001        assume adl=1
040000             0002        org 0x040000
040000 C3 45 00 04 0003        jp start
040004             0004        align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0005        db "MOS"
040043 00          0006        db 00h
040044 01          0007        db 01h
040045             0008    
040045             0009    start:
040045 F5          0010        push af
040046 C5          0011        push bc
040047 D5          0012        push de
040048 DD E5       0013        push ix
04004A FD E5       0014        push iy
04004C             0015    
04004C CD 41 2E 04 0016        call init
040050 CD C0 2F 04 0017        call main
040054             0018    
040054             0019    exit:
040054 FD E1       0020        pop iy
040056 DD E1       0021        pop ix
040058 D1          0022        pop de
040059 C1          0023        pop bc
04005A F1          0024        pop af
04005B 21 00 00 00 0025        ld hl,0
04005F             0026    
04005F C9          0027        ret
040060             0028    
040060             0029    ; API INCLUDES
040060             0030        include "mos_api.inc"
040060             0001*   ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.inc
040060             0002*   ; Title:	AGON MOS - API for user projects
040060             0003*   ; Author:	Dean Belfield
040060             0004*   ;			Adapted for agon-ez80asm by Jeroen Venema
040060             0005*   ;			Added MOS error codes for return in HL
040060             0006*   ; Created:	03/08/2022
040060             0007*   ; Last Updated:	10/08/2023
040060             0008*   ;
040060             0009*   ; Modinfo:
040060             0010*   ; 05/08/2022:	Added mos_feof
040060             0011*   ; 09/08/2022:	Added system variables: cursorX, cursorY
040060             0012*   ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040060             0013*   ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040060             0014*   ; 24/09/2022:	Added mos_getError, mos_mkdir
040060             0015*   ; 13/10/2022:	Added mos_oscli
040060             0016*   ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040060             0017*   ; 04/03/2023:	Added sysvar_scrpixelIndex
040060             0018*   ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040060             0019*   ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040060             0020*   ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040060             0021*   ; 22/03/2023:	The VDP commands are now indexed from 0x80
040060             0022*   ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040060             0023*   ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040060             0024*   ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040060             0025*   ; 19/05/2023:	Added sysvar_scrMode
040060             0026*   ; 05/06/2023:	Added sysvar_rtcEnable
040060             0027*   ; 03/08/2023:	Added mos_setkbvector
040060             0028*   ; 10/08/2023:	Added mos_getkbmap
040060             0029*   
040060             0030*   ; VDP control (VDU 23, 0, n)
040060             0031*   ;
040060             0032*   vdp_gp:				EQU 80h
040060             0033*   vdp_keycode:		EQU 81h
040060             0034*   vdp_cursor:			EQU	82h
040060             0035*   vdp_scrchar:		EQU	83h
040060             0036*   vdp_scrpixel:		EQU	84h
040060             0037*   vdp_audio:			EQU	85h
040060             0038*   vdp_mode:			EQU	86h
040060             0039*   vdp_rtc:			EQU	87h
040060             0040*   vdp_keystate:		EQU	88h
040060             0041*   vdp_logicalcoords:	EQU	C0h
040060             0042*   vdp_terminalmode:	EQU	FFh
040060             0043*   
040060             0044*   ; MOS high level functions
040060             0045*   ;
040060             0046*   mos_getkey:			EQU	00h
040060             0047*   mos_load:			EQU	01h
040060             0048*   mos_save:			EQU	02h
040060             0049*   mos_cd:				EQU	03h
040060             0050*   mos_dir:			EQU	04h
040060             0051*   mos_del:			EQU	05h
040060             0052*   mos_ren:			EQU	06h
040060             0053*   mos_mkdir:			EQU	07h
040060             0054*   mos_sysvars:		EQU	08h
040060             0055*   mos_editline:		EQU	09h
040060             0056*   mos_fopen:			EQU	0Ah
040060             0057*   mos_fclose:			EQU	0Bh
040060             0058*   mos_fgetc:			EQU	0Ch
040060             0059*   mos_fputc:			EQU	0Dh
040060             0060*   mos_feof:			EQU	0Eh
040060             0061*   mos_getError:		EQU	0Fh
040060             0062*   mos_oscli:			EQU	10h
040060             0063*   mos_copy:			EQU	11h
040060             0064*   mos_getrtc:			EQU	12h
040060             0065*   mos_setrtc:			EQU	13h
040060             0066*   mos_setintvector:	EQU	14h
040060             0067*   mos_uopen:			EQU	15h
040060             0068*   mos_uclose:			EQU	16h
040060             0069*   mos_ugetc:			EQU	17h
040060             0070*   mos_uputc:			EQU	18h
040060             0071*   mos_getfil:			EQU	19h
040060             0072*   mos_fread:			EQU	1Ah
040060             0073*   mos_fwrite:			EQU	1Bh
040060             0074*   mos_flseek:			EQU	1Ch
040060             0075*   mos_setkbvector:	EQU	1Dh
040060             0076*   mos_getkbmap:		EQU	1Eh
040060             0077*   
040060             0078*   ; MOS program exit codes
040060             0079*   ;
040060             0080*   EXIT_OK:				EQU  0;	"OK",
040060             0081*   EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
040060             0082*   EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
040060             0083*   EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
040060             0084*   EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
040060             0085*   EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
040060             0086*   EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
040060             0087*   EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
040060             0088*   EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
040060             0089*   EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
040060             0090*   EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
040060             0091*   EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
040060             0092*   EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
040060             0093*   EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
040060             0094*   EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
040060             0095*   EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
040060             0096*   EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
040060             0097*   EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
040060             0098*   EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
040060             0099*   EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
040060             0100*   EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
040060             0101*   EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
040060             0102*   ; FatFS file access functions
040060             0103*   ;
040060             0104*   ffs_fopen:			EQU	80h
040060             0105*   ffs_fclose:			EQU	81h
040060             0106*   ffs_fread:			EQU	82h
040060             0107*   ffs_fwrite:			EQU	83h
040060             0108*   ffs_flseek:			EQU	84h
040060             0109*   ffs_ftruncate:		EQU	85h
040060             0110*   ffs_fsync:			EQU	86h
040060             0111*   ffs_fforward:		EQU	87h
040060             0112*   ffs_fexpand:		EQU	88h
040060             0113*   ffs_fgets:			EQU	89h
040060             0114*   ffs_fputc:			EQU	8Ah
040060             0115*   ffs_fputs:			EQU	8Bh
040060             0116*   ffs_fprintf:		EQU	8Ch
040060             0117*   ffs_ftell:			EQU	8Dh
040060             0118*   ffs_feof:			EQU	8Eh
040060             0119*   ffs_fsize:			EQU	8Fh
040060             0120*   ffs_ferror:			EQU	90h
040060             0121*   
040060             0122*   ; FatFS directory access functions
040060             0123*   ;
040060             0124*   ffs_dopen:			EQU	91h
040060             0125*   ffs_dclose:			EQU	92h
040060             0126*   ffs_dread:			EQU	93h
040060             0127*   ffs_dfindfirst:		EQU	94h
040060             0128*   ffs_dfindnext:		EQU	95h
040060             0129*   
040060             0130*   ; FatFS file and directory management functions
040060             0131*   ;
040060             0132*   ffs_stat:			EQU	96h
040060             0133*   ffs_unlink:			EQU	97h
040060             0134*   ffs_rename:			EQU	98h
040060             0135*   ffs_chmod:			EQU	99h
040060             0136*   ffs_utime:			EQU	9Ah
040060             0137*   ffs_mkdir:			EQU	9Bh
040060             0138*   ffs_chdir:			EQU	9Ch
040060             0139*   ffs_chdrive:		EQU	9Dh
040060             0140*   ffs_getcwd:			EQU	9Eh
040060             0141*   
040060             0142*   ; FatFS volume management and system configuration functions
040060             0143*   ;
040060             0144*   ffs_mount:			EQU	9Fh
040060             0145*   ffs_mkfs:			EQU	A0h
040060             0146*   ffs_fdisk:			EQU	A1h
040060             0147*   ffs_getfree:		EQU	A2h
040060             0148*   ffs_getlabel:		EQU	A3h
040060             0149*   ffs_setlabel:		EQU	A4h
040060             0150*   ffs_setcp:			EQU	A5h
040060             0151*   
040060             0152*   ; File access modes
040060             0153*   ;
040060             0154*   fa_read:			EQU	01h
040060             0155*   fa_write:			EQU	02h
040060             0156*   fa_open_existing:	EQU	00h
040060             0157*   fa_create_new:		EQU	04h
040060             0158*   fa_create_always:	EQU	08h
040060             0159*   fa_open_always:		EQU	10h
040060             0160*   fa_open_append:		EQU	30h
040060             0161*   
040060             0162*   ; System variable indexes for api_sysvars
040060             0163*   ; Index into _sysvars in globals.inc
040060             0164*   ;
040060             0165*   sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040060             0166*   sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
040060             0167*   sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040060             0168*   sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
040060             0169*   sysvar_cursorX:			EQU	07h	; 1: Cursor X position
040060             0170*   sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
040060             0171*   sysvar_scrchar:			EQU	09h	; 1: Character read from screen
040060             0172*   sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040060             0173*   sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040060             0174*   sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040060             0175*   sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
040060             0176*   sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
040060             0177*   sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
040060             0178*   sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
040060             0179*   sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
040060             0180*   sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040060             0181*   sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
040060             0182*   sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040060             0183*   sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
040060             0184*   sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
040060             0185*   sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
040060             0186*   sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
040060             0187*   sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
040060             0188*   sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
040060             0189*   sysvar_scrMode:			EQU	27h	; 1: Screen mode
040060             0190*   sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040060             0191*   
040060             0192*   ; Flags for the VPD protocol
040060             0193*   ;
040060             0194*   vdp_pflag_cursor:		EQU	00000001b
040060             0195*   vdp_pflag_scrchar:		EQU	00000010b
040060             0196*   vdp_pflag_point:		EQU	00000100b
040060             0197*   vdp_pflag_audio:		EQU	00001000b
040060             0198*   vdp_pflag_mode:			EQU	00010000b
040060             0199*   vdp_pflag_rtc:			EQU	00100000b
040060             0200*   
040060             0201*   ;
040060             0202*   ; FatFS structures
040060             0203*   ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040060             0204*   ;
040060             0205*   ; Object ID and allocation information (FFOBJID)
040060             0206*   ;
040060             0207*   ; Indexes into FFOBJID structure
040060             0208*   ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
040060             0209*   ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
040060             0210*   ffobjid_attr:		EQU	5	; 1: Object attribute
040060             0211*   ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040060             0212*   ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
040060             0213*   ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
040060             0214*   ;
040060             0215*   ; File object structure (FIL)
040060             0216*   ;
040060             0217*   ; Indexes into FIL structure
040060             0218*   fil_obj:		EQU 0	; 15: Object identifier
040060             0219*   fil_flag:		EQU	15 	;  1: File status flags
040060             0220*   fil_err:		EQU	16	;  1: Abort flag (error code)
040060             0221*   fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
040060             0222*   fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
040060             0223*   fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
040060             0224*   fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
040060             0225*   fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
040060             0226*   ;
040060             0227*   ; Directory object structure (DIR)
040060             0228*   ; Indexes into DIR structure
040060             0229*   dir_obj:		EQU  0	; 15: Object identifier
040060             0230*   dir_dptr:		EQU	15	;  4: Current read/write offset
040060             0231*   dir_clust:		EQU	19	;  4: Current cluster
040060             0232*   dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
040060             0233*   dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
040060             0234*   dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
040060             0235*   dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040060             0236*   ;
040060             0237*   ; File information structure (FILINFO)
040060             0238*   ;
040060             0239*   ; Indexes into FILINFO structure
040060             0240*   filinfo_fsize:		EQU 0	;   4: File size
040060             0241*   filinfo_fdate:		EQU	4	;   2: Modified date
040060             0242*   filinfo_ftime:		EQU	6	;   2: Modified time
040060             0243*   filinfo_fattrib:	EQU	8	;   1: File attribute
040060             0244*   filinfo_altname:	EQU	9	;  13: Alternative file name
040060             0245*   filinfo_fname:		EQU	22	; 256: Primary file name
040060             0246*   ;
040060             0247*   ; Macro for calling the API
040060             0248*   ; Parameters:
040060             0249*   ; - function: One of the function numbers listed above
040060             0250*   ;
040060             0251*   	MACRO	MOSCALL	function
040060             0252*   			LD	A, function
040060             0253*   			RST.LIL	08h
040060             0254*   	ENDMACRO
040060             0031        include "macros.inc"
040060             0001*   
040060             0002*   ; test the sign of HL
040060             0003*   ; inputs: HL obviously
040060             0004*   ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
040060             0005*   ; destroys: flags
040060             0006*       MACRO SIGN_HLU
040060             0007*       add hl,de ; 1 cycle
040060             0008*       or a ; clear flags ; 1 cycle
040060             0009*       sbc hl,de ; 2 cycles
040060             0010*       ; 4 cycles total
040060             0011*       ENDMACRO
040060             0012*   
040060             0013*   ; put the value in A into HLU
040060             0014*   ; affects: HLU
040060             0015*   ; destroys: nothing
040060             0016*   ; note: $ instead of @@ b/c anon labels deprecated in ez80asm
040060             0017*       MACRO A_TO_HLU
040060             0018*       xor a ; 1 cycle
040060             0019*       ld ($+8+1),hl ; 7 cycles
040060             0020*       ld ($+4+3),a ; 5 cycles
040060             0021*       ld hl,0x000000 ; 4 cycles
040060             0022*       ; 17 cycles total
040060             0023*       ENDMACRO
040060             0024*   
040060             0025*   ; alternative: https://discord.com/channels/1158535358624039014/1282290921815408681/1318315567102300220
040060             0026*   ; one cycle less but burns flags
040060             0027*       MACRO A_TO_HLU_ALT
040060             0028*       push hl ; 4 cycles
040060             0029*       ld hl,2 ; 4 cycles
040060             0030*       add hl,sp ; 1 cycle
040060             0031*       ld (hl),a ; 2 cycles
040060             0032*       pop hl ; 4 cycles
040060             0033*       ; 15 cycles total
040060             0034*       ENDMACRO
040060             0035*   
040060             0036*       MACRO hlu_mul256
040060             0037*       add hl,hl ; * 2
040060             0038*       add hl,hl ; * 4
040060             0039*       add hl,hl ; * 8
040060             0040*       add hl,hl ; * 16
040060             0041*       add hl,hl ; * 32
040060             0042*       add hl,hl ; * 64
040060             0043*       add hl,hl ; * 128
040060             0044*       add hl,hl ; * 256
040060             0045*       ENDMACRO
040060             0046*   
040060             0047*   ; https://discord.com/channels/1158535358624039014/1282290921815408681/1317793870070812715
040060             0048*       MACRO SRL_UHL
040060             0049*       dec sp ; 1 cycle
040060             0050*       push hl ; 4 cycles
040060             0051*       inc sp ; 1 cycle
040060             0052*       pop hl ; 4 cycles
040060             0053*       inc hl ; 1 cycle
040060             0054*       dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
040060             0055*       ; 13 cycles total
040060             0056*       ENDMACRO
040060             0057*   
040060             0058*       MACRO printChar char
040060             0059*       LD A, char
040060             0060*       RST.LIL 10h
040060             0061*       ENDMACRO
040060             0062*   
040060             0063*   ; Simulated call to subroutine at HL
040060             0064*   ; inputs: HL pointing to the subroutine address plus whatever the called function expects
040060             0065*   ; outputs: whatever the subroutine does, including HL and BC
040060             0066*   ; destroys: only what the subroutine does, but always BC
040060             0067*       MACRO CALL_HL
040060             0068*       ld bc,$+6 ; Address of first instruction after the jump
040060             0069*       push bc ; which constitutes the return address
040060             0070*       jp (hl) ; Jump to the address in HL
040060             0071*       ENDMACRO
040060             0072*   
040060             0073*   ; Simulated call to subroutine at IX
040060             0074*   ; inputs: IX pointing to the subroutine address plus whatever the called function expects
040060             0075*   ; outputs: whatever the subroutine does, including IX and BC
040060             0076*   ; destroys: only what the subroutine does, but always BC
040060             0077*       MACRO CALL_IX
040060             0078*       ld bc,$+6 ; Address of first instruction after the jump
040060             0079*       push bc ; which constitutes the return address
040060             0080*       jp (ix) ; Jump to the address in IX
040060             0081*       ENDMACRO
040060             0082*   
040060             0083*   ; Simulated call to soubroutinte at IY
040060             0084*   ; inputs: IY pointing to the subroutine address plus whatever the called function expects
040060             0085*   ; outputs: whatever the subroutine does, including IY and BC
040060             0086*   ; destroys: only what the subroutine does, but always BC
040060             0087*       MACRO CALL_IY
040060             0088*       ld bc,$+6 ; Address of first instruction after the jump
040060             0089*       push bc ; which constitutes the return address
040060             0090*       jp (iy) ; Jump to the address in IY
040060             0091*       ENDMACRO
040060             0092*   
040060             0093*   ; put the value in HLU into A
040060             0094*   ; destroys: af
040060             0095*       MACRO HLU_TO_A
040060             0096*       dec sp ; 1 cycle
040060             0097*       push hl ; 4 cycles
040060             0098*       inc sp ; 1 cycle
040060             0099*       pop af ; 4 cycles
040060             0100*       ; 10 cycles total
040060             0101*       ENDMACRO
040060             0102*   
040060             0103*       MACRO PUSH_ALL
040060             0104*       ex af,af'
040060             0105*       exx
040060             0106*       push af
040060             0107*       push hl
040060             0108*       push bc
040060             0109*       push de
040060             0110*   
040060             0111*       ex af,af'
040060             0112*       exx
040060             0113*       push af
040060             0114*       push hl
040060             0115*       push bc
040060             0116*       push de
040060             0117*       push ix
040060             0118*       push iy
040060             0119*       ENDMACRO
040060             0120*   
040060             0121*       MACRO POP_ALL
040060             0122*       pop iy
040060             0123*       pop ix
040060             0124*       pop de
040060             0125*       pop bc
040060             0126*       pop hl
040060             0127*       pop af
040060             0128*       ex af,af'
040060             0129*       exx
040060             0130*   
040060             0131*       pop de
040060             0132*       pop bc
040060             0133*       pop hl
040060             0134*       pop af
040060             0135*       ex af,af'
040060             0136*       exx
040060             0137*       ENDMACRO
040060             0032        include "functions.inc"
040060             0001*   ; Print a zero-terminated string inline with code, e.g.:
040060             0002*   ;
040060             0003*   ;    call printInline
040060             0004*   ;    ASCIZ "Hello, world!\r\n"
040060             0005*   ;
040060             0006*   ; Destroys: HL,AF
040060             0007*   printInline:
040060 E1          0008*       pop hl ; get the return address = pointer to start of string
040061 CD 67 00 04 0009*       call printString ; HL advances to end of string
040065 E5          0010*       push hl ; restore the return address = pointer to end of string
040066 C9          0011*       ret
040067             0012*   
040067             0013*   ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
040067             0014*   ; Print a zero-terminated string
040067             0015*   ; HL: Pointer to string
040067             0016*   ; returns: hl pointed to character after string terminator
040067             0017*   ; destroys: af, hl
040067             0018*   printString:
040067 C5          0019*       PUSH BC
040068 01 00 00 00 0020*       LD BC,0
04006C 3E 00       0021*       LD A,0
04006E 5B DF       0022*       RST.LIL 18h
040070 C1          0023*       POP BC
040071 C9          0024*       RET
040072             0025*   ; print a VDU sequence
040072             0026*   ; HL: Pointer to VDU sequence - <1 byte length> <data>
040072             0027*   sendVDUsequence:
040072 C5          0028*       PUSH BC
040073 01 00 00 00 0029*       LD BC, 0
040077 4E          0030*       LD C, (HL)
040078 5B DF       0031*       RST.LIL 18h
04007A C1          0032*       POP BC
04007B C9          0033*       RET
04007C             0034*   ; Print Newline sequence to VDP
04007C             0035*   ; destroys: nothing
04007C             0036*   printNewLine:
04007C F5          0037*       push af ; for some reason rst.lil 10h sets carry flag
04007D 3E 0D       0038*       LD A, '\r'
04007F 5B D7       0039*       RST.LIL 10h
040081 3E 0A       0040*       LD A, '\n'
040083 5B D7       0041*       RST.LIL 10h
040085 F1          0042*       pop af
040086 C9          0043*       RET
040087             0044*   
040087             0045*   ; print a zero-terminated string at a graphics coordinate
040087             0046*   ; Inputs: HL Pointer to string, BC,DE x,y position (in pixels)
040087             0047*   printStringGfx:
040087 E5          0048*       push hl ; preserve string pointer
040088             0049*   ; move graphics cursor to x,y location
040088 3E 44       0050*       ld a,plot_pt+mv_abs
04008A CD DE 1B 04 0051*       call vdu_plot
04008E             0052*   ; print string
04008E E1          0053*       pop hl ; restore string pointer
04008F             0054*   @print_loop:
04008F 7E          0055*       ld a,(hl)
040090 B7          0056*       or a ; check for end of string
040091 C8          0057*       ret z ; if zero, we're done
040092 08          0058*       ex af,af' ; preserve character
040093 3E 05       0059*       ld a,5 ; VDU 5 char to gfx cursor
040095 5B D7       0060*       rst.lil 10h ; send it
040097 08          0061*       ex af,af' ; restore character
040098 5B D7       0062*       rst.lil 10h ; print character
04009A 23          0063*       inc hl
04009B C3 8F 00 04 0064*       jp @print_loop
04009F C9          0065*       ret
0400A0             0066*   ; end printStringGfx
0400A0             0067*   
0400A0             0068*   ; Print a 24-bit HEX number
0400A0             0069*   ; HLU: Number to print
0400A0             0070*   printHex24:
0400A0             0071*       HLU_TO_A
                       M1 Args: none
0400A0 3B          0001*M1     dec sp ; 1 cycle
0400A1 E5          0002*M1     push hl ; 4 cycles
0400A2 33          0003*M1     inc sp ; 1 cycle
0400A3 F1          0004*M1     pop af ; 4 cycles
0400A4             0005*M1     ; 10 cycles total
0400A4 CD AE 00 04 0072*       CALL printHex8
0400A8             0073*   ; Print a 16-bit HEX number
0400A8             0074*   ; HL: Number to print
0400A8             0075*   printHex16:
0400A8 7C          0076*       LD A,H
0400A9 CD AE 00 04 0077*       CALL printHex8
0400AD 7D          0078*       LD A,L
0400AE             0079*   ; Print an 8-bit HEX number
0400AE             0080*   ; A: Number to print
0400AE             0081*   printHex8:
0400AE 4F          0082*       LD C,A
0400AF 1F          0083*       RRA
0400B0 1F          0084*       RRA
0400B1 1F          0085*       RRA
0400B2 1F          0086*       RRA
0400B3 CD B8 00 04 0087*       CALL @F
0400B7 79          0088*       LD A,C
0400B8             0089*   @@:
0400B8 E6 0F       0090*       AND 0Fh
0400BA C6 90       0091*       ADD A,90h
0400BC 27          0092*       DAA
0400BD CE 40       0093*       ADC A,40h
0400BF 27          0094*       DAA
0400C0 5B D7       0095*       RST.LIL 10h
0400C2 C9          0096*       RET
0400C3             0097*   
0400C3             0098*   ; Print a 0x HEX prefix
0400C3             0099*   DisplayHexPrefix:
0400C3 3E 30       0100*       LD A, '0'
0400C5 5B D7       0101*       RST.LIL 10h
0400C7 3E 78       0102*       LD A, 'x'
0400C9 5B D7       0103*       RST.LIL 10h
0400CB C9          0104*       RET
0400CC             0105*   
0400CC             0106*       MACRO printDecBC
0400CC             0107*       push hl
0400CC             0108*       push bc
0400CC             0109*       pop hl
0400CC             0110*       call printDec
0400CC             0111*       pop hl
0400CC             0112*       ENDMACRO
0400CC             0113*   
0400CC             0114*       MACRO printDecDE
0400CC             0115*       push hl
0400CC             0116*       push de
0400CC             0117*       pop hl
0400CC             0118*       call printDec
0400CC             0119*       pop hl
0400CC             0120*       ENDMACRO
0400CC             0121*   
0400CC             0122*       MACRO printDecHL
0400CC             0123*       call printDec
0400CC             0124*       ENDMACRO
0400CC             0125*   
0400CC             0126*       MACRO printDecIX
0400CC             0127*       push hl
0400CC             0128*       push ix
0400CC             0129*       pop hl
0400CC             0130*       call printDec
0400CC             0131*       pop hl
0400CC             0132*       ENDMACRO
0400CC             0133*   
0400CC             0134*       MACRO printDecIY
0400CC             0135*       push hl
0400CC             0136*       push iy
0400CC             0137*       pop hl
0400CC             0138*       call printDec
0400CC             0139*       pop hl
0400CC             0140*       ENDMACRO
0400CC             0141*   
0400CC             0142*   
0400CC             0143*   ; Prints the right justified decimal value in HL without leading zeroes
0400CC             0144*   ; HL : Value to print
0400CC             0145*   ; preserves all registers and flags
0400CC             0146*   printDec:
0400CC             0147*   ; BEGIN MY CODE
0400CC             0148*   ; back up all the things
0400CC F5          0149*       push af
0400CD C5          0150*       push bc
0400CE D5          0151*       push de
0400CF E5          0152*       push hl
0400D0             0153*   ; END MY CODE
0400D0 11 F8 00 04 0154*       LD DE, _printDecBuffer
0400D4 CD 08 01 04 0155*       CALL u24_to_ascii
0400D8             0156*   ; BEGIN MY CODE
0400D8             0157*   ; replace leading zeroes with spaces
0400D8 21 F8 00 04 0158*       LD HL, _printDecBuffer
0400DC 06 07       0159*       ld B, 7 ; if HL was 0, we want to keep the final zero
0400DE             0160*   @loop:
0400DE 7E          0161*       LD A, (HL)
0400DF FE 30       0162*       CP '0'
0400E1 C2 EB 00 04 0163*       JP NZ, @done
0400E5 3E 20       0164*       LD A, ' '
0400E7 77          0165*       LD (HL), A
0400E8 23          0166*       INC HL
0400E9             0167*       ; CALL vdu_cursor_forward
0400E9 10 F3       0168*       DJNZ @loop
0400EB             0169*   @done:
0400EB             0170*   ; END MY CODE
0400EB 21 F8 00 04 0171*       LD HL, _printDecBuffer
0400EF CD 67 00 04 0172*       CALL printString
0400F3             0173*   ; BEGIN MY CODE
0400F3             0174*   ; restore all the things
0400F3 E1          0175*       pop hl
0400F4 D1          0176*       pop de
0400F5 C1          0177*       pop bc
0400F6 F1          0178*       pop af
0400F7             0179*   ; END MY CODE
0400F7 C9          0180*       RET
0400F8 00 00 00 00 0181*   _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040108             0182*   
040108             0183*   ; This routine converts the unsigned 24-bit value in HLU into its ASCII representation,
040108             0184*   ; starting to memory location pointing by DE, in decimal form and with leading zeroes
040108             0185*   ; so it will allways be 8 characters length
040108             0186*   ; HL : Value to convert to string
040108             0187*   ; DE : pointer to buffer, at least 8 byte + 0
040108             0188*   u24_to_ascii:
040108 01 80 69 67 0189*       LD BC,-10000000
04010C CD 3F 01 04 0190*       CALL @one_digit
040110 01 C0 BD F0 0191*       LD BC,-1000000
040114 CD 3F 01 04 0192*       CALL @one_digit
040118 01 60 79 FE 0193*       LD BC,-100000
04011C CD 3F 01 04 0194*       CALL @one_digit
040120 01 F0 D8 FF 0195*       LD BC,-10000
040124 CD 3F 01 04 0196*       CALL @one_digit
040128 01 18 FC FF 0197*       LD BC,-1000
04012C CD 3F 01 04 0198*       CALL @one_digit
040130 01 9C FF FF 0199*       LD BC,-100
040134 CD 3F 01 04 0200*       CALL @one_digit
040138 0E F6       0201*       LD C,-10
04013A CD 3F 01 04 0202*       CALL @one_digit
04013E 48          0203*       LD C,B
04013F             0204*   @one_digit:
04013F 3E 2F       0205*       LD A,'0'-1
040141             0206*   @divide_me:
040141 3C          0207*       INC A
040142 09          0208*       ADD HL,BC
040143 38 FC       0209*       JR C,@divide_me
040145 ED 42       0210*       SBC HL,BC
040147 12          0211*       LD (DE),A
040148 13          0212*       INC DE
040149 C9          0213*       RET
04014A             0214*   
04014A             0215*   print_u24:
04014A D5          0216*       push de
04014B E5          0217*       push hl
04014C 11 F8 00 04 0218*       ld de,_printDecBuffer
040150 CD 08 01 04 0219*       call u24_to_ascii
040154 21 F8 00 04 0220*       ld hl,_printDecBuffer
040158 CD 67 00 04 0221*       call printString
04015C 3E 20       0222*       ld a,' '
04015E 5B D7       0223*       rst.lil 10h
040160 E1          0224*       pop hl
040161 D1          0225*       pop de
040162 C9          0226*       ret
040163             0227*   
040163             0228*   ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
040163             0229*   ; HL : Value to convert to string (integer part in H, fractional part in L)
040163             0230*   ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
040163             0231*   u168_to_ascii:
040163             0232*   ; add a leading space to make room for sign flag if needed
040163 3E 20       0233*       ld a,' '
040165 12          0234*       ld (de),a
040166 13          0235*       inc de
040167             0236*   ; Convert integer part
040167 E5          0237*       push hl ; Save HL (we’ll need the fractional part later)
040168             0238*       ; call hlu_udiv256 ; Shift to get integer portion in HL
040168             0239*       SRL_UHL ; Shift to get integer portion in HL
                       M1 Args: none
040168 3B          0001*M1     dec sp ; 1 cycle
040169 E5          0002*M1     push hl ; 4 cycles
04016A 33          0003*M1     inc sp ; 1 cycle
04016B E1          0004*M1     pop hl ; 4 cycles
04016C 23          0005*M1     inc hl ; 1 cycle
04016D 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
04016F             0007*M1     ; 13 cycles total
04016F 01 F0 D8 FF 0240*       ld bc, -10000
040173 CD 96 01 04 0241*       call @one_int
040177 01 18 FC FF 0242*       ld bc, -1000
04017B CD 96 01 04 0243*       call @one_int
04017F 01 9C FF FF 0244*       ld bc, -100
040183 CD 96 01 04 0245*       call @one_int
040187 0E F6       0246*       ld c, -10
040189 CD 96 01 04 0247*       call @one_int
04018D 48          0248*       ld c, b
04018E CD 96 01 04 0249*       call @one_int
040192 C3 A1 01 04 0250*       jp @frac ; Jump to fractional part conversion
040196             0251*   @one_int:
040196 3E 2F       0252*       ld a, '0' - 1 ; Start ASCII character at '0'
040198             0253*   @divide_me:
040198 3C          0254*       inc a
040199 09          0255*       add hl, bc ; Accumulate until overflow
04019A 38 FC       0256*       jr c, @divide_me
04019C ED 42       0257*       sbc hl, bc ; Remove excess after overflow
04019E 12          0258*       ld (de), a ; Store ASCII digit
04019F 13          0259*       inc de
0401A0 C9          0260*       ret
0401A1             0261*   ; Convert fractional part
0401A1             0262*   @frac:
0401A1 3E 2E       0263*       ld a, '.' ; Decimal point
0401A3 12          0264*       ld (de), a
0401A4 13          0265*       inc de
0401A5 E1          0266*       pop hl ; Restore HL with original fraction
0401A6 06 03       0267*       ld b, 3 ; Loop counter for 3 fractional digits
0401A8             0268*   @frac_loop:
0401A8 26 0A       0269*       ld h, 10 ; Load multiplier for fractional part
0401AA ED 6C       0270*       mlt hl ; Multiply by 10, result in HL (H holds the integer part)
0401AC 3E 30       0271*       ld a, '0'
0401AE 84          0272*       add a, h ; Convert integer part to ASCII
0401AF 12          0273*       ld (de), a
0401B0 13          0274*       inc de
0401B1 10 F5       0275*       djnz @frac_loop ; Repeat for each fractional digit
0401B3             0276*   ; Add null terminator
0401B3 AF          0277*       xor a ; Null terminator
0401B4 12          0278*       ld (de), a
0401B5 C9          0279*       ret
0401B6             0280*   
0401B6             0281*   print_u168:
0401B6 D5          0282*       push de
0401B7 E5          0283*       push hl
0401B8 11 F8 00 04 0284*       ld de,_printDecBuffer
0401BC CD 63 01 04 0285*       call u168_to_ascii
0401C0 21 F8 00 04 0286*       ld hl,_printDecBuffer
0401C4 CD 67 00 04 0287*       call printString
0401C8 E1          0288*       pop hl
0401C9 D1          0289*       pop de
0401CA C9          0290*       ret
0401CB             0291*   
0401CB             0292*   ; signed version of u168_to_ascii
0401CB             0293*   s168_to_ascii:
0401CB D5          0294*       push de ; save starting address of buffer
0401CC CD 70 04 04 0295*       call hlu_abs
0401D0 F5          0296*       push af ; save sign flag
0401D1 CD 63 01 04 0297*       call u168_to_ascii
0401D5 F1          0298*       pop af ; restore sign flag
0401D6 D1          0299*       pop de ; restore starting address of buffer
0401D7 F0          0300*       ret p ; hlu was positive so nothing to do
0401D8 3E 2D       0301*       ld a,'-'
0401DA 12          0302*       ld (de),a
0401DB C9          0303*       ret
0401DC             0304*   
0401DC             0305*   print_s168:
0401DC D5          0306*       push de
0401DD E5          0307*       push hl
0401DE 11 F8 00 04 0308*       ld de,_printDecBuffer
0401E2 CD CB 01 04 0309*       call s168_to_ascii
0401E6 21 F8 00 04 0310*       ld hl,_printDecBuffer
0401EA CD 67 00 04 0311*       call printString
0401EE E1          0312*       pop hl
0401EF D1          0313*       pop de
0401F0 C9          0314*       ret
0401F1             0315*   
0401F1             0316*   print_s168_hl:
0401F1 F5          0317*       push af
0401F2 E5          0318*       push hl
0401F3 CD DC 01 04 0319*       call print_s168
0401F7 3E 20       0320*       ld a,' '
0401F9 5B D7       0321*       rst.lil 10h
0401FB E1          0322*       pop hl
0401FC F1          0323*       pop af
0401FD C9          0324*       ret
0401FE             0325*   
0401FE             0326*   print_s168_bc:
0401FE F5          0327*       push af
0401FF C5          0328*       push bc
040200 E5          0329*       push hl
040201 C5          0330*       push bc
040202 E1          0331*       pop hl
040203 CD DC 01 04 0332*       call print_s168
040207 3E 20       0333*       ld a,' '
040209 5B D7       0334*       rst.lil 10h
04020B E1          0335*       pop hl
04020C C1          0336*       pop bc
04020D F1          0337*       pop af
04020E C9          0338*       ret
04020F             0339*   
04020F             0340*   print_s168_de:
04020F F5          0341*       push af
040210 D5          0342*       push de
040211 E5          0343*       push hl
040212 EB          0344*       ex de,hl
040213 CD DC 01 04 0345*       call print_s168
040217 3E 20       0346*       ld a,' '
040219 5B D7       0347*       rst.lil 10h
04021B E1          0348*       pop hl
04021C D1          0349*       pop de
04021D F1          0350*       pop af
04021E C9          0351*       ret
04021F             0352*   
04021F             0353*   print_s168_hl_bc_de:
04021F F5          0354*       push af
040220 C5          0355*       push bc
040221 D5          0356*       push de
040222 E5          0357*       push hl
040223 CD DC 01 04 0358*       call print_s168
040227 3E 20       0359*       ld a,' '
040229 5B D7       0360*       rst.lil 10h
04022B C5          0361*       push bc
04022C E1          0362*       pop hl
04022D CD DC 01 04 0363*       call print_s168
040231 3E 20       0364*       ld a,' '
040233 5B D7       0365*       rst.lil 10h
040235 EB          0366*       ex de,hl
040236 CD DC 01 04 0367*       call print_s168
04023A 3E 20       0368*       ld a,' '
04023C 5B D7       0369*       rst.lil 10h
04023E E1          0370*       pop hl
04023F D1          0371*       pop de
040240 C1          0372*       pop bc
040241 F1          0373*       pop af
040242 C9          0374*       ret
040243             0375*   
040243             0376*   print_s168_bc_de:
040243 F5          0377*       push af
040244 C5          0378*       push bc
040245 D5          0379*       push de
040246 C5          0380*       push bc
040247 E1          0381*       pop hl
040248 CD DC 01 04 0382*       call print_s168
04024C 3E 20       0383*       ld a,' '
04024E 5B D7       0384*       rst.lil 10h
040250 EB          0385*       ex de,hl
040251 CD DC 01 04 0386*       call print_s168
040255 3E 20       0387*       ld a,' '
040257 5B D7       0388*       rst.lil 10h
040259 E1          0389*       pop hl
04025A D1          0390*       pop de
04025B C1          0391*       pop bc
04025C F1          0392*       pop af
04025D C9          0393*       ret
04025E             0394*   
04025E             0395*   print_s168_a:
04025E F5          0396*       push af
04025F C5          0397*       push bc
040260 E5          0398*       push hl
040261 21 00 00 00 0399*       ld hl,0
040265 6F          0400*       ld l,a
040266 CD F1 01 04 0401*       call print_s168_hl
04026A E1          0402*       pop hl
04026B C1          0403*       pop bc
04026C F1          0404*       pop af
04026D C9          0405*       ret
04026E             0406*   
04026E             0407*   ; #### new functions added by Brandon R. Gates ####
04026E             0408*   
04026E             0409*   ; print the binary representation of the 8-bit value in a
04026E             0410*   ; destroys a, hl, bc
04026E             0411*   printBin8:
04026E 06 08       0412*       ld b,8 ; loop counter for 8 bits
040270 21 8B 02 04 0413*       ld hl,@cmd ; set hl to the low byte of the output string
040274             0414*       ; (which will be the high bit of the value in a)
040274             0415*   @loop:
040274 07          0416*       rlca ; put the next highest bit into carry
040275 38 04       0417*       jr c,@one
040277 36 30       0418*       ld (hl),'0'
040279 18 02       0419*       jr @next_bit
04027B             0420*   @one:
04027B 36 31       0421*       ld (hl),'1'
04027D             0422*   @next_bit:
04027D 23          0423*       inc hl
04027E 10 F4       0424*       djnz @loop
040280             0425*   ; print it
040280 21 8B 02 04 0426*       ld hl,@cmd
040284 01 08 00 00 0427*       ld bc,@end-@cmd
040288 5B DF       0428*       rst.lil $18
04028A C9          0429*       ret
04028B             0430*   @cmd: ds 8 ; eight bytes for eight bits
040293             0431*   @end:
040293             0432*   
040293             0433*   ; print the binary representation of the 8-bit value in a
040293             0434*   ; in reverse order (lsb first)
040293             0435*   ; destroys a, hl, bc
040293             0436*   printBin8Rev:
       FF FF FF FF 
       FF FF FF FF 
040293 06 08       0437*       ld b,8 ; loop counter for 8 bits
040295 21 B0 02 04 0438*       ld hl,@cmd ; set hl to the low byte of the output string
040299             0439*       ; (which will be the high bit of the value in a)
040299             0440*   @loop:
040299 0F          0441*       rrca ; put the next lowest bit into carry
04029A 38 04       0442*       jr c,@one
04029C 36 30       0443*       ld (hl),'0'
04029E 18 02       0444*       jr @next_bit
0402A0             0445*   @one:
0402A0 36 31       0446*       ld (hl),'1'
0402A2             0447*   @next_bit:
0402A2 23          0448*       inc hl
0402A3 10 F4       0449*       djnz @loop
0402A5             0450*   ; print it
0402A5 21 B0 02 04 0451*       ld hl,@cmd
0402A9 01 08 00 00 0452*       ld bc,@end-@cmd
0402AD 5B DF       0453*       rst.lil $18
0402AF C9          0454*       ret
0402B0             0455*   @cmd: ds 8 ; eight bytes for eight bits
0402B8             0456*   @end:
0402B8             0457*   
       FF FF FF FF 
       FF FF FF FF 
0402B8 20 61 66 3D 0458*   str_afu: db " af=",0
       00          
0402BD 20 68 6C 3D 0459*   str_hlu: db " hl=",0
       00          
0402C2 20 62 63 3D 0460*   str_bcu: db " bc=",0
       00          
0402C7 20 64 65 3D 0461*   str_deu: db " de=",0
       00          
0402CC 20 69 78 3D 0462*   str_ixu: db " ix=",0
       00          
0402D1 20 69 79 3D 0463*   str_iyu: db " iy=",0
       00          
0402D6             0464*   
0402D6             0465*   ; print udeuhl to screen in hexidecimal format
0402D6             0466*   ; inputs: none
0402D6             0467*   ; outputs: concatenated hexidecimal udeuhl
0402D6             0468*   ; destroys: nothing
0402D6             0469*   dumpUDEUHLHex:
0402D6             0470*   ; store everything in scratch
0402D6 22 35 03 04 0471*       ld (uhl),hl
0402DA ED 43 38 03 0472*       ld (ubc),bc
       04          
0402DF ED 53 3B 03 0473*       ld (ude),de
       04          
0402E4 DD 22 3E 03 0474*       ld (uix),ix
       04          
0402E9 FD 22 41 03 0475*       ld (uiy),iy
       04          
0402EE F5          0476*       push af
0402EF             0477*   
0402EF             0478*   ; print each register
0402EF             0479*   
0402EF 21 29 03 04 0480*       ld hl,str_udeuhl
0402F3 CD 67 00 04 0481*       call printString
0402F7 2A 3B 03 04 0482*       ld hl,(ude)
0402FB CD A0 00 04 0483*       call printHex24
0402FF 3E 2E       0484*       ld a,'.' ; print a dot to separate the values
040301 5B D7       0485*       rst.lil 10h
040303 2A 35 03 04 0486*       ld hl,(uhl)
040307 CD A0 00 04 0487*       call printHex24
04030B CD 7C 00 04 0488*       call printNewLine
04030F             0489*   
04030F             0490*   ; restore everything
04030F 2A 35 03 04 0491*       ld hl, (uhl)
040313 ED 4B 38 03 0492*       ld bc, (ubc)
       04          
040318 ED 5B 3B 03 0493*       ld de, (ude)
       04          
04031D DD 2A 3E 03 0494*       ld ix, (uix)
       04          
040322 FD 2A 41 03 0495*       ld iy, (uiy)
       04          
040327 F1          0496*       pop af
040328             0497*   ; all done
040328 C9          0498*       ret
040329             0499*   
040329 75 64 65 2E 0500*   str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
040332             0501*   
040332             0502*   ; global scratch memory for registers
040332 00 00 00    0503*   uaf: dl 0
040335 00 00 00    0504*   uhl: dl 0
040338 00 00 00    0505*   ubc: dl 0
04033B 00 00 00    0506*   ude: dl 0
04033E 00 00 00    0507*   uix: dl 0
040341 00 00 00    0508*   uiy: dl 0
040344 00 00 00    0509*   usp: dl 0
040347 00 00 00    0510*   upc: dl 0
04034A             0511*   
04034A             0512*   
04034A             0513*   ; set all the bits in the flag register
04034A             0514*   ; more of an academic exercise than anything useful
04034A             0515*   ; inputs; none
04034A             0516*   ; outputs; a=0,f=255
04034A             0517*   ; destroys: flags, hl
04034A             0518*   ; preserves: a, because why not
04034A             0519*   setAllFlags:
04034A 21 FF 00 00 0520*       ld hl,255
04034E 67          0521*       ld h,a ; four cycles to preserve a is cheap
04034F E5          0522*       push hl
040350 F1          0523*       pop af
040351 C9          0524*       ret
040352             0525*   
040352             0526*   ; reset all the bits in the flag register
040352             0527*   ; unlike its inverse counterpart, this may actually be useful
040352             0528*   ; inputs; none
040352             0529*   ; outputs; a=0,f=0
040352             0530*   ; destroys: flags, hl
040352             0531*   ; preserves: a, because why not
040352             0532*   resetAllFlags:
040352 21 00 00 00 0533*       ld hl,0
040356 67          0534*       ld h,a ; four cycles to preserve a is cheap
040357 E5          0535*       push hl
040358 F1          0536*       pop af
040359 C9          0537*       ret
04035A             0538*   
04035A             0539*   ; wait until user presses a key
04035A             0540*   ; inputs: none
04035A             0541*   ; outputs: ascii code of key pressed in a
04035A             0542*   ; destroys: af,ix
04035A             0543*   waitKeypress:
04035A             0544*       MOSCALL mos_getkey
                       M1 Args: function=mos_getkey 
04035A 3E 00       0001*M1 			LD	A, function
04035C 5B CF       0002*M1 			RST.LIL	08h
04035E C9          0545*       ret
04035F             0546*   
04035F             0547*   ; clear a block of memory by writing a prescribed value to each byte in the range
04035F             0548*   ; inputs: a = value to write, hl = address of first byte, bc = number of bytes
04035F             0549*   ; outputs: memory block is cleared
04035F             0550*   ; destroys: hl, de
04035F             0551*   clear_mem:
04035F 0B          0552*       dec bc ; we do this because we will increment de before writing the first byte
040360 77          0553*       ld (hl),a
040361 E5          0554*       push hl
040362 D1          0555*       pop de
040363 13          0556*       inc de ; target address
040364 ED B0       0557*       ldir
040366 C9          0558*       ret
040367             0033        include "arith24.inc"
040367             0001*   ;------------------------------------------------------------------------
040367             0002*   ;  arith24.asm
040367             0003*   ;  24-bit ez80 arithmetic routines
040367             0004*   ;  Copyright (c) Shawn Sijnstra 2024
040367             0005*   ;  MIT license
040367             0006*   ;
040367             0007*   ;  This library was created as a tool to help make ez80
040367             0008*   ;  24-bit native assembly routines for simple mathematical problems
040367             0009*   ;  more widely available.
040367             0010*   ;
040367             0011*   ;------------------------------------------------------------------------
040367             0012*   
040367             0013*   ;------------------------------------------------------------------------
040367             0014*   ; umul24:	HL = HL*DE (unsigned)
040367             0015*   ; Preserves AF, BC, DE
040367             0016*   ; Uses a fast multiply routine.
040367             0017*   ;------------------------------------------------------------------------
040367             0018*   umul24:
040367 D5          0019*   	push	DE
040368 C5          0020*   	push	BC
040369 F5          0021*   	push	AF
04036A E5          0022*   	push	HL
04036B C1          0023*   	pop		BC
04036C 3E 18       0024*       ld	 	a, 24 ; No. of bits to process
04036E 21 00 00 00 0025*       ld	 	hl, 0 ; Result
040372             0026*   umul24_lp:
040372 29          0027*   	add	hl,hl
040373 EB          0028*   	ex	de,hl
040374 29          0029*   	add	hl,hl
040375 EB          0030*   	ex	de,hl
040376 30 01       0031*   	jr	nc,umul24_nc
040378 09          0032*   	add	hl,bc
040379             0033*   umul24_nc:
040379 3D          0034*   	dec	a
04037A 20 F6       0035*   	jr	nz,umul24_lp
04037C F1          0036*   	pop	af
04037D C1          0037*   	pop	bc
04037E D1          0038*   	pop	de
04037F C9          0039*   	ret
040380             0040*   
040380             0041*   
040380             0042*   ;------------------------------------------------------------------------
040380             0043*   ; udiv24
040380             0044*   ; Unsigned 24-bit division
040380             0045*   ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
040380             0046*   ;
040380             0047*   ; Uses AF BC DE HL
040380             0048*   ; Uses Restoring Division algorithm
040380             0049*   ;------------------------------------------------------------------------
040380             0050*   
040380             0051*   udiv24:
040380 E5          0052*   	push	hl
040381 C1          0053*   	pop		bc	;move dividend to BCU
040382 21 00 00 00 0054*   	ld		hl,0	;result
040386 A7          0055*   	and		a
040387 ED 52       0056*   	sbc		hl,de	;test for div by 0
040389 C8          0057*   	ret		z		;it's zero, carry flag is clear
04038A 19          0058*   	add		hl,de	;HL is 0 again
04038B 3E 18       0059*   	ld		a,24	;number of loops through.
04038D             0060*   udiv1:
04038D C5          0061*   	push	bc	;complicated way of doing this because of lack of access to top bits
04038E E3          0062*   	ex		(sp),hl
04038F 37          0063*   	scf
040390 ED 6A       0064*   	adc	hl,hl
040392 E3          0065*   	ex	(sp),hl
040393 C1          0066*   	pop	bc		;we now have bc = (bc * 2) + 1
040394             0067*   
040394 ED 6A       0068*   	adc	hl,hl
040396 A7          0069*   	and	a		;is this the bug
040397 ED 52       0070*   	sbc	hl,de
040399 30 02       0071*   	jr	nc,udiv2
04039B 19          0072*   	add	hl,de
04039C             0073*   ;	dec	c
04039C 0B          0074*   	dec	bc
04039D             0075*   udiv2:
04039D 3D          0076*   	dec	a
04039E 20 ED       0077*   	jr	nz,udiv1
0403A0 37          0078*   	scf		;flag used for div0 error
0403A1 C5          0079*   	push	bc
0403A2 D1          0080*   	pop		de	;remainder
0403A3 C9          0081*   	ret
0403A4             0082*   
0403A4             0083*   
0403A4             0084*   
0403A4             0085*   ;------------------------------------------------------------------------
0403A4             0086*   ; neg24
0403A4             0087*   ; Returns: HLU = 0-HLU
0403A4             0088*   ; preserves all other registers
0403A4             0089*   ;------------------------------------------------------------------------
0403A4             0090*   neg24:
0403A4 D5          0091*   	push	de
0403A5 EB          0092*   	ex		de,hl
0403A6 21 00 00 00 0093*   	ld		hl,0
0403AA B7          0094*   	or		a
0403AB ED 52       0095*   	sbc		hl,de
0403AD D1          0096*   	pop		de
0403AE C9          0097*   	ret
0403AF             0098*   
0403AF             0099*   ;------------------------------------------------------------------------
0403AF             0100*   ; or_hlu_deu: 24 bit bitwise OR
0403AF             0101*   ; Returns: hlu = hlu OR deu
0403AF             0102*   ; preserves all other registers
0403AF             0103*   ;------------------------------------------------------------------------
0403AF             0104*   or_hlu_deu:
0403AF 22 38 04 04 0105*   	ld	(bitbuf1),hl
0403B3 ED 53 3B 04 0106*   	ld	(bitbuf2),de
       04          
0403B8 D5          0107*   	push	de	;preserve DEU
0403B9 C5          0108*   	push	bc	;preserve BCU
0403BA 06 03       0109*   	ld		b,3
0403BC 21 38 04 04 0110*   	ld	hl,bitbuf1
0403C0 11 38 04 04 0111*   	ld	de,bitbuf1
0403C4             0112*   orloop_24:
0403C4 1A          0113*   	ld	a,(de)
0403C5 B6          0114*   	or	(hl)
0403C6 12          0115*   	ld	(de),a
0403C7 13          0116*   	inc	de
0403C8 23          0117*   	inc	hl
0403C9 10 F9       0118*   	djnz	orloop_24
0403CB 2A 3B 04 04 0119*   	ld	hl,(bitbuf2)
0403CF C1          0120*   	pop		bc	;restore BC
0403D0 D1          0121*   	pop		de	;restore DE
0403D1             0122*   
0403D1             0123*   ;------------------------------------------------------------------------
0403D1             0124*   ; and_hlu_deu: 24 bit bitwise AND
0403D1             0125*   ; Returns: hlu = hlu AND deu
0403D1             0126*   ; preserves all other registers
0403D1             0127*   ;------------------------------------------------------------------------
0403D1             0128*   and_hlu_deu:
0403D1 22 38 04 04 0129*   	ld	(bitbuf1),hl
0403D5 ED 53 3B 04 0130*   	ld	(bitbuf2),de
       04          
0403DA D5          0131*   	push	de	;preserve DEU
0403DB C5          0132*   	push	bc	;preserve BCU
0403DC 06 03       0133*   	ld		b,3
0403DE 21 38 04 04 0134*   	ld	hl,bitbuf1
0403E2 11 38 04 04 0135*   	ld	de,bitbuf1
0403E6             0136*   andloop_24:
0403E6 1A          0137*   	ld	a,(de)
0403E7 A6          0138*   	and	(hl)
0403E8 12          0139*   	ld	(de),a
0403E9 13          0140*   	inc	de
0403EA 23          0141*   	inc	hl
0403EB 10 F9       0142*   	djnz	andloop_24
0403ED 2A 3B 04 04 0143*   	ld	hl,(bitbuf2)
0403F1 C1          0144*   	pop		bc	;restore BC
0403F2 D1          0145*   	pop		de	;restore DE
0403F3             0146*   
0403F3             0147*   ;------------------------------------------------------------------------
0403F3             0148*   ; xor_hlu_deu: 24 bit bitwise XOR
0403F3             0149*   ; Returns: hlu = hlu XOR deu
0403F3             0150*   ; preserves all other registers
0403F3             0151*   ;------------------------------------------------------------------------
0403F3             0152*   xor_hlu_deu:
0403F3 22 38 04 04 0153*   	ld	(bitbuf1),hl
0403F7 ED 53 3B 04 0154*   	ld	(bitbuf2),de
       04          
0403FC D5          0155*   	push	de	;preserve DEU
0403FD C5          0156*   	push	bc	;preserve BCU
0403FE 06 03       0157*   	ld		b,3
040400 21 38 04 04 0158*   	ld	hl,bitbuf1
040404 11 38 04 04 0159*   	ld	de,bitbuf1
040408             0160*   xorloop_24:
040408 1A          0161*   	ld	a,(de)
040409 AE          0162*   	xor	(hl)
04040A 12          0163*   	ld	(de),a
04040B 13          0164*   	inc	de
04040C 23          0165*   	inc	hl
04040D 10 F9       0166*   	djnz	xorloop_24
04040F 2A 3B 04 04 0167*   	ld	hl,(bitbuf2)
040413 C1          0168*   	pop		bc	;restore BC
040414 D1          0169*   	pop		de	;restore DE
040415             0170*   
040415             0171*   ;------------------------------------------------------------------------
040415             0172*   ; shl_hlu: 24 bit shift left hlu by a positions
040415             0173*   ; Returns: hlu = hlu << a
040415             0174*   ;		   a = 0
040415             0175*   ; NOTE: only considers a up to 16 bits.
040415             0176*   ; preserves all other registers
040415             0177*   ; modified by Brandon R. Gates to use a instead of de
040415             0178*   ;------------------------------------------------------------------------
040415             0179*   shl_hlu:
040415 B7          0180*   	or a
040416 C8          0181*   	ret		z		;we're done
040417 29          0182*   	add		hl,hl	;shift HLU left
040418 3D          0183*   	dec a
040419 18 FA       0184*   	jr		shl_hlu
04041B             0185*   
04041B             0186*   ;------------------------------------------------------------------------
04041B             0187*   ; shr_hlu: 24 bit shift right hlu by a positions
04041B             0188*   ; Returns: hlu = hlu >> a
04041B             0189*   ;		   a = 0
04041B             0190*   ; NOTE: only considers a up to 16 bits.
04041B             0191*   ; preserves all other registers
04041B             0192*   ; modified by Brandon R. Gates to use a instead of de
04041B             0193*   ;------------------------------------------------------------------------
04041B             0194*   shr_hlu:
04041B 22 38 04 04 0195*   	ld		(bitbuf1),hl
04041F 21 3A 04 04 0196*   	ld		hl,bitbuf1+2
040423             0197*   @shr_loop:
040423 B7          0198*   	or a
040424 28 0D       0199*   	jr		z,@shr_done		;we're done
040426             0200*   ;carry is clear from or instruction
040426 CB 1E       0201*   	rr		(hl)
040428 2B          0202*   	dec		hl
040429 CB 1E       0203*   	rr		(hl)
04042B 2B          0204*   	dec		hl
04042C CB 1E       0205*   	rr		(hl)
04042E 23          0206*   	inc		hl
04042F 23          0207*   	inc		hl
040430 3D          0208*   	dec a
040431 18 F0       0209*   	jr		@shr_loop
040433             0210*   @shr_done:
040433 2A 38 04 04 0211*   	ld		hl,(bitbuf1)	;collect result
040437 C9          0212*   	ret
040438             0213*   
040438             0214*   ;------------------------------------------------------------------------
040438             0215*   ; Scratch area for calculations
040438             0216*   ;------------------------------------------------------------------------
040438 00 00 00    0217*   bitbuf1:	dw24	0	;bit manipulation buffer 1
04043B 00 00 00    0218*   bitbuf2:	dw24	0	;bit manipulation buffer 2
04043E             0219*   
04043E             0220*   ; -----------------------------------------------------------------------
04043E             0221*   ; Functions added by Brandon R. Gates
04043E             0222*   ; -----------------------------------------------------------------------
04043E             0223*   
04043E             0224*   ;------------------------------------------------------------------------
04043E             0225*   ; shr_hlu_div: Quick division by powers of two based on log2 of A
04043E             0226*   ;              Determines the LSB of A and shifts HLU accordingly.
04043E             0227*   ;              HLU = HLU >> LSB(A)
04043E             0228*   ; Returns: HLU = HLU >> LSB(A)
04043E             0229*   ; Destroys: af
04043E             0230*   ;------------------------------------------------------------------------
04043E             0231*   shr_hlu_log2a:
04043E B7          0232*   	or a    ; check for zero
04043F C8          0233*   	ret z   ; nothing to shift so we're done
040440 C5          0234*   	push 	bc ; preserve
040441 06 00       0235*   	ld		b,0 ; clear b
040443             0236*   @find_bit:
040443 0F          0237*   	rrca ; bit 0 to carry
040444 DA 4D 04 04 0238*   	jp c,@found_bit
040448 04          0239*   	inc b ; next bit
040449 C3 43 04 04 0240*   	jp @find_bit
04044D             0241*   @found_bit:
04044D 78          0242*   	ld a,b
04044E CD 1B 04 04 0243*   	call shr_hlu
040452 C1          0244*   	pop 	bc ; restore
040453 C9          0245*   	ret
040454             0246*   ; end shr_hlu_log2a
040454             0247*   
040454             0248*   ;------------------------------------------------------------------------
040454             0249*   ; shl_hlu_log2a: Quick multiplication by powers of two based on log2 of A
040454             0250*   ;                Determines the LSB of A and shifts HLU accordingly.
040454             0251*   ;                HLU = HLU << LSB(A)
040454             0252*   ; Returns: HLU = HLU << LSB(A)
040454             0253*   ; Destroys: af
040454             0254*   ;------------------------------------------------------------------------
040454             0255*   shl_hlu_log2a:
040454 B7          0256*   	or a    ; check for zero
040455 C8          0257*   	ret z   ; nothing to shift so we're done
040456 C5          0258*   	push 	bc ; preserve
040457 06 00       0259*   	ld		b,0 ; clear b
040459             0260*   @find_bit:
040459 0F          0261*   	rrca ; bit 0 to carry
04045A DA 63 04 04 0262*   	jp c,@found_bit
04045E 04          0263*   	inc b ; next bit
04045F C3 59 04 04 0264*   	jp @find_bit
040463             0265*   @found_bit:
040463 78          0266*   	ld a,b
040464 CD 15 04 04 0267*   	call shl_hlu
040468 C1          0268*   	pop 	bc ; restore
040469 C9          0269*   	ret
04046A             0270*   ; end shl_hlu_log2a
04046A             0034        include "maths.inc"
04046A             0001*   ;------------------------------------------------------------------------
04046A             0002*   ; Scratch area for calculations
04046A             0003*   ;------------------------------------------------------------------------
04046A 00 00 00    0004*   scratch1: dw24 0 ;bit manipulation buffer 1
04046D 00 00 00    0005*   scratch2: dw24 0 ;bit manipulation buffer 2
040470             0006*   
040470             0007*   ; absolute value of hlu
040470             0008*   ; returns: abs(hlu), flags set according to the incoming sign of hlu:
040470             0009*   ;         s1,z0,pv0,n1,c0 if hlu was negative
040470             0010*   ;         s0,z1,pv0,n1,c0 if hlu was zero
040470             0011*   ;         s0,z0,pv0,n1,c0 if hlu was positive
040470             0012*   ; destroys: a
040470             0013*   hlu_abs:
040470 19          0014*       add hl,de
040471 B7          0015*       or a
040472 ED 52       0016*       sbc hl,de
040474 FA 79 04 04 0017*       jp m,@is_neg
040478 C9          0018*       ret ; hlu is positive or zero so we're done
040479             0019*   @is_neg:
040479 F5          0020*       push af ; otherwise, save current flags for return
04047A CD 80 04 04 0021*       call neg_hlu ; negate hlu
04047E F1          0022*       pop af ; get back flags
04047F C9          0023*       ret
040480             0024*   
040480             0025*   ; flip the sign of hlu
040480             0026*   ; inputs: hlu
040480             0027*   ; returns: 0-hlu, flags set appropriately for the result:
040480             0028*   ;         s1,z0,pv0,n1,c1 if result is negative
040480             0029*   ;         s0,z1,pv0,n1,c0 if result is zero
040480             0030*   ;         s0,z0,pv0,n1,c1 if result is positive
040480             0031*   ; destroys a
040480             0032*   neg_hlu:
040480 D5          0033*       push de ; save de
040481 EB          0034*       ex de,hl ; put hl into de
040482 21 00 00 00 0035*       ld hl,0 ; clear hl
040486 AF          0036*       xor a ; clear carry
040487 ED 52       0037*       sbc hl,de ; 0-hlu = -hlu
040489 D1          0038*       pop de ; get de back
04048A C9          0039*       ret ; easy peasy
04048B             0040*   
04048B             0041*   ;------------------------------------------------------------------------
04048B             0042*   ; divide hlu by 2, inspired by above
04048B             0043*   ;------------------------------------------------------------------------
04048B             0044*   hlu_div2:
04048B 22 6A 04 04 0045*       ld (scratch1),hl
04048F 21 6C 04 04 0046*       ld hl,scratch1+2
040493 CB 1E       0047*       rr (hl)
040495 2B          0048*       dec hl
040496 CB 1E       0049*       rr (hl)
040498 2B          0050*       dec hl
040499 CB 1E       0051*       rr (hl)
04049B 23          0052*       inc hl
04049C 23          0053*       inc hl
04049D 2A 6A 04 04 0054*       ld hl,(scratch1)
0404A1 C9          0055*       ret
0404A2             0056*   
0404A2             0057*   ; this is my little hack to divide by 16
0404A2             0058*   hlu_div16:
0404A2 AF          0059*       xor a
0404A3 29          0060*       add hl,hl
0404A4 17          0061*       rla
0404A5 29          0062*       add hl,hl
0404A6 17          0063*       rla
0404A7 29          0064*       add hl,hl
0404A8 17          0065*       rla
0404A9 29          0066*       add hl,hl
0404AA 17          0067*       rla
0404AB 22 B8 04 04 0068*       ld (@scratch),hl
0404AF 32 BB 04 04 0069*       ld (@scratch+3),a
0404B3 2A B9 04 04 0070*       ld hl,(@scratch+1)
0404B7 C9          0071*       ret
0404B8             0072*   @scratch: ds 4
0404BC             0073*   
0404BC             0074*   ; hlu signed division by 256
0404BC             0075*   ; returns: hlu / 256
0404BC             0076*   ; destroys: af
0404BC             0077*   hlu_sdiv256:
       FF FF FF FF 
0404BC AF          0078*       xor a ; assume hl is positive
0404BD 22 D3 04 04 0079*       ld (@buffer),hl
0404C1             0080*       SIGN_HLU
                       M1 Args: none
0404C1 19          0001*M1     add hl,de ; 1 cycle
0404C2 B7          0002*M1     or a ; clear flags ; 1 cycle
0404C3 ED 52       0003*M1     sbc hl,de ; 2 cycles
0404C5             0004*M1     ; 4 cycles total
0404C5 F2 CA 04 04 0081*       jp p,@hl_pos
0404C9 3D          0082*       dec a
0404CA             0083*   @hl_pos:
0404CA 32 D6 04 04 0084*       ld (@buffer+3),a
0404CE 2A D4 04 04 0085*       ld hl,(@buffer+1)
0404D2 C9          0086*       ret
0404D3             0087*   @buffer: ds 4
0404D7             0088*   
0404D7             0089*   ; hlu 1 byte right shift, unsigned
0404D7             0090*   ; returns: hlu / 256, fractional portion in a
0404D7             0091*   ; destroys: af
0404D7             0092*   hlu_udiv256:
       FF FF FF FF 
0404D7 AF          0093*       xor a
0404D8 32 E9 04 04 0094*       ld (@buffer+3),a
0404DC 7D          0095*       ld a,l ; save the fractional portion
0404DD 22 E6 04 04 0096*       ld (@buffer),hl
0404E1 2A E7 04 04 0097*       ld hl,(@buffer+1)
0404E5 C9          0098*       ret
0404E6             0099*   @buffer: ds 4
0404EA             0100*   
0404EA             0101*   ; floor(value,n)
0404EA             0102*   ; inputs: hl = value to floor, de = n
0404EA             0103*   ; outputs: hl = value floored to n
0404EA             0104*   ; destroys: af, hl, bc, de
0404EA             0105*   hlu_floor:
       FF FF FF FF 
0404EA D5          0106*       push de ; save n
0404EB CD 80 03 04 0107*       call udiv24 ; de = quotient, hl = remainder
0404EF E1          0108*       pop hl ; get n back (was de)
0404F0 CD 67 03 04 0109*       call umul24 ; hl = n * quotient
0404F4 C9          0110*       ret
0404F5             0111*   ; end hlu_floor
0404F5             0112*   
0404F5             0113*   ; ceil(value,n)
0404F5             0114*   ; inputs: hl = value to ceil, de = n
0404F5             0115*   ; outputs: hl = value ceiled to n
0404F5             0116*   ; destroys: af, hl, bc, de
0404F5             0117*   hlu_ceiling:
0404F5 D5          0118*       push de ; save n
0404F6 CD 80 03 04 0119*       call udiv24 ; de = quotient, hl = remainder
0404FA             0120*       SIGN_HLU ; test remaider for zero
                       M1 Args: none
0404FA 19          0001*M1     add hl,de ; 1 cycle
0404FB B7          0002*M1     or a ; clear flags ; 1 cycle
0404FC ED 52       0003*M1     sbc hl,de ; 2 cycles
0404FE             0004*M1     ; 4 cycles total
0404FE CA 03 05 04 0121*       jp z,@F ; if zero, nothing to add
040502 13          0122*       inc de ; add 1 to quotient for the ceiling
040503             0123*   @@:
040503 E1          0124*       pop hl ; get n back (was de)
040504 CD 67 03 04 0125*       call umul24 ; hl = n * quotient
040508 C9          0126*       ret
040509             0127*   ; end hlu_ceiling
040509             0128*   
040509 C9          0129*       ret
04050A             0130*   
04050A 00 00 00 00 0131*   add_bcd_arg1: db #00,#00,#00,#00
04050E 00 00 00 00 0132*   add_bcd_arg2: db #00,#00,#00,#00
040512             0133*   
040512             0134*   ; set bcd values in a scratch memory address from registers bcde
040512             0135*   ; input: hl; scratch address,bcde; 8-place bcd number
040512             0136*   ; destroys ; hl
040512             0137*   set_bcd:
040512 73          0138*       ld (hl),e
040513 23          0139*       inc hl
040514 72          0140*       ld (hl),d
040515 23          0141*       inc hl
040516 71          0142*       ld (hl),c
040517 23          0143*       inc hl
040518 70          0144*       ld (hl),b
040519 C9          0145*       ret
04051A             0146*   
04051A             0147*   ; load bcd values from a scratch memory address to bcde
04051A             0148*   ; input: hl; scratch address
04051A             0149*   ; output: bcde; 8-place bcd number
04051A             0150*   ; destroys: hl
04051A             0151*   get_bcd:
04051A 5E          0152*       ld e,(hl)
04051B 23          0153*       inc hl
04051C 56          0154*       ld d,(hl)
04051D 23          0155*       inc hl
04051E 4E          0156*       ld c,(hl)
04051F 23          0157*       inc hl
040520 46          0158*       ld b,(hl)
040521 C9          0159*       ret
040522             0160*   
040522             0161*   ; BCD addition
040522             0162*   ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
040522             0163*   ;       a is the number of bytes holding each number (number of places/2)
040522             0164*   ; outputs: (hl) + (de) --> (hl)
040522             0165*   ; destroys: a,b,de,hl
040522             0166*   add_bcd:
040522 47          0167*       ld b,a ; loop counter
040523 AF          0168*       xor a ; reset a, clear carry flag
040524             0169*   adcec:
040524 1A          0170*       ld a,(de) ; addend to acc
040525 8E          0171*       adc a,(hl) ; add (hl) to acc
040526 27          0172*       daa ; adjust result to bcd
040527 77          0173*       ld (hl),a ; store result
040528 23          0174*       inc hl ; advance memory pointers
040529 13          0175*       inc de
04052A 10 F8       0176*       djnz adcec ; loop until b == 0
04052C C9          0177*       ret
04052D             0178*   
04052D             0179*   ; BCD subtraction
04052D             0180*   ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
04052D             0181*   ;       a is the number of bytes holding each number (number of places/2)
04052D             0182*   ; outputs: (hl) - (de) --> (hl)
04052D             0183*   ; destroys: a,b,de,hl
04052D             0184*   sub_bcd:
04052D 47          0185*       ld b,a ; loop counter
04052E AF          0186*       xor a ; reset a,clear carry flag
04052F             0187*   subdec:
04052F 1A          0188*       ld a,(de) ; subtrahend to acc
040530 9E          0189*       sbc a,(hl) ; subtract (hl) from acc
040531 27          0190*       daa ; adjust result to bcd
040532 77          0191*       ld (hl),a ; store result
040533 23          0192*       inc hl ; advance memory pointers
040534 13          0193*       inc de
040535 10 F8       0194*       djnz subdec ; loop until b == 0
040537 C9          0195*       ret
040538             0196*   
040538             0197*   ; http://www.z80.info/pseudo-random.txt
040538             0198*   rand_8:
040538 C5          0199*       push bc
040539 3A 4C 05 04 0200*       ld a,(r_seed)
04053D 4F          0201*       ld c,a
04053E             0202*   
04053E 0F          0203*       rrca ; multiply by 32
04053F 0F          0204*       rrca
040540 0F          0205*       rrca
040541 EE 1F       0206*       xor 0x1f
040543             0207*   
040543 81          0208*       add a,c
040544 DE FF       0209*       sbc a,255 ; carry
040546             0210*   
040546 32 4C 05 04 0211*       ld (r_seed),a
04054A C1          0212*       pop bc
04054B C9          0213*       ret
04054C 50          0214*   r_seed: defb $50
04054D             0215*   
04054D             0216*   ; https://www.omnimaga.org/asm-language/ez80-optimized-routines/msg399325/#msg399325
04054D             0217*   prng24:
04054D             0218*   ;;Expects ADL mode.
04054D             0219*   ;;Output: HL
04054D             0220*   ;;50cc
04054D             0221*   ;;33 bytes
04054D             0222*   ;;cycle length: 281,474,959,933,440 (about 2.8 trillion)
04054D ED 5B 6E 05 0223*       ld de,(seed1)
       04          
040552 B7          0224*       or a
040553 ED 62       0225*       sbc hl,hl
040555 19          0226*       add hl,de
040556 29          0227*       add hl,hl
040557 29          0228*       add hl,hl
040558 2C          0229*       inc l
040559 19          0230*       add hl,de
04055A 22 6E 05 04 0231*       ld (seed1),hl
04055E 2A 71 05 04 0232*       ld hl,(seed2)
040562 29          0233*       add hl,hl
040563 9F          0234*       sbc a,a
040564 E6 1B       0235*       and %00011011
040566 AD          0236*       xor l
040567 6F          0237*       ld l,a
040568 22 71 05 04 0238*       ld (seed2),hl
04056C 19          0239*       add hl,de
04056D C9          0240*       ret
04056E 00 00 00    0241*   seed1: dl 0
040571 00 00 00    0242*   seed2: dl 0
040574             0243*   
040574             0244*   
040574             0245*   ; https://map.grauw.nl/sources/external/z80bits.html#2.1
040574             0246*   ; 2.1 Restoring 8-bit / 8-bit Unsigned
040574             0247*   ; Input: H = Dividend, L = Divisor, A = 0
040574             0248*   ; Output: H = Quotient, A = Remainder, L = Divisor (unchanged)
040574             0249*   udiv8:
040574 AF          0250*       xor a
040575 06 08       0251*       ld b,8
040577             0252*   @loop:
040577 CB 24       0253*       sla h
040579 17          0254*       rla
04057A BD          0255*       cp l
04057B 38 02       0256*       jr c,$+4
04057D 95          0257*       sub l
04057E 24          0258*       inc h
04057F 10 F6       0259*       djnz @loop
040581 C9          0260*       ret
040582             0035        include "fonts.inc"
040582             0001*   fonts_load:
040582 DD 21 B3 05 0002*       ld ix,font_list ; pointer to font list lookup
       04          
040587 06 1D       0003*       ld b,num_fonts ; loop counter
040589             0004*   
040589             0005*   @load_loop:
040589 C5          0006*       push bc ; save loop counter
04058A             0007*   
04058A             0008*   ; load font into a buffer
04058A DD 27 06    0009*       ld hl,(ix+font_list_bufferId)
04058D DD 31 09    0010*       ld iy,(ix+font_list_filename)
040590 CD 12 19 04 0011*       call vdu_load_buffer_from_file
040594             0012*   
040594             0013*   ; create font from buffer
040594 DD 27 06    0014*       ld hl,(ix+font_list_bufferId)
040597 DD 5E 00    0015*       ld e,(ix+font_list_width)
04059A DD 56 03    0016*       ld d,(ix+font_list_height)
04059D 3E 00       0017*       ld a,0 ; flags
04059F CD 65 1B 04 0018*       call vdu_font_create
0405A3             0019*   
0405A3             0020*   ; select font
0405A3 DD 27 06    0021*       ld hl,(ix+font_list_bufferId)
0405A6 3E 01       0022*       ld a,1 ; flags
0405A8 CD 4B 1B 04 0023*       call vdu_font_select
0405AC             0024*   
0405AC             0025*   ; ; debug print filename
0405AC             0026*   ;     call printNewLine
0405AC             0027*   ;     ld hl,(ix+font_list_filename)
0405AC             0028*   ;     call printString
0405AC             0029*   
0405AC             0030*   ; advance font_list pointer to next record
0405AC ED 32 0C    0031*       lea ix,ix+font_list_record_size
0405AF             0032*   
0405AF             0033*   ; restore loop counter
0405AF C1          0034*       pop bc
0405B0 10 D7       0035*       djnz @load_loop
0405B2             0036*   
0405B2             0037*   ; all done
0405B2 C9          0038*       ret
0405B3             0036        include "fonts_list.inc"
0405B3             0001*   ; Generated by asm_config_editor.py
0405B3             0002*   font_list_record_size: equ 12
0405B3             0003*   font_list_width: equ 0
0405B3             0004*   font_list_height: equ 3
0405B3             0005*   font_list_bufferId: equ 6
0405B3             0006*   font_list_filename: equ 9
0405B3             0007*   
0405B3             0008*   num_fonts: equ 29
0405B3             0009*   
0405B3             0010*   ; Index list:
0405B3             0011*   amiga_forever_16x16: equ 64000
0405B3             0012*   amiga_forever_16x24: equ 64001
0405B3             0013*   amiga_forever_8x16: equ 64002
0405B3             0014*   amiga_forever_8x8: equ 64003
0405B3             0015*   computer_pixel_7_10x15: equ 64004
0405B3             0016*   computer_pixel_7_10x24: equ 64005
0405B3             0017*   computer_pixel_7_8x12: equ 64006
0405B3             0018*   computer_pixel_7_8x14: equ 64007
0405B3             0019*   computer_pixel_7_8x16: equ 64008
0405B3             0020*   dopecre_8x8: equ 64009
0405B3             0021*   gamer_2_8x8: equ 64010
0405B3             0022*   Lat15_VGA8_8x8: equ 64011
0405B3             0023*   Lat2_Terminus12x6_6x12: equ 64012
0405B3             0024*   Lat2_TerminusBold14_8x14: equ 64013
0405B3             0025*   Lat2_VGA14_8x14: equ 64014
0405B3             0026*   Lat2_VGA16_8x16: equ 64015
0405B3             0027*   Lat2_VGA8_8x8: equ 64016
0405B3             0028*   Lat38_VGA8_8x8: equ 64017
0405B3             0029*   Lat7_Fixed13_8x13: equ 64018
0405B3             0030*   Lat7_Terminus12x6_6x12: equ 64019
0405B3             0031*   Lat7_TerminusBold16_8x16: equ 64020
0405B3             0032*   Lat7_VGA14_8x14: equ 64021
0405B3             0033*   Lat7_VGA16_8x16: equ 64022
0405B3             0034*   Lat7_VGA8_8x8: equ 64023
0405B3             0035*   planetary_contact_8x8: equ 64024
0405B3             0036*   scriptorium_12x14: equ 64025
0405B3             0037*   Squarewave_Bold_8x12: equ 64026
0405B3             0038*   super_mario_bros_2_8x8: equ 64027
0405B3             0039*   wendy_neue_6x6: equ 64028
0405B3             0040*   
0405B3             0041*   font_list: ; width; height; bufferId; filename;:
0405B3 10 00 00 10 0042*   	dl 16, 16, 64000, fn_amiga_forever_16x16
       00 00 00 FA 
       00 0F 07 04 
0405BF 10 00 00 18 0043*   	dl 16, 24, 64001, fn_amiga_forever_16x24
       00 00 01 FA 
       00 2D 07 04 
0405CB 08 00 00 10 0044*   	dl 8, 16, 64002, fn_amiga_forever_8x16
       00 00 02 FA 
       00 4B 07 04 
0405D7 08 00 00 08 0045*   	dl 8, 8, 64003, fn_amiga_forever_8x8
       00 00 03 FA 
       00 68 07 04 
0405E3 0A 00 00 0F 0046*   	dl 10, 15, 64004, fn_computer_pixel_7_10x15
       00 00 04 FA 
       00 84 07 04 
0405EF 0A 00 00 18 0047*   	dl 10, 24, 64005, fn_computer_pixel_7_10x24
       00 00 05 FA 
       00 A5 07 04 
0405FB 08 00 00 0C 0048*   	dl 8, 12, 64006, fn_computer_pixel_7_8x12
       00 00 06 FA 
       00 C6 07 04 
040607 08 00 00 0E 0049*   	dl 8, 14, 64007, fn_computer_pixel_7_8x14
       00 00 07 FA 
       00 E6 07 04 
040613 08 00 00 10 0050*   	dl 8, 16, 64008, fn_computer_pixel_7_8x16
       00 00 08 FA 
       00 06 08 04 
04061F 08 00 00 08 0051*   	dl 8, 8, 64009, fn_dopecre_8x8
       00 00 09 FA 
       00 26 08 04 
04062B 08 00 00 08 0052*   	dl 8, 8, 64010, fn_gamer_2_8x8
       00 00 0A FA 
       00 3C 08 04 
040637 08 00 00 08 0053*   	dl 8, 8, 64011, fn_Lat15_VGA8_8x8
       00 00 0B FA 
       00 52 08 04 
040643 06 00 00 0C 0054*   	dl 6, 12, 64012, fn_Lat2_Terminus12x6_6x12
       00 00 0C FA 
       00 6B 08 04 
04064F 08 00 00 0E 0055*   	dl 8, 14, 64013, fn_Lat2_TerminusBold14_8x14
       00 00 0D FA 
       00 8C 08 04 
04065B 08 00 00 0E 0056*   	dl 8, 14, 64014, fn_Lat2_VGA14_8x14
       00 00 0E FA 
       00 AF 08 04 
040667 08 00 00 10 0057*   	dl 8, 16, 64015, fn_Lat2_VGA16_8x16
       00 00 0F FA 
       00 C9 08 04 
040673 08 00 00 08 0058*   	dl 8, 8, 64016, fn_Lat2_VGA8_8x8
       00 00 10 FA 
       00 E3 08 04 
04067F 08 00 00 08 0059*   	dl 8, 8, 64017, fn_Lat38_VGA8_8x8
       00 00 11 FA 
       00 FB 08 04 
04068B 08 00 00 0D 0060*   	dl 8, 13, 64018, fn_Lat7_Fixed13_8x13
       00 00 12 FA 
       00 14 09 04 
040697 06 00 00 0C 0061*   	dl 6, 12, 64019, fn_Lat7_Terminus12x6_6x12
       00 00 13 FA 
       00 30 09 04 
0406A3 08 00 00 10 0062*   	dl 8, 16, 64020, fn_Lat7_TerminusBold16_8x16
       00 00 14 FA 
       00 51 09 04 
0406AF 08 00 00 0E 0063*   	dl 8, 14, 64021, fn_Lat7_VGA14_8x14
       00 00 15 FA 
       00 74 09 04 
0406BB 08 00 00 10 0064*   	dl 8, 16, 64022, fn_Lat7_VGA16_8x16
       00 00 16 FA 
       00 8E 09 04 
0406C7 08 00 00 08 0065*   	dl 8, 8, 64023, fn_Lat7_VGA8_8x8
       00 00 17 FA 
       00 A8 09 04 
0406D3 08 00 00 08 0066*   	dl 8, 8, 64024, fn_planetary_contact_8x8
       00 00 18 FA 
       00 C0 09 04 
0406DF 0C 00 00 0E 0067*   	dl 12, 14, 64025, fn_scriptorium_12x14
       00 00 19 FA 
       00 E0 09 04 
0406EB 08 00 00 0C 0068*   	dl 8, 12, 64026, fn_Squarewave_Bold_8x12
       00 00 1A FA 
       00 FC 09 04 
0406F7 08 00 00 08 0069*   	dl 8, 8, 64027, fn_super_mario_bros_2_8x8
       00 00 1B FA 
       00 1B 0A 04 
040703 06 00 00 06 0070*   	dl 6, 6, 64028, fn_wendy_neue_6x6
       00 00 1C FA 
       00 3C 0A 04 
04070F             0071*   
04070F             0072*   ; files_list: ; filename:
04070F 66 6F 6E 74 0073*   fn_amiga_forever_16x16: db "fontsamiga_forever_16x16.font",0
       73 61 6D 69 
       67 61 5F 66 
       6F 72 65 76 
       65 72 5F 31 
       36 78 31 36 
       2E 66 6F 6E 
       74 00       
04072D 66 6F 6E 74 0074*   fn_amiga_forever_16x24: db "fontsamiga_forever_16x24.font",0
       73 61 6D 69 
       67 61 5F 66 
       6F 72 65 76 
       65 72 5F 31 
       36 78 32 34 
       2E 66 6F 6E 
       74 00       
04074B 66 6F 6E 74 0075*   fn_amiga_forever_8x16: db "fontsamiga_forever_8x16.font",0
       73 61 6D 69 
       67 61 5F 66 
       6F 72 65 76 
       65 72 5F 38 
       78 31 36 2E 
       66 6F 6E 74 
       00          
040768 66 6F 6E 74 0076*   fn_amiga_forever_8x8: db "fontsamiga_forever_8x8.font",0
       73 61 6D 69 
       67 61 5F 66 
       6F 72 65 76 
       65 72 5F 38 
       78 38 2E 66 
       6F 6E 74 00 
040784 66 6F 6E 74 0077*   fn_computer_pixel_7_10x15: db "fontscomputer_pixel_7_10x15.font",0
       73 63 6F 6D 
       70 75 74 65 
       72 5F 70 69 
       78 65 6C 5F 
       37 5F 31 30 
       78 31 35 2E 
       66 6F 6E 74 
       00          
0407A5 66 6F 6E 74 0078*   fn_computer_pixel_7_10x24: db "fontscomputer_pixel_7_10x24.font",0
       73 63 6F 6D 
       70 75 74 65 
       72 5F 70 69 
       78 65 6C 5F 
       37 5F 31 30 
       78 32 34 2E 
       66 6F 6E 74 
       00          
0407C6 66 6F 6E 74 0079*   fn_computer_pixel_7_8x12: db "fontscomputer_pixel_7_8x12.font",0
       73 63 6F 6D 
       70 75 74 65 
       72 5F 70 69 
       78 65 6C 5F 
       37 5F 38 78 
       31 32 2E 66 
       6F 6E 74 00 
0407E6 66 6F 6E 74 0080*   fn_computer_pixel_7_8x14: db "fontscomputer_pixel_7_8x14.font",0
       73 63 6F 6D 
       70 75 74 65 
       72 5F 70 69 
       78 65 6C 5F 
       37 5F 38 78 
       31 34 2E 66 
       6F 6E 74 00 
040806 66 6F 6E 74 0081*   fn_computer_pixel_7_8x16: db "fontscomputer_pixel_7_8x16.font",0
       73 63 6F 6D 
       70 75 74 65 
       72 5F 70 69 
       78 65 6C 5F 
       37 5F 38 78 
       31 36 2E 66 
       6F 6E 74 00 
040826 66 6F 6E 74 0082*   fn_dopecre_8x8: db "fontsdopecre_8x8.font",0
       73 64 6F 70 
       65 63 72 65 
       5F 38 78 38 
       2E 66 6F 6E 
       74 00       
04083C 66 6F 6E 74 0083*   fn_gamer_2_8x8: db "fontsgamer_2_8x8.font",0
       73 67 61 6D 
       65 72 5F 32 
       5F 38 78 38 
       2E 66 6F 6E 
       74 00       
040852 66 6F 6E 74 0084*   fn_Lat15_VGA8_8x8: db "fontsLat15-VGA8_8x8.font",0
       73 4C 61 74 
       31 35 2D 56 
       47 41 38 5F 
       38 78 38 2E 
       66 6F 6E 74 
       00          
04086B 66 6F 6E 74 0085*   fn_Lat2_Terminus12x6_6x12: db "fontsLat2-Terminus12x6_6x12.font",0
       73 4C 61 74 
       32 2D 54 65 
       72 6D 69 6E 
       75 73 31 32 
       78 36 5F 36 
       78 31 32 2E 
       66 6F 6E 74 
       00          
04088C 66 6F 6E 74 0086*   fn_Lat2_TerminusBold14_8x14: db "fontsLat2-TerminusBold14_8x14.font",0
       73 4C 61 74 
       32 2D 54 65 
       72 6D 69 6E 
       75 73 42 6F 
       6C 64 31 34 
       5F 38 78 31 
       34 2E 66 6F 
       6E 74 00    
0408AF 66 6F 6E 74 0087*   fn_Lat2_VGA14_8x14: db "fontsLat2-VGA14_8x14.font",0
       73 4C 61 74 
       32 2D 56 47 
       41 31 34 5F 
       38 78 31 34 
       2E 66 6F 6E 
       74 00       
0408C9 66 6F 6E 74 0088*   fn_Lat2_VGA16_8x16: db "fontsLat2-VGA16_8x16.font",0
       73 4C 61 74 
       32 2D 56 47 
       41 31 36 5F 
       38 78 31 36 
       2E 66 6F 6E 
       74 00       
0408E3 66 6F 6E 74 0089*   fn_Lat2_VGA8_8x8: db "fontsLat2-VGA8_8x8.font",0
       73 4C 61 74 
       32 2D 56 47 
       41 38 5F 38 
       78 38 2E 66 
       6F 6E 74 00 
0408FB 66 6F 6E 74 0090*   fn_Lat38_VGA8_8x8: db "fontsLat38-VGA8_8x8.font",0
       73 4C 61 74 
       33 38 2D 56 
       47 41 38 5F 
       38 78 38 2E 
       66 6F 6E 74 
       00          
040914 66 6F 6E 74 0091*   fn_Lat7_Fixed13_8x13: db "fontsLat7-Fixed13_8x13.font",0
       73 4C 61 74 
       37 2D 46 69 
       78 65 64 31 
       33 5F 38 78 
       31 33 2E 66 
       6F 6E 74 00 
040930 66 6F 6E 74 0092*   fn_Lat7_Terminus12x6_6x12: db "fontsLat7-Terminus12x6_6x12.font",0
       73 4C 61 74 
       37 2D 54 65 
       72 6D 69 6E 
       75 73 31 32 
       78 36 5F 36 
       78 31 32 2E 
       66 6F 6E 74 
       00          
040951 66 6F 6E 74 0093*   fn_Lat7_TerminusBold16_8x16: db "fontsLat7-TerminusBold16_8x16.font",0
       73 4C 61 74 
       37 2D 54 65 
       72 6D 69 6E 
       75 73 42 6F 
       6C 64 31 36 
       5F 38 78 31 
       36 2E 66 6F 
       6E 74 00    
040974 66 6F 6E 74 0094*   fn_Lat7_VGA14_8x14: db "fontsLat7-VGA14_8x14.font",0
       73 4C 61 74 
       37 2D 56 47 
       41 31 34 5F 
       38 78 31 34 
       2E 66 6F 6E 
       74 00       
04098E 66 6F 6E 74 0095*   fn_Lat7_VGA16_8x16: db "fontsLat7-VGA16_8x16.font",0
       73 4C 61 74 
       37 2D 56 47 
       41 31 36 5F 
       38 78 31 36 
       2E 66 6F 6E 
       74 00       
0409A8 66 6F 6E 74 0096*   fn_Lat7_VGA8_8x8: db "fontsLat7-VGA8_8x8.font",0
       73 4C 61 74 
       37 2D 56 47 
       41 38 5F 38 
       78 38 2E 66 
       6F 6E 74 00 
0409C0 66 6F 6E 74 0097*   fn_planetary_contact_8x8: db "fontsplanetary_contact_8x8.font",0
       73 70 6C 61 
       6E 65 74 61 
       72 79 5F 63 
       6F 6E 74 61 
       63 74 5F 38 
       78 38 2E 66 
       6F 6E 74 00 
0409E0 66 6F 6E 74 0098*   fn_scriptorium_12x14: db "fontsscriptorium_12x14.font",0
       73 73 63 72 
       69 70 74 6F 
       72 69 75 6D 
       5F 31 32 78 
       31 34 2E 66 
       6F 6E 74 00 
0409FC 66 6F 6E 74 0099*   fn_Squarewave_Bold_8x12: db "fontsSquarewave_Bold_8x12.font",0
       73 53 71 75 
       61 72 65 77 
       61 76 65 5F 
       42 6F 6C 64 
       5F 38 78 31 
       32 2E 66 6F 
       6E 74 00    
040A1B 66 6F 6E 74 0100*   fn_super_mario_bros_2_8x8: db "fontssuper_mario_bros_2_8x8.font",0
       73 73 75 70 
       65 72 5F 6D 
       61 72 69 6F 
       5F 62 72 6F 
       73 5F 32 5F 
       38 78 38 2E 
       66 6F 6E 74 
       00          
040A3C 66 6F 6E 74 0101*   fn_wendy_neue_6x6: db "fontswendy_neue_6x6.font",0
       73 77 65 6E 
       64 79 5F 6E 
       65 75 65 5F 
       36 78 36 2E 
       66 6F 6E 74 
       00          
040A55             0037        include "fixed168.inc"
040A55             0001*   ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
040A55             0002*   ; uses EZ80 MLT instruction for speed
040A55             0003*   ; operation: UHL * A --> UHL
040A55             0004*   ; destroys: AF, HL
040A55             0005*   smul24x8:
040A55             0006*   ; make hl positive and store sign flag
040A55 CD 70 04 04 0007*       call hlu_abs
040A59 F5          0008*       push af
040A5A             0009*   ; do the division
040A5A CD 65 0A 04 0010*       call mul24x8 ; hl = product
040A5E             0011*   ; adjust sign of result
040A5E F1          0012*       pop af ; sign de
040A5F F0          0013*       ret p ; hl was positive, nothing to do
040A60 CD 80 04 04 0014*       call neg_hlu ; result is negative
040A64 C9          0015*       ret
040A65             0016*   
040A65             0017*   ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
040A65             0018*   ; uses EZ80 MLT instruction for speed
040A65             0019*   ; operation: UHL * A --> AUHL
040A65             0020*   ; destroys: AF, HL
040A65             0021*   mul24x8:
040A65 D5          0022*       push de ; preserve de
040A66             0023*   ; low byte
040A66 5D          0024*       ld e,l
040A67 57          0025*       ld d,a
040A68 ED 5C       0026*       mlt de
040A6A 6B          0027*       ld l,e ; product low byte
040A6B 08          0028*       ex af,af' ; save multiplier
040A6C 7A          0029*       ld a,d ; carry
040A6D 08          0030*       ex af,af' ; save carry, restore multiplier
040A6E             0031*   ; high byte
040A6E 5C          0032*       ld e,h
040A6F 57          0033*       ld d,a
040A70 ED 5C       0034*       mlt de
040A72 08          0035*       ex af,af' ; save multiplier, restore carry
040A73 83          0036*       add a,e ; add carry
040A74 67          0037*       ld h,a ; product middle byte
040A75 7A          0038*       ld a,d ; carry
040A76 08          0039*       ex af,af' ; save carry, restore multiplier
040A77             0040*   ; upper byte
040A77 22 92 0A 04 0041*       ld (@scratch),hl ; 7 cycles
040A7B 5F          0042*       ld e,a
040A7C 3A 94 0A 04 0043*       ld a,(@scratch+2)
040A80 57          0044*       ld d,a
040A81 ED 5C       0045*       mlt de
040A83 08          0046*       ex af,af' ; restore carry
040A84 8B          0047*       adc a,e ; add carry
040A85 32 94 0A 04 0048*       ld (@scratch+2),a ; 5 cycles
040A89 2A 92 0A 04 0049*       ld hl,(@scratch) ; 7 cycles
040A8D             0050*   ; highest byte
040A8D 3E 00       0051*       ld a,0 ; preserve carry flag
040A8F 8A          0052*       adc a,d ; product highest byte
040A90 D1          0053*       pop de ; restore de
040A91 C9          0054*       ret
040A92             0055*   @scratch: ds 3
040A95             0056*   
       FF FF FF 
040A95 00 00 00 00 0057*   mul24out: blkb 6,0
       00 00       
040A9B             0058*   
040A9B             0059*   ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
040A9B             0060*   ; operation: UHL * UDE --> mul24out
040A9B             0061*   mul24:
040A9B DD E5       0062*       push ix ; preserve
040A9D             0063*   ; point to output buffer and clear it
040A9D DD 21 95 0A 0064*       ld ix,mul24out
       04          
040AA2 C5          0065*       push bc
040AA3 01 00 00 00 0066*       ld bc,0
040AA7 DD 0F 00    0067*       ld (ix),bc
040AAA DD 0F 03    0068*       ld (ix+3),bc
040AAD C1          0069*       pop bc
040AAE             0070*   ; STEP 1: UHL * E
040AAE 7B          0071*       ld a,e
040AAF E5          0072*       push hl
040AB0 CD 65 0A 04 0073*       call mul24x8
040AB4 DD 2F 00    0074*       ld (ix+0),hl
040AB7 DD 77 03    0075*       ld (ix+3),a
040ABA             0076*   ; STEP 2: UHL * D
040ABA E1          0077*       pop hl
040ABB E5          0078*       push hl
040ABC 7A          0079*       ld a,d
040ABD CD 65 0A 04 0080*       call mul24x8
040AC1 CD DA 0A 04 0081*       call @accumulate
040AC5             0082*   ; STEP 3: UHL * DEU
040AC5 E1          0083*       pop hl
040AC6 ED 53 0A 0B 0084*       ld (@de),de
       04          
040ACB 3A 0C 0B 04 0085*       ld a,(@de+2)
040ACF CD 65 0A 04 0086*       call mul24x8
040AD3 CD DA 0A 04 0087*       call @accumulate
040AD7             0088*   ; all done
040AD7 DD E1       0089*       pop ix ; restore
040AD9 C9          0090*       ret
040ADA             0091*   @accumulate:
040ADA DD 23       0092*       inc ix
040ADC             0093*   ; highest byte of product to carry
040ADC DD 77 03    0094*       ld (ix+3),a
040ADF             0095*   ; low byte of product
040ADF 7D          0096*       ld a,l
040AE0 DD 86 00    0097*       add a,(ix+0)
040AE3 DD 77 00    0098*       ld (ix+0),a
040AE6             0099*   ; high byte of product
040AE6 7C          0100*       ld a,h
040AE7 DD 8E 01    0101*       adc a,(ix+1)
040AEA DD 77 01    0102*       ld (ix+1),a
040AED             0103*   ; uppper byte of product
040AED 22 07 0B 04 0104*       ld (@hl),hl
040AF1 3A 09 0B 04 0105*       ld a,(@hl+2)
040AF5 DD 8E 02    0106*       adc a,(ix+2)
040AF8 DD 77 02    0107*       ld (ix+2),a
040AFB             0108*   ; carry
040AFB 3E 00       0109*       ld a,0 ; preserve flags
040AFD DD 8E 03    0110*       adc a,(ix+3)
040B00 DD 77 03    0111*       ld (ix+3),a
040B03 C9          0112*       ret
040B04             0113*   
040B04 00 00 00    0114*   @ix: dl 0
040B07 00 00 00    0115*   @hl: dl 0
040B0A 00 00 00    0116*   @de: dl 0
040B0D             0117*   
040B0D             0118*   ; ; UHL * UDE --> UHL (unsigned)
040B0D             0119*   ; umul24:
040B0D             0120*   ;     call mul24
040B0D             0121*   ;     ld hl,(mul24out)
040B0D             0122*   ;     ret
040B0D             0123*   
040B0D             0124*   ; UH.L = UH.L*UD.E (unsigned)
040B0D             0125*   umul168:
040B0D CD 9B 0A 04 0126*       call mul24
040B11 2A 96 0A 04 0127*       ld hl,(mul24out+1)
040B15 C9          0128*       ret
040B16             0129*   
040B16             0130*   ; UH.L * UD.E --> UH.L (signed)
040B16             0131*   smul168:
040B16             0132*   ; make everything positive and store sign flags
040B16 CD 70 04 04 0133*       call hlu_abs
040B1A F5          0134*       push af
040B1B EB          0135*       ex de,hl
040B1C CD 70 04 04 0136*       call hlu_abs
040B20 EB          0137*       ex de,hl
040B21 F5          0138*       push af
040B22             0139*   ; do the division
040B22 CD 0D 0B 04 0140*       call umul168 ; hl = product
040B26             0141*   ; adjust sign of result
040B26 F1          0142*       pop af ; sign de
040B27 FA 32 0B 04 0143*       jp m,@de_neg
040B2B F1          0144*       pop af ; sign hl
040B2C F0          0145*       ret p ; both positive, nothing to do
040B2D             0146*   @hl_neg:
040B2D CD 80 04 04 0147*       call neg_hlu ; de pos, hl neg, result is negative
040B31 C9          0148*       ret
040B32             0149*   @de_neg:
040B32 F1          0150*       pop af
040B33 F8          0151*       ret m ; both negative, nothing to do
040B34 CD 80 04 04 0152*       call neg_hlu ; result is negative
040B38 C9          0153*       ret
040B39             0154*   
040B39             0155*   ; UH.L / UD.E --> UD.E rem UHL (unsigned)
040B39             0156*   ; perform unsigned division of 16.8 fixed place values
040B39             0157*   ; with an unsigned 16.8 fixed place result and 24-bit remainder
040B39             0158*   udiv168:
040B39             0159*   ; back up divisor
040B39 ED 53 70 0B 0160*       ld (@ude),de
       04          
040B3E             0161*   ; get the 16-bit integer part of the quotient
040B3E CD 80 03 04 0162*       call udiv24 ; de = quotient, hl = remainder
040B42             0163*   ; load quotient to upper three bytes of output
040B42 ED 53 77 0B 0164*       ld (div168_out+1),de
       04          
040B47             0165*   @div256:
040B47             0166*   ; multiply remainder by 256
040B47             0167*       hlu_mul256
                       M1 Args: none
040B47 29          0001*M1     add hl,hl ; * 2
040B48 29          0002*M1     add hl,hl ; * 4
040B49 29          0003*M1     add hl,hl ; * 8
040B4A 29          0004*M1     add hl,hl ; * 16
040B4B 29          0005*M1     add hl,hl ; * 32
040B4C 29          0006*M1     add hl,hl ; * 64
040B4D 29          0007*M1     add hl,hl ; * 128
040B4E 29          0008*M1     add hl,hl ; * 256
040B4F             0168*   ; skip fractional computation if remainder is zero
040B4F             0169*       SIGN_HLU
                       M1 Args: none
040B4F 19          0001*M1     add hl,de ; 1 cycle
040B50 B7          0002*M1     or a ; clear flags ; 1 cycle
040B51 ED 52       0003*M1     sbc hl,de ; 2 cycles
040B53             0004*M1     ; 4 cycles total
040B53 20 03       0170*       jr nz,@div_frac
040B55 AF          0171*       xor a
040B56 18 0A       0172*       jr @write_frac
040B58             0173*   ; now divide the shifted remainder by the divisor
040B58             0174*   @div_frac:
040B58 ED 5B 70 0B 0175*       ld de,(@ude) ; get back divisor
       04          
040B5D CD 80 03 04 0176*       call udiv24 ; de = quotient, hl = remainder
040B61             0177*   ; load low byte of quotient to low byte of output
040B61 7B          0178*       ld a,e
040B62             0179*   @write_frac:
040B62 32 76 0B 04 0180*       ld (div168_out),a
040B66             0181*   ; load de with return value
040B66 ED 5B 76 0B 0182*       ld de,(div168_out)
       04          
040B6B             0183*   ; load a with any overflow
040B6B 3A 79 0B 04 0184*       ld a,(div168_out+3)
040B6F C9          0185*       ret ; ud.e is the 16.8 result
040B70             0186*   @ude: ds 6
040B76             0187*   div168_out: ds 4 ; the extra byte is for overflow
040B7A             0188*   
040B7A             0189*   ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
040B7A             0190*   ; perform signed division of 16.8 fixed place values
040B7A             0191*   ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
040B7A             0192*   sdiv168:
040B7A             0193*   ; make everything positive and store sign flags
       FF FF FF FF 
       FF FF FF FF 
       FF FF 
040B7A CD 70 04 04 0194*       call hlu_abs
040B7E F5          0195*       push af
040B7F EB          0196*       ex de,hl
040B80 CD 70 04 04 0197*       call hlu_abs
040B84 EB          0198*       ex de,hl
040B85 F5          0199*       push af
040B86             0200*   ; do the division
040B86 CD 39 0B 04 0201*       call udiv168 ; de = quotient, hl = remainder
040B8A             0202*   ; adjust sign of result
040B8A F1          0203*       pop af ; sign de
040B8B FA 98 0B 04 0204*       jp m,@de_neg
040B8F F1          0205*       pop af ; sign hl
040B90 F0          0206*       ret p ; both positive, nothing to do
040B91             0207*   @hl_neg:
040B91 EB          0208*       ex de,hl ; hl = quotient, de = remainder
040B92 CD 80 04 04 0209*       call neg_hlu ; de pos, hl neg, result is negative
040B96 EB          0210*       ex de,hl ; de = negated quotient, hl = remainder
040B97 C9          0211*       ret
040B98             0212*   @de_neg:
040B98 F1          0213*       pop af
040B99 F8          0214*       ret m ; both negative, nothing to do
040B9A EB          0215*       ex de,hl ; hl = quotient, de = remainder
040B9B CD 80 04 04 0216*       call neg_hlu ; result is negative
040B9F EB          0217*       ex de,hl ; de = negated quotient, hl = remainder
040BA0 C9          0218*       ret
040BA1             0219*   
040BA1             0220*   ; convert signed angles from a 360 to 256 degree circle
040BA1             0221*   ; inputs: uh.l is the angle360 in 16.8 fixed format
040BA1             0222*   ; outputs: uh.l is the angle256 in 16.8 fixed format
040BA1             0223*   ; destroys: TODO
040BA1             0224*   deg_360_to_256:
040BA1 D5          0225*       push de ; preserve de
040BA2             0226*   ; make angle positive and store sign flag
040BA2 CD 70 04 04 0227*       call hlu_abs
040BA6 F5          0228*       push af
040BA7             0229*   ; multiply by coversion factor of 256/360
040BA7 11 B6 00 00 0230*       ld de,0x0000B6 ; 0.711
040BAB CD 0D 0B 04 0231*       call umul168 ; uh.l = uh.l * 0.711
040BAF             0232*   ; restore sign flag and adjust output accordingly
040BAF F1          0233*       pop af
040BB0 F2 B8 0B 04 0234*       jp p,@pos ; positive number
040BB4 CD 80 04 04 0235*       call neg_hlu
040BB8             0236*   @pos:
040BB8             0237*   ; restore de and return uh.l as the result
040BB8 D1          0238*       pop de
040BB9 C9          0239*       ret
040BBA             0240*   
040BBA             0241*   ; convert signed angles from a 256 to 360 degree circle
040BBA             0242*   ; inputs: uh.l is the angle256 in 16.8 fixed format
040BBA             0243*   ; outputs: uh.l is the angle360 in 16.8 fixed format
040BBA             0244*   ; destroys: TODO
040BBA             0245*   deg_256_to_360:
040BBA D5          0246*       push de ; preserve de
040BBB             0247*   ; make angle positive and store sign flag
040BBB CD 70 04 04 0248*       call hlu_abs
040BBF F5          0249*       push af
040BC0             0250*   ; multiply by coversion factor of 360/256
040BC0 11 68 01 00 0251*       ld de,0x000168 ; 1.406
040BC4 CD 0D 0B 04 0252*       call umul168 ; uh.l = uh.l * 1.406
040BC8             0253*   ; restore sign flag and adjust output accordingly
040BC8 F1          0254*       pop af
040BC9 F2 D1 0B 04 0255*       jp p,@pos ; positive number
040BCD CD 80 04 04 0256*       call neg_hlu
040BD1             0257*   @pos:
040BD1             0258*   ; restore de and return uh.l as the result
040BD1 D1          0259*       pop de
040BD2 C9          0260*       ret
040BD3             0261*   
040BD3             0262*   ; fixed 16.8 routine
040BD3             0263*   ; cos(uh.l) --> uh.l
040BD3             0264*   ; destroys: f, hl
040BD3             0265*   cos168:
040BD3 D5          0266*       push de ; preserve de
040BD4             0267*   ; for cos we simply increment the angle by 90 degrees
040BD4             0268*   ; or 0x004000 in 16.8 degrees256
040BD4             0269*   ; which makes it a sin problem
040BD4 11 00 40 00 0270*       ld de,0x004000
040BD8 19          0271*       add hl,de ; modulo 256 happens below
040BD9 D1          0272*       pop de ; restore de
040BDA             0273*   ; fall through to sin168
040BDA             0274*   
040BDA             0275*   ; ---------------------
040BDA             0276*   ; fixed 16.8 routine
040BDA             0277*   ; sin(uh.l) --> uh.l
040BDA             0278*   ; destroys: f, hl
040BDA             0279*   sin168:
040BDA D5          0280*       push de
040BDB             0281*   ; handle negative angles appropriately
040BDB CD 70 04 04 0282*       call hlu_abs
040BDF F2 E8 0B 04 0283*       jp p,@F
040BE3 11 00 00 FF 0284*       ld de,-256*256
040BE7 19          0285*       add hl,de
040BE8             0286*   @@:
040BE8 2E 03       0287*       ld l,3 ; multiply by 3 to get our lookup index
040BEA ED 6C       0288*       mlt hl
040BEC 11 A0 0E 04 0289*       ld de,sin_lut_168 ; grab the lut address
040BF0 19          0290*       add hl,de ; bump hl by the index
040BF1 ED 27       0291*       ld hl,(hl) ; don't try this on a z80!
040BF3 D1          0292*       pop de
040BF4 C9          0293*       ret
040BF5             0294*   
040BF5             0295*   ; 16.8 fixed inputs / outputs
040BF5             0296*   ; takes: uh.l as angle in degrees 256
040BF5             0297*   ;        ud.e as radius
040BF5             0298*   ; returns ub.c as dx, ud.e as dy, uh.l as radius
040BF5             0299*   ;        displacements from origin (0,0)
040BF5             0300*   ; destroys: everything except indexes
040BF5             0301*   polar_to_cartesian:
040BF5             0302*   ; back up input parameters
040BF5 22 24 0C 04 0303*       ld (@angle), hl
040BF9 ED 53 27 0C 0304*       ld (@radius), de
       04          
040BFE             0305*   ; compute dx = sin(uh.l) * ud.e
040BFE CD DA 0B 04 0306*       call sin168 ; uh.l = sin(uh.l)
040C02 ED 5B 27 0C 0307*       ld de,(@radius)
       04          
040C07 CD 16 0B 04 0308*       call smul168 ; uh.l = dx
040C0B E5          0309*       push hl
040C0C             0310*   ; compute dy = -cos(uh.l) * ud.e
040C0C 2A 24 0C 04 0311*       ld hl,(@angle)
040C10 CD D3 0B 04 0312*       call cos168 ; uh.l = cos(uh.l)
040C14 ED 5B 27 0C 0313*       ld de,(@radius)
       04          
040C19 CD 16 0B 04 0314*       call smul168 ; uh.l = dy
040C1D CD 80 04 04 0315*       call neg_hlu ; invert dy for screen coords convention
040C21 EB          0316*       ex de,hl ; de = dy for output
040C22 C1          0317*       pop bc ; bc = dx for output
040C23             0318*   ; and out
040C23 C9          0319*       ret
040C24             0320*   @angle: ds 3
040C27             0321*   @radius: ds 3
040C2A             0322*   
040C2A             0323*   ; 16.8 fixed inputs / outputs
040C2A             0324*   ; inputs: ub.c as dx, ud.e as dy
040C2A             0325*   ;        displacements from origin (0,0)
040C2A             0326*   ; returns: uh.l as angle in degrees 256
040C2A             0327*   ;        ud.e as radius
040C2A             0328*   ; destroys: everything except indexes
040C2A             0329*   cartesian_to_polar:
       FF FF FF FF 
       FF FF 
040C2A ED 43 83 0C 0330*       ld (dx168),bc ; dx argument for distance168
       04          
040C2F ED 53 89 0C 0331*       ld (dy168),de ; dy argument for distance168
       04          
040C34             0332*   ; compute radius
040C34 CD 8F 0C 04 0333*       call distance168 ; uh.l = radius
040C38 E5          0334*       push hl ; save radius
040C39             0335*   ; compute angle
040C39 ED 4B 83 0C 0336*       ld bc,(dx168) ; dx argument for atan2_168fast
       04          
040C3E ED 5B 89 0C 0337*       ld de,(dy168) ; dy argument for atan2_168fast
       04          
040C43 CD EF 0C 04 0338*       call atan2_168fast ; uh.l = angle
040C47             0339*   ; return result
040C47 D1          0340*       pop de ; de = radius (was hl)
040C48 C9          0341*       ret
040C49             0342*   ; end cartesian_to_polar
040C49             0343*   
040C49             0344*   ; 16.8 fixed inputs / outputs
040C49             0345*   ; inputs: ub.c as dx, ud.e as dy
040C49             0346*   ;        displacements from origin (0,0)
040C49             0347*   ; returns: uh.l as angle in degrees 256
040C49             0348*   ;        ud.e as radius
040C49             0349*   ; destroys: everything except indexes
040C49             0350*   ; note: uses distance168sm which is more accurate for small deltas
040C49             0351*   cartesian_to_polar_sm:
040C49 ED 43 83 0C 0352*       ld (dx168),bc ; dx argument for distance168
       04          
040C4E ED 53 89 0C 0353*       ld (dy168),de ; dy argument for distance168
       04          
040C53             0354*   ; compute radius
040C53 CD CA 0C 04 0355*       call distance168sm ; uh.l = radius
040C57 E5          0356*       push hl ; save radius
040C58             0357*   ; compute angle
040C58 ED 4B 83 0C 0358*       ld bc,(dx168) ; dx argument for atan2_168fast
       04          
040C5D ED 5B 89 0C 0359*       ld de,(dy168) ; dy argument for atan2_168fast
       04          
040C62 CD EF 0C 04 0360*       call atan2_168fast ; uh.l = angle
040C66             0361*   ; return result
040C66 D1          0362*       pop de ; de = radius (was hl)
040C67 C9          0363*       ret
040C68             0364*   ; end cartesian_to_polar
040C68             0365*   
040C68             0366*   ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
040C68             0367*   ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
040C68             0368*   ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
040C68             0369*   ;         also populates scratch locations dx168 and dy168
040C68             0370*   ; destroys: a,hl,bc,de
040C68             0371*   dxy168:
040C68             0372*   ; compute dx = x1-x0
040C68 AF          0373*       xor a ; clear carry
040C69 DD E5       0374*       push ix ; move ix to hl via the stack
040C6B E1          0375*       pop hl ; hl = x1
040C6C ED 42       0376*       sbc hl,bc ; hl = dx
040C6E 22 83 0C 04 0377*       ld (dx168),hl ; dx to scratch
040C72             0378*   ; compute dy = y1-y0
040C72 AF          0379*       xor a ; clear carry
040C73 FD E5       0380*       push iy ; move iy to hl via the stack
040C75 E1          0381*       pop hl ; hl = y1
040C76 ED 52       0382*       sbc hl,de ; hl = dy
040C78 22 89 0C 04 0383*       ld (dy168),hl ; dy to scratch
040C7C             0384*   ; populate output registers and return
040C7C EB          0385*       ex de,hl ; ud.e = dy
040C7D ED 4B 83 0C 0386*       ld bc,(dx168) ; ub.c = dx
       04          
040C82 C9          0387*       ret
040C83 00 00 00 00 0388*   dx168: blkb 6,0
       00 00       
040C89 00 00 00 00 0389*   dy168: blkb 6,0
       00 00       
040C8F             0390*   
040C8F             0391*   ; compute the euclidian distance between two cartesian coordinates
040C8F             0392*   ; using the formula d = sqrt(dx^2+dy^2)
040C8F             0393*   ; inputs: dx168 and dy168 are dx and dy in 16.8 fixed format
040C8F             0394*   ; output; uh.l is the 16.8 fixed format distance
040C8F             0395*   ;         also populates scratch locations dx168 and dy168
040C8F             0396*   ; destroys: a,hl,bc,de
040C8F             0397*   ; NOTE: rounds both deltas down to the nearest integer to avoid overflow when squaring,
040C8F             0398*   ;       thus the result will always be an integer, albeit in 16.8 format
040C8F             0399*   distance168:
040C8F             0400*   ; compute dy^2
040C8F 2A 89 0C 04 0401*       ld hl,(dy168)
040C93 CD 70 04 04 0402*       call hlu_abs
040C97             0403*       ; call hlu_udiv256 ; make integer to avoid overflow
040C97             0404*       SRL_UHL ; make integer to avoid overflow
                       M1 Args: none
040C97 3B          0001*M1     dec sp ; 1 cycle
040C98 E5          0002*M1     push hl ; 4 cycles
040C99 33          0003*M1     inc sp ; 1 cycle
040C9A E1          0004*M1     pop hl ; 4 cycles
040C9B 23          0005*M1     inc hl ; 1 cycle
040C9C 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
040C9E             0007*M1     ; 13 cycles total
040C9E E5          0405*       push hl
040C9F D1          0406*       pop de
040CA0 CD 67 03 04 0407*       call umul24 ; hl = dy^2
040CA4 E5          0408*       push hl ; save dy^2
040CA5             0409*   ; compute dx^2
040CA5 2A 83 0C 04 0410*       ld hl,(dx168)
040CA9 CD 70 04 04 0411*       call hlu_abs
040CAD             0412*       ; call hlu_udiv256 ; make integer to avoid overflow
040CAD             0413*       SRL_UHL ; make integer to avoid overflow
                       M1 Args: none
040CAD 3B          0001*M1     dec sp ; 1 cycle
040CAE E5          0002*M1     push hl ; 4 cycles
040CAF 33          0003*M1     inc sp ; 1 cycle
040CB0 E1          0004*M1     pop hl ; 4 cycles
040CB1 23          0005*M1     inc hl ; 1 cycle
040CB2 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
040CB4             0007*M1     ; 13 cycles total
040CB4 E5          0414*       push hl
040CB5 D1          0415*       pop de
040CB6 CD 67 03 04 0416*       call umul24 ; hl = dx^2
040CBA             0417*   ; add dx^2 and dy^2
040CBA D1          0418*       pop de ; de = dy^2 (was hl)
040CBB 19          0419*       add hl,de ; hl = dx^2 + dy^2
040CBC             0420*   ; compute the square root
040CBC CD BA 0D 04 0421*       call sqrt24 ; de = sqrt(dx^2 + dy^2)
040CC0 EB          0422*       ex de,hl ; hl = distance
040CC1             0423*       hlu_mul256 ; convert back to 16.8 fixed
                       M1 Args: none
040CC1 29          0001*M1     add hl,hl ; * 2
040CC2 29          0002*M1     add hl,hl ; * 4
040CC3 29          0003*M1     add hl,hl ; * 8
040CC4 29          0004*M1     add hl,hl ; * 16
040CC5 29          0005*M1     add hl,hl ; * 32
040CC6 29          0006*M1     add hl,hl ; * 64
040CC7 29          0007*M1     add hl,hl ; * 128
040CC8 29          0008*M1     add hl,hl ; * 256
040CC9 C9          0424*       ret
040CCA             0425*   
040CCA             0426*   ; compute the euclidian distance between two cartesian coordinates
040CCA             0427*   ; using the formula d = sqrt(dx^2+dy^2)
040CCA             0428*   ; inputs: dx168 and dy168 are dx and dy in 16.8 fixed format
040CCA             0429*   ; output; uh.l is the 16.8 fixed format distance
040CCA             0430*   ;         also populates scratch locations dx168 and dy168
040CCA             0431*   ; destroys: a,hl,bc,de
040CCA             0432*   ; NOTE: sm means 'small' because it doesn't round down the deltas
040CCA             0433*   ;       making it more accurate for small deltas,
040CCA             0434*   ;       but will overflow if used for screen-sized deltas
040CCA             0435*   distance168sm:
040CCA             0436*   ; compute dy^2
040CCA 2A 89 0C 04 0437*       ld hl,(dy168)
040CCE CD 70 04 04 0438*       call hlu_abs
040CD2 E5          0439*       push hl
040CD3 D1          0440*       pop de
040CD4 CD 67 03 04 0441*       call umul24 ; hl = dy^2
040CD8 E5          0442*       push hl ; save dy^2
040CD9             0443*   ; compute dx^2
040CD9 2A 83 0C 04 0444*       ld hl,(dx168)
040CDD CD 70 04 04 0445*       call hlu_abs
040CE1 E5          0446*       push hl
040CE2 D1          0447*       pop de
040CE3 CD 67 03 04 0448*       call umul24 ; hl = dx^2
040CE7             0449*   ; add dx^2 and dy^2
040CE7 D1          0450*       pop de ; de = dy^2 (was hl)
040CE8 19          0451*       add hl,de ; hl = dx^2 + dy^2
040CE9             0452*   ; compute the square root
040CE9 CD BA 0D 04 0453*       call sqrt24 ; de = sqrt(dx^2 + dy^2)
040CED EB          0454*       ex de,hl ; hl = distance
040CEE C9          0455*       ret
040CEF             0456*   
040CEF             0457*   ; atan2_(ub.c,ud.e) --> uh.l
040CEF             0458*   ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040CEF             0459*   ;   whether inputs are integers or fractional doesn't matter
040CEF             0460*   ;   so long as the sign bit of the upper byte is correct
040CEF             0461*   ; output: uh.l is the 16.8 fixed angle in degrees 256
040CEF             0462*   ; angles are COMPASS HEADINGS based on
040CEF             0463*   ; screen coordinate conventions,where the y axis is flipped
040CEF             0464*   ; #E0 224      0       32 #20
040CEF             0465*   ;        -x,-y | +x,-y
040CEF             0466*   ; #C0 192------+------ 64 #40
040CEF             0467*   ;        -x,+y | +x,+y
040CEF             0468*   ; #A0 160   128 #80   96 #60
040CEF             0469*   atan2_168fast:
040CEF             0470*   ; get signs and make everything positive
040CEF             0471*   ; get abs(x) and store its original sign
040CEF C5          0472*       push bc
040CF0 E1          0473*       pop hl
040CF1 CD 70 04 04 0474*       call hlu_abs ; if x was negative this also sets the sign flag
040CF5 E5          0475*       push hl ; store abs(x)
040CF6 C1          0476*       pop bc ; bc = abs(x)
040CF7 F5          0477*       push af ; store sign of x
040CF8             0478*   ; get abs(y) and store its original sign
040CF8 EB          0479*       ex de,hl ; hl = y
040CF9 CD 70 04 04 0480*       call hlu_abs ; if y was negative this also sets the sign flag
040CFD EB          0481*       ex de,hl ; de = abs(y)
040CFE F5          0482*       push af ; store sign of y
040CFF             0483*   ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
040CFF             0484*   ; this ensures that our lookup value is between 0 and 1 inclusive
040CFF AF          0485*       xor a ; clear the carry flag
040D00 D5          0486*       push de
040D01 E1          0487*       pop hl
040D02 ED 42       0488*       sbc hl,bc
040D04 F5          0489*       push af ; save sign of de - bc
040D05 F2 0E 0D 04 0490*       jp p,@1 ; bc <= de, so we skip ahead
040D09             0491*   ; otherwise we swap bc and de
040D09 C5          0492*       push bc
040D0A E1          0493*       pop hl
040D0B EB          0494*       ex de,hl
040D0C E5          0495*       push hl
040D0D C1          0496*       pop bc
040D0E             0497*   @1:
040D0E             0498*   ; now we're ready to snag our preliminary result
040D0E C5          0499*       push bc
040D0F E1          0500*       pop hl
040D10 CD 7E 0D 04 0501*       call atan_168fast ; uh.l comes back with prelim result
040D14             0502*   ; now we adjust uh.l based on sign of de - bc
040D14 F1          0503*       pop af
040D15 F2 21 0D 04 0504*       jp p,@2 ; bc <= de,so we skip ahead
040D19 EB          0505*       ex de,hl
040D1A 21 00 40 00 0506*       ld hl,64*256 ; subtract from 64 (90) degrees
040D1E AF          0507*       xor a ; clear the carry flag
040D1F ED 52       0508*       sbc hl,de
040D21             0509*   @2:
040D21             0510*   ; adjust the result based on quadrant
040D21             0511*   ; #E0 224      0       32 #20
040D21             0512*   ;        -x,-y | +x,-y
040D21             0513*   ; #C0 192------+------ 64 #40
040D21             0514*   ;        -x,+y | +x,+y
040D21             0515*   ; #A0 160   128 #80   96 #60
040D21 F1          0516*       pop af ; sign of y
040D22 CA 5F 0D 04 0517*       jp z,@y_zero
040D26 F2 3F 0D 04 0518*       jp p,@y_pos
040D2A             0519*   ; y neg,check x
040D2A F1          0520*       pop af ; sign of x
040D2B CA 39 0D 04 0521*       jp z,@y_neg_x_zero
040D2F F2 3E 0D 04 0522*       jp p,@y_neg_x_pos
040D33             0523*   ; y neg,x neg
040D33             0524*   ; angle is 128 to 256 (270 to 360)
040D33             0525*   ; negating the intermediate does the trick
040D33 CD 80 04 04 0526*       call neg_hlu
040D37 18 31       0527*       jr @zero_hlu
040D39             0528*   
040D39             0529*   @y_neg_x_zero:
040D39             0530*   ; y neg,x zero
040D39             0531*   ; angle is 0
040D39 21 00 00 00 0532*       ld hl,0
040D3D C9          0533*       ret
040D3E             0534*   @y_neg_x_pos:
040D3E             0535*   ; y neg,x pos
040D3E             0536*   ; angle is 0 to 64 (0 to 90)
040D3E             0537*   ; so we're good
040D3E C9          0538*       ret
040D3F             0539*   
040D3F             0540*   @y_pos:
040D3F F1          0541*       pop af ; sign of x
040D40 CA 4F 0D 04 0542*       jp z,@y_pos_x_zero
040D44 F2 54 0D 04 0543*       jp p,@y_pos_x_pos
040D48             0544*   ; y pos,x neg
040D48             0545*   ; angle is 128 to 192 (180-270)
040D48             0546*   ; so we add 128 to intermediate
040D48 11 00 80 00 0547*       ld de,128*256
040D4C 19          0548*       add hl,de
040D4D 18 1B       0549*       jr @zero_hlu
040D4F             0550*   @y_pos_x_zero:
040D4F             0551*   ; y pos,x zero
040D4F             0552*   ; angle is 128 (180)
040D4F 21 00 80 00 0553*       ld hl,128*256
040D53 C9          0554*       ret
040D54             0555*   @y_pos_x_pos:
040D54             0556*   ; y pos,x pos
040D54             0557*   ; angle is 64 to 128 (90 to 180)
040D54             0558*   ; neg the intermediate and add 180 degrees
040D54 CD 80 04 04 0559*       call neg_hlu
040D58 11 00 80 00 0560*       ld de,128*256
040D5C 19          0561*       add hl,de
040D5D 18 0B       0562*       jr @zero_hlu
040D5F             0563*   
040D5F             0564*   @y_zero:
040D5F F1          0565*       pop af ; sign of x
040D60 FA 65 0D 04 0566*       jp m,@y_zero_x_neg
040D64             0567*   ; y zero,x pos
040D64             0568*   ; angle is 64 (90),nothing to do
040D64 C9          0569*       ret
040D65             0570*   @y_zero_x_neg:
040D65             0571*   ; y zero ,x neg
040D65             0572*   ; angle is 192 (270)
040D65 21 00 C0 00 0573*       ld hl,192*256
040D69 C9          0574*       ret
040D6A             0575*   @zero_hlu:
040D6A AF          0576*       xor a
040D6B 22 78 0D 04 0577*       ld (@scratch),hl
040D6F 32 7A 0D 04 0578*       ld (@scratch+2),a
040D73 2A 78 0D 04 0579*       ld hl,(@scratch)
040D77 C9          0580*       ret
040D78             0581*   @scratch: ds 6
040D7E             0582*   
040D7E             0583*   ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040D7E             0584*   ; output: uh.l is the 16.8 fixed format angle in degrees 256
040D7E             0585*   ; destroys: a,hl,bc,de
040D7E             0586*   ; note: only works for angles from 0 to 32 (45) degrees
040D7E             0587*   ;   use atan2_168fast (which calls this proc) to handle the full 256 (360) degrees
040D7E             0588*   atan_168fast:
040D7E             0589*   ; because we use compass headings instead of geometric angles
040D7E             0590*   ; we compute dx/dy which is 1/tan(theta) in the maths world
040D7E             0591*   ; we can do faster unsigned division here because we know dx and dy are positive
       FF FF FF FF 
       FF FF 
040D7E CD 39 0B 04 0592*       call udiv168 ; ud.e = dx/dy
040D82 EB          0593*       ex de,hl ; uh.l = dx/dy
040D83             0594*   ; test uh.l for 0
040D83 19          0595*       add hl,de
040D84 B7          0596*       or a
040D85 ED 52       0597*       sbc hl,de
040D87 28 22       0598*       jr z,@is_zero
040D89             0599*   ; test uh.l for 1
040D89 AF          0600*       xor a ; clear carry
040D8A EB          0601*       ex de,hl
040D8B 21 00 01 00 0602*       ld hl,1*256 ; 1 in 16.8 fixed format
040D8F ED 52       0603*       sbc hl,de
040D91 28 13       0604*       jr z,@is_45
040D93 EB          0605*       ex de,hl
040D94             0606*   ; no special cases so we move on
040D94             0607*   ; l contains the fractional portion of tan(uh.l)
040D94             0608*   ; we multiply it by three to get our lookup table index
040D94 26 03       0609*       ld h,3
040D96 ED 6C       0610*       mlt hl ; index into lut
040D98 11 00 00 00 0611*       ld de,0 ; clear deu
040D9C 54          0612*       ld d,h ; copy hl to de
040D9D 5D          0613*       ld e,l ; de contains our index
040D9E 21 A3 11 04 0614*       ld hl,atan_lut_168 ; grab the lut address
040DA2 19          0615*       add hl,de ; bump hl by the index
040DA3 ED 27       0616*       ld hl,(hl) ; don't try this on a z80!
040DA5 C9          0617*       ret ; and out
040DA6             0618*   @is_45:
040DA6 21 00 20 00 0619*       ld hl,32*256
040DAA C9          0620*       ret
040DAB             0621*   ; for the case tan(0)
040DAB             0622*   @is_zero:
040DAB 21 00 00 00 0623*       ld hl,0*256
040DAF C9          0624*       ret
040DB0             0625*   
040DB0             0626*   ; Expects  ADL mode
040DB0             0627*   ; Inputs:  UH.L
040DB0             0628*   ; Outputs: UH.L is the 16.8 square root
040DB0             0629*   ;          UDE is the integer difference inputHL-DE^2
040DB0             0630*   sqrt168:
040DB0 CD BA 0D 04 0631*       call sqrt24
040DB4 EB          0632*       ex de,hl
040DB5 29          0633*       add hl,hl
040DB6 29          0634*       add hl,hl
040DB7 29          0635*       add hl,hl
040DB8 29          0636*       add hl,hl
040DB9 C9          0637*       ret
040DBA             0638*   
040DBA             0639*   ; credit: xeda112358
040DBA             0640*   ; https://www.cemetech.net/forum/viewtopic.php?t=11178&postdays=0&postorder=asc&start=0
040DBA             0641*   sqrt24:
040DBA             0642*   ; Expects ADL mode
040DBA             0643*   ; Inputs: HL
040DBA             0644*   ; Outputs: DE is the integer square root
040DBA             0645*   ;  HL is the difference inputHL-DE^2
040DBA             0646*   ;  c flag reset
040DBA 01 00 00 00 0647*       ld bc,0 ; clear bcu
040DBE 11 00 00 00 0648*       ld de,0 ; clear deu
040DC2 AF          0649*       xor a
040DC3 45          0650*       ld b,l
040DC4 C5          0651*       push bc
040DC5 47          0652*       ld b,a
040DC6 6F          0653*       ld l,a
040DC7             0654*   ; Iteration 1
040DC7 29          0655*       add hl,hl
040DC8 CB 11       0656*       rl c
040DCA 29          0657*       add hl,hl
040DCB CB 11       0658*       rl c
040DCD 91          0659*       sub c
040DCE 30 04       0660*       jr nc,$+6
040DD0 1C          0661*       inc e
040DD1 1C          0662*       inc e
040DD2 2F          0663*       cpl
040DD3 4F          0664*       ld c,a
040DD4             0665*   ; Iteration 2
040DD4 29          0666*       add hl,hl
040DD5 CB 11       0667*       rl c
040DD7 29          0668*       add hl,hl
040DD8 CB 11       0669*       rl c
040DDA CB 13       0670*       rl e
040DDC 7B          0671*       ld a,e
040DDD 91          0672*       sub c
040DDE 30 04       0673*       jr nc,$+6
040DE0 1C          0674*       inc e
040DE1 1C          0675*       inc e
040DE2 2F          0676*       cpl
040DE3 4F          0677*       ld c,a
040DE4             0678*   ; Iteration 3
040DE4 29          0679*       add hl,hl
040DE5 CB 11       0680*       rl c
040DE7 29          0681*       add hl,hl
040DE8 CB 11       0682*       rl c
040DEA CB 13       0683*       rl e
040DEC 7B          0684*       ld a,e
040DED 91          0685*       sub c
040DEE 30 04       0686*       jr nc,$+6
040DF0 1C          0687*       inc e
040DF1 1C          0688*       inc e
040DF2 2F          0689*       cpl
040DF3 4F          0690*       ld c,a
040DF4             0691*   ; Iteration 4
040DF4 29          0692*       add hl,hl
040DF5 CB 11       0693*       rl c
040DF7 29          0694*       add hl,hl
040DF8 CB 11       0695*       rl c
040DFA CB 13       0696*       rl e
040DFC 7B          0697*       ld a,e
040DFD 91          0698*       sub c
040DFE 30 04       0699*       jr nc,$+6
040E00 1C          0700*       inc e
040E01 1C          0701*       inc e
040E02 2F          0702*       cpl
040E03 4F          0703*       ld c,a
040E04             0704*   ; Iteration 5
040E04 29          0705*       add hl,hl
040E05 CB 11       0706*       rl c
040E07 29          0707*       add hl,hl
040E08 CB 11       0708*       rl c
040E0A CB 13       0709*       rl e
040E0C 7B          0710*       ld a,e
040E0D 91          0711*       sub c
040E0E 30 04       0712*       jr nc,$+6
040E10 1C          0713*       inc e
040E11 1C          0714*       inc e
040E12 2F          0715*       cpl
040E13 4F          0716*       ld c,a
040E14             0717*   ; Iteration 6
040E14 29          0718*       add hl,hl
040E15 CB 11       0719*       rl c
040E17 29          0720*       add hl,hl
040E18 CB 11       0721*       rl c
040E1A CB 13       0722*       rl e
040E1C 7B          0723*       ld a,e
040E1D 91          0724*       sub c
040E1E 30 04       0725*       jr nc,$+6
040E20 1C          0726*       inc e
040E21 1C          0727*       inc e
040E22 2F          0728*       cpl
040E23 4F          0729*       ld c,a
040E24             0730*   ; Iteration 7
040E24 29          0731*       add hl,hl
040E25 CB 11       0732*       rl c
040E27 29          0733*       add hl,hl
040E28 CB 11       0734*       rl c
040E2A CB 10       0735*       rl b
040E2C EB          0736*       ex de,hl
040E2D 29          0737*       add hl,hl
040E2E E5          0738*       push hl
040E2F ED 42       0739*       sbc hl,bc
040E31 30 06       0740*       jr nc,$+8
040E33 7C          0741*       ld a,h
040E34 2F          0742*       cpl
040E35 47          0743*       ld b,a
040E36 7D          0744*       ld a,l
040E37 2F          0745*       cpl
040E38 4F          0746*       ld c,a
040E39 E1          0747*       pop hl
040E3A 30 02       0748*       jr nc,$+4
040E3C 23          0749*       inc hl
040E3D 23          0750*       inc hl
040E3E EB          0751*       ex de,hl
040E3F             0752*   ; Iteration 8
040E3F 29          0753*       add hl,hl
040E40 69          0754*       ld l,c
040E41 60          0755*       ld h,b
040E42 ED 6A       0756*       adc hl,hl
040E44 ED 6A       0757*       adc hl,hl
040E46 EB          0758*       ex de,hl
040E47 29          0759*       add hl,hl
040E48 ED 52       0760*       sbc hl,de
040E4A 19          0761*       add hl,de
040E4B EB          0762*       ex de,hl
040E4C 30 04       0763*       jr nc,$+6
040E4E ED 52       0764*       sbc hl,de
040E50 13          0765*       inc de
040E51 13          0766*       inc de
040E52             0767*   ; Iteration 9
040E52 F1          0768*       pop af
040E53 17          0769*       rla
040E54 ED 6A       0770*       adc hl,hl
040E56 17          0771*       rla
040E57 ED 6A       0772*       adc hl,hl
040E59 EB          0773*       ex de,hl
040E5A 29          0774*       add hl,hl
040E5B ED 52       0775*       sbc hl,de
040E5D 19          0776*       add hl,de
040E5E EB          0777*       ex de,hl
040E5F 30 04       0778*       jr nc,$+6
040E61 ED 52       0779*       sbc hl,de
040E63 13          0780*       inc de
040E64 13          0781*       inc de
040E65             0782*   ; Iteration 10
040E65 17          0783*       rla
040E66 ED 6A       0784*       adc hl,hl
040E68 17          0785*       rla
040E69 ED 6A       0786*       adc hl,hl
040E6B EB          0787*       ex de,hl
040E6C 29          0788*       add hl,hl
040E6D ED 52       0789*       sbc hl,de
040E6F 19          0790*       add hl,de
040E70 EB          0791*       ex de,hl
040E71 30 04       0792*       jr nc,$+6
040E73 ED 52       0793*       sbc hl,de
040E75 13          0794*       inc de
040E76 13          0795*       inc de
040E77             0796*   ; Iteration 11
040E77 17          0797*       rla
040E78 ED 6A       0798*       adc hl,hl
040E7A 17          0799*       rla
040E7B ED 6A       0800*       adc hl,hl
040E7D EB          0801*       ex de,hl
040E7E 29          0802*       add hl,hl
040E7F ED 52       0803*       sbc hl,de
040E81 19          0804*       add hl,de
040E82 EB          0805*       ex de,hl
040E83 30 04       0806*       jr nc,$+6
040E85 ED 52       0807*       sbc hl,de
040E87 13          0808*       inc de
040E88 13          0809*       inc de
040E89             0810*   ; Iteration 12
040E89 17          0811*       rla
040E8A ED 6A       0812*       adc hl,hl
040E8C 17          0813*       rla
040E8D ED 6A       0814*       adc hl,hl
040E8F EB          0815*       ex de,hl
040E90 29          0816*       add hl,hl
040E91 ED 52       0817*       sbc hl,de
040E93 19          0818*       add hl,de
040E94 EB          0819*       ex de,hl
040E95 30 04       0820*       jr nc,$+6
040E97 ED 52       0821*       sbc hl,de
040E99 13          0822*       inc de
040E9A 13          0823*       inc de
040E9B CB 1A       0824*       rr d
040E9D CB 1B       0825*       rr e
040E9F C9          0826*       ret
040EA0             0827*   
040EA0             0828*   sin_lut_168:
040EA0 00 00 00    0829*       dl 0x000000 ; 0.000 00, 0.000
040EA3 06 00 00    0830*       dl 0x000006 ; 1.406 01, 0.025
040EA6 0C 00 00    0831*       dl 0x00000C ; 2.813 02, 0.049
040EA9 12 00 00    0832*       dl 0x000012 ; 4.219 03, 0.074
040EAC 19 00 00    0833*       dl 0x000019 ; 5.625 04, 0.098
040EAF 1F 00 00    0834*       dl 0x00001F ; 7.031 05, 0.122
040EB2 25 00 00    0835*       dl 0x000025 ; 8.438 06, 0.147
040EB5 2B 00 00    0836*       dl 0x00002B ; 9.844 07, 0.171
040EB8 31 00 00    0837*       dl 0x000031 ; 11.250 08, 0.195
040EBB 38 00 00    0838*       dl 0x000038 ; 12.656 09, 0.219
040EBE 3E 00 00    0839*       dl 0x00003E ; 14.063 0A, 0.243
040EC1 44 00 00    0840*       dl 0x000044 ; 15.469 0B, 0.267
040EC4 4A 00 00    0841*       dl 0x00004A ; 16.875 0C, 0.290
040EC7 50 00 00    0842*       dl 0x000050 ; 18.281 0D, 0.314
040ECA 56 00 00    0843*       dl 0x000056 ; 19.688 0E, 0.337
040ECD 5C 00 00    0844*       dl 0x00005C ; 21.094 0F, 0.360
040ED0 61 00 00    0845*       dl 0x000061 ; 22.500 10, 0.383
040ED3 67 00 00    0846*       dl 0x000067 ; 23.906 11, 0.405
040ED6 6D 00 00    0847*       dl 0x00006D ; 25.313 12, 0.428
040ED9 73 00 00    0848*       dl 0x000073 ; 26.719 13, 0.450
040EDC 78 00 00    0849*       dl 0x000078 ; 28.125 14, 0.471
040EDF 7E 00 00    0850*       dl 0x00007E ; 29.531 15, 0.493
040EE2 83 00 00    0851*       dl 0x000083 ; 30.938 16, 0.514
040EE5 88 00 00    0852*       dl 0x000088 ; 32.344 17, 0.535
040EE8 8E 00 00    0853*       dl 0x00008E ; 33.750 18, 0.556
040EEB 93 00 00    0854*       dl 0x000093 ; 35.156 19, 0.576
040EEE 98 00 00    0855*       dl 0x000098 ; 36.563 1A, 0.596
040EF1 9D 00 00    0856*       dl 0x00009D ; 37.969 1B, 0.615
040EF4 A2 00 00    0857*       dl 0x0000A2 ; 39.375 1C, 0.634
040EF7 A7 00 00    0858*       dl 0x0000A7 ; 40.781 1D, 0.653
040EFA AB 00 00    0859*       dl 0x0000AB ; 42.188 1E, 0.672
040EFD B0 00 00    0860*       dl 0x0000B0 ; 43.594 1F, 0.690
040F00 B5 00 00    0861*       dl 0x0000B5 ; 45.000 20, 0.707
040F03 B9 00 00    0862*       dl 0x0000B9 ; 46.406 21, 0.724
040F06 BD 00 00    0863*       dl 0x0000BD ; 47.813 22, 0.741
040F09 C1 00 00    0864*       dl 0x0000C1 ; 49.219 23, 0.757
040F0C C5 00 00    0865*       dl 0x0000C5 ; 50.625 24, 0.773
040F0F C9 00 00    0866*       dl 0x0000C9 ; 52.031 25, 0.788
040F12 CD 00 00    0867*       dl 0x0000CD ; 53.438 26, 0.803
040F15 D1 00 00    0868*       dl 0x0000D1 ; 54.844 27, 0.818
040F18 D4 00 00    0869*       dl 0x0000D4 ; 56.250 28, 0.831
040F1B D8 00 00    0870*       dl 0x0000D8 ; 57.656 29, 0.845
040F1E DB 00 00    0871*       dl 0x0000DB ; 59.063 2A, 0.858
040F21 DE 00 00    0872*       dl 0x0000DE ; 60.469 2B, 0.870
040F24 E1 00 00    0873*       dl 0x0000E1 ; 61.875 2C, 0.882
040F27 E4 00 00    0874*       dl 0x0000E4 ; 63.281 2D, 0.893
040F2A E7 00 00    0875*       dl 0x0000E7 ; 64.688 2E, 0.904
040F2D EA 00 00    0876*       dl 0x0000EA ; 66.094 2F, 0.914
040F30 EC 00 00    0877*       dl 0x0000EC ; 67.500 30, 0.924
040F33 EE 00 00    0878*       dl 0x0000EE ; 68.906 31, 0.933
040F36 F1 00 00    0879*       dl 0x0000F1 ; 70.313 32, 0.942
040F39 F3 00 00    0880*       dl 0x0000F3 ; 71.719 33, 0.950
040F3C F4 00 00    0881*       dl 0x0000F4 ; 73.125 34, 0.957
040F3F F6 00 00    0882*       dl 0x0000F6 ; 74.531 35, 0.964
040F42 F8 00 00    0883*       dl 0x0000F8 ; 75.938 36, 0.970
040F45 F9 00 00    0884*       dl 0x0000F9 ; 77.344 37, 0.976
040F48 FB 00 00    0885*       dl 0x0000FB ; 78.750 38, 0.981
040F4B FC 00 00    0886*       dl 0x0000FC ; 80.156 39, 0.985
040F4E FD 00 00    0887*       dl 0x0000FD ; 81.563 3A, 0.989
040F51 FE 00 00    0888*       dl 0x0000FE ; 82.969 3B, 0.992
040F54 FE 00 00    0889*       dl 0x0000FE ; 84.375 3C, 0.995
040F57 FF 00 00    0890*       dl 0x0000FF ; 85.781 3D, 0.997
040F5A FF 00 00    0891*       dl 0x0000FF ; 87.188 3E, 0.999
040F5D FF 00 00    0892*       dl 0x0000FF ; 88.594 3F, 1.000
040F60 00 01 00    0893*       dl 0x000100 ; 90.000 40, 1.000
040F63 FF 00 00    0894*       dl 0x0000FF ; 91.406 41, 1.000
040F66 FF 00 00    0895*       dl 0x0000FF ; 92.813 42, 0.999
040F69 FF 00 00    0896*       dl 0x0000FF ; 94.219 43, 0.997
040F6C FE 00 00    0897*       dl 0x0000FE ; 95.625 44, 0.995
040F6F FE 00 00    0898*       dl 0x0000FE ; 97.031 45, 0.992
040F72 FD 00 00    0899*       dl 0x0000FD ; 98.438 46, 0.989
040F75 FC 00 00    0900*       dl 0x0000FC ; 99.844 47, 0.985
040F78 FB 00 00    0901*       dl 0x0000FB ; 101.250 48, 0.981
040F7B F9 00 00    0902*       dl 0x0000F9 ; 102.656 49, 0.976
040F7E F8 00 00    0903*       dl 0x0000F8 ; 104.063 4A, 0.970
040F81 F6 00 00    0904*       dl 0x0000F6 ; 105.469 4B, 0.964
040F84 F4 00 00    0905*       dl 0x0000F4 ; 106.875 4C, 0.957
040F87 F3 00 00    0906*       dl 0x0000F3 ; 108.281 4D, 0.950
040F8A F1 00 00    0907*       dl 0x0000F1 ; 109.688 4E, 0.942
040F8D EE 00 00    0908*       dl 0x0000EE ; 111.094 4F, 0.933
040F90 EC 00 00    0909*       dl 0x0000EC ; 112.500 50, 0.924
040F93 EA 00 00    0910*       dl 0x0000EA ; 113.906 51, 0.914
040F96 E7 00 00    0911*       dl 0x0000E7 ; 115.313 52, 0.904
040F99 E4 00 00    0912*       dl 0x0000E4 ; 116.719 53, 0.893
040F9C E1 00 00    0913*       dl 0x0000E1 ; 118.125 54, 0.882
040F9F DE 00 00    0914*       dl 0x0000DE ; 119.531 55, 0.870
040FA2 DB 00 00    0915*       dl 0x0000DB ; 120.938 56, 0.858
040FA5 D8 00 00    0916*       dl 0x0000D8 ; 122.344 57, 0.845
040FA8 D4 00 00    0917*       dl 0x0000D4 ; 123.750 58, 0.831
040FAB D1 00 00    0918*       dl 0x0000D1 ; 125.156 59, 0.818
040FAE CD 00 00    0919*       dl 0x0000CD ; 126.563 5A, 0.803
040FB1 C9 00 00    0920*       dl 0x0000C9 ; 127.969 5B, 0.788
040FB4 C5 00 00    0921*       dl 0x0000C5 ; 129.375 5C, 0.773
040FB7 C1 00 00    0922*       dl 0x0000C1 ; 130.781 5D, 0.757
040FBA BD 00 00    0923*       dl 0x0000BD ; 132.188 5E, 0.741
040FBD B9 00 00    0924*       dl 0x0000B9 ; 133.594 5F, 0.724
040FC0 B5 00 00    0925*       dl 0x0000B5 ; 135.000 60, 0.707
040FC3 B0 00 00    0926*       dl 0x0000B0 ; 136.406 61, 0.690
040FC6 AB 00 00    0927*       dl 0x0000AB ; 137.813 62, 0.672
040FC9 A7 00 00    0928*       dl 0x0000A7 ; 139.219 63, 0.653
040FCC A2 00 00    0929*       dl 0x0000A2 ; 140.625 64, 0.634
040FCF 9D 00 00    0930*       dl 0x00009D ; 142.031 65, 0.615
040FD2 98 00 00    0931*       dl 0x000098 ; 143.438 66, 0.596
040FD5 93 00 00    0932*       dl 0x000093 ; 144.844 67, 0.576
040FD8 8E 00 00    0933*       dl 0x00008E ; 146.250 68, 0.556
040FDB 88 00 00    0934*       dl 0x000088 ; 147.656 69, 0.535
040FDE 83 00 00    0935*       dl 0x000083 ; 149.063 6A, 0.514
040FE1 7E 00 00    0936*       dl 0x00007E ; 150.469 6B, 0.493
040FE4 78 00 00    0937*       dl 0x000078 ; 151.875 6C, 0.471
040FE7 73 00 00    0938*       dl 0x000073 ; 153.281 6D, 0.450
040FEA 6D 00 00    0939*       dl 0x00006D ; 154.688 6E, 0.428
040FED 67 00 00    0940*       dl 0x000067 ; 156.094 6F, 0.405
040FF0 61 00 00    0941*       dl 0x000061 ; 157.500 70, 0.383
040FF3 5C 00 00    0942*       dl 0x00005C ; 158.906 71, 0.360
040FF6 56 00 00    0943*       dl 0x000056 ; 160.313 72, 0.337
040FF9 50 00 00    0944*       dl 0x000050 ; 161.719 73, 0.314
040FFC 4A 00 00    0945*       dl 0x00004A ; 163.125 74, 0.290
040FFF 44 00 00    0946*       dl 0x000044 ; 164.531 75, 0.267
041002 3E 00 00    0947*       dl 0x00003E ; 165.938 76, 0.243
041005 38 00 00    0948*       dl 0x000038 ; 167.344 77, 0.219
041008 31 00 00    0949*       dl 0x000031 ; 168.750 78, 0.195
04100B 2B 00 00    0950*       dl 0x00002B ; 170.156 79, 0.171
04100E 25 00 00    0951*       dl 0x000025 ; 171.563 7A, 0.147
041011 1F 00 00    0952*       dl 0x00001F ; 172.969 7B, 0.122
041014 19 00 00    0953*       dl 0x000019 ; 174.375 7C, 0.098
041017 12 00 00    0954*       dl 0x000012 ; 175.781 7D, 0.074
04101A 0C 00 00    0955*       dl 0x00000C ; 177.188 7E, 0.049
04101D 06 00 00    0956*       dl 0x000006 ; 178.594 7F, 0.025
041020 00 00 00    0957*       dl 0x000000 ; 180.000 80, 0.000
041023 FA FF FF    0958*       dl 0xFFFFFA ; 181.406 81, -0.025
041026 F4 FF FF    0959*       dl 0xFFFFF4 ; 182.813 82, -0.049
041029 EE FF FF    0960*       dl 0xFFFFEE ; 184.219 83, -0.074
04102C E7 FF FF    0961*       dl 0xFFFFE7 ; 185.625 84, -0.098
04102F E1 FF FF    0962*       dl 0xFFFFE1 ; 187.031 85, -0.122
041032 DB FF FF    0963*       dl 0xFFFFDB ; 188.438 86, -0.147
041035 D5 FF FF    0964*       dl 0xFFFFD5 ; 189.844 87, -0.171
041038 CF FF FF    0965*       dl 0xFFFFCF ; 191.250 88, -0.195
04103B C8 FF FF    0966*       dl 0xFFFFC8 ; 192.656 89, -0.219
04103E C2 FF FF    0967*       dl 0xFFFFC2 ; 194.063 8A, -0.243
041041 BC FF FF    0968*       dl 0xFFFFBC ; 195.469 8B, -0.267
041044 B6 FF FF    0969*       dl 0xFFFFB6 ; 196.875 8C, -0.290
041047 B0 FF FF    0970*       dl 0xFFFFB0 ; 198.281 8D, -0.314
04104A AA FF FF    0971*       dl 0xFFFFAA ; 199.688 8E, -0.337
04104D A4 FF FF    0972*       dl 0xFFFFA4 ; 201.094 8F, -0.360
041050 9F FF FF    0973*       dl 0xFFFF9F ; 202.500 90, -0.383
041053 99 FF FF    0974*       dl 0xFFFF99 ; 203.906 91, -0.405
041056 93 FF FF    0975*       dl 0xFFFF93 ; 205.313 92, -0.428
041059 8D FF FF    0976*       dl 0xFFFF8D ; 206.719 93, -0.450
04105C 88 FF FF    0977*       dl 0xFFFF88 ; 208.125 94, -0.471
04105F 82 FF FF    0978*       dl 0xFFFF82 ; 209.531 95, -0.493
041062 7D FF FF    0979*       dl 0xFFFF7D ; 210.938 96, -0.514
041065 78 FF FF    0980*       dl 0xFFFF78 ; 212.344 97, -0.535
041068 72 FF FF    0981*       dl 0xFFFF72 ; 213.750 98, -0.556
04106B 6D FF FF    0982*       dl 0xFFFF6D ; 215.156 99, -0.576
04106E 68 FF FF    0983*       dl 0xFFFF68 ; 216.563 9A, -0.596
041071 63 FF FF    0984*       dl 0xFFFF63 ; 217.969 9B, -0.615
041074 5E FF FF    0985*       dl 0xFFFF5E ; 219.375 9C, -0.634
041077 59 FF FF    0986*       dl 0xFFFF59 ; 220.781 9D, -0.653
04107A 55 FF FF    0987*       dl 0xFFFF55 ; 222.188 9E, -0.672
04107D 50 FF FF    0988*       dl 0xFFFF50 ; 223.594 9F, -0.690
041080 4B FF FF    0989*       dl 0xFFFF4B ; 225.000 A0, -0.707
041083 47 FF FF    0990*       dl 0xFFFF47 ; 226.406 A1, -0.724
041086 43 FF FF    0991*       dl 0xFFFF43 ; 227.813 A2, -0.741
041089 3F FF FF    0992*       dl 0xFFFF3F ; 229.219 A3, -0.757
04108C 3B FF FF    0993*       dl 0xFFFF3B ; 230.625 A4, -0.773
04108F 37 FF FF    0994*       dl 0xFFFF37 ; 232.031 A5, -0.788
041092 33 FF FF    0995*       dl 0xFFFF33 ; 233.438 A6, -0.803
041095 2F FF FF    0996*       dl 0xFFFF2F ; 234.844 A7, -0.818
041098 2C FF FF    0997*       dl 0xFFFF2C ; 236.250 A8, -0.831
04109B 28 FF FF    0998*       dl 0xFFFF28 ; 237.656 A9, -0.845
04109E 25 FF FF    0999*       dl 0xFFFF25 ; 239.063 AA, -0.858
0410A1 22 FF FF    1000*       dl 0xFFFF22 ; 240.469 AB, -0.870
0410A4 1F FF FF    1001*       dl 0xFFFF1F ; 241.875 AC, -0.882
0410A7 1C FF FF    1002*       dl 0xFFFF1C ; 243.281 AD, -0.893
0410AA 19 FF FF    1003*       dl 0xFFFF19 ; 244.688 AE, -0.904
0410AD 16 FF FF    1004*       dl 0xFFFF16 ; 246.094 AF, -0.914
0410B0 14 FF FF    1005*       dl 0xFFFF14 ; 247.500 B0, -0.924
0410B3 12 FF FF    1006*       dl 0xFFFF12 ; 248.906 B1, -0.933
0410B6 0F FF FF    1007*       dl 0xFFFF0F ; 250.313 B2, -0.942
0410B9 0D FF FF    1008*       dl 0xFFFF0D ; 251.719 B3, -0.950
0410BC 0C FF FF    1009*       dl 0xFFFF0C ; 253.125 B4, -0.957
0410BF 0A FF FF    1010*       dl 0xFFFF0A ; 254.531 B5, -0.964
0410C2 08 FF FF    1011*       dl 0xFFFF08 ; 255.938 B6, -0.970
0410C5 07 FF FF    1012*       dl 0xFFFF07 ; 257.344 B7, -0.976
0410C8 05 FF FF    1013*       dl 0xFFFF05 ; 258.750 B8, -0.981
0410CB 04 FF FF    1014*       dl 0xFFFF04 ; 260.156 B9, -0.985
0410CE 03 FF FF    1015*       dl 0xFFFF03 ; 261.563 BA, -0.989
0410D1 02 FF FF    1016*       dl 0xFFFF02 ; 262.969 BB, -0.992
0410D4 02 FF FF    1017*       dl 0xFFFF02 ; 264.375 BC, -0.995
0410D7 01 FF FF    1018*       dl 0xFFFF01 ; 265.781 BD, -0.997
0410DA 01 FF FF    1019*       dl 0xFFFF01 ; 267.188 BE, -0.999
0410DD 01 FF FF    1020*       dl 0xFFFF01 ; 268.594 BF, -1.000
0410E0 00 FF FF    1021*       dl 0xFFFF00 ; 270.000 C0, -1.000
0410E3 01 FF FF    1022*       dl 0xFFFF01 ; 271.406 C1, -1.000
0410E6 01 FF FF    1023*       dl 0xFFFF01 ; 272.813 C2, -0.999
0410E9 01 FF FF    1024*       dl 0xFFFF01 ; 274.219 C3, -0.997
0410EC 02 FF FF    1025*       dl 0xFFFF02 ; 275.625 C4, -0.995
0410EF 02 FF FF    1026*       dl 0xFFFF02 ; 277.031 C5, -0.992
0410F2 03 FF FF    1027*       dl 0xFFFF03 ; 278.438 C6, -0.989
0410F5 04 FF FF    1028*       dl 0xFFFF04 ; 279.844 C7, -0.985
0410F8 05 FF FF    1029*       dl 0xFFFF05 ; 281.250 C8, -0.981
0410FB 07 FF FF    1030*       dl 0xFFFF07 ; 282.656 C9, -0.976
0410FE 08 FF FF    1031*       dl 0xFFFF08 ; 284.063 CA, -0.970
041101 0A FF FF    1032*       dl 0xFFFF0A ; 285.469 CB, -0.964
041104 0C FF FF    1033*       dl 0xFFFF0C ; 286.875 CC, -0.957
041107 0D FF FF    1034*       dl 0xFFFF0D ; 288.281 CD, -0.950
04110A 0F FF FF    1035*       dl 0xFFFF0F ; 289.688 CE, -0.942
04110D 12 FF FF    1036*       dl 0xFFFF12 ; 291.094 CF, -0.933
041110 14 FF FF    1037*       dl 0xFFFF14 ; 292.500 D0, -0.924
041113 16 FF FF    1038*       dl 0xFFFF16 ; 293.906 D1, -0.914
041116 19 FF FF    1039*       dl 0xFFFF19 ; 295.313 D2, -0.904
041119 1C FF FF    1040*       dl 0xFFFF1C ; 296.719 D3, -0.893
04111C 1F FF FF    1041*       dl 0xFFFF1F ; 298.125 D4, -0.882
04111F 22 FF FF    1042*       dl 0xFFFF22 ; 299.531 D5, -0.870
041122 25 FF FF    1043*       dl 0xFFFF25 ; 300.938 D6, -0.858
041125 28 FF FF    1044*       dl 0xFFFF28 ; 302.344 D7, -0.845
041128 2C FF FF    1045*       dl 0xFFFF2C ; 303.750 D8, -0.831
04112B 2F FF FF    1046*       dl 0xFFFF2F ; 305.156 D9, -0.818
04112E 33 FF FF    1047*       dl 0xFFFF33 ; 306.563 DA, -0.803
041131 37 FF FF    1048*       dl 0xFFFF37 ; 307.969 DB, -0.788
041134 3B FF FF    1049*       dl 0xFFFF3B ; 309.375 DC, -0.773
041137 3F FF FF    1050*       dl 0xFFFF3F ; 310.781 DD, -0.757
04113A 43 FF FF    1051*       dl 0xFFFF43 ; 312.188 DE, -0.741
04113D 47 FF FF    1052*       dl 0xFFFF47 ; 313.594 DF, -0.724
041140 4B FF FF    1053*       dl 0xFFFF4B ; 315.000 E0, -0.707
041143 50 FF FF    1054*       dl 0xFFFF50 ; 316.406 E1, -0.690
041146 55 FF FF    1055*       dl 0xFFFF55 ; 317.813 E2, -0.672
041149 59 FF FF    1056*       dl 0xFFFF59 ; 319.219 E3, -0.653
04114C 5E FF FF    1057*       dl 0xFFFF5E ; 320.625 E4, -0.634
04114F 63 FF FF    1058*       dl 0xFFFF63 ; 322.031 E5, -0.615
041152 68 FF FF    1059*       dl 0xFFFF68 ; 323.438 E6, -0.596
041155 6D FF FF    1060*       dl 0xFFFF6D ; 324.844 E7, -0.576
041158 72 FF FF    1061*       dl 0xFFFF72 ; 326.250 E8, -0.556
04115B 78 FF FF    1062*       dl 0xFFFF78 ; 327.656 E9, -0.535
04115E 7D FF FF    1063*       dl 0xFFFF7D ; 329.063 EA, -0.514
041161 82 FF FF    1064*       dl 0xFFFF82 ; 330.469 EB, -0.493
041164 88 FF FF    1065*       dl 0xFFFF88 ; 331.875 EC, -0.471
041167 8D FF FF    1066*       dl 0xFFFF8D ; 333.281 ED, -0.450
04116A 93 FF FF    1067*       dl 0xFFFF93 ; 334.688 EE, -0.428
04116D 99 FF FF    1068*       dl 0xFFFF99 ; 336.094 EF, -0.405
041170 9F FF FF    1069*       dl 0xFFFF9F ; 337.500 F0, -0.383
041173 A4 FF FF    1070*       dl 0xFFFFA4 ; 338.906 F1, -0.360
041176 AA FF FF    1071*       dl 0xFFFFAA ; 340.313 F2, -0.337
041179 B0 FF FF    1072*       dl 0xFFFFB0 ; 341.719 F3, -0.314
04117C B6 FF FF    1073*       dl 0xFFFFB6 ; 343.125 F4, -0.290
04117F BC FF FF    1074*       dl 0xFFFFBC ; 344.531 F5, -0.267
041182 C2 FF FF    1075*       dl 0xFFFFC2 ; 345.938 F6, -0.243
041185 C8 FF FF    1076*       dl 0xFFFFC8 ; 347.344 F7, -0.219
041188 CF FF FF    1077*       dl 0xFFFFCF ; 348.750 F8, -0.195
04118B D5 FF FF    1078*       dl 0xFFFFD5 ; 350.156 F9, -0.171
04118E DB FF FF    1079*       dl 0xFFFFDB ; 351.563 FA, -0.147
041191 E1 FF FF    1080*       dl 0xFFFFE1 ; 352.969 FB, -0.122
041194 E7 FF FF    1081*       dl 0xFFFFE7 ; 354.375 FC, -0.098
041197 EE FF FF    1082*       dl 0xFFFFEE ; 355.781 FD, -0.074
04119A F4 FF FF    1083*       dl 0xFFFFF4 ; 357.188 FE, -0.049
04119D FA FF FF    1084*       dl 0xFFFFFA ; 358.594 FF, -0.025
0411A0 00 00 00    1085*       dl 0x000000 ; 0.000 00, 0.000 for interpolation
0411A3             1086*   
0411A3             1087*   atan_lut_168:
0411A3 00 00 00    1088*       dl 0x000000 ; 000000, 0.000
0411A6 28 00 00    1089*       dl 0x000028 ; 000001, 0.224
0411A9 51 00 00    1090*       dl 0x000051 ; 000002, 0.448
0411AC 7A 00 00    1091*       dl 0x00007A ; 000003, 0.671
0411AF A2 00 00    1092*       dl 0x0000A2 ; 000004, 0.895
0411B2 CB 00 00    1093*       dl 0x0000CB ; 000005, 1.119
0411B5 F4 00 00    1094*       dl 0x0000F4 ; 000006, 1.343
0411B8 1D 01 00    1095*       dl 0x00011D ; 000007, 1.566
0411BB 45 01 00    1096*       dl 0x000145 ; 000008, 1.790
0411BE 6E 01 00    1097*       dl 0x00016E ; 000009, 2.013
0411C1 97 01 00    1098*       dl 0x000197 ; 00000A, 2.237
0411C4 BF 01 00    1099*       dl 0x0001BF ; 00000B, 2.460
0411C7 E8 01 00    1100*       dl 0x0001E8 ; 00000C, 2.684
0411CA 11 02 00    1101*       dl 0x000211 ; 00000D, 2.907
0411CD 39 02 00    1102*       dl 0x000239 ; 00000E, 3.130
0411D0 62 02 00    1103*       dl 0x000262 ; 00000F, 3.353
0411D3 8B 02 00    1104*       dl 0x00028B ; 000010, 3.576
0411D6 B3 02 00    1105*       dl 0x0002B3 ; 000011, 3.799
0411D9 DC 02 00    1106*       dl 0x0002DC ; 000012, 4.022
0411DC 04 03 00    1107*       dl 0x000304 ; 000013, 4.245
0411DF 2D 03 00    1108*       dl 0x00032D ; 000014, 4.467
0411E2 55 03 00    1109*       dl 0x000355 ; 000015, 4.690
0411E5 7E 03 00    1110*       dl 0x00037E ; 000016, 4.912
0411E8 A6 03 00    1111*       dl 0x0003A6 ; 000017, 5.134
0411EB CE 03 00    1112*       dl 0x0003CE ; 000018, 5.356
0411EE F7 03 00    1113*       dl 0x0003F7 ; 000019, 5.578
0411F1 1F 04 00    1114*       dl 0x00041F ; 00001A, 5.799
0411F4 48 04 00    1115*       dl 0x000448 ; 00001B, 6.021
0411F7 70 04 00    1116*       dl 0x000470 ; 00001C, 6.242
0411FA 98 04 00    1117*       dl 0x000498 ; 00001D, 6.463
0411FD C0 04 00    1118*       dl 0x0004C0 ; 00001E, 6.684
041200 E8 04 00    1119*       dl 0x0004E8 ; 00001F, 6.905
041203 11 05 00    1120*       dl 0x000511 ; 000020, 7.125
041206 39 05 00    1121*       dl 0x000539 ; 000021, 7.345
041209 61 05 00    1122*       dl 0x000561 ; 000022, 7.565
04120C 89 05 00    1123*       dl 0x000589 ; 000023, 7.785
04120F B1 05 00    1124*       dl 0x0005B1 ; 000024, 8.005
041212 D9 05 00    1125*       dl 0x0005D9 ; 000025, 8.224
041215 01 06 00    1126*       dl 0x000601 ; 000026, 8.443
041218 28 06 00    1127*       dl 0x000628 ; 000027, 8.662
04121B 50 06 00    1128*       dl 0x000650 ; 000028, 8.881
04121E 78 06 00    1129*       dl 0x000678 ; 000029, 9.099
041221 A0 06 00    1130*       dl 0x0006A0 ; 00002A, 9.317
041224 C7 06 00    1131*       dl 0x0006C7 ; 00002B, 9.535
041227 EF 06 00    1132*       dl 0x0006EF ; 00002C, 9.752
04122A 16 07 00    1133*       dl 0x000716 ; 00002D, 9.970
04122D 3E 07 00    1134*       dl 0x00073E ; 00002E, 10.187
041230 65 07 00    1135*       dl 0x000765 ; 00002F, 10.403
041233 8D 07 00    1136*       dl 0x00078D ; 000030, 10.620
041236 B4 07 00    1137*       dl 0x0007B4 ; 000031, 10.836
041239 DB 07 00    1138*       dl 0x0007DB ; 000032, 11.051
04123C 03 08 00    1139*       dl 0x000803 ; 000033, 11.267
04123F 2A 08 00    1140*       dl 0x00082A ; 000034, 11.482
041242 51 08 00    1141*       dl 0x000851 ; 000035, 11.697
041245 78 08 00    1142*       dl 0x000878 ; 000036, 11.911
041248 9F 08 00    1143*       dl 0x00089F ; 000037, 12.125
04124B C6 08 00    1144*       dl 0x0008C6 ; 000038, 12.339
04124E ED 08 00    1145*       dl 0x0008ED ; 000039, 12.553
041251 13 09 00    1146*       dl 0x000913 ; 00003A, 12.766
041254 3A 09 00    1147*       dl 0x00093A ; 00003B, 12.978
041257 61 09 00    1148*       dl 0x000961 ; 00003C, 13.191
04125A 87 09 00    1149*       dl 0x000987 ; 00003D, 13.403
04125D AE 09 00    1150*       dl 0x0009AE ; 00003E, 13.614
041260 D4 09 00    1151*       dl 0x0009D4 ; 00003F, 13.825
041263 FB 09 00    1152*       dl 0x0009FB ; 000040, 14.036
041266 21 0A 00    1153*       dl 0x000A21 ; 000041, 14.247
041269 47 0A 00    1154*       dl 0x000A47 ; 000042, 14.457
04126C 6D 0A 00    1155*       dl 0x000A6D ; 000043, 14.666
04126F 94 0A 00    1156*       dl 0x000A94 ; 000044, 14.876
041272 BA 0A 00    1157*       dl 0x000ABA ; 000045, 15.085
041275 E0 0A 00    1158*       dl 0x000AE0 ; 000046, 15.293
041278 05 0B 00    1159*       dl 0x000B05 ; 000047, 15.501
04127B 2B 0B 00    1160*       dl 0x000B2B ; 000048, 15.709
04127E 51 0B 00    1161*       dl 0x000B51 ; 000049, 15.916
041281 77 0B 00    1162*       dl 0x000B77 ; 00004A, 16.123
041284 9C 0B 00    1163*       dl 0x000B9C ; 00004B, 16.329
041287 C2 0B 00    1164*       dl 0x000BC2 ; 00004C, 16.535
04128A E7 0B 00    1165*       dl 0x000BE7 ; 00004D, 16.740
04128D 0C 0C 00    1166*       dl 0x000C0C ; 00004E, 16.945
041290 32 0C 00    1167*       dl 0x000C32 ; 00004F, 17.150
041293 57 0C 00    1168*       dl 0x000C57 ; 000050, 17.354
041296 7C 0C 00    1169*       dl 0x000C7C ; 000051, 17.558
041299 A1 0C 00    1170*       dl 0x000CA1 ; 000052, 17.761
04129C C6 0C 00    1171*       dl 0x000CC6 ; 000053, 17.964
04129F EB 0C 00    1172*       dl 0x000CEB ; 000054, 18.166
0412A2 0F 0D 00    1173*       dl 0x000D0F ; 000055, 18.368
0412A5 34 0D 00    1174*       dl 0x000D34 ; 000056, 18.569
0412A8 58 0D 00    1175*       dl 0x000D58 ; 000057, 18.770
0412AB 7D 0D 00    1176*       dl 0x000D7D ; 000058, 18.970
0412AE A1 0D 00    1177*       dl 0x000DA1 ; 000059, 19.170
0412B1 C6 0D 00    1178*       dl 0x000DC6 ; 00005A, 19.370
0412B4 EA 0D 00    1179*       dl 0x000DEA ; 00005B, 19.569
0412B7 0E 0E 00    1180*       dl 0x000E0E ; 00005C, 19.767
0412BA 32 0E 00    1181*       dl 0x000E32 ; 00005D, 19.965
0412BD 56 0E 00    1182*       dl 0x000E56 ; 00005E, 20.163
0412C0 7A 0E 00    1183*       dl 0x000E7A ; 00005F, 20.360
0412C3 9E 0E 00    1184*       dl 0x000E9E ; 000060, 20.556
0412C6 C1 0E 00    1185*       dl 0x000EC1 ; 000061, 20.752
0412C9 E5 0E 00    1186*       dl 0x000EE5 ; 000062, 20.947
0412CC 08 0F 00    1187*       dl 0x000F08 ; 000063, 21.142
0412CF 2C 0F 00    1188*       dl 0x000F2C ; 000064, 21.337
0412D2 4F 0F 00    1189*       dl 0x000F4F ; 000065, 21.531
0412D5 72 0F 00    1190*       dl 0x000F72 ; 000066, 21.724
0412D8 95 0F 00    1191*       dl 0x000F95 ; 000067, 21.917
0412DB B8 0F 00    1192*       dl 0x000FB8 ; 000068, 22.109
0412DE DB 0F 00    1193*       dl 0x000FDB ; 000069, 22.301
0412E1 FE 0F 00    1194*       dl 0x000FFE ; 00006A, 22.493
0412E4 21 10 00    1195*       dl 0x001021 ; 00006B, 22.683
0412E7 44 10 00    1196*       dl 0x001044 ; 00006C, 22.874
0412EA 66 10 00    1197*       dl 0x001066 ; 00006D, 23.063
0412ED 89 10 00    1198*       dl 0x001089 ; 00006E, 23.253
0412F0 AB 10 00    1199*       dl 0x0010AB ; 00006F, 23.441
0412F3 CD 10 00    1200*       dl 0x0010CD ; 000070, 23.629
0412F6 EF 10 00    1201*       dl 0x0010EF ; 000071, 23.817
0412F9 11 11 00    1202*       dl 0x001111 ; 000072, 24.004
0412FC 33 11 00    1203*       dl 0x001133 ; 000073, 24.191
0412FF 55 11 00    1204*       dl 0x001155 ; 000074, 24.376
041302 77 11 00    1205*       dl 0x001177 ; 000075, 24.562
041305 99 11 00    1206*       dl 0x001199 ; 000076, 24.747
041308 BA 11 00    1207*       dl 0x0011BA ; 000077, 24.931
04130B DC 11 00    1208*       dl 0x0011DC ; 000078, 25.115
04130E FD 11 00    1209*       dl 0x0011FD ; 000079, 25.298
041311 1E 12 00    1210*       dl 0x00121E ; 00007A, 25.481
041314 3F 12 00    1211*       dl 0x00123F ; 00007B, 25.663
041317 60 12 00    1212*       dl 0x001260 ; 00007C, 25.844
04131A 81 12 00    1213*       dl 0x001281 ; 00007D, 26.025
04131D A2 12 00    1214*       dl 0x0012A2 ; 00007E, 26.206
041320 C3 12 00    1215*       dl 0x0012C3 ; 00007F, 26.386
041323 E4 12 00    1216*       dl 0x0012E4 ; 000080, 26.565
041326 04 13 00    1217*       dl 0x001304 ; 000081, 26.744
041329 25 13 00    1218*       dl 0x001325 ; 000082, 26.922
04132C 45 13 00    1219*       dl 0x001345 ; 000083, 27.100
04132F 65 13 00    1220*       dl 0x001365 ; 000084, 27.277
041332 85 13 00    1221*       dl 0x001385 ; 000085, 27.453
041335 A5 13 00    1222*       dl 0x0013A5 ; 000086, 27.629
041338 C5 13 00    1223*       dl 0x0013C5 ; 000087, 27.805
04133B E5 13 00    1224*       dl 0x0013E5 ; 000088, 27.979
04133E 05 14 00    1225*       dl 0x001405 ; 000089, 28.154
041341 24 14 00    1226*       dl 0x001424 ; 00008A, 28.327
041344 44 14 00    1227*       dl 0x001444 ; 00008B, 28.501
041347 63 14 00    1228*       dl 0x001463 ; 00008C, 28.673
04134A 83 14 00    1229*       dl 0x001483 ; 00008D, 28.845
04134D A2 14 00    1230*       dl 0x0014A2 ; 00008E, 29.017
041350 C1 14 00    1231*       dl 0x0014C1 ; 00008F, 29.187
041353 E0 14 00    1232*       dl 0x0014E0 ; 000090, 29.358
041356 FF 14 00    1233*       dl 0x0014FF ; 000091, 29.527
041359 1E 15 00    1234*       dl 0x00151E ; 000092, 29.697
04135C 3C 15 00    1235*       dl 0x00153C ; 000093, 29.865
04135F 5B 15 00    1236*       dl 0x00155B ; 000094, 30.033
041362 79 15 00    1237*       dl 0x001579 ; 000095, 30.201
041365 98 15 00    1238*       dl 0x001598 ; 000096, 30.368
041368 B6 15 00    1239*       dl 0x0015B6 ; 000097, 30.534
04136B D4 15 00    1240*       dl 0x0015D4 ; 000098, 30.700
04136E F2 15 00    1241*       dl 0x0015F2 ; 000099, 30.865
041371 10 16 00    1242*       dl 0x001610 ; 00009A, 31.030
041374 2E 16 00    1243*       dl 0x00162E ; 00009B, 31.194
041377 4C 16 00    1244*       dl 0x00164C ; 00009C, 31.357
04137A 6A 16 00    1245*       dl 0x00166A ; 00009D, 31.520
04137D 87 16 00    1246*       dl 0x001687 ; 00009E, 31.682
041380 A5 16 00    1247*       dl 0x0016A5 ; 00009F, 31.844
041383 C2 16 00    1248*       dl 0x0016C2 ; 0000A0, 32.005
041386 DF 16 00    1249*       dl 0x0016DF ; 0000A1, 32.166
041389 FC 16 00    1250*       dl 0x0016FC ; 0000A2, 32.326
04138C 19 17 00    1251*       dl 0x001719 ; 0000A3, 32.486
04138F 36 17 00    1252*       dl 0x001736 ; 0000A4, 32.645
041392 53 17 00    1253*       dl 0x001753 ; 0000A5, 32.803
041395 70 17 00    1254*       dl 0x001770 ; 0000A6, 32.961
041398 8C 17 00    1255*       dl 0x00178C ; 0000A7, 33.118
04139B A9 17 00    1256*       dl 0x0017A9 ; 0000A8, 33.275
04139E C5 17 00    1257*       dl 0x0017C5 ; 0000A9, 33.431
0413A1 E2 17 00    1258*       dl 0x0017E2 ; 0000AA, 33.587
0413A4 FE 17 00    1259*       dl 0x0017FE ; 0000AB, 33.742
0413A7 1A 18 00    1260*       dl 0x00181A ; 0000AC, 33.896
0413AA 36 18 00    1261*       dl 0x001836 ; 0000AD, 34.050
0413AD 52 18 00    1262*       dl 0x001852 ; 0000AE, 34.203
0413B0 6E 18 00    1263*       dl 0x00186E ; 0000AF, 34.356
0413B3 8A 18 00    1264*       dl 0x00188A ; 0000B0, 34.509
0413B6 A5 18 00    1265*       dl 0x0018A5 ; 0000B1, 34.660
0413B9 C1 18 00    1266*       dl 0x0018C1 ; 0000B2, 34.811
0413BC DC 18 00    1267*       dl 0x0018DC ; 0000B3, 34.962
0413BF F7 18 00    1268*       dl 0x0018F7 ; 0000B4, 35.112
0413C2 13 19 00    1269*       dl 0x001913 ; 0000B5, 35.262
0413C5 2E 19 00    1270*       dl 0x00192E ; 0000B6, 35.410
0413C8 49 19 00    1271*       dl 0x001949 ; 0000B7, 35.559
0413CB 64 19 00    1272*       dl 0x001964 ; 0000B8, 35.707
0413CE 7F 19 00    1273*       dl 0x00197F ; 0000B9, 35.854
0413D1 99 19 00    1274*       dl 0x001999 ; 0000BA, 36.001
0413D4 B4 19 00    1275*       dl 0x0019B4 ; 0000BB, 36.147
0413D7 CE 19 00    1276*       dl 0x0019CE ; 0000BC, 36.293
0413DA E9 19 00    1277*       dl 0x0019E9 ; 0000BD, 36.438
0413DD 03 1A 00    1278*       dl 0x001A03 ; 0000BE, 36.582
0413E0 1D 1A 00    1279*       dl 0x001A1D ; 0000BF, 36.726
0413E3 37 1A 00    1280*       dl 0x001A37 ; 0000C0, 36.870
0413E6 51 1A 00    1281*       dl 0x001A51 ; 0000C1, 37.013
0413E9 6B 1A 00    1282*       dl 0x001A6B ; 0000C2, 37.155
0413EC 85 1A 00    1283*       dl 0x001A85 ; 0000C3, 37.297
0413EF 9F 1A 00    1284*       dl 0x001A9F ; 0000C4, 37.439
0413F2 B9 1A 00    1285*       dl 0x001AB9 ; 0000C5, 37.579
0413F5 D2 1A 00    1286*       dl 0x001AD2 ; 0000C6, 37.720
0413F8 EC 1A 00    1287*       dl 0x001AEC ; 0000C7, 37.859
0413FB 05 1B 00    1288*       dl 0x001B05 ; 0000C8, 37.999
0413FE 1E 1B 00    1289*       dl 0x001B1E ; 0000C9, 38.137
041401 37 1B 00    1290*       dl 0x001B37 ; 0000CA, 38.276
041404 50 1B 00    1291*       dl 0x001B50 ; 0000CB, 38.413
041407 69 1B 00    1292*       dl 0x001B69 ; 0000CC, 38.550
04140A 82 1B 00    1293*       dl 0x001B82 ; 0000CD, 38.687
04140D 9B 1B 00    1294*       dl 0x001B9B ; 0000CE, 38.823
041410 B4 1B 00    1295*       dl 0x001BB4 ; 0000CF, 38.959
041413 CC 1B 00    1296*       dl 0x001BCC ; 0000D0, 39.094
041416 E5 1B 00    1297*       dl 0x001BE5 ; 0000D1, 39.228
041419 FD 1B 00    1298*       dl 0x001BFD ; 0000D2, 39.362
04141C 16 1C 00    1299*       dl 0x001C16 ; 0000D3, 39.496
04141F 2E 1C 00    1300*       dl 0x001C2E ; 0000D4, 39.629
041422 46 1C 00    1301*       dl 0x001C46 ; 0000D5, 39.762
041425 5E 1C 00    1302*       dl 0x001C5E ; 0000D6, 39.894
041428 76 1C 00    1303*       dl 0x001C76 ; 0000D7, 40.025
04142B 8E 1C 00    1304*       dl 0x001C8E ; 0000D8, 40.156
04142E A5 1C 00    1305*       dl 0x001CA5 ; 0000D9, 40.286
041431 BD 1C 00    1306*       dl 0x001CBD ; 0000DA, 40.416
041434 D5 1C 00    1307*       dl 0x001CD5 ; 0000DB, 40.546
041437 EC 1C 00    1308*       dl 0x001CEC ; 0000DC, 40.675
04143A 04 1D 00    1309*       dl 0x001D04 ; 0000DD, 40.803
04143D 1B 1D 00    1310*       dl 0x001D1B ; 0000DE, 40.931
041440 32 1D 00    1311*       dl 0x001D32 ; 0000DF, 41.059
041443 49 1D 00    1312*       dl 0x001D49 ; 0000E0, 41.186
041446 60 1D 00    1313*       dl 0x001D60 ; 0000E1, 41.312
041449 77 1D 00    1314*       dl 0x001D77 ; 0000E2, 41.438
04144C 8E 1D 00    1315*       dl 0x001D8E ; 0000E3, 41.564
04144F A5 1D 00    1316*       dl 0x001DA5 ; 0000E4, 41.689
041452 BB 1D 00    1317*       dl 0x001DBB ; 0000E5, 41.814
041455 D2 1D 00    1318*       dl 0x001DD2 ; 0000E6, 41.938
041458 E9 1D 00    1319*       dl 0x001DE9 ; 0000E7, 42.061
04145B FF 1D 00    1320*       dl 0x001DFF ; 0000E8, 42.184
04145E 15 1E 00    1321*       dl 0x001E15 ; 0000E9, 42.307
041461 2C 1E 00    1322*       dl 0x001E2C ; 0000EA, 42.429
041464 42 1E 00    1323*       dl 0x001E42 ; 0000EB, 42.551
041467 58 1E 00    1324*       dl 0x001E58 ; 0000EC, 42.672
04146A 6E 1E 00    1325*       dl 0x001E6E ; 0000ED, 42.793
04146D 84 1E 00    1326*       dl 0x001E84 ; 0000EE, 42.913
041470 99 1E 00    1327*       dl 0x001E99 ; 0000EF, 43.033
041473 AF 1E 00    1328*       dl 0x001EAF ; 0000F0, 43.152
041476 C5 1E 00    1329*       dl 0x001EC5 ; 0000F1, 43.271
041479 DA 1E 00    1330*       dl 0x001EDA ; 0000F2, 43.390
04147C F0 1E 00    1331*       dl 0x001EF0 ; 0000F3, 43.508
04147F 05 1F 00    1332*       dl 0x001F05 ; 0000F4, 43.625
041482 1B 1F 00    1333*       dl 0x001F1B ; 0000F5, 43.742
041485 30 1F 00    1334*       dl 0x001F30 ; 0000F6, 43.859
041488 45 1F 00    1335*       dl 0x001F45 ; 0000F7, 43.975
04148B 5A 1F 00    1336*       dl 0x001F5A ; 0000F8, 44.091
04148E 6F 1F 00    1337*       dl 0x001F6F ; 0000F9, 44.206
041491 84 1F 00    1338*       dl 0x001F84 ; 0000FA, 44.321
041494 99 1F 00    1339*       dl 0x001F99 ; 0000FB, 44.435
041497 AD 1F 00    1340*       dl 0x001FAD ; 0000FC, 44.549
04149A C2 1F 00    1341*       dl 0x001FC2 ; 0000FD, 44.662
04149D D7 1F 00    1342*       dl 0x001FD7 ; 0000FE, 44.775
0414A0 EB 1F 00    1343*       dl 0x001FEB ; 0000FF, 44.888
0414A3 00 20 00    1344*       dl 0x002000 ; 000100, 45.000 only needed for interpolation
0414A6             0038        include "timer.inc"
0414A6             0001*   ; Table 32. Timer Control Registers
0414A6             0002*   TMR0_CTL: equ 80h
0414A6             0003*   TMR1_CTL: equ 83h
0414A6             0004*   TMR2_CTL: equ 86h
0414A6             0005*   TMR3_CTL: equ 89h
0414A6             0006*   TMR4_CTL: equ 8Ch
0414A6             0007*   TMR5_CTL: equ 8Fh
0414A6             0008*   
0414A6             0009*   ; each timer register takes three bytes:
0414A6             0010*   ;   0: control register
0414A6             0011*   ;   1: low byte of timer reset value
0414A6             0012*   ;   2: high byte of timer reset value
0414A6             0013*   ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
0414A6             0014*   ; which correctly force the high and upper bytes of the address bus to zero
0414A6             0015*   
0414A6             0016*   TMR_REG_CTL: equ 0
0414A6             0017*   TMR_RES_LOW: equ 1
0414A6             0018*   TMR_RES_HIGH: equ 2
0414A6             0019*   
0414A6             0020*   ; Timer Control Register Bit Definitions
0414A6             0021*   PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
0414A6             0022*                               ; This bit is reset to 0 every time the TMRx_CTL register is read.
0414A6             0023*   PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
0414A6             0024*                               ; an interrupt signal is sent to the CPU. This bit remains 1 until
0414A6             0025*                               ; the TMRx_CTL register is read.
0414A6             0026*   
0414A6             0027*   IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
0414A6             0028*   IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
0414A6             0029*   
0414A6             0030*   PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
0414A6             0031*                               ;  0,and counting stops when the end-of-count value is reached.
0414A6             0032*   PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
0414A6             0033*                               ; written to the counter when the end-of-count value is reached.
0414A6             0034*   
0414A6             0035*   ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
0414A6             0036*   CLK_DIV_256:  equ %00001100 ;
0414A6             0037*   CLK_DIV_64:   equ %00001000 ;
0414A6             0038*   CLK_DIV_16:   equ %00000100 ;
0414A6             0039*   CLK_DIV_4:    equ %00000000 ;
0414A6             0040*   
0414A6             0041*   RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
0414A6             0042*   RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
0414A6             0043*                               ; When a 1 is written to this bit,the values in the reload registers
0414A6             0044*                               ;  are loaded into the downcounter when the timer restarts. The
0414A6             0045*                               ; programmer must ensure that this bit is set to 1 each time
0414A6             0046*                               ; SINGLE-PASS mode is used.
0414A6             0047*   
0414A6             0048*   ; disable/enable the programmable reload timer
0414A6             0049*   PRT_EN_0:     equ %00000000 ;
0414A6             0050*   PRT_EN_1:     equ %00000001 ;
0414A6             0051*   
0414A6             0052*   ; Table 37. Timer Input Source Select Register
0414A6             0053*   ; Each of the 4 timers are allocated two bits of the 8-bit register
0414A6             0054*   ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
0414A6             0055*   ;   00: System clock / CLK_DIV
0414A6             0056*   ;   01: RTC / CLK_DIV
0414A6             0057*   ;   NOTE: these are the values given in the manual,but it may be a typo
0414A6             0058*   ;   10: GPIO port B pin 1.
0414A6             0059*   ;   11: GPIO port B pin 1.
0414A6             0060*   TMR_ISS:   equ 92h ; register address
0414A6             0061*   
0414A6             0062*   ; Table 51. Real-Time Clock Control Register
0414A6             0063*   RTC_CTRL: equ EDh ; register address
0414A6             0064*   
0414A6             0065*   ; alarm interrupt disable/enable
0414A6             0066*   RTC_ALARM_0:    equ %00000000
0414A6             0067*   RTC_ALARM_1:    equ %10000000
0414A6             0068*   
0414A6             0069*   ; interrupt on alarm disable/enable
0414A6             0070*   RTC_INT_ENT_0:  equ %00000000
0414A6             0071*   RTC_INT_ENT_1:  equ %01000000
0414A6             0072*   
0414A6             0073*   RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
0414A6             0074*   RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
0414A6             0075*   
0414A6             0076*   RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
0414A6             0077*                                   ; On-chip 32768 Hz oscillator is enabled.
0414A6             0078*   RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
0414A6             0079*                                   ; On-chip 32768 Hz oscillator is disabled.
0414A6             0080*   
0414A6             0081*   RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
0414A6             0082*   RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
0414A6             0083*   
0414A6             0084*   RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
0414A6             0085*   RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
0414A6             0086*   
0414A6             0087*   RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
0414A6             0088*                                   ; RTC counter is enabled.
0414A6             0089*   RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
0414A6             0090*                                   ; RTC counter is disabled.
0414A6             0091*   
0414A6             0092*   ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
0414A6             0093*   
0414A6             0094*   prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
0414A6             0095*   prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
0414A6 00 00 00    0096*   prt_reload: dl 0x000000
0414A9             0097*   
0414A9             0098*   ; returns: a = 0 if running on hardware,1 if running on emulator
0414A9             0099*   ;          de = number PRT interrupts during test interval
0414A9             0100*   prt_calibrate:
0414A9 CD 78 17 04 0101*       call vdu_vblank
0414AD             0102*   ; set a MOS timer
0414AD 21 78 00 00 0103*       ld hl,120*1 ; 1 second
0414B1 FD 21 31 16 0104*       ld iy,tmr_test
       04          
0414B6 CD 0F 16 04 0105*       call tmr_set
0414BA             0106*   ; set a PRT timer
0414BA             0107*       ; ld hl,prt_reload_hardware
0414BA             0108*       ; ld hl,prt_reload_emulator
0414BA 21 05 2D 00 0109*       ld hl,prt_reload_emulator + prt_reload_hardware / 2
0414BE 22 A6 14 04 0110*       ld (prt_reload),hl
0414C2 CD 4A 15 04 0111*       call prt_set
0414C6             0112*   @loop:
0414C6             0113*   ; check time remaining on MOS timer
0414C6 CD 1D 16 04 0114*       call tmr_get
0414CA CA D4 14 04 0115*       jp z,@done ; time expired,so quit
0414CE FA D4 14 04 0116*       jp m,@done ; time past expiration (negative),so quit
0414D2 18 F2       0117*       jr @loop
0414D4             0118*   @done:
0414D4 ED 5B 98 15 0119*       ld de,(prt_irq_counter)
       04          
0414D9 01 0C 2D 00 0120*       ld bc,prt_reload_hardware ; default value for running on hardware
0414DD ED 43 A6 14 0121*       ld (prt_reload),bc
       04          
0414E2 21 64 00 00 0122*       ld hl,100 ; halfway between 101 for real hardware and 99 for emulator
0414E6 AF          0123*       xor a ; clear carry,zero is default value for running on hardware
0414E7 32 09 15 04 0124*       ld (is_emulator),a
0414EB ED 52       0125*       sbc hl,de
0414ED 21 0A 15 04 0126*       ld hl,on_hardware ; default message for running on hardware
0414F1 CA A9 14 04 0127*       jp z,prt_calibrate ; zero result is indeterminate so we try again
0414F5 F8          0128*       ret m ; negative result means we're on hardware
0414F6 3C          0129*       inc a ; we're on emulator
0414F7 32 09 15 04 0130*       ld (is_emulator),a
0414FB 01 FF 2C 00 0131*       ld bc,prt_reload_emulator
0414FF ED 43 A6 14 0132*       ld (prt_reload),bc
       04          
041504 21 20 15 04 0133*       ld hl,on_emulator
041508 C9          0134*       ret
041509 00          0135*   is_emulator: db 0
04150A 52 75 6E 6E 0136*   on_hardware: defb "Running on hardware\r\n",0
       69 6E 67 20 
       6F 6E 20 68 
       61 72 64 77 
       61 72 65 0D 
       0A 00       
041520 52 75 6E 6E 0137*   on_emulator: defb "Running on emulator\r\n",0
       69 6E 67 20 
       6F 6E 20 65 
       6D 75 6C 61 
       74 6F 72 0D 
       0A 00       
041536             0138*   
041536 43 61 6C 69 0139*   calibrating_timer: defb "Calibrating timer\r\n",0
       62 72 61 74 
       69 6E 67 20 
       74 69 6D 65 
       72 0D 0A 00 
04154A             0140*   
04154A             0141*   ; set PRT timer
04154A             0142*   prt_set:
04154A 21 00 00 00 0143*       ld hl,0
04154E 22 98 15 04 0144*       ld (prt_irq_counter),hl
041552 2A A6 14 04 0145*       ld hl,(prt_reload)
041556 ED 29 84    0146*       out0 (TMR1_CTL+TMR_RES_LOW),l
041559 ED 21 85    0147*   	out0 (TMR1_CTL+TMR_RES_HIGH),h
04155C             0148*   ; disable timer
04155C 3E 06       0149*       ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
04155E ED 39 83    0150*   	out0 (TMR1_CTL+TMR_REG_CTL),a
041561             0151*   ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
041561 3E 57       0152*       ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
041563 ED 39 83    0153*   	out0 (TMR1_CTL+TMR_REG_CTL),a
041566 C9          0154*       ret
041567             0155*   
041567             0156*   ; ===============================================
041567             0157*   ; PRT Timer Interrupt Handling
041567             0158*   ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.asm
041567             0159*   ; -----------------------------------------------
041567             0160*   prt_irq_init:
041567             0161*       ; set up interrupt vector table 2
041567 21 00 00 00 0162*   	ld hl,0
04156B 3A 0C 01 00 0163*   	ld a,($10c)
04156F 6F          0164*   	ld l,a
041570 3A 0D 01 00 0165*   	ld a,($10d)
041574 67          0166*   	ld h,a
041575             0167*   
041575             0168*   	; skip over CALL ($c3)
041575 23          0169*   	inc hl
041576             0170*   	; load address of jump into vector table 2 (in ram)
041576 ED 27       0171*   	ld hl,(hl)
041578             0172*   
041578             0173*   	; write CALL prt_irq_handler to vector table 2
041578 3E C3       0174*   	ld a,$c3
04157A 77          0175*   	ld (hl),a
04157B 23          0176*   	inc hl
04157C 11 83 15 04 0177*   	ld de,prt_irq_handler
041580 ED 1F       0178*   	ld (hl),de
041582             0179*   
041582 C9          0180*       ret
041583             0181*   
041583             0182*   prt_irq_handler:
041583 F3          0183*   	di
041584 F5          0184*   	push af
041585 E5          0185*       push hl
041586 ED 38 83    0186*   	in0 a,(TMR1_CTL+TMR_REG_CTL)
041589 2A 98 15 04 0187*   	ld hl,(prt_irq_counter)
04158D 23          0188*   	inc hl
04158E 22 98 15 04 0189*   	ld (prt_irq_counter),hl
041592 E1          0190*       pop hl
041593 F1          0191*   	pop af
041594 FB          0192*   	ei
041595 5B ED 4D    0193*   	reti.l
041598             0194*   
041598             0195*   prt_irq_counter:
041598 00 00 00    0196*   	.dl 0
04159B             0197*   prt_irq_counter_saved:
04159B 00 00 00    0198*       .dl 0
04159E             0199*   
04159E             0200*   prt_loop_reset:
04159E E5          0201*       push hl
04159F 21 00 00 00 0202*   	ld hl,0
0415A3 22 98 15 04 0203*   	ld (prt_irq_counter),hl
0415A7 22 09 16 04 0204*       ld (prt_loop_counter),hl
0415AB 22 0C 16 04 0205*       ld (prt_loops),hl
0415AF CD 4A 15 04 0206*       call prt_set
0415B3 E1          0207*       pop hl
0415B4 C9          0208*       ret
0415B5             0209*   
0415B5             0210*   prt_loop_start:
0415B5 E5          0211*       push hl
0415B6 21 00 00 00 0212*   	ld hl,0
0415BA 22 98 15 04 0213*   	ld (prt_irq_counter),hl
0415BE E1          0214*       pop hl
0415BF C9          0215*       ret
0415C0             0216*   
0415C0             0217*   prt_loop_stop:
0415C0 E5          0218*       push hl
0415C1 D5          0219*       push de
0415C2 2A 98 15 04 0220*       ld hl,(prt_irq_counter)
0415C6 ED 5B 09 16 0221*       ld de,(prt_loop_counter)
       04          
0415CB 19          0222*       add hl,de
0415CC 22 09 16 04 0223*       ld (prt_loop_counter),hl
0415D0 21 00 00 00 0224*       ld hl,0
0415D4 22 98 15 04 0225*       ld (prt_irq_counter),hl
0415D8 2A 0C 16 04 0226*       ld hl,(prt_loops)
0415DC 23          0227*       inc hl
0415DD 22 0C 16 04 0228*       ld (prt_loops),hl
0415E1 D1          0229*       pop de
0415E2 E1          0230*       pop hl
0415E3 C9          0231*       ret
0415E4             0232*   
0415E4             0233*   ; inputs: bc = y,x text coordinates to print
0415E4             0234*   prt_loop_print:
0415E4 F5          0235*       push af
0415E5 E5          0236*       push hl
0415E6 C5          0237*       push bc
0415E7 D5          0238*       push de
0415E8 DD E5       0239*       push ix
0415EA FD E5       0240*       push iy
0415EC CD F0 16 04 0241*       call vdu_move_cursor
0415F0             0242*   
0415F0 2A 09 16 04 0243*       ld hl,(prt_loop_counter)
0415F4 CD CC 00 04 0244*       call printDec
0415F8             0245*   
0415F8 2A 0C 16 04 0246*       ld hl,(prt_loops)
0415FC CD CC 00 04 0247*       call printDec
041600             0248*   
041600 FD E1       0249*       pop iy
041602 DD E1       0250*       pop ix
041604 D1          0251*       pop de
041605 C1          0252*       pop bc
041606 E1          0253*       pop hl
041607 F1          0254*       pop af
041608 C9          0255*       ret
041609             0256*   
041609             0257*   prt_loop_counter:
041609 00 00 00    0258*       .dl 0
04160C             0259*   prt_loops:
04160C 00 00 00    0260*       .dl 0
04160F             0261*   
04160F             0262*   ; ===============================================
04160F             0263*   ; Timer functions
04160F             0264*   ; -----------------------------------------------
04160F             0265*   ; set a countdown timer
04160F             0266*   ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
04160F             0267*   ; returns: hl = current time
04160F             0268*   tmr_set:
04160F FD 2F 03    0269*       ld (iy+3),hl            ; set time remaining
041612             0270*       MOSCALL mos_sysvars     ; ix points to syvars table
                       M1 Args: function=mos_sysvars 
041612 3E 08       0001*M1 			LD	A, function
041614 5B CF       0002*M1 			RST.LIL	08h
041616 DD 27 00    0271*       ld hl,(ix+sysvar_time)  ; get current time
041619 FD 2F 00    0272*       ld (iy+0),hl            ; set start time
04161C C9          0273*       ret
04161D             0274*   
04161D             0275*   ; gets time remaining on a countdown timer
04161D             0276*   ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
04161D             0277*   ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
04161D             0278*   ;          sign flags: pos = time not expired,zero or neg = time expired
04161D             0279*   tmr_get:
04161D             0280*       MOSCALL mos_sysvars     ; ix points to syvars table
                       M1 Args: function=mos_sysvars 
04161D 3E 08       0001*M1 			LD	A, function
04161F 5B CF       0002*M1 			RST.LIL	08h
041621 DD 17 00    0281*       ld de,(ix+sysvar_time)  ; get current time
041624 FD 27 00    0282*       ld hl,(iy+0)            ; get start time
041627 AF          0283*       xor a                   ; clear carry
041628 ED 52       0284*       sbc hl,de               ; hl = time elapsed (will always be zero or negative)
04162A FD 17 03    0285*       ld de,(iy+3)            ; get timer set value
04162D AF          0286*       xor a                   ; clear carry
04162E ED 5A       0287*       adc hl,de               ; hl = time remaining
041630             0288*                               ; (we do adc because add hl,rr doesn't set sign or zero flags)
041630 C9          0289*       ret
041631             0290*   
041631             0291*   tmr_test: ds 6 ; example of a buffer to hold timer data
041637             0292*   
       FF FF FF FF 
       FF FF 
041637 00 00 00    0293*   timestamp_now: dl 0
04163A 00 00 00    0294*   timestamp_old: dl 0
04163D 00 00 00    0295*   timestamp_chg: dl 0
041640             0296*   
041640             0297*   ; update the global timestamp from the system clock
041640             0298*   ; inputs: none
041640             0299*   ; returns: hl = time elapsed in 1/120ths of a second
041640             0300*   ;          de = current time
041640             0301*   ;          ix = pointer to syvars table
041640             0302*   ; destroys: af,hl,de,ix
041640             0303*   timestamp_tick:
041640 ED 5B 37 16 0304*       ld de,(timestamp_now)   ; get previous time
       04          
041645 ED 53 3A 16 0305*       ld (timestamp_old),de   ; save previous time
       04          
04164A             0306*       MOSCALL mos_sysvars     ; ix points to syvars table
                       M1 Args: function=mos_sysvars 
04164A 3E 08       0001*M1 			LD	A, function
04164C 5B CF       0002*M1 			RST.LIL	08h
04164E DD 27 00    0307*       ld hl,(ix+sysvar_time)  ; get current time
041651 22 37 16 04 0308*       ld (timestamp_now),hl   ; save current time
041655 AF          0309*       xor a                   ; clear carry
041656 ED 52       0310*       sbc hl,de               ; hl = time elapsed
041658 22 3D 16 04 0311*       ld (timestamp_chg),hl   ; save elapsed time
04165C C9          0312*       ret
04165D             0313*   
04165D             0314*   ; set a countdown timer
04165D             0315*   ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
04165D             0316*   ; requires: timestamp_tick to be called at least once before this function
04165D             0317*   ; returns: hl = current time
04165D             0318*   ; destroys: hl
04165D             0319*   timestamp_tmr_set:
04165D FD 2F 03    0320*       ld (iy+3),hl            ; set time remaining
041660 2A 37 16 04 0321*       ld hl,(timestamp_now)   ; get current timestamp
041664 FD 2F 00    0322*       ld (iy+0),hl            ; set start time
041667 C9          0323*       ret
041668             0324*   
041668             0325*   ; gets time remaining on a countdown timer following the global timestamp
041668             0326*   ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
041668             0327*   ; requires: timestamp_tick to be called at least once before this function
041668             0328*   ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
041668             0329*   ;          sign flags: pos = time not expired,zero or neg = time expired
041668             0330*   ; destroys: af,hl,de
041668             0331*   timestamp_tmr_get:
041668 ED 5B 37 16 0332*       ld de,(timestamp_now)   ; get current timestamp
       04          
04166D FD 27 00    0333*       ld hl,(iy+0)            ; get start time
041670 AF          0334*       xor a                   ; clear carry
041671 ED 52       0335*       sbc hl,de               ; hl = time elapsed (will always be zero or negative)
041673 FD 17 03    0336*       ld de,(iy+3)            ; get timer set value
041676 AF          0337*       xor a                   ; clear carry
041677 ED 5A       0338*       adc hl,de               ; hl = time remaining
041679             0339*                               ; (we do adc because add hl,rr doesn't set sign or zero flags)
041679 C9          0340*       ret
04167A             0341*   
04167A             0342*   ; set a stopwatch
04167A             0343*   ; returns: hl = start time
04167A             0344*   ; destroys: hl,ix
04167A             0345*   stopwatch_set:
04167A             0346*       MOSCALL mos_sysvars     ; ix points to syvars table
                       M1 Args: function=mos_sysvars 
04167A 3E 08       0001*M1 			LD	A, function
04167C 5B CF       0002*M1 			RST.LIL	08h
04167E DD 27 00    0347*       ld hl,(ix+sysvar_time)  ; get current time
041681 22 96 16 04 0348*       ld (stopwatch_started),hl            ; set start time
041685 C9          0349*       ret
041686             0350*   
041686             0351*   ; gets time elapsed on a stopwatch
041686             0352*   ; returns: hl = time elapsed in 1/120ths of a second
041686             0353*   ; destroys: af,hl,de,ix
041686             0354*   stopwatch_get:
041686             0355*       MOSCALL mos_sysvars     ; ix points to syvars table
                       M1 Args: function=mos_sysvars 
041686 3E 08       0001*M1 			LD	A, function
041688 5B CF       0002*M1 			RST.LIL	08h
04168A DD 27 00    0356*       ld hl,(ix+sysvar_time)  ; get current time
04168D ED 5B 96 16 0357*       ld de,(stopwatch_started)            ; get start time
       04          
041692 AF          0358*       xor a                   ; clear carry
041693 ED 52       0359*       sbc hl,de               ; hl = time elapsed (will always be zero or positive)
041695 C9          0360*       ret
041696             0361*   
041696             0362*   stopwatch_started: ds 3 ; buffer to hold stopwatch start time
041699             0363*   
041699             0364*   ; ------------------
041699             0365*   ; delay routine
041699             0366*   ; Author: Richard Turrnidge
041699             0367*   ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.asm
041699             0368*   ; routine waits a fixed time,then returns
041699             0369*   ; arrive with A =  the delay byte. One bit to be set only.
041699             0370*   ; eg. ld A,00000100b
041699             0371*   
041699             0372*   multiPurposeDelay:
       FF FF FF 
041699 F5          0373*       push af
04169A C5          0374*       push bc
04169B DD E5       0375*       push ix
04169D 47          0376*       ld b,a
04169E 3E 08       0377*       ld a,$08
0416A0 5B CF       0378*       RST.LIL	08h                 ; get IX pointer to sysvars
0416A2             0379*   
0416A2             0380*   waitLoop:
0416A2             0381*   
0416A2 DD 7E 00    0382*       ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
0416A5             0383*   
0416A5             0384*                                   ;   we check if bit set is same as last time we checked.
0416A5             0385*                                   ;   bit 0 - don't use
0416A5             0386*                                   ;   bit 1 - changes 64 times per second
0416A5             0387*                                   ;   bit 2 - changes 32 times per second
0416A5             0388*                                   ;   bit 3 - changes 16 times per second
0416A5             0389*   
0416A5             0390*                                   ;   bit 4 - changes 8 times per second
0416A5             0391*                                   ;   bit 5 - changes 4 times per second
0416A5             0392*                                   ;   bit 6 - changes 2 times per second
0416A5             0393*                                   ;   bit 7 - changes 1 times per second
0416A5 A0          0394*       and b
0416A6 4F          0395*       ld c,a
0416A7 3A B8 16 04 0396*       ld a,(oldTimeStamp)
0416AB B9          0397*       cp c                        ; is A same as last value?
0416AC 28 F4       0398*       jr z,waitLoop              ; loop here if it is
0416AE 79          0399*       ld a,c
0416AF 32 B8 16 04 0400*       ld (oldTimeStamp),a        ; set new value
0416B3             0401*   
0416B3 DD E1       0402*       pop ix
0416B5 C1          0403*       pop bc
0416B6 F1          0404*       pop af
0416B7 C9          0405*       ret
0416B8             0406*   
0416B8 00          0407*   oldTimeStamp:   .db 00h
0416B9             0039        include "vdu.inc"
0416B9             0001*   ; VDU 30: Home cursor
0416B9             0002*   vdu_home_cursor:
0416B9 3E 1E       0003*       ld a,30
0416BB 5B D7       0004*   	rst.lil $10
0416BD C9          0005*   	ret
0416BE             0006*   
0416BE             0007*   vdu_cursor_on:
0416BE 21 C9 16 04 0008*   	ld hl,@cmd
0416C2 01 03 00 00 0009*   	ld bc,@end-@cmd
0416C6 5B DF       0010*   	rst.lil $18
0416C8 C9          0011*   	ret
0416C9             0012*   @cmd:
0416C9 17 01 01    0013*   	db 23,1,1
0416CC             0014*   @end:
0416CC             0015*   
0416CC             0016*   vdu_cursor_off:
0416CC 21 D7 16 04 0017*   	ld hl,@cmd
0416D0 01 03 00 00 0018*   	ld bc,@end-@cmd
0416D4 5B DF       0019*   	rst.lil $18
0416D6 C9          0020*   	ret
0416D7             0021*   @cmd:
0416D7 17 01 00    0022*   	db 23,1,0
0416DA             0023*   @end:
0416DA             0024*   
0416DA             0025*   ; VDU 5: Write text at graphics cursor
0416DA             0026*   ; inputs: a is the character to write to the screen
0416DA             0027*   ; prerequisites: the graphics cursor at the intended position on screen
0416DA             0028*   ; outputs: see the name of the function
0416DA             0029*   ; destroys: a, hl, bc
0416DA             0030*   vdu_char_to_gfx_cursor:
0416DA 32 EA 16 04 0031*   	ld (@arg),a
0416DE 21 E9 16 04 0032*   	ld hl,@cmd
0416E2 01 02 00 00 0033*   	ld bc,@end-@cmd
0416E6 5B DF       0034*   	rst.lil $18
0416E8 C9          0035*   	ret
0416E9 05          0036*   @cmd: db 5
0416EA 00          0037*   @arg: db 0
0416EB             0038*   @end:
0416EB             0039*   ; VDU 9: Move cursor forward one character
0416EB             0040*   vdu_cursor_forward:
0416EB 3E 09       0041*       ld a,9
0416ED 5B D7       0042*   	rst.lil $10
0416EF C9          0043*   	ret
0416F0             0044*   
0416F0             0045*   ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
0416F0             0046*   ; inputs: c=x, b=y 8-bit unsigned integers
0416F0             0047*   vdu_move_cursor:
0416F0 ED 43 01 17 0048*       ld (@x0),bc
       04          
0416F5 21 00 17 04 0049*   	ld hl,@cmd
0416F9 01 03 00 00 0050*   	ld bc,@end-@cmd
0416FD 5B DF       0051*   	rst.lil $18
0416FF C9          0052*   	ret
041700 1F          0053*   @cmd: 	db 31
041701 00          0054*   @x0:	db 0
041702 00          0055*   @y0: 	db 0
041703 00          0056*   @end: 	db 0 ; padding
041704             0057*   
041704             0058*   ; VDU 12: Clear text area (CLS)
041704             0059*   vdu_cls:
041704 3E 0C       0060*       ld a,12
041706 5B D7       0061*   	rst.lil $10
041708 C9          0062*   	ret
041709             0063*   
041709             0064*   vdu_flip:
041709 21 14 17 04 0065*   	ld hl,@cmd
04170D 01 03 00 00 0066*   	ld bc,@end-@cmd
041711 5B DF       0067*   	rst.lil $18
041713 C9          0068*   	ret
041714 17 00 C3    0069*   @cmd: db 23,0,0xC3
041717             0070*   @end:
041717             0071*   
041717             0072*   ; VDU 16: Clear graphics area (CLG)
041717             0073*   vdu_clg:
041717 3E 10       0074*       ld a,16
041719 5B D7       0075*   	rst.lil $10
04171B C9          0076*   	ret
04171C             0077*   
04171C             0078*   ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
04171C             0079*   ; VDU 23, 7: Scrolling
04171C             0080*   ;     VDU 23, 7, extent, direction, speed: Scroll the screen
04171C             0081*   ; inputs: a, extent; l, direction; h; speed
04171C             0082*   vdu_scroll_down:
04171C 32 31 17 04 0083*   	ld (@extent),a
041720 22 32 17 04 0084*   	ld (@dir),hl ; implicitly populates @speed
041724 21 2F 17 04 0085*   	ld hl,@cmd
041728 01 05 00 00 0086*   	ld bc,@end-@cmd
04172C 5B DF       0087*   	rst.lil $18     ;; Sending command to VDP
04172E C9          0088*   	ret
04172F 17 07       0089*   @cmd:       db 23,7
041731 00          0090*   @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
041732 00          0091*   @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
041733 00          0092*   @speed:     db 0x00 ; pixels
041734 00          0093*   @end:		db 0x00 ; padding
041735             0094*   
041735             0095*   ; COLOUR MODES
041735             0096*   ; Mode	Effect
041735             0097*   ; 0	Set on-screen pixel to target colour value
041735             0098*   ; 1	OR value with the on-screen pixel
041735             0099*   ; 2	AND value with the on-screen pixel
041735             0100*   ; 3	XOR value with the on-screen pixel
041735             0101*   ; 4	Invert the on-screen pixel
041735             0102*   ; 5	No operation
041735             0103*   ; 6	AND the inverse of the specified colour with the on-screen pixel
041735             0104*   ; 7	OR the inverse of the specified colour with the on-screen pixel
041735             0105*   
041735             0106*   ; VDU 17, colour: Define text colour (COLOUR)
041735             0107*   vdu_colour_text:
041735 32 45 17 04 0108*   	ld (@arg),a
041739 21 44 17 04 0109*   	ld hl,@cmd
04173D 01 02 00 00 0110*   	ld bc,@end-@cmd
041741 5B DF       0111*   	rst.lil $18
041743 C9          0112*   	ret
041744 11          0113*   @cmd: db 17
041745 00          0114*   @arg: db 0
041746             0115*   @end:
041746             0116*   
041746             0117*   ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
041746             0118*   ; inputs: a=mode, c=colour (add 128 to set background colour)
041746             0119*   vdu_gcol:
041746 32 5B 17 04 0120*   	ld (@mode),a
04174A 79          0121*       ld a,c
04174B 32 5C 17 04 0122*       ld (@col),a
04174F 21 5A 17 04 0123*   	ld hl,@cmd
041753 01 03 00 00 0124*   	ld bc,@end-@cmd
041757 5B DF       0125*   	rst.lil $18
041759 C9          0126*   	ret
04175A 12          0127*   @cmd:  db 18
04175B 00          0128*   @mode: db 0
04175C 00          0129*   @col:  db 0
04175D             0130*   @end:
04175D             0131*   
04175D             0132*   
04175D             0133*   ; VDU 28, left, bottom, right, top: Set text viewport **
04175D             0134*   ; MIND THE LITTLE-ENDIANESS
04175D             0135*   ; inputs: c=left,b=bottom,e=right,d=top
04175D             0136*   ; outputs; nothing
04175D             0137*   ; destroys: a might make it out alive
04175D             0138*   vdu_set_txt_viewport:
04175D ED 43 73 17 0139*       ld (@lb),bc
       04          
041762 ED 53 75 17 0140*   	ld (@rt),de
       04          
041767 21 72 17 04 0141*   	ld hl,@cmd
04176B 01 05 00 00 0142*   	ld bc,@end-@cmd
04176F 5B DF       0143*   	rst.lil $18
041771 C9          0144*   	ret
041772 1C          0145*   @cmd:   db 28 ; set text viewport command
041773 00 00       0146*   @lb: 	dw 0x0000 ; set by bc
041775 00 00       0147*   @rt: 	dw 0x0000 ; set by de
041777 00          0148*   @end:   db 0x00	  ; padding
041778             0149*   
041778             0150*   ; Wait for VBLANK interrupt
041778             0151*   vdu_vblank:
041778 DD E5       0152*       PUSH 	IX
04177A             0153*   	MOSCALL	mos_sysvars
                       M1 Args: function=mos_sysvars 
04177A 3E 08       0001*M1 			LD	A, function
04177C 5B CF       0002*M1 			RST.LIL	08h
04177E DD 7E 00    0154*   	LD	A, (IX + sysvar_time + 0)
041781             0155*   @wait:
041781 DD BE 00    0156*       CP 	A, (IX + sysvar_time + 0)
041784 28 FB       0157*       JR	Z, @wait
041786 DD E1       0158*       POP	IX
041788 C9          0159*       RET
041789             0160*   
041789             0161*   ; VDU 29, x; y;: Set graphics origin
041789             0162*   ; This command sets the graphics origin.
041789             0163*   ; The origin is the point on the screen where the coordinates (0,0) are located.
041789             0164*   ; inputs: bc=x0,de=y0
041789             0165*   ; outputs; nothing
041789             0166*   ; destroys: a might make it out alive
041789             0167*   vdu_set_gfx_origin:
041789 ED 43 9F 17 0168*       ld (@x0),bc
       04          
04178E ED 53 A1 17 0169*       ld (@y0),de
       04          
041793 21 9E 17 04 0170*       ld hl,@cmd
041797 01 05 00 00 0171*       ld bc,@end-@cmd
04179B 5B DF       0172*       rst.lil $18
04179D C9          0173*       ret
04179E 1D          0174*   @cmd:   db 29 ; set graphics origin command
04179F 00 00       0175*   @x0: 	dw 0x0000 ; set by bc
0417A1 00 00       0176*   @y0: 	dw 0x0000 ; set by de
0417A3 00          0177*   @end:   db 0x00	  ; padding
0417A4             0178*   
0417A4             0179*   ; VDU 24, left; bottom; right; top;: Set graphics viewport
0417A4             0180*   ; NOTE: the order of the y-coordinate parameters are inverted
0417A4             0181*   ; 	because we have turned off logical screen scaling
0417A4             0182*   ; NOTE: coordinates are relative to current gfx origin
0417A4             0183*   ; inputs: bc=x0,de=y0,ix=x1,iy=y1
0417A4             0184*   ; outputs; nothing
0417A4             0185*   ; destroys: a might make it out alive
0417A4             0186*   vdu_set_gfx_viewport:
0417A4 ED 43 C4 17 0187*       ld (@x0),bc
       04          
0417A9 FD 22 C6 17 0188*       ld (@y1),iy
       04          
0417AE DD 22 C8 17 0189*   	ld (@x1),ix
       04          
0417B3 ED 53 CA 17 0190*   	ld (@y0),de
       04          
0417B8 21 C3 17 04 0191*   	ld hl,@cmd
0417BC 01 09 00 00 0192*   	ld bc,@end-@cmd
0417C0 5B DF       0193*   	rst.lil $18
0417C2 C9          0194*   	ret
0417C3 18          0195*   @cmd:   db 24 ; set graphics viewport command
0417C4 00 00       0196*   @x0: 	dw 0x0000 ; set by bc
0417C6 00 00       0197*   @y1: 	dw 0x0000 ; set by iy
0417C8 00 00       0198*   @x1: 	dw 0x0000 ; set by ix
0417CA 00 00       0199*   @y0: 	dw 0x0000 ; set by de
0417CC 00          0200*   @end:   db 0x00	  ; padding
0417CD             0201*   
0417CD             0202*   ; VDU 26: Reset graphics and text viewports
0417CD             0203*   vdu_reset_viewports:
0417CD 3E 1A       0204*       ld a,26
0417CF 5B D7       0205*       rst.lil $10
0417D1 C9          0206*       ret
0417D2             0207*   
0417D2             0208*   ; SCREEN MODES
0417D2             0209*   ; ===============================
0417D2             0210*   ; Mode  Horz  Vert  Cols  Refresh
0417D2             0211*   ; ---   ----  ----  ----  -------
0417D2             0212*   ; 11    320   240   2     60hz
0417D2             0213*   ; 139   320   240   2     60hz
0417D2             0214*   ; 23    512   384   2     60hz
0417D2             0215*   ; 151   512   384   2     60hz
0417D2             0216*   ; 6     640   240   2     60hz
0417D2             0217*   ; 134   640   240   2     60hz
0417D2             0218*   ; 2     640   480   2     60hz
0417D2             0219*   ; 130   640   480   2     60hz
0417D2             0220*   ; 17    800   600   2     60hz
0417D2             0221*   ; 145   800   600   2     60hz
0417D2             0222*   ; 18    1024  768   2     60hz
0417D2             0223*   ; 146   1024  768   2     60hz
0417D2             0224*   ; ---   ----  ----  ----  -------
0417D2             0225*   ; 10    320   240   4     60hz
0417D2             0226*   ; 138   320   240   4     60hz
0417D2             0227*   ; 22    512   384   4     60hz
0417D2             0228*   ; 150   512   384   4     60hz
0417D2             0229*   ; 5     640   240   4     60hz
0417D2             0230*   ; 133   640   240   4     60hz
0417D2             0231*   ; 1     640   480   4     60hz
0417D2             0232*   ; 129   640   480   4     60hz
0417D2             0233*   ; 16    800   600   4     60hz
0417D2             0234*   ; 19    1024  768   4     60hz
0417D2             0235*   ; ---   ----  ----  ----  -------
0417D2             0236*   ; 9     320   240   16    60hz
0417D2             0237*   ; 137   320   240   16    60hz
0417D2             0238*   ; 21    512   384   16    60hz
0417D2             0239*   ; 149   512   384   16    60hz
0417D2             0240*   ; 4     640   240   16    60hz
0417D2             0241*   ; 132   640   240   16    60hz
0417D2             0242*   ; 0     640   480   16    60hz
0417D2             0243*   ; 7     n/a   n/a   16    60hz
0417D2             0244*   ; ---   ----  ----  ----  -------
0417D2             0245*   ; 8     320   240   64    60hz
0417D2             0246*   ; 136   320   240   64    60hz
0417D2             0247*   ; 20    512   384   64    60hz
0417D2             0248*   ; 3     640   240   64    60hz
0417D2             0249*   ; ---   ----  ----  ----  -------
0417D2             0250*   vdu_set_screen_mode:
0417D2 32 E2 17 04 0251*   	ld (@arg),a
0417D6 21 E1 17 04 0252*   	ld hl,@cmd
0417DA 01 02 00 00 0253*   	ld bc,@end-@cmd
0417DE 5B DF       0254*   	rst.lil $18
0417E0 C9          0255*   	ret
0417E1 16          0256*   @cmd: db 22 ; set screen mode
0417E2 00          0257*   @arg: db 0  ; screen mode parameter
0417E3             0258*   @end:
0417E3             0259*   
0417E3             0260*   ; get the current screen mode
0417E3             0261*   ; inputs: none
0417E3             0262*   ; outputs: a=screen mode
0417E3             0263*   ; destroys: af, ix
0417E3             0264*   vdu_get_screen_mode:
0417E3             0265*       MOSCALL mos_sysvars
                       M1 Args: function=mos_sysvars 
0417E3 3E 08       0001*M1 			LD	A, function
0417E5 5B CF       0002*M1 			RST.LIL	08h
0417E7 DD 7E 27    0266*       ld a,(IX+sysvar_scrMode)
0417EA C9          0267*       ret
0417EB             0268*   ; end vdu_get_screen_mode
0417EB             0269*   
0417EB             0270*   ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
0417EB             0271*   ; inputs: a is scaling mode, 1=on, 0=off
0417EB             0272*   ; note: default setting on boot is scaling ON
0417EB             0273*   vdu_set_scaling:
0417EB 32 FD 17 04 0274*   	ld (@arg),a
0417EF 21 FA 17 04 0275*   	ld hl,@cmd
0417F3 01 04 00 00 0276*   	ld bc,@end-@cmd
0417F7 5B DF       0277*   	rst.lil $18
0417F9 C9          0278*   	ret
0417FA 17 00 C0    0279*   @cmd: db 23,0,0xC0
0417FD 00          0280*   @arg: db 0  ; scaling on/off
0417FE             0281*   @end:
0417FE             0282*   
0417FE             0283*   ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
0417FE             0284*   ; inputs: hl=bufferId
0417FE             0285*   vdu_buff_select:
0417FE 22 10 18 04 0286*   	ld (@bufferId),hl
041802 21 0D 18 04 0287*   	ld hl,@cmd
041806 01 05 00 00 0288*   	ld bc,@end-@cmd
04180A 5B DF       0289*   	rst.lil $18
04180C C9          0290*   	ret
04180D 17 1B 20    0291*   @cmd: db 23,27,0x20
041810 00 00       0292*   @bufferId: dw 0x0000
041812 00          0293*   @end: db 0x00 ; padding
041813             0294*   
041813             0295*   ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
041813             0296*   ; inputs: a=format; bc=width; de=height
041813             0297*   ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
041813             0298*   ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
041813             0299*   ; 0 	RGBA8888 (4-bytes per pixel)
041813             0300*   ; 1 	RGBA2222 (1-bytes per pixel)
041813             0301*   ; 2 	Mono/Mask (1-bit per pixel)
041813             0302*   ; 3 	Reserved for internal use by VDP (“native” format)
041813             0303*   vdu_bmp_create:
041813 ED 43 2F 18 0304*       ld (@width),bc
       04          
041818 ED 53 31 18 0305*       ld (@height),de
       04          
04181D 32 33 18 04 0306*       ld (@fmt),a
041821 21 2C 18 04 0307*   	ld hl,@cmd
041825 01 08 00 00 0308*   	ld bc,@end-@cmd
041829 5B DF       0309*   	rst.lil $18
04182B C9          0310*   	ret
04182C 17 1B 21    0311*   @cmd:       db 23,27,0x21
04182F 00 00       0312*   @width:     dw 0x0000
041831 00 00       0313*   @height:    dw 0x0000
041833 00          0314*   @fmt:       db 0x00
041834             0315*   @end:
041834             0316*   
041834             0317*   ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
041834             0318*   ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
041834             0319*   vdu_load_img_rgba2_to_8:
041834             0320*   ; backup the target buffer id and image dimensions
041834 E5          0321*       push hl
041835 D5          0322*       push de
041836 C5          0323*       push bc
041837             0324*   ; load the rgba2 image to working buffer 65534
041837 21 FE FF 00 0325*       ld hl,65534 ; temporary working buffer id
04183B CD 12 19 04 0326*   	call vdu_load_buffer_from_file
04183F             0327*   ; restore the image dimensions and target buffer id
04183F C1          0328*       pop bc
041840 D1          0329*       pop de
041841 E1          0330*       pop hl
041842             0331*   ; fall through to vdu_rgba2_to_8
041842             0332*   
041842             0333*   ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
041842             0334*   ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
041842             0335*   ; the "expand bitmap" command is:
041842             0336*   ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
041842             0337*   ; and then to reverse the byte order to fix endian-ness:
041842             0338*   ; VDU 23,0,&A0,targetBufferID%;24,4,4;
041842             0339*   ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
041842             0340*   ; VDU 23,27,&20,targetBufferID%;
041842             0341*   ; VDU 23,27,&21,width%;height%;0
041842             0342*   ; -------------------------------------------------------------------
041842             0343*   ; inputs: bc,de image width,height ; hl = targetBufferId
041842             0344*   ; prerequisites: rgba2 image data loaded into workingBufferId 65534
041842             0345*   vdu_rgba2_to_8:
041842             0346*   ; load the image dimensions and buffer id parameters
041842 ED 43 9E 18 0347*       ld (@width),bc
       04          
041847 ED 53 A0 18 0348*       ld (@height),de
       04          
04184C 22 83 18 04 0349*       ld (@bufferId0),hl
041850 22 90 18 04 0350*       ld (@bufferId2),hl
041854 22 99 18 04 0351*       ld (@bufferId1),hl
041858             0352*   ; clean up bytes that got stomped on by the ID loads
041858 3E 48       0353*       ld a,0x48
04185A 32 85 18 04 0354*       ld (@bufferId0+2),a
04185E 3E 17       0355*       ld a,23
041860 32 9B 18 04 0356*       ld (@bufferId1+2),a
041864 3E 18       0357*       ld a,24
041866 32 92 18 04 0358*       ld (@bufferId2+2),a
04186A AF          0359*       xor a
04186B 32 A2 18 04 0360*       ld (@height+2),a
04186F             0361*   ; send the vdu command strings
04186F 21 7A 18 04 0362*       ld hl,@beg
041873 01 29 00 00 0363*       ld bc,@end-@beg
041877 5B DF       0364*       rst.lil $18
041879 C9          0365*       ret
04187A             0366*   @beg:
04187A             0367*   ; Command 14: Consolidate blocks in a buffer
04187A             0368*   ; VDU 23, 0, &A0, bufferId; 14
04187A 17 00 A0    0369*       db 23,0,0xA0
04187D FE FF       0370*       dw 65534 ; workingBufferId
04187F 0E          0371*       db 14 ; consolidate blocks
041880             0372*   ; the "expand bitmap" command is:
041880             0373*   ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
041880 17 00 A0    0374*       db 23,0,0xA0
041883 00 00       0375*   @bufferId0: dw 0x0000 ; targetBufferId
041885 48          0376*       db 0x48 ; given as decimal command 72 in the docs
041886 02          0377*       db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
041887 FE FF       0378*       dw 65534 ; sourceBufferId
041889 00 7F BF FF 0379*       db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
04188D             0380*   ; reverse the byte order to fix endian-ness:
04188D             0381*   ; Command 24: Reverse the order of data of blocks within a buffer
04188D             0382*   ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
04188D             0383*   ; VDU 23,0,&A0,targetBufferID%;24,4,4;
04188D 17 00 A0    0384*       db 23,0,0xA0
041890 00 00       0385*   @bufferId2:    dw 0x0000 ; targetBufferId
041892 18          0386*       db 24 ; reverse byte order
041893 04          0387*       db 4 ; option: Reverse data of the value size within chunk of data of the specified size
041894 04 00       0388*       dw 4 ; size (4 bytes)
041896             0389*   ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
041896             0390*   ; VDU 23,27,&20,targetBufferID%;
041896 17 1B 20    0391*       db 23,27,0x20 ; select bitmap
041899 00 00       0392*   @bufferId1: dw 0x0000 ; targetBufferId
04189B             0393*   ; VDU 23,27,&21,width%;height%;0
04189B 17 1B 21    0394*       db 23,27,0x21 ; create bitmap from buffer
04189E 00 00       0395*   @width: dw 0x0000
0418A0 00 00       0396*   @height: dw 0x0000
0418A2 00          0397*       db 0x00 ; rgba8888 format
0418A3             0398*   @end:
0418A3             0399*   
0418A3             0400*   ; scratch variables
0418A3 00 00 00    0401*   bufferId0: dl 0x000000
0418A6 00 00 00    0402*   bufferId1: dl 0x000000
0418A9             0403*   
0418A9             0404*   ; load a vdu buffer from local memory
0418A9             0405*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0418A9             0406*   vdu_load_buffer:
0418A9 ED 43 D2 18 0407*       ld (@length),bc
       04          
0418AE D5          0408*       push de ; save data pointer
0418AF             0409*   ; send the vdu command string
0418AF 7D          0410*       ld a,l
0418B0 32 CF 18 04 0411*       ld (@bufferId),a
0418B4 7C          0412*       ld a,h
0418B5 32 D0 18 04 0413*       ld (@bufferId+1),a
0418B9 21 CC 18 04 0414*       ld hl,@cmd
0418BD 01 08 00 00 0415*       ld bc,@end-@cmd
0418C1 5B DF       0416*       rst.lil $18
0418C3             0417*   ; send the buffer data
0418C3 E1          0418*       pop hl ; pointer to data
0418C4 ED 4B D2 18 0419*       ld bc,(@length)
       04          
0418C9 5B DF       0420*       rst.lil $18 ; send it
0418CB C9          0421*       ret
0418CC             0422*   ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0418CC 17 00 A0    0423*   @cmd:       db 23,0,0xA0
0418CF 00 00       0424*   @bufferId:	dw 0x0000
0418D1 00          0425*   		    db 0 ; load buffer
0418D2 00 00       0426*   @length:	dw 0x0000
0418D4 00          0427*   @end: db 0 ; padding
0418D5             0428*   
0418D5             0429*   ; Command 14: Consolidate blocks in a buffer
0418D5             0430*   vdu_consolidate_buffer:
0418D5             0431*   ; set parameters for vdu call
0418D5 7D          0432*       ld a,l
0418D6 32 ED 18 04 0433*       ld (@bufferId),a
0418DA 7C          0434*       ld a,h
0418DB 32 EE 18 04 0435*       ld (@bufferId+1),a
0418DF 21 EA 18 04 0436*       ld hl,@beg
0418E3 01 06 00 00 0437*       ld bc,@end-@beg
0418E7 5B DF       0438*       rst.lil $18
0418E9 C9          0439*       ret
0418EA             0440*   ; VDU 23, 0, &A0, bufferId; 14
0418EA 17 00 A0    0441*   @beg: db 23,0,0xA0
0418ED 00 00       0442*   @bufferId: dw 0x0000
0418EF 0E          0443*              db 14
0418F0             0444*   @end:
0418F0             0445*   
0418F0             0446*   ; load an image file to a buffer and make it a bitmap
0418F0             0447*   ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
0418F0             0448*   vdu_load_img:
0418F0             0449*   ; back up image type and dimension parameters
0418F0 22 A3 18 04 0450*       ld (bufferId0),hl
0418F4 F5          0451*       push af
0418F5 C5          0452*   	push bc
0418F6 D5          0453*   	push de
0418F7             0454*   ; load the image
0418F7 CD 12 19 04 0455*   	call vdu_load_buffer_from_file
0418FB             0456*   ; now make it a bitmap
0418FB 2A A3 18 04 0457*       ld hl,(bufferId0)
0418FF CD D5 18 04 0458*       call vdu_consolidate_buffer
041903 2A A3 18 04 0459*       ld hl,(bufferId0)
041907 CD FE 17 04 0460*       call vdu_buff_select
04190B D1          0461*   	pop de ; image height
04190C C1          0462*   	pop bc ; image width
04190D F1          0463*   	pop af ; image type
04190E C3 13 18 04 0464*   	jp vdu_bmp_create ; will return to caller from there
041912             0465*   
041912             0466*   ; inputs: hl = bufferId; iy = pointer to filename
041912             0467*   vdu_load_buffer_from_file:
041912 22 A3 18 04 0468*       ld (bufferId0),hl
041916             0469*   
041916             0470*   ; clear target buffer
041916 CD BE 1A 04 0471*       call vdu_clear_buffer
04191A             0472*   
04191A             0473*   ; open the file in read mode
04191A             0474*   ; Open a file
04191A             0475*   ; HLU: Filename
04191A             0476*   ;   C: Mode
04191A             0477*   ; Returns:
04191A             0478*   ;   A: Filehandle, or 0 if couldn't open
04191A FD E5       0479*   	push iy ; pointer to filename
04191C E1          0480*   	pop hl
04191D 0E 01       0481*   	ld c,fa_read
04191F             0482*       MOSCALL mos_fopen
                       M1 Args: function=mos_fopen 
04191F 3E 0A       0001*M1 			LD	A, function
041921 5B CF       0002*M1 			RST.LIL	08h
041923 32 5E 19 04 0483*       ld (@filehandle),a
041927             0484*   
041927             0485*   @read_file:
041927             0486*   ; Read a block of data from a file
041927             0487*   ;   C: Filehandle
041927             0488*   ; HLU: Pointer to where to write the data to
041927             0489*   ; DEU: Number of bytes to read
041927             0490*   ; Returns:
041927             0491*   ; DEU: Number of bytes read
041927 3A 5E 19 04 0492*       ld a,(@filehandle)
04192B 4F          0493*       ld c,a
04192C 21 00 E0 B7 0494*       ld hl,filedata
041930 11 00 20 00 0495*       ld de,8192 ; max we can read into onboard sram at one time
041934             0496*       MOSCALL mos_fread
                       M1 Args: function=mos_fread 
041934 3E 1A       0001*M1 			LD	A, function
041936 5B CF       0002*M1 			RST.LIL	08h
041938             0497*   
041938             0498*   ; test de for zero bytes read
041938 21 00 00 00 0499*       ld hl,0
04193C AF          0500*       xor a ; clear carry
04193D ED 52       0501*       sbc hl,de
04193F CA 55 19 04 0502*       jp z,@close_file
041943             0503*   
041943             0504*   ; load a vdu buffer from local memory
041943             0505*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
041943 2A A3 18 04 0506*       ld hl,(bufferId0)
041947 D5          0507*       push de ; chunksize
041948 C1          0508*       pop bc
041949 11 00 E0 B7 0509*       ld de,filedata
04194D CD A9 18 04 0510*       call vdu_load_buffer
041951             0511*   
041951             0512*   ; read the next block
041951 C3 27 19 04 0513*       jp @read_file
041955             0514*   
041955             0515*   ; close the file
041955             0516*   @close_file:
041955 3A 5E 19 04 0517*       ld a,(@filehandle)
041959             0518*       MOSCALL mos_fclose
                       M1 Args: function=mos_fclose 
041959 3E 0B       0001*M1 			LD	A, function
04195B 5B CF       0002*M1 			RST.LIL	08h
04195D C9          0519*       ret ; vdu_load_buffer_from_file
04195E             0520*   
04195E 00          0521*   @filehandle: db 0 ; file handle
04195F 00 00 00    0522*   @fil: dl 0 ; pointer to FIL struct
041962             0523*   
041962 00 00 00    0524*   @chunkpointer: dl 0 ; pointer to current chunk
041965             0525*   
041965             0526*   ; File information structure (FILINFO)
041965             0527*   @filinfo:
041965 00 00 00 00 0528*   @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
041969 00 00       0529*   @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
04196B 00 00       0530*   @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
04196D 00          0531*   @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
04196E 00 00 00 00 0532*   @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
04197B 00 00 00 00 0533*   @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041A7B             0040        include "vdu_buffered_api.inc"
041A7B             0001*   ; https://agonconsole8.github.io/agon-docs/vdp/Buffered-Commands-API/
041A7B             0002*   
041A7B             0003*   ; Command 0: Write block to a buffer
041A7B             0004*   ; VDU 23, 0, &A0, bufferId; 0, length; <buffer-data>
041A7B             0005*   ; inputs: hl = bufferId, bc = length of data, de = pointer to data
041A7B             0006*   vdu_write_block_to_buffer:
041A7B             0007*   ; back up input parameters
041A7B D5          0008*       push de ; pointer to data
041A7C C5          0009*       push bc ; length of data
041A7D             0010*   ; set up the vdu command string
041A7D 22 9D 1A 04 0011*       ld (@bufferId),hl
041A81 ED 43 A0 1A 0012*       ld (@length),bc
       04          
041A86 AF          0013*       xor a ; load buffer
041A87 32 9F 1A 04 0014*       ld (@bufferId+2),a
041A8B 21 9A 1A 04 0015*       ld hl,@cmd0
041A8F 01 08 00 00 0016*       ld bc,@end0-@cmd0
041A93 5B DF       0017*       rst.lil $18
041A95             0018*   ; send the buffer data
041A95 C1          0019*       pop bc ; length of data
041A96 E1          0020*       pop hl ; pointer to data (was de)
041A97 5B DF       0021*       rst.lil $18 ; send it
041A99 C9          0022*       ret
041A9A             0023*   ; command string data
041A9A 17 00 A0    0024*   @cmd0:      db 23,0,0xA0
041A9D 00 00       0025*   @bufferId:	dw 0x0000
041A9F 00          0026*               db 0 ; load buffer
041AA0 00 00       0027*   @length:	dw 0x0000
041AA2 00          0028*   @end0:      db 0x00 ; padding
041AA3             0029*   ; end vdu_write_block_to_buffer
041AA3             0030*   
041AA3             0031*   ; Command 1: Call a buffer
041AA3             0032*   ; VDU 23, 0, &A0, bufferId; 1
041AA3             0033*   ; inputs: hl = bufferId
041AA3             0034*   vdu_call_buffer:
041AA3 22 BB 1A 04 0035*       ld (@bufferId),hl
041AA7 3E 01       0036*       ld a,1 ; call buffer
041AA9 32 BD 1A 04 0037*       ld (@bufferId+2),a
041AAD 21 B8 1A 04 0038*       ld hl,@cmd
041AB1 01 06 00 00 0039*       ld bc,@end-@cmd
041AB5 5B DF       0040*       rst.lil $18
041AB7 C9          0041*       ret
041AB8 17 00 A0    0042*   @cmd:     db 23,0,0xA0
041ABB 00 00       0043*   @bufferId: dw 0x0000
041ABD 01          0044*              db 1 ; call buffer
041ABE             0045*   @end:
041ABE             0046*   ; end vdu_call_buffer
041ABE             0047*   
041ABE             0048*   ; Command 2: Clear a buffer
041ABE             0049*   ; VDU 23, 0 &A0, bufferId; 2
041ABE             0050*   ; inputs: hl = bufferId
041ABE             0051*   vdu_clear_buffer:
041ABE 22 D6 1A 04 0052*       ld (@bufferId),hl
041AC2 3E 02       0053*       ld a,2 ; clear buffer
041AC4 32 D8 1A 04 0054*       ld (@bufferId+2),a
041AC8 21 D3 1A 04 0055*       ld hl,@cmd
041ACC 01 06 00 00 0056*       ld bc,@end-@cmd
041AD0 5B DF       0057*       rst.lil $18
041AD2 C9          0058*       ret
041AD3 17 00 A0    0059*   @cmd:     db 23,0,0xA0
041AD6 00 00       0060*   @bufferId: dw 0x0000
041AD8 02          0061*              db 2 ; clear buffer
041AD9             0062*   @end:
041AD9             0063*   ; end vdu_clear_buffer
041AD9             0064*   
041AD9             0065*   ; Clear all buffers
041AD9             0066*   ; inputs: none
041AD9             0067*   vdu_clear_all_buffers:
041AD9             0068*   ; clear all buffers
041AD9 21 E4 1A 04 0069*       ld hl,@beg
041ADD 01 06 00 00 0070*       ld bc,@end-@beg
041AE1 5B DF       0071*       rst.lil $18
041AE3 C9          0072*       ret
041AE4 17 00 A0    0073*   @beg: db 23,0,$A0
041AE7 FF FF       0074*         dw -1 ; bufferId -1 (65535) means clear all buffers
041AE9 02          0075*         db 2  ; command 2: clear a buffer
041AEA             0076*   @end:
041AEA             0077*   ; end vdu_clear_all_buffers
041AEA             0078*   
041AEA             0079*   ; Command 3: Create a writeable buffer
041AEA             0080*   ; VDU 23, 0 &A0, bufferId; 3, length;
041AEA             0081*   ; inputs: hl = bufferId, bc = length
041AEA             0082*   vdu_create_writeable_buffer:
041AEA 22 07 1B 04 0083*       ld (@bufferId),hl
041AEE ED 43 0A 1B 0084*       ld (@length),bc
       04          
041AF3 3E 03       0085*       ld a,3 ; create writeable buffer
041AF5 32 09 1B 04 0086*       ld (@bufferId+2),a
041AF9 21 04 1B 04 0087*       ld hl,@cmd
041AFD 01 08 00 00 0088*       ld bc,@end-@cmd
041B01 5B DF       0089*       rst.lil $18
041B03 C9          0090*       ret
041B04 17 00 A0    0091*   @cmd:     db 23,0,0xA0
041B07 00 00       0092*   @bufferId: dw 0x0000
041B09 03          0093*              db 3 ; create writeable buffer
041B0A 00 00       0094*   @length: dw 0x0000
041B0C 00          0095*   @end:     db 0x00 ; padding
041B0D             0096*   ; end vdu_create_writeable_buffer
041B0D             0097*   
041B0D             0098*   ; Command 4: Set output stream to a buffer
041B0D             0099*   ; VDU 23, 0 &A0, bufferId; 4
041B0D             0100*   ; inputs: hl = bufferId
041B0D             0101*   vdu_set_output_stream_buffer:
041B0D 22 25 1B 04 0102*       ld (@bufferId),hl
041B11 3E 04       0103*       ld a,4 ; set output stream to buffer
041B13 32 27 1B 04 0104*       ld (@bufferId+2),a
041B17 21 22 1B 04 0105*       ld hl,@cmd
041B1B 01 06 00 00 0106*       ld bc,@end-@cmd
041B1F 5B DF       0107*       rst.lil $18
041B21 C9          0108*       ret
041B22 17 00 A0    0109*   @cmd:     db 23,0,0xA0
041B25 00 00       0110*   @bufferId: dw 0x0000
041B27 04          0111*              db 4 ; set output stream to buffer
041B28 00          0112*   @end:     db 0x00 ; padding
041B29             0113*   ; end vdu_set_output_stream_buffer
041B29             0114*   
041B29             0115*   ; Command 5: Adjust buffer contents
041B29             0116*   ; VDU 23, 0, &A0, bufferId; 5, operation, offset; [count;] <operand>, [arguments]
041B29             0117*   vdu_adjust_buffer:
041B29 C9          0118*       ret ; TODO: implement
041B2A             0119*   ; end vdu_adjust_buffer
041B2A             0120*   
041B2A             0121*   ; Command 6: Conditionally call a buffer
041B2A             0122*   ; VDU 23, 0, &A0, bufferId; 6, operation, checkBufferId; checkOffset; [arguments]
041B2A             0123*   vdu_call_buffer_conditional:
041B2A C9          0124*       ret ; TODO: implement
041B2B             0125*   ; end vdu_call_buffer_conditional
041B2B             0126*   
041B2B             0127*   ; Command 7: Jump to a buffer
041B2B             0128*   ; VDU 23, 0, &A0, bufferId; 7
041B2B             0129*   ; inputs: hl = bufferId
041B2B             0130*   vdu_jump_to_buffer:
041B2B 22 43 1B 04 0131*       ld (@bufferId),hl
041B2F 3E 07       0132*       ld a,7 ; jump to buffer
041B31 32 45 1B 04 0133*       ld (@bufferId+2),a
041B35 21 40 1B 04 0134*       ld hl,@cmd
041B39 01 06 00 00 0135*       ld bc,@end-@cmd
041B3D 5B DF       0136*       rst.lil $18
041B3F C9          0137*       ret
041B40 17 00 A0    0138*   @cmd:     db 23,0,0xA0
041B43 00 00       0139*   @bufferId: dw 0x0000
041B45 07          0140*              db 7 ; jump to buffer
041B46 00          0141*   @end:     db 0x00 ; padding
041B47             0142*   ; end vdu_jump_to_buffer
041B47             0143*   
041B47             0144*   ; Command 8: Conditional Jump to a buffer
041B47             0145*   ; VDU 23, 0, &A0, bufferId; 8, operation, checkBufferId; checkOffset; [arguments]
041B47             0146*   vdu_jump_to_buffer_conditional:
041B47 C9          0147*       ret ; TODO: implement
041B48             0148*   ; end vdu_jump_to_buffer_conditional
041B48             0149*   
041B48             0150*   ; Command 9: Jump to an offset in a buffer
041B48             0151*   ; VDU 23, 0, &A0, bufferId; 9, offset; offsetHighByte, [blockNumber;]
041B48             0152*   vdu_jump_to_buffer_offset:
041B48 C9          0153*       ret ; TODO: implement
041B49             0154*   ; end vdu_jump_to_buffer_offset
041B49             0155*   
041B49             0156*   ; Command 10: Conditional jump to an offset in a buffer
041B49             0157*   ; VDU 23, 0, &A0, bufferId; 10, offset; offsetHighByte, [blockNumber;] [arguments]
041B49             0158*   vdu_jump_to_buffer_offset_conditional:
041B49 C9          0159*       ret ; TODO: implement
041B4A             0160*   ; end vdu_jump_to_buffer_offset_conditional
041B4A             0161*   
041B4A             0162*   ; Command 11: Call buffer with an offset
041B4A             0163*   ; VDU 23, 0, &A0, bufferId; 11, offset; offsetHighByte, [blockNumber;]
041B4A             0164*   vdu_call_buffer_offset:
041B4A C9          0165*       ret ; TODO: implement
041B4B             0166*   ; end vdu_call_buffer_offset
041B4B             0167*   
041B4B             0041        include "vdu_fonts.inc"
041B4B             0001*   ; select font
041B4B             0002*   ; inputs: hl = bufferId, a = font flags
041B4B             0003*   ; Flags:
041B4B             0004*   ; Bit	Description
041B4B             0005*   ; 0	Adjust cursor position to ensure text baseline is aligned
041B4B             0006*   ;   0: Do not adjust cursor position (best for changing font on a new line)
041B4B             0007*   ;   1: Adjust cursor position (best for changing font in the middle of a line)
041B4B             0008*   ; 1-7	Reserved for future use
041B4B             0009*   ; VDU 23, 0, &95, 0, bufferId; flags: Select font
041B4B             0010*   vdu_font_select:
041B4B 22 62 1B 04 0011*       ld (@bufferId),hl
041B4F 32 64 1B 04 0012*       ld (@flags),a
041B53 21 5E 1B 04 0013*       ld hl,@cmd
041B57 01 07 00 00 0014*       ld bc,@end-@cmd
041B5B 5B DF       0015*       rst.lil $18
041B5D C9          0016*       ret
041B5E 17 00 95 00 0017*   @cmd: db 23, 0, 0x95, 0
041B62 00 00       0018*   @bufferId: dw 0x0000
041B64 00          0019*   @flags: db 0x00
041B65             0020*   @end:
041B65             0021*   
041B65             0022*   ; create font from buffer
041B65             0023*   ; inputs: hl = bufferId, e = width, d = height, d = ascent, a = flags
041B65             0024*   ; VDU 23, 0, &95, 1, bufferId; width, height, ascent, flags: Create font from buffer
041B65             0025*   vdu_font_create:
041B65 22 8A 1B 04 0026*       ld (@bufferId),hl
041B69 ED 53 8C 1B 0027*       ld (@width),de ; also loads height
       04          
041B6E 32 8F 1B 04 0028*       ld (@flags),a
041B72 7A          0029*       ld a,d ; height
041B73 32 8E 1B 04 0030*       ld (@ascent),a ; ascent = height
041B77             0031*   ; consolidate buffer
041B77 CD D5 18 04 0032*       call vdu_consolidate_buffer
041B7B             0033*   ; create font
041B7B 21 86 1B 04 0034*       ld hl,@cmd
041B7F 01 0A 00 00 0035*       ld bc,@end-@cmd
041B83 5B DF       0036*       rst.lil $18
041B85 C9          0037*       ret
041B86 17 00 95 01 0038*   @cmd: db 23, 0, 0x95, 1
041B8A 00 00       0039*   @bufferId: dw 0x0000
041B8C 00          0040*   @width: db 0x00
041B8D 00          0041*   @height: db 0x00
041B8E 00          0042*   @ascent: db 0x00
041B8F 00          0043*   @flags: db 0x00
041B90             0044*   @end:
041B90             0045*   
041B90             0046*   ; set or adjust font property
041B90             0047*   ; inputs: hl = bufferId, a = field, de = value
041B90             0048*   ; VDU 23, 0, &95, 2, bufferId; field, value;: Set or adjust font property
041B90             0049*   vdu_font_property:
041B90 22 AC 1B 04 0050*       ld (@bufferId),hl
041B94 32 AE 1B 04 0051*       ld (@field),a
041B98 ED 53 AF 1B 0052*       ld (@value),de
       04          
041B9D 21 A8 1B 04 0053*       ld hl,@cmd
041BA1 01 09 00 00 0054*       ld bc,@end-@cmd
041BA5 5B DF       0055*       rst.lil $18
041BA7 C9          0056*       ret
041BA8 17 00 95 02 0057*   @cmd: db 23, 0, 0x95, 2
041BAC 00 00       0058*   @bufferId: dw 0x0000
041BAE 00          0059*   @field: db 0x00
041BAF 00 00       0060*   @value: dw 0x0000
041BB1 00          0061*   @end: db 0x00 ; padding
041BB2             0062*   
041BB2             0063*   ; VDU 23, 0, &95, 3, bufferId; [<args>]: Reserved
041BB2             0064*   
041BB2             0065*   ; Clear/Delete font
041BB2             0066*   ; inputs: hl = bufferId
041BB2             0067*   ; VDU 23, 0, &95, 4, bufferId;: Clear/Delete font
041BB2             0068*   vdu_font_clear:
041BB2 22 C5 1B 04 0069*       ld (@bufferId),hl
041BB6 21 C1 1B 04 0070*       ld hl,@cmd
041BBA 01 06 00 00 0071*       ld bc,@end-@cmd
041BBE 5B DF       0072*       rst.lil $18
041BC0 C9          0073*       ret
041BC1 17 00 95 04 0074*   @cmd: db 23, 0, 0x95, 4
041BC5 00 00       0075*   @bufferId: dw 0x0000
041BC7 00          0076*   @end: db 0x00 ; padding
041BC8             0077*   
041BC8             0078*   ; Copy system font to buffer
041BC8             0079*   ; inputs: hl = bufferId
041BC8             0080*   ; VDU 23, 0, &95, 5, bufferId;: Copy system font to buffer
041BC8             0081*   vdu_font_copy_system:
041BC8 22 DB 1B 04 0082*       ld (@bufferId),hl
041BCC 21 D7 1B 04 0083*       ld hl,@cmd
041BD0 01 06 00 00 0084*       ld bc,@end-@cmd
041BD4 5B DF       0085*       rst.lil $18
041BD6 C9          0086*       ret
041BD7 17 00 95 05 0087*   @cmd: db 23, 0, 0x95, 5
041BDB 00 00       0088*   @bufferId: dw 0x0000
041BDD 00          0089*   @end: db 0x00 ; padding
041BDE             0042        include "vdu_plot.inc"
041BDE             0001*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
041BDE             0002*   ; PLOT code 	(Decimal) 	Effect
041BDE             0003*   ; &00-&07 	0-7 	Solid line, includes both ends
041BDE             0004*   plot_sl_both: equ 0x00
041BDE             0005*   
041BDE             0006*   ; &08-&0F 	8-15 	Solid line, final point omitted
041BDE             0007*   plot_sl_first: equ 0x08
041BDE             0008*   
041BDE             0009*   ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
041BDE             0010*   ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
041BDE             0011*   
041BDE             0012*   ; &20-&27 	32-39 	Solid line, first point omitted
041BDE             0013*   plot_sl_last: equ 0x20
041BDE             0014*   
041BDE             0015*   ; &28-&2F 	40-47 	Solid line, both points omitted
041BDE             0016*   plot_sl_none: equ 0x28
041BDE             0017*   
041BDE             0018*   ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
041BDE             0019*   ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
041BDE             0020*   
041BDE             0021*   ; &40-&47 	64-71 	Point plot
041BDE             0022*   plot_pt: equ 0x40
041BDE             0023*   
041BDE             0024*   ; &48-&4F 	72-79 	Line fill left and right to non-background §§
041BDE             0025*   plot_lf_lr_non_bg: equ 0x48
041BDE             0026*   
041BDE             0027*   ; &50-&57 	80-87 	Triangle fill
041BDE             0028*   plot_tf: equ 0x50
041BDE             0029*   
041BDE             0030*   ; &58-&5F 	88-95 	Line fill right to background §§
041BDE             0031*   plot_lf_r_bg: equ 0x58
041BDE             0032*   
041BDE             0033*   ; &60-&67 	96-103 	Rectangle fill
041BDE             0034*   plot_rf: equ 0x60
041BDE             0035*   
041BDE             0036*   ; &68-&6F 	104-111 	Line fill left and right to foreground §§
041BDE             0037*   plot_lf_lr_fg: equ 0x60
041BDE             0038*   
041BDE             0039*   ; &70-&77 	112-119 	Parallelogram fill
041BDE             0040*   plot_pf: equ 0x70
041BDE             0041*   
041BDE             0042*   ; &78-&7F 	120-127 	Line fill right to non-foreground §§
041BDE             0043*   plot_lf_r_non_fg: equ 0x78
041BDE             0044*   
041BDE             0045*   ; &80-&87 	128-135 	Not supported (Flood until non-background)
041BDE             0046*   ; &88-&8F 	136-143 	Not supported (Flood until foreground)
041BDE             0047*   
041BDE             0048*   ; &90-&97 	144-151 	Circle outline
041BDE             0049*   plot_co: equ 0x90
041BDE             0050*   
041BDE             0051*   ; &98-&9F 	152-159 	Circle fill
041BDE             0052*   plot_cf: equ 0x98
041BDE             0053*   
041BDE             0054*   ; &A0-&A7 	160-167 	Not supported (Circular arc)
041BDE             0055*   ; &A8-&AF 	168-175 	Not supported (Circular segment)
041BDE             0056*   ; &B0-&B7 	176-183 	Not supported (Circular sector)
041BDE             0057*   
041BDE             0058*   ; &B8-&BF 	184-191 	Rectangle copy/move
041BDE             0059*   plot_rcm: equ 0xB8
041BDE             0060*   
041BDE             0061*   ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
041BDE             0062*   ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
041BDE             0063*   ; &D0-&D7 	208-215 	Not defined
041BDE             0064*   ; &D8-&DF 	216-223 	Not defined
041BDE             0065*   ; &E0-&E7 	224-231 	Not defined
041BDE             0066*   
041BDE             0067*   ; &E8-&EF 	232-239 	Bitmap plot §
041BDE             0068*   plot_bmp: equ 0xE8
041BDE             0069*   
041BDE             0070*   ; &F0-&F7 	240-247 	Not defined
041BDE             0071*   ; &F8-&FF 	248-255 	Not defined
041BDE             0072*   
041BDE             0073*   ; § Support added in Agon Console8 VDP 2.1.0 §§ Support added in
041BDE             0074*   ; Agon Console8 VDP 2.2.0
041BDE             0075*   
041BDE             0076*   ; Within each group of eight plot codes, the effects are as follows:
041BDE             0077*   ; Plot code 	Effect
041BDE             0078*   ; 0 	Move relative
041BDE             0079*   mv_rel: equ 0
041BDE             0080*   
041BDE             0081*   ; 1 	Plot relative in current foreground colour
041BDE             0082*   dr_rel_fg: equ 1
041BDE             0083*   
041BDE             0084*   ; 2 	Not supported (Plot relative in logical inverse colour)
041BDE             0085*   ; 3 	Plot relative in current background colour
041BDE             0086*   dr_rel_bg: equ 3
041BDE             0087*   
041BDE             0088*   ; 4 	Move absolute
041BDE             0089*   mv_abs: equ 4
041BDE             0090*   
041BDE             0091*   ; 5 	Plot absolute in current foreground colour
041BDE             0092*   dr_abs_fg: equ 5
041BDE             0093*   
041BDE             0094*   ; 6 	Not supported (Plot absolute in logical inverse colour)
041BDE             0095*   ; 7 	Plot absolute in current background colour
041BDE             0096*   dr_abs_bg: equ 7
041BDE             0097*   
041BDE             0098*   ; Codes 0-3 use the position data provided as part of the command
041BDE             0099*   ; as a relative position, adding the position given to the current
041BDE             0100*   ; graphical cursor position. Codes 4-7 use the position data provided
041BDE             0101*   ; as part of the command as an absolute position, setting the current
041BDE             0102*   ; graphical cursor position to the position given.
041BDE             0103*   
041BDE             0104*   ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
041BDE             0105*   ; current pixel colour. These operations cannot currently be supported
041BDE             0106*   ; by the graphics system the Agon VDP uses, so these codes are not
041BDE             0107*   ; supported. Support for these codes may be added in a future version
041BDE             0108*   ; of the VDP firmware.
041BDE             0109*   
041BDE             0110*   ; 16 colour palette constants
041BDE             0111*   c_black: equ 0
041BDE             0112*   c_red_dk: equ 1
041BDE             0113*   c_green_dk: equ 2
041BDE             0114*   c_yellow_dk: equ 3
041BDE             0115*   c_blue_dk: equ 4
041BDE             0116*   c_magenta_dk: equ 5
041BDE             0117*   c_cyan_dk: equ 6
041BDE             0118*   c_grey: equ 7
041BDE             0119*   c_grey_dk: equ 8
041BDE             0120*   c_red: equ 9
041BDE             0121*   c_green: equ 10
041BDE             0122*   c_yellow: equ 11
041BDE             0123*   c_blue: equ 12
041BDE             0124*   c_magenta: equ 13
041BDE             0125*   c_cyan: equ 14
041BDE             0126*   c_white: equ 15
041BDE             0127*   
041BDE             0128*   ; VDU 25, mode, x; y;: PLOT command
041BDE             0129*   ; inputs: a=mode, bc=x0, de=y0
041BDE             0130*   vdu_plot:
041BDE 32 F8 1B 04 0131*       ld (@mode),a
041BE2 ED 43 F9 1B 0132*       ld (@x0),bc
       04          
041BE7 ED 53 FB 1B 0133*       ld (@y0),de
       04          
041BEC 21 F7 1B 04 0134*   	ld hl,@cmd
041BF0 01 06 00 00 0135*   	ld bc,@end-@cmd
041BF4 5B DF       0136*   	rst.lil $18
041BF6 C9          0137*   	ret
041BF7 19          0138*   @cmd:   db 25
041BF8 00          0139*   @mode:  db 0
041BF9 00 00       0140*   @x0: 	dw 0
041BFB 00 00       0141*   @y0: 	dw 0
041BFD 00          0142*   @end:   db 0 ; extra byte to soak up deu
041BFE             0143*   
041BFE             0144*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
041BFE             0145*   ; &E8-&EF 	232-239 	Bitmap plot §
041BFE             0146*   ; VDU 25, mode, x; y;: PLOT command
041BFE             0147*   ; inputs: bc=x0, de=y0
041BFE             0148*   ; prerequisites: vdu_buff_select
041BFE             0149*   vdu_plot_bmp:
041BFE ED 43 15 1C 0150*       ld (@x0),bc
       04          
041C03 ED 53 17 1C 0151*       ld (@y0),de
       04          
041C08 21 13 1C 04 0152*   	ld hl,@cmd
041C0C 01 06 00 00 0153*   	ld bc,@end-@cmd
041C10 5B DF       0154*   	rst.lil $18
041C12 C9          0155*   	ret
041C13 19          0156*   @cmd:   db 25
041C14 ED          0157*   @mode:  db plot_bmp+dr_abs_fg ; 0xED
041C15 00 00       0158*   @x0: 	dw 0x0000
041C17 00 00       0159*   @y0: 	dw 0x0000
041C19 00          0160*   @end:   db 0x00 ; padding
041C1A             0161*   
041C1A             0162*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
041C1A             0163*   ; &E8-&EF 	232-239 	Bitmap plot §
041C1A             0164*   ; VDU 25, mode, x; y;: PLOT command
041C1A             0165*   ; inputs: bc=x0, de=y0
041C1A             0166*   ; USING 16.8 FIXED POINT COORDINATES
041C1A             0167*   ; inputs: ub.c is x coordinate, ud.e is y coordinate
041C1A             0168*   ;   the fractional portiion of the inputs are truncated
041C1A             0169*   ;   leaving only the 16-bit integer portion
041C1A             0170*   ; prerequisites: vdu_buff_select
041C1A             0171*   vdu_plot_bmp168:
041C1A             0172*   ; populate in the reverse of normal to keep the
041C1A             0173*   ; inputs from stomping on each other
041C1A ED 53 38 1C 0174*       ld (@y0-1),de
       04          
041C1F ED 43 36 1C 0175*       ld (@x0-1),bc
       04          
041C24 3E ED       0176*       ld a,plot_bmp+dr_abs_fg ; 0xED
041C26 32 36 1C 04 0177*       ld (@mode),a ; restore the mode byte that got stomped on by bcu
041C2A 21 35 1C 04 0178*   	ld hl,@cmd
041C2E 01 06 00 00 0179*   	ld bc,@end-@cmd
041C32 5B DF       0180*   	rst.lil $18
041C34 C9          0181*   	ret
041C35 19          0182*   @cmd:   db 25
041C36 ED          0183*   @mode:  db plot_bmp+dr_abs_fg ; 0xED
041C37 00 00       0184*   @x0: 	dw 0x0000
041C39 00 00       0185*   @y0: 	dw 0x0000
041C3B             0186*   @end:  ; no padding required b/c we shifted de right
041C3B             0187*   
041C3B             0188*   ; draw a filled rectangle
041C3B             0189*   vdu_plot_rf:
041C3B ED 43 62 1C 0190*       ld (@x0),bc
       04          
041C40 ED 53 64 1C 0191*       ld (@y0),de
       04          
041C45 DD 22 68 1C 0192*       ld (@x1),ix
       04          
041C4A FD 22 6A 1C 0193*       ld (@y1),iy
       04          
041C4F 3E 19       0194*       ld a,25 ; we have to reload the 2nd plot command
041C51 32 66 1C 04 0195*       ld (@cmd1),a ; because the 24-bit y0 load stomped on it
041C55 21 60 1C 04 0196*   	ld hl,@cmd0
041C59 01 0C 00 00 0197*   	ld bc,@end-@cmd0
041C5D 5B DF       0198*   	rst.lil $18
041C5F C9          0199*       ret
041C60 19          0200*   @cmd0:  db 25 ; plot
041C61 04          0201*   @arg0:  db plot_sl_both+mv_abs
041C62 00 00       0202*   @x0:    dw 0x0000
041C64 00 00       0203*   @y0:    dw 0x0000
041C66 19          0204*   @cmd1:  db 25 ; plot
041C67 65          0205*   @arg1:  db plot_rf+dr_abs_fg
041C68 00 00       0206*   @x1:    dw 0x0000
041C6A 00 00       0207*   @y1:    dw 0x0000
041C6C 00          0208*   @end:   db 0x00 ; padding
041C6D             0209*   
041C6D             0210*   ; draw a filled circle
041C6D             0211*   vdu_plot_cf:
041C6D ED 43 94 1C 0212*       ld (@x0),bc
       04          
041C72 ED 53 96 1C 0213*       ld (@y0),de
       04          
041C77 DD 22 9A 1C 0214*       ld (@x1),ix
       04          
041C7C FD 22 9C 1C 0215*       ld (@y1),iy
       04          
041C81 3E 19       0216*       ld a,25 ; we have to reload the 2nd plot command
041C83 32 98 1C 04 0217*       ld (@cmd1),a ; because the 24-bit y0 load stomped on it
041C87 21 92 1C 04 0218*   	ld hl,@cmd0
041C8B 01 0C 00 00 0219*   	ld bc,@end-@cmd0
041C8F 5B DF       0220*   	rst.lil $18
041C91 C9          0221*       ret
041C92 19          0222*   @cmd0:  db 25 ; plot
041C93 04          0223*   @arg0:  db plot_sl_both+mv_abs
041C94 00 00       0224*   @x0:    dw 0x0000
041C96 00 00       0225*   @y0:    dw 0x0000
041C98 19          0226*   @cmd1:  db 25 ; plot
041C99 9D          0227*   @arg1:  db plot_cf+dr_abs_fg
041C9A 00 00       0228*   @x1:    dw 0x0000
041C9C 00 00       0229*   @y1:    dw 0x0000
041C9E 00          0230*   @end:   db 0x00 ; padding
041C9F             0043        include "vdu_sound.inc"
041C9F             0001*   ; enable enough additional channels so that total enabled = max_channels
041C9F             0002*   ; inputs: max_channels set
041C9F             0003*   ; returns: nothing
041C9F             0004*   ; destroys: af, bc, hl
041C9F             0005*   vdu_enable_channels:
041C9F 3E 01       0006*       ld a,max_channels
041CA1 D6 03       0007*       sub 3 ; subtract number of default channels already enabled
041CA3 F2 AA 1C 04 0008*       jp p,@loop
041CA7 C9          0009*       ret
041CA8 3E 03       0010*       ld a,3 ; first non-default channel
041CAA             0011*   @loop:
041CAA 32 C5 1C 04 0012*       ld (@channel),a
041CAE 21 C2 1C 04 0013*       ld hl,@beg
041CB2 01 05 00 00 0014*       ld bc,@end-@beg
041CB6 F5          0015*       push af
041CB7 5B DF       0016*       rst.lil $18
041CB9 F1          0017*       pop af
041CBA 3C          0018*       inc a
041CBB FE 01       0019*       cp max_channels
041CBD C2 AA 1C 04 0020*       jp nz,@loop
041CC1 C9          0021*       ret
041CC2             0022*   @beg:
041CC2 17 00 85    0023*               db 23, 0, $85
041CC5 00          0024*   @channel:   db 0
041CC6 08          0025*               db 8 ; command 8: enable channel
041CC7             0026*   @end:
041CC7             0027*   
041CC7             0028*   ; disable all but the three default sound channels
041CC7             0029*   ; inputs: max_channels set
041CC7             0030*   ; outputs: none
041CC7             0031*   ; destroys: ah,hl,bc
041CC7             0032*   vdu_disable_channels:
041CC7 3E 01       0033*       ld a,max_channels
041CC9 D6 03       0034*       sub 3 ; subtract number of default channels already enabled
041CCB F2 D2 1C 04 0035*       jp p,@loop
041CCF C9          0036*       ret
041CD0 3E 03       0037*       ld a,3 ; first non-default channel
041CD2             0038*   @loop:
041CD2 32 ED 1C 04 0039*       ld (@channel),a
041CD6 21 EA 1C 04 0040*       ld hl,@beg
041CDA 01 05 00 00 0041*       ld bc,@end-@beg
041CDE F5          0042*       push af
041CDF 5B DF       0043*       rst.lil $18
041CE1 F1          0044*       pop af
041CE2 3C          0045*       inc a
041CE3 FE 01       0046*       cp max_channels
041CE5 C2 D2 1C 04 0047*       jp nz,@loop
041CE9 C9          0048*       ret
041CEA             0049*   @beg:
041CEA 17 00 85    0050*       db 23, 0, $85
041CED 00          0051*   @channel: db 0
041CEE 09          0052*       db 9 ; command 9: disable channel
041CEF             0053*   @end:
041CEF             0054*   
041CEF             0055*   
041CEF             0056*   ; ############################################################
041CEF             0057*   ; VDU SOUND API
041CEF             0058*   ; ############################################################
041CEF             0059*   ; Command 0: Play note
041CEF             0060*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
041CEF             0061*       MACRO PLAY_NOTE channel, volume, frequency, duration
041CEF             0062*       ld hl, @PLAY_NOTE_CMD        ; Start of command block
041CEF             0063*       ld bc, @PLAY_NOTE_END - @PLAY_NOTE_CMD  ; Command block size
041CEF             0064*       rst.lil $18
041CEF             0065*       jr @PLAY_NOTE_END
041CEF             0066*   @PLAY_NOTE_CMD:  db 23, 0, 0x85               ; Command header
041CEF             0067*                    db channel                  ; Channel, 0 (commented out)
041CEF             0068*                    db 0                        ; Play note command
041CEF             0069*                    db volume                   ; Volume
041CEF             0070*                    dw frequency                ; Frequency
041CEF             0071*                    dw duration                 ; Duration
041CEF             0072*   @PLAY_NOTE_END:
041CEF             0073*       ENDMACRO
041CEF             0074*   
041CEF             0075*       MACRO MUTE_CHANNEL channel
041CEF             0076*       ld hl, @MUTE_CHANNEL_CMD     ; Start of command block
041CEF             0077*       ld bc, @MUTE_CHANNEL_END - @MUTE_CHANNEL_CMD  ; Command block size
041CEF             0078*       rst.lil $18
041CEF             0079*       jr @MUTE_CHANNEL_END
041CEF             0080*   @MUTE_CHANNEL_CMD: db 23, 0, 0x85             ; Command header
041CEF             0081*                      db channel                ; Channel, 0 (commented out)
041CEF             0082*                      db 2                      ; Set volume command
041CEF             0083*                      db 0                      ; Volume (mute)
041CEF             0084*   @MUTE_CHANNEL_END:
041CEF             0085*       ENDMACRO
041CEF             0086*   
041CEF             0087*   ; inputs: c = channel, b = volume, hl = frequency; de = duration;
041CEF             0088*   vdu_play_note:
041CEF 79          0089*       ld a,c
041CF0 32 10 1D 04 0090*       ld (@channel),a
041CF4 78          0091*       ld a,b
041CF5 32 12 1D 04 0092*       ld (@volume),a
041CF9 22 13 1D 04 0093*       ld (@frequency),hl
041CFD ED 53 15 1D 0094*       ld (@duration),de
       04          
041D02 21 0D 1D 04 0095*       ld hl,@cmd
041D06 01 0A 00 00 0096*       ld bc,@end-@cmd
041D0A 5B DF       0097*       rst.lil $18
041D0C C9          0098*       ret
041D0D 17 00 85    0099*   @cmd:       db 23, 0, 0x85
041D10 00          0100*   @channel:   db 0x00
041D11 00          0101*               db 0x00 ; play note command
041D12 00          0102*   @volume:    db 0x00
041D13 00 00       0103*   @frequency: dw 0x0000
041D15 00 00       0104*   @duration:  dw 0x0000
041D17 00          0105*   @end:       db 0x00 ; padding
041D18             0106*   
041D18             0107*   ; Command 1: Status
041D18             0108*   ; VDU 23, 0, &85, channel, 1
041D18             0109*   ; inputs: a = channel
041D18             0110*   ; Returns a bit mask indicating the status of the specified channel, or 255 if the channel is not valid, or has been disabled. The bit mask is as follows:
041D18             0111*   ; Bit 	Name 	Meaning
041D18             0112*   ; 0 	Active 	When set this indicates the channel is in use (has an active waveform)
041D18             0113*   ; 1 	Playing 	Indicates the channel is actively playing a note, and thus will reject calls to play a new note
041D18             0114*   ; 2 	Indefinite 	Set if the channel is playing an indefinite duration note
041D18             0115*   ; 3 	Has Volume Envelope 	Set if the channel has a volume envelope
041D18             0116*   ; 4 	Has Frequency Envelope 	Set if the channel has a frequency envelope
041D18             0117*   
041D18             0118*   ; Bits 5-7 are reserved for future use and, for enabled channels, will currently always be zero.
041D18             0119*   vdu_channel_status:
041D18 32 2A 1D 04 0120*       ld (@channel),a
041D1C 21 27 1D 04 0121*       ld hl,@cmd
041D20 01 05 00 00 0122*       ld bc,@end-@cmd
041D24 5B DF       0123*       rst.lil $18
041D26 C9          0124*       ret
041D27 17 00 85    0125*   @cmd:       db 23, 0, 0x85
041D2A 00          0126*   @channel:   db 0x00
041D2B 01          0127*               db 0x01 ; get channel status command
041D2C             0128*   @end:
041D2C             0129*   
041D2C             0130*   ; VDU 23, 0, &85, channel, 2, volume
041D2C             0131*   ; inputs: c = channel, b = volume
041D2C             0132*   ; Sets the volume of the specified channel. The volume is a value from 0 to 127, where 0 is silent and 127 is full volume. Values over 127 will be treated as 127 (with one exception described later).
041D2C             0133*   
041D2C             0134*   ; Specifying a channel of -1 (or 255) will set the global sound system volume level. (Requires Console8 VDP 2.5.0 or later.)
041D2C             0135*   
041D2C             0136*   ; Using this command provides more direct control over a channel than the play note command. It can be used to adjust the volume of a channel that is already playing a note.
041D2C             0137*   vdu_channel_volume:
041D2C 79          0138*       ld a,c
041D2D 32 44 1D 04 0139*       ld (@channel),a
041D31 78          0140*       ld a,b
041D32 32 46 1D 04 0141*       ld (@volume),a
041D36 21 41 1D 04 0142*       ld hl,@cmd
041D3A 01 06 00 00 0143*       ld bc,@end-@cmd
041D3E 5B DF       0144*       rst.lil $18
041D40 C9          0145*       ret
041D41 17 00 85    0146*   @cmd:       db 23, 0, 0x85
041D44 00          0147*   @channel:   db 0x00
041D45 02          0148*               db 0x02 ; set volume command
041D46 00          0149*   @volume:    db 0x00
041D47             0150*   @end:
041D47             0151*   
041D47             0152*   ; VDU 23, 0, &85, channel, 3, frequency;
041D47             0153*   
041D47             0154*   ; Sets the frequency of the specified channel. The frequency is a 16-bit value specifying in Hz the frequency of the note to be played.
041D47             0155*   
041D47             0156*   ; Using this command provides more direct control over a channel than the play note command. It can be used to adjust the frequency of a channel that is already playing a note.
041D47             0157*   
041D47             0158*   ; Returns 1 on success, 0 for failure.
041D47             0159*   vdu_channel_frequency:
041D47 79          0160*       ld a,c
041D48 32 5F 1D 04 0161*       ld (@channel),a
041D4C ED 53 61 1D 0162*       ld (@frequency),de
       04          
041D51 21 5C 1D 04 0163*       ld hl,@cmd
041D55 01 07 00 00 0164*       ld bc,@end-@cmd
041D59 5B DF       0165*       rst.lil $18
041D5B C9          0166*       ret
041D5C 17 00 85    0167*   @cmd:       db 23, 0, 0x85
041D5F 00          0168*   @channel:   db 0x00
041D60 03          0169*               db 0x03 ; set frequency command
041D61 00 00       0170*   @frequency: dw 0x0000
041D63 00          0171*   @end:       db 0x00 ; padding
041D64             0172*   
041D64             0173*   
041D64             0174*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
041D64             0175*   ; inputs: c = channel, b = waveformOrSample, [hl = bufferId]
041D64             0176*   ; Sets the waveform type for a channel to use. The waveformOrSample value is a single byte treated as a signed value.
041D64             0177*   
041D64             0178*   ; Using a negative value for the waveform indicates that a sample should be used instead. For more information see the documentation for the sample command.
041D64             0179*   
041D64             0180*   ; By default a channel is set to use waveform 0 (square wave).
041D64             0181*   
041D64             0182*   ; Valid waveform values are as follows:
041D64             0183*   ; Value 	Waveform
041D64             0184*   ; 0 	Square wave
041D64             0185*   ; 1 	Triangle wave
041D64             0186*   ; 2 	Sawtooth wave
041D64             0187*   ; 3 	Sine wave
041D64             0188*   ; 4 	Noise (simple white noise with no frequency support)
041D64             0189*   ; 5 	VIC Noise (emulates a VIC6561; supports frequency)
041D64             0190*   ; 8 	Sample (specifying a 16-bit buffer ID for sample data)
041D64             0191*   
041D64             0192*   vdu_channel_waveform:
041D64 79          0193*       ld a,c
041D65 32 8A 1D 04 0194*       ld (@channel),a
041D69 78          0195*       ld a,b
041D6A 32 8C 1D 04 0196*       ld (@waveform),a
041D6E FE 08       0197*       cp 8 ; check if the waveform is a sample
041D70 28 06       0198*       jr z, @sample
041D72 01 06 00 00 0199*       ld bc,@bufferId-@cmd
041D76 18 08       0200*       jr @sendToVdu
041D78             0201*   @sample:
041D78 22 8D 1D 04 0202*       ld (@bufferId),hl
041D7C 01 08 00 00 0203*       ld bc,@end-@cmd
041D80             0204*   @sendToVdu:
041D80 21 87 1D 04 0205*       ld hl,@cmd
041D84 5B DF       0206*       rst.lil $18
041D86 C9          0207*       ret
041D87 17 00 85    0208*   @cmd:       db 23, 0, 0x85
041D8A 00          0209*   @channel:   db 0x00
041D8B 04          0210*               db 0x04 ; set waveform command
041D8C 00          0211*   @waveform:  db 0x00
041D8D 00 00       0212*   @bufferId:  dw 0x0000
041D8F 00          0213*   @end:       db 0x00 ; padding
041D90             0214*   
041D90             0215*   ; VDU 23, 0, &85, channel (ignored), 5, 2, bufferId; format, [sampleRate;]
041D90             0216*   ; inputs: hl = bufferId; a = format, de = sample rate in Hz
041D90             0217*   ; The format is a single byte giving the format of the sample data. The following formats are supported:
041D90             0218*   ; Value	Description
041D90             0219*   ; 0	8-bit signed
041D90             0220*   ; 1	8-bit unsigned
041D90             0221*   ; The format value can also have modifier bits set to modify the behaviour of the sample. The following modifier bits are supported:
041D90             0222*   ; Value	Description
041D90             0223*   ; 8	sample rate is sent in the next 16-bits
041D90             0224*   ; 16	sample is tuneable
041D90             0225*   ; The default sample rate for samples on the VDP is 16kHz (actually 16.384kHz to be precise).
041D90             0226*   vdu_buffer_to_sound:
041D90 22 B0 1D 04 0227*       ld (@bufferId),hl
041D94 C6 08       0228*       add a,8 ; modify format byte to indicate sample rate argument is given
041D96 32 B2 1D 04 0229*       ld (@format),a
041D9A ED 53 B3 1D 0230*       ld (@sampleRate),de
       04          
041D9F 21 AA 1D 04 0231*       ld hl,@cmd
041DA3 01 0B 00 00 0232*       ld bc,@end-@cmd
041DA7 5B DF       0233*       rst.lil $18
041DA9 C9          0234*       ret
041DAA 17 00 85    0235*   @cmd:       db 23, 0, 0x85
041DAD 00          0236*   @channel:   db 0x00 ; ignored
041DAE 05          0237*               db 0x05 ; buffer to sound command
041DAF 02          0238*               db 0x02 ; command 2 create sample
041DB0 00 00       0239*   @bufferId:  dw 0x0000
041DB2 00          0240*   @format:    db 0x00
041DB3 00 00       0241*   @sampleRate: dw 0x0000
041DB5 00          0242*   @end:       db 0x00 ; padding
041DB6             0243*   
041DB6             0244*   ; Command 13: Set sample rate
041DB6             0245*   ; VDU 23, 0, &85, channel, 13, sampleRate;
041DB6             0246*   ; inputs: c = channel, hl = sampleRate (Hz)
041DB6             0247*   vdu_set_sample_rate:
041DB6 79          0248*       ld a,c
041DB7 32 CD 1D 04 0249*       ld (@channel),a
041DBB 22 CF 1D 04 0250*       ld (@sampleRate),hl
041DBF 21 CA 1D 04 0251*       ld hl,@cmd
041DC3 01 07 00 00 0252*       ld bc,@end-@cmd
041DC7 5B DF       0253*       rst.lil $18
041DC9 C9          0254*       ret
041DCA 17 00 85    0255*   @cmd:       db 23, 0, 0x85
041DCD 00          0256*   @channel:   db 0x00
041DCE 0D          0257*               db 13 ; set sample rate command
041DCF 00 00       0258*   @sampleRate: dw 0x0000
041DD1 00          0259*   @end:       db 0x00 ; padding
041DD2             0260*   
041DD2             0261*   ; load a sound file to a buffer
041DD2             0262*   ; inputs: hl = bufferId ; de = sampleRate in Hz ; iy = pointer to filename
041DD2             0263*   vdu_load_sfx:
041DD2             0264*   ; back up input parameters
041DD2 E5          0265*       push hl ; bufferId
041DD3 D5          0266*       push de ; sample rate
041DD4             0267*   ; load the sound
041DD4 CD 12 19 04 0268*       call vdu_load_buffer_from_file
041DD8             0269*   ; now make the buffer a sound sample
041DD8 D1          0270*       pop de ; sample rate
041DD9 E1          0271*       pop hl ; bufferId
041DDA AF          0272*       xor a ; zero is the magic number for mono 8-bit signed PCM
041DDB CD 90 1D 04 0273*       call vdu_buffer_to_sound
041DDF C9          0274*       ret
041DE0             0275*   
041DE0             0276*   
041DE0 00          0277*   last_channel: db 0
041DE1             0278*   max_channels: equ 1
041DE1             0279*   
041DE1             0280*   ; play a sound effect from an already loaded buffer
041DE1             0281*   ; inputs: hl = bufferId ; bc = duration in milliseconds
041DE1             0282*   vdu_play_sfx:
041DE1 22 19 1E 04 0283*       ld (@bufferId),hl
041DE5 ED 43 23 1E 0284*       ld (@duration),bc
       04          
041DEA 3E 17       0285*       ld a,23
041DEC 32 1B 1E 04 0286*       ld (@bufferId+2),a
041DF0 3A E0 1D 04 0287*       ld a,(last_channel)
041DF4 3C          0288*       inc a
041DF5             0289*       ; and 31 ; modulo 32
041DF5 FE 01       0290*       cp max_channels
041DF7 C2 FC 1D 04 0291*       jp nz,@load_channel
041DFB AF          0292*       xor a
041DFC             0293*   @load_channel:
041DFC 32 E0 1D 04 0294*       ld (last_channel),a
041E00 32 16 1E 04 0295*       ld (@channel0),a
041E04 32 1E 1E 04 0296*       ld (@channel1),a
041E08 21 13 1E 04 0297*       ld hl, @sample
041E0C 01 12 00 00 0298*       ld bc, @sample_end - @sample
041E10 5B DF       0299*       rst.lil $18
041E12 C9          0300*       ret
041E13             0301*   @sample:
041E13             0302*   ; Command 4: Set waveform
041E13             0303*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
041E13 17 00 85    0304*       .db 23,0,$85                        ; do sound
041E16             0305*   @channel0:
041E16 00 04 08    0306*       .db 0,4,8 ; channel, command, waveform
041E19             0307*   @bufferId:
041E19 00 00       0308*       .dw 0x0000
041E1B             0309*   ; Command 0: Play note
041E1B             0310*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
041E1B 17 00 85    0311*       .db 23,0,$85                        ; do sound
041E1E             0312*   @channel1:
041E1E 00 00 7F    0313*       .db 0,0,127                ; channel, volume
041E21 00 00       0314*       .dw 0
041E23             0315*   @duration:                              ; freq (tuneable samples only)
041E23 00 00       0316*       .dw 0x0000                        ; duration
041E25             0317*   @sample_end:
041E25 00          0318*       .db 0x00 ; padding
041E26             0319*   
041E26             0320*   ; inputs: c = channel, b = volume, de = sample rate; hl = bufferId;
041E26             0321*   vdu_play_sample:
041E26             0322*       ; populate input parameters
041E26 79          0323*       ld a,c
041E27 32 59 1E 04 0324*       ld (@channel0),a
041E2B 32 61 1E 04 0325*       ld (@channel1),a
041E2F 32 68 1E 04 0326*       ld (@channel2),a
041E33 78          0327*       ld a,b
041E34 32 6A 1E 04 0328*       ld (@volume),a
041E38 ED 53 63 1E 0329*       ld (@sampleRate),de
       04          
041E3D 22 5C 1E 04 0330*       ld (@bufferId),hl
041E41 3E 17       0331*       ld a,23
041E43 32 5E 1E 04 0332*       ld (@cmd1),a
041E47 32 65 1E 04 0333*       ld (@cmd2),a
041E4B             0334*       ; prep the vdu command string
041E4B 21 56 1E 04 0335*       ld hl, @cmd0
041E4F 01 19 00 00 0336*       ld bc, @end - @cmd0
041E53 5B DF       0337*       rst.lil $18
041E55 C9          0338*       ret
041E56             0339*   ; set waveform command
041E56 17 00 85    0340*   @cmd0:       db 23, 0, 0x85
041E59 00          0341*   @channel0:   db 0x00
041E5A 04          0342*                db 0x04 ; set waveform command
041E5B 08          0343*   @waveform:   db 0x08 ; sample
041E5C 00 00       0344*   @bufferId:   dw 0x0000
041E5E             0345*   ; set sample rate command
041E5E 17 00 85    0346*   @cmd1:       db 23, 0, 0x85
041E61 00          0347*   @channel1:   db 0x00
041E62 0D          0348*               db 13 ; set sample rate command
041E63 00 00       0349*   @sampleRate: dw 0x0000
041E65             0350*   ; play note command
041E65 17 00 85    0351*   @cmd2:       db 23, 0, 0x85
041E68 00          0352*   @channel2:   db 0x00
041E69 00          0353*                db 0x00 ; play note command
041E6A 00          0354*   @volume:     db 0x00
041E6B 00 00       0355*   @frequency:  dw 0x00 ; no effect unless buffer has been set to tuneable sample
041E6D 00 00       0356*   @duration:   dw 0x0000 ; milliseconds: set to -1 to loop indefinitely, 0 to play full duration once
041E6F 00          0357*   @end:        db 0x00 ; padding
041E70             0044    
041E70             0045    ; APPLICATION INCLUDES
041E70             0046        include "layout.inc"
041E70             0001*   text_right: equ 63       ; 64 columns, zero-based
041E70             0002*   text_bottom: equ 47      ; 48 rows, zero-based
041E70             0003*   
041E70             0004*   ; set text viewport for current playing song
041E70             0005*   vp_now_playing_left: equ 0
041E70             0006*   vp_now_playing_top: equ 0
041E70             0007*   vp_now_playing_right: equ text_right
041E70             0008*   vp_now_playing_bottom: equ vp_now_playing_top+1
041E70             0009*   
041E70             0010*   vp_now_playing:
041E70 0E 00       0011*       ld c, vp_now_playing_left
041E72 16 00       0012*       ld d, vp_now_playing_top
041E74 1E 3F       0013*       ld e, vp_now_playing_right
041E76 06 01       0014*       ld b, vp_now_playing_bottom
041E78 CD 5D 17 04 0015*       call vdu_set_txt_viewport
041E7C C9          0016*       ret
041E7D             0017*   ; end vp_now_playing
041E7D             0018*   
041E7D             0019*   ; set text viewport for playing breadcrumbs
041E7D             0020*   vp_breadcrumbs_left: equ 0
041E7D             0021*   vp_breadcrumbs_top: equ 1
041E7D             0022*   vp_breadcrumbs_right: equ text_right
041E7D             0023*   vp_breadcrumbs_bottom: equ vp_breadcrumbs_top
041E7D             0024*   
041E7D             0025*   vp_breadcrumbs:
041E7D 0E 00       0026*       ld c, vp_breadcrumbs_left
041E7F 16 01       0027*       ld d, vp_breadcrumbs_top
041E81 1E 3F       0028*       ld e, vp_breadcrumbs_right
041E83 06 01       0029*       ld b, vp_breadcrumbs_bottom
041E85 CD 5D 17 04 0030*       call vdu_set_txt_viewport
041E89 C9          0031*       ret
041E8A             0032*   ; end vp_breadcrumbs
041E8A             0033*   
041E8A             0034*   ; set text viewport for directory listing
041E8A             0035*   vp_dir_left: equ 0
041E8A             0036*   vp_dir_top: equ 30
041E8A             0037*   vp_dir_right: equ text_right
041E8A             0038*   vp_dir_bottom: equ vp_dir_top+10
041E8A             0039*   vp_dir:
041E8A 0E 00       0040*       ld c,vp_dir_left
041E8C 16 1E       0041*       ld d,vp_dir_top
041E8E 1E 3F       0042*       ld e,vp_dir_right
041E90 06 28       0043*       ld b,vp_dir_bottom
041E92 CD 5D 17 04 0044*       call vdu_set_txt_viewport
041E96 C9          0045*       ret
041E97             0046*   
041E97             0047*   ; print bottom border of directory listing
041E97             0048*   print_dir_border_bottom:
041E97 0E 00       0049*       ld c,vp_dir_left
041E99 16 28       0050*       ld d,vp_dir_bottom
041E9B 1E 3F       0051*       ld e,text_right
041E9D 06 28       0052*       ld b,vp_dir_bottom
041E9F CD 5D 17 04 0053*       call vdu_set_txt_viewport
041EA3 21 80 2F 04 0054*       ld hl,str_thick_dashes
041EA7 CD 67 00 04 0055*       call printString
041EAB C9          0056*       ret
041EAC             0057*   ; end vp_dir_border
041EAC             0058*   
041EAC             0059*   vp_prt_reload_left: equ 0
041EAC             0060*   vp_prt_reload_top: equ vp_dir_bottom+1
041EAC             0061*   vp_prt_reload_right: equ text_right
041EAC             0062*   vp_prt_reload_bottom: equ vp_prt_reload_top
041EAC             0063*   vp_prt_reload:
041EAC 0E 00       0064*       ld c,vp_prt_reload_left
041EAE 16 29       0065*       ld d,vp_prt_reload_top
041EB0 1E 3F       0066*       ld e,vp_prt_reload_right
041EB2 06 29       0067*       ld b,vp_prt_reload_bottom
041EB4 CD 5D 17 04 0068*       call vdu_set_txt_viewport
041EB8 CD 04 17 04 0069*       call vdu_cls
041EBC CD 60 00 04 0070*       call printInline
041EC0 50 52 54 20 0071*       asciz "PRT reload: "
       72 65 6C 6F 
       61 64 3A 20 
       00          
041ECD 2A BD 29 04 0072*       ld hl,(ps_prt_reload)
041ED1 CD CC 00 04 0073*       call printDec
041ED5 C9          0074*       ret
041ED6             0047        include "ascii.inc"
041ED6             0001*   agon_jukebox_ascii:
041ED6 20 20 20 5F 0002*       db 32,32,32,95,95,95,95,95,32,32,32,32,95,95,95,95,95,95,95,95,32,95,95,95,95,95,95,95,95,32,32,32,32,95,95,95,95,95,95,95,13,10
       5F 5F 5F 5F 
       20 20 20 20 
       5F 5F 5F 5F 
       5F 5F 5F 5F 
       20 5F 5F 5F 
       5F 5F 5F 5F 
       5F 20 20 20 
       20 5F 5F 5F 
       5F 5F 5F 5F 
       0D 0A       
041F00 20 20 2F 20 0003*       db 32,32,47,32,32,95,32,32,92,32,32,47,32,32,95,95,95,95,95,47,32,92,95,95,95,95,95,32,32,92,32,32,32,92,32,32,32,32,32,32,92,13,10
       20 5F 20 20 
       5C 20 20 2F 
       20 20 5F 5F 
       5F 5F 5F 2F 
       20 5C 5F 5F 
       5F 5F 5F 20 
       20 5C 20 20 
       20 5C 20 20 
       20 20 20 20 
       5C 0D 0A    
041F2B 20 2F 20 20 0004*       db 32,47,32,32,47,95,92,32,32,92,47,32,32,32,92,32,32,95,95,95,32,32,47,32,32,32,124,32,32,32,92,32,32,47,32,32,32,124,32,32,32,92,13,10
       2F 5F 5C 20 
       20 5C 2F 20 
       20 20 5C 20 
       20 5F 5F 5F 
       20 20 2F 20 
       20 20 7C 20 
       20 20 5C 20 
       20 2F 20 20 
       20 7C 20 20 
       20 5C 0D 0A 
041F57 2F 20 20 20 0005*       db 47,32,32,32,32,124,32,32,32,32,92,32,32,32,32,92,95,92,32,32,92,47,32,32,32,32,124,32,32,32,32,92,47,32,32,32,32,124,32,32,32,32,92,13,10
       20 7C 20 20 
       20 20 5C 20 
       20 20 20 5C 
       5F 5C 20 20 
       5C 2F 20 20 
       20 20 7C 20 
       20 20 20 5C 
       2F 20 20 20 
       20 7C 20 20 
       20 20 5C 0D 
       0A          
041F84 5C 5F 5F 5F 0006*       db 92,95,95,95,95,124,95,95,32,32,47,92,95,95,95,95,95,95,32,32,47,92,95,95,95,95,95,95,95,32,32,47,92,95,95,95,95,124,95,95,32,32,47,13,10
       5F 7C 5F 5F 
       20 20 2F 5C 
       5F 5F 5F 5F 
       5F 5F 20 20 
       2F 5C 5F 5F 
       5F 5F 5F 5F 
       5F 20 20 2F 
       5C 5F 5F 5F 
       5F 7C 5F 5F 
       20 20 2F 0D 
       0A          
041FB1 20 20 20 20 0007*       db 32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,32,92,47,13,10
       20 20 20 20 
       5C 2F 20 20 
       20 20 20 20 
       20 20 5C 2F 
       20 20 20 20 
       20 20 20 20 
       20 5C 2F 20 
       20 20 20 20 
       20 20 20 20 
       5C 2F 0D 0A 
041FDD 20 20 20 20 0008*       db 32,32,32,32,32,95,95,95,95,32,95,95,95,95,32,95,95,95,32,95,95,95,95,32,32,95,95,32,95,95,95,95,95,95,95,95,95,95,95,13,10
       20 5F 5F 5F 
       5F 20 5F 5F 
       5F 5F 20 5F 
       5F 5F 20 5F 
       5F 5F 5F 20 
       20 5F 5F 20 
       5F 5F 5F 5F 
       5F 5F 5F 5F 
       5F 5F 5F 0D 
       0A          
042006 20 20 20 20 0009*       db 32,32,32,32,124,32,32,32,32,124,32,32,32,32,124,32,32,32,92,32,32,32,32,124,47,32,95,124,92,95,32,32,32,95,95,95,95,95,47,13,10
       7C 20 20 20 
       20 7C 20 20 
       20 20 7C 20 
       20 20 5C 20 
       20 20 20 7C 
       2F 20 5F 7C 
       5C 5F 20 20 
       20 5F 5F 5F 
       5F 5F 2F 0D 
       0A          
04202F 20 20 20 20 0010*       db 32,32,32,32,124,32,32,32,32,124,32,32,32,32,124,32,32,32,47,32,32,32,32,32,32,60,32,32,32,124,32,32,32,32,95,95,41,95,13,10
       7C 20 20 20 
       20 7C 20 20 
       20 20 7C 20 
       20 20 2F 20 
       20 20 20 20 
       20 3C 20 20 
       20 7C 20 20 
       20 20 5F 5F 
       29 5F 0D 0A 
042057 2F 5C 5F 5F 0011*       db 47,92,95,95,124,32,32,32,32,124,32,32,32,32,124,32,32,47,124,32,32,32,32,124,32,32,92,32,32,124,32,32,32,32,32,32,32,32,92,13,10
       7C 20 20 20 
       20 7C 20 20 
       20 20 7C 20 
       20 2F 7C 20 
       20 20 20 7C 
       20 20 5C 20 
       20 7C 20 20 
       20 20 20 20 
       20 20 5C 0D 
       0A          
042080 5C 5F 5F 5F 0012*       db 92,95,95,95,95,95,95,95,95,124,95,95,95,95,95,95,47,32,124,95,95,95,95,124,95,95,32,92,47,95,95,95,95,95,95,95,32,32,47,13,10
       5F 5F 5F 5F 
       5F 7C 5F 5F 
       5F 5F 5F 5F 
       2F 20 7C 5F 
       5F 5F 5F 7C 
       5F 5F 20 5C 
       2F 5F 5F 5F 
       5F 5F 5F 5F 
       20 20 2F 0D 
       0A          
0420A9 20 20 20 20 0013*       db 32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,92,47,13,10
       20 20 20 20 
       20 20 20 20 
       20 20 20 20 
       20 20 20 20 
       20 20 20 20 
       20 20 5C 2F 
       20 20 20 20 
       20 20 20 20 
       5C 2F 0D 0A 
0420D1 20 20 20 20 0014*       db 32,32,32,32,95,95,95,95,95,95,95,95,95,95,32,95,95,95,95,95,95,95,95,32,32,95,95,95,95,32,32,95,95,95,13,10
       5F 5F 5F 5F 
       5F 5F 5F 5F 
       5F 5F 20 5F 
       5F 5F 5F 5F 
       5F 5F 5F 20 
       20 5F 5F 5F 
       5F 20 20 5F 
       5F 5F 0D 0A 
0420F5 20 20 20 20 0015*       db 32,32,32,32,92,95,95,95,95,95,95,32,32,32,92,92,95,95,95,95,95,32,32,92,32,92,32,32,32,92,47,32,32,47,13,10
       5C 5F 5F 5F 
       5F 5F 5F 20 
       20 20 5C 5C 
       5F 5F 5F 5F 
       5F 20 20 5C 
       20 5C 20 20 
       20 5C 2F 20 
       20 2F 0D 0A 
042119 20 20 20 20 0016*       db 32,32,32,32,32,124,32,32,32,32,124,32,32,95,47,32,47,32,32,32,124,32,32,32,92,32,92,32,32,32,32,32,47,13,10
       20 7C 20 20 
       20 20 7C 20 
       20 5F 2F 20 
       2F 20 20 20 
       7C 20 20 20 
       5C 20 5C 20 
       20 20 20 20 
       2F 0D 0A    
04213C 20 20 20 20 0017*       db 32,32,32,32,32,124,32,32,32,32,124,32,32,32,92,47,32,32,32,32,124,32,32,32,32,92,47,32,32,32,32,32,92,13,10
       20 7C 20 20 
       20 20 7C 20 
       20 20 5C 2F 
       20 20 20 20 
       7C 20 20 20 
       20 5C 2F 20 
       20 20 20 20 
       5C 0D 0A    
04215F 20 20 20 20 0018*       db 32,32,32,32,32,124,95,95,95,95,95,95,32,32,47,92,95,95,95,95,95,95,95,32,32,47,95,95,95,47,92,32,32,92,13,10
       20 7C 5F 5F 
       5F 5F 5F 5F 
       20 20 2F 5C 
       5F 5F 5F 5F 
       5F 5F 5F 20 
       20 2F 5F 5F 
       5F 2F 5C 20 
       20 5C 0D 0A 
042183 20 20 20 20 0019*       db 32,32,32,32,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,92,95,47,13,10
       20 20 20 20 
       20 20 20 20 
       5C 2F 20 20 
       20 20 20 20 
       20 20 20 5C 
       2F 20 20 20 
       20 20 20 5C 
       5F 2F 0D 0A 
0421A7             0048        include "input_dir.inc"
0421A7             0001*   get_input:
0421A7             0002*   @loop:
0421A7             0003*   ; wait for the user to push a button
0421A7             0004*       MOSCALL mos_getkey ; a = ascii code of key pressed
                       M1 Args: function=mos_getkey 
0421A7 3E 00       0001*M1 			LD	A, function
0421A9 5B CF       0002*M1 			RST.LIL	08h
0421AB F3          0005*       di ; disable interrupts
0421AC             0006*       ; rst.lil 10h ; print the key pressed
0421AC             0007*   ; app control commands
0421AC FE 1B       0008*       cp '\e' ; escape
0421AE C8          0009*       ret z ; returns to main, which re-enables interrupts and exits app
0421AF             0010*   ; prt time tweaking
0421AF FE 5B       0011*       cp '[' ; decrease PRT timer reload value
0421B1 C2 D3 21 04 0012*       jp nz,@F
0421B5 2A BD 29 04 0013*       ld hl,(ps_prt_reload)
0421B9 11 B8 FF FF 0014*       ld de,-72 ; 1 ms
0421BD 19          0015*       add hl,de
0421BE 22 BD 29 04 0016*       ld (ps_prt_reload),hl
0421C2 CD AC 1E 04 0017*       call vp_prt_reload
0421C6 CD 7D 1E 04 0018*       call vp_breadcrumbs
0421CA CD C0 29 04 0019*       call ps_prt_start
0421CE FB          0020*       ei
0421CF C3 A7 21 04 0021*       jp @loop
0421D3             0022*   @@:
0421D3 FE 5D       0023*       cp ']' ; increase PRT timer reload value
0421D5 C2 F7 21 04 0024*       jp nz,@F
0421D9 2A BD 29 04 0025*       ld hl,(ps_prt_reload)
0421DD 11 48 00 00 0026*       ld de,72 ; 1 ms
0421E1 19          0027*       add hl,de
0421E2 22 BD 29 04 0028*       ld (ps_prt_reload),hl
0421E6 CD AC 1E 04 0029*       call vp_prt_reload
0421EA CD 7D 1E 04 0030*       call vp_breadcrumbs
0421EE CD C0 29 04 0031*       call ps_prt_start
0421F2 FB          0032*       ei
0421F3 C3 A7 21 04 0033*       jp @loop
0421F7             0034*   ; DIRECTORY PAGING
0421F7             0035*   @@:
0421F7 FE 15       0036*       cp 0x15 ; right arrow
0421F9 CA 7C 28 04 0037*       jp z,ps_dir_next_page
0421FD FE 08       0038*       cp 0x08 ; left arrow
0421FF CA 9F 28 04 0039*       jp z,ps_dir_prev_page
042203             0040*   ; SONG PLAYING COMMANDS
042203             0041*   ; toggle pause playback
042203 FE 70       0042*       cp 'p'
042205 C2 4B 22 04 0043*       jp nz,@F
042209 3E 01       0044*       ld a,ps_mode_playing
04220B 21 6C 22 04 0045*       ld hl,ps_mode
04220F AE          0046*       xor a,(hl)
042210 77          0047*       ld (hl),a
042211 C3 A7 21 04 0048*       jp @loop
042215             0049*   ; toggle loop play
042215 FE 6C       0050*       cp 'l'
042217 C2 4B 22 04 0051*       jp nz,@F
04221B 3E 0A       0052*       ld a,ps_mode_loop
04221D 21 6C 22 04 0053*       ld hl,ps_mode
042221 AE          0054*       xor a,(hl)
042222 77          0055*       ld (hl),a
042223 C3 A7 21 04 0056*       jp @loop
042227             0057*   ; toggle shuffle play
042227 FE 73       0058*       cp 's'
042229 C2 4B 22 04 0059*       jp nz,@F
04222D 3E 04       0060*       ld a,ps_mode_shuffle
04222F 21 6C 22 04 0061*       ld hl,ps_mode
042233 AE          0062*       xor a,(hl)
042234 77          0063*       ld (hl),a
042235 C3 A7 21 04 0064*       jp @loop
042239             0065*   ; play random song
042239 FE 72       0066*       cp 'r'
04223B C2 4B 22 04 0067*       jp nz,@F
04223F 3E 04       0068*       ld a,ps_mode_shuffle
042241 21 6C 22 04 0069*       ld hl,ps_mode
042245 B6          0070*       or a,(hl)
042246 77          0071*       ld (hl),a
042247 C3 E8 28 04 0072*       jp ps_play_random
04224B             0073*   ; 0-9 play song keys
04224B             0074*   @@:
04224B FE 30       0075*       cp '0'
04224D DA 67 22 04 0076*       jp c,@no_cmd ; not a song command
042251 FE 3A       0077*       cp '9'+1
042253 D2 67 22 04 0078*       jp nc,@no_cmd ; not a song command
042257 F5          0079*       push af ; preserve keypress
042258 CD 09 27 04 0080*       call ps_close_file
04225C F1          0081*       pop af ; restore keypress
04225D             0082*   ; get pointer to song filename and play it
04225D D6 30       0083*       sub '0' ; a = index into filename lut
04225F CD C6 28 04 0084*       call ps_get_song_fn_from_pg_idx ; carry set indicates success
042263 DA 48 26 04 0085*       jp c,play_song ; re-enables interrupts and jp's to get_input when finished
042267             0086*   @no_cmd: ; no valid commands so loop
042267 FB          0087*       ei ; reenable interrupts
042268 C3 A7 21 04 0088*       jp @loop
04226C             0089*   ; end get_input
04226C             0049        include "play_dir.inc"
04226C             0001*   ; stream a song from the SD card
04226C             0002*   ; inputs: hl = pointer to filename
04226C             0003*   ; requirements: the file must be 8-bit signed PCM mono
04226C             0004*   ; uses: sound channels 0 and 1, buffers 0x3000 and 0x3001
04226C             0005*   ; play_song constants
04226C             0006*   ch0_buffer: equ 0x3000
04226C             0007*   ch1_buffer: equ 0x3001
04226C             0008*   cmd0_buffer: equ 0x3002
04226C             0009*   cmd1_buffer: equ 0x3003
04226C             0010*   
04226C             0011*   ; ps_mode bitmasks
04226C             0012*   ps_mode_playing: equ %00000001 ; 0 = paused 1 = playing, p key toggles
04226C             0013*   ps_mode_loop:    equ 000000010 ; 0 = no loop 1 = loop (overrides ps_mode_shuffle if on), l key toggles
04226C             0014*   ps_mode_shuffle: equ %00000100 ; 0 = shuffle off 1 = on, s key toggles
04226C             0015*   
04226C             0016*   ; play_song state variables
04226C             0017*   ; current active channel and bufferId's
04226C 00          0018*   ps_mode: db 0 ; playback mode bitmask
04226D 00          0019*   ps_channel: db 0 ; channel number
04226E 00 00 00    0020*   ps_cmdId: dl 0 ; command bufferId
042271 00 00 00    0021*   ps_sampleId: dl 0 ; sample bufferId
042274 00 00 00 00 0022*   ps_dir_path:   blkw 256,0 ; path of the current directory
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042474 00 00 00    0023*   ps_dir_num_files: dl 0 ; number of files/directories in the directory (virtually unlimited)
042477 00 00 00    0024*   ps_dir_num_pages: dl 0 ; number of pages in the directory (virtually unlimited)
04247A 00 00 00    0025*   ps_page_num_files: dl 0 ; number of files/directories in the current directory page (max 10)
04247D 00 00 00    0026*   ps_pagelast_num_files: dl 0 ; mod(ps_dir_num_files,10)
042480 00 00 00    0027*   ps_page_cur: dl 0 ; current directory page number
042483 00          0028*   ps_song_idx_cur: db 0 ; current song index in the directory page
042484 00 00 00    0029*   ps_song_fn_cur: dl 0 ; pointer to current song filename
042487 00 00 00 00 0030*   ps_page_fn_ptrs: blkw 10*3,0 ; list of filename pointers in the current directory page
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0424C3             0031*   
0424C3             0032*   ; play_song directory info
0424C3             0033*   ps_dir_struct:
0424C3 00 00 00 00 0034*   ps_dptr:       blkb  4,0   ; Current read/write offset
0424C7 00 00 00 00 0035*   ps_clust:      blkb  4,0   ; Current cluster
0424CB 00 00 00 00 0036*   ps_sect:       blkb  4,0   ; Current sector (0:Read operation has terminated)
0424CF 00 00 00    0037*   ps_dir:        blkb  3,0   ; Pointer to the directory item in the win[]
0424D2 00 00 00 00 0038*   ps_fn:         blkb  12,0  ; SFN (in/out) {body[8],ext[3],status[1]}
       00 00 00 00 
       00 00 00 00 
0424DE 00 00 00 00 0039*   ps_blk_ofs:    blkb  4,0   ; Offset of current entry block being processed (0xFFFFFFFF:Invalid)
0424E2             0040*   
0424E2             0041*   ; play_song file info
0424E2 00          0042*   ps_filehandle_cur: db 0 ; file handle
0424E3 00 00 00    0043*   ps_chunkpointer: dl 0 ; pointer to current chunk
0424E6             0044*   ; File information structure (FILINFO)
0424E6             0045*   ps_filinfo_struct:
0424E6 00 00 00 00 0046*   ps_filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
0424EA 00 00       0047*   ps_filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
0424EC 00 00       0048*   ps_filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
0424EE 00          0049*   ps_filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
0424EF 00 00 00 00 0050*   ps_filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
0424FC 00 00 00 00 0051*   ps_filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0425FC             0052*   
0425FC             0053*   ; buffer for play_song sound data
0425FC             0054*   ps_wav_header: ; marker for top of the wav file header and song data
0425FC             0055*   ; (must be last so buffer doesn't overwrite other program code or data)
0425FC             0056*   ; .wav header data
0425FC             0057*   ; WAV File Structure in Memory with LIST Chunk
0425FC 00 00 00 00 0058*   ps_wav_riff:          blkb 4,0   ; 4 bytes: "RIFF" identifier
042600 00 00 00 00 0059*   ps_wav_file_size:     blkb 4,0   ; 4 bytes: Total file size minus 8 bytes for RIFF header
042604 00 00 00 00 0060*   ps_wav_wave:          blkb 4,0   ; 4 bytes: "WAVE" identifier
042608 00 00 00 00 0061*   ps_wav_fmt_marker:    blkb 4,0   ; 4 bytes: "fmt " subchunk marker
04260C 00 00 00 00 0062*   ps_wav_fmt_size:      blkb 4,0   ; 4 bytes: Format chunk size (16 for PCM)
042610 00 00       0063*   ps_wav_audio_format:  blkb 2,0   ; 2 bytes: Audio format (1 = PCM)
042612 00 00       0064*   ps_wav_num_channels:  blkb 2,0   ; 2 bytes: Number of channels (1 = mono, 2 = stereo)
042614 00 00 00 00 0065*   ps_wav_sample_rate:   blkb 4,0   ; 4 bytes: Sample rate in Hz (e.g., 32768)
042618 00 00 00 00 0066*   ps_wav_byte_rate:     blkb 4,0   ; 4 bytes: Bytes per second (SampleRate * NumChannels * BitsPerSample / 8)
04261C 00 00       0067*   ps_wav_block_align:   blkb 2,0   ; 2 bytes: Bytes per sample block (NumChannels * BitsPerSample / 8)
04261E 00 00       0068*   ps_wav_bits_per_sample: blkb 2,0 ; 2 bytes: Bits per sample (e.g., 8 or 16)
042620             0069*   
042620             0070*   ; LIST Chunk (Extra Metadata)
042620 00 00 00 00 0071*   ps_wav_list_marker:   blkb 4,0   ; 4 bytes: "LIST" marker
042624 00 00 00 00 0072*   ps_wav_list_size:     blkb 4,0   ; 4 bytes: Size of the LIST chunk (e.g., 26)
042628 00 00 00 00 0073*   ps_wav_info_marker:   blkb 4,0   ; 4 bytes: "INFO" marker
04262C 00 00 00 00 0074*   ps_wav_isft_marker:   blkb 4,0   ; 4 bytes: "ISFT" marker (software identifier)
042630 00 00 00 00 0075*   ps_wav_isft_data:     blkb 14,0  ; 14 bytes: Software info string (e.g., "Lavf59.27.100")
       00 00 00 00 
       00 00 00 00 
       00 00       
04263E 00 00       0076*   ps_wav_isft_padding:  blkb 2,0   ; 2 bytes: Padding/NULL terminator for alignment
042640             0077*   
042640             0078*   ; Data Chunk
042640 00 00 00 00 0079*   ps_wav_data_marker:   blkb 4,0   ; 4 bytes: "data" subchunk marker
042644 00 00 00 00 0080*   ps_wav_data_size:     blkb 4,0   ; 4 bytes: Size of the audio data in bytes
042648             0081*   ; Total Header Size: 76 bytes
042648             0082*   play_song:
042648 22 84 24 04 0083*       ld (ps_song_fn_cur),hl
04264C             0084*   ; stop the PRT timer
04264C CD DD 29 04 0085*       call ps_prt_stop
042650             0086*   ; tell the user what they've won
042650 CD 70 1E 04 0087*       call vp_now_playing
042654 CD 04 17 04 0088*       call vdu_cls
042658 2A 84 24 04 0089*       ld hl,(ps_song_fn_cur)
04265C CD 60 00 04 0090*       call printInline
042660 50 6C 61 79 0091*       asciz "Playing song: "
       69 6E 67 20 
       73 6F 6E 67 
       3A 20 00    
04266F 2A 84 24 04 0092*       ld hl,(ps_song_fn_cur)
042673 CD 67 00 04 0093*       call printString ; print the song filename
042677             0094*   ; highlight the song being played
042677 CD 3E 28 04 0095*       call ps_highlight_song
04267B             0096*   ; reset text viewport for playing breadcrumbs
04267B CD 7D 1E 04 0097*       call vp_breadcrumbs
04267F             0098*   ; open the file in read mode
04267F             0099*   ; Open a file
04267F             0100*   ; HLU: Filename
04267F             0101*   ;   C: Mode
04267F             0102*   ; Returns:
04267F             0103*   ;   A: Filehandle, or 0 if couldn't open
04267F 2A 84 24 04 0104*       ld hl,(ps_song_fn_cur)
042683 0E 01       0105*   	ld c,fa_read
042685             0106*       MOSCALL mos_fopen
                       M1 Args: function=mos_fopen 
042685 3E 0A       0001*M1 			LD	A, function
042687 5B CF       0002*M1 			RST.LIL	08h
042689 32 E2 24 04 0107*       ld (ps_filehandle_cur),a
04268D             0108*   ; read the .wav header data and copy it to the buffer
04268D CD 18 29 04 0109*       call ps_read_wav_header
042691             0110*   ; read the first block of data
042691 CD A4 26 04 0111*       call ps_read_file
042695             0112*   ; set ps_mode_playing
042695 21 6C 22 04 0113*       ld hl,ps_mode
042699 CB CE       0114*       set ps_mode_playing,(hl)
04269B             0115*   ; enable interrupts and start the PRT timer
04269B FB          0116*       ei
04269C CD C0 29 04 0117*       call ps_prt_start
0426A0             0118*   ; jump to user input loop:
0426A0             0119*   ; the play sample interrupt will return to there
0426A0             0120*   ; and exit app will return to main from there as well
0426A0 C3 A7 21 04 0121*       jp get_input
0426A4             0122*   ; end play_song
0426A4             0123*   
0426A4             0124*   ; read the next 1-second's worth of sound data from the file
0426A4             0125*   ; and upload it to the sample buffer
0426A4             0126*   ps_read_file:
0426A4             0127*   ; disable interrupts so load is guaranteed to complete
0426A4 F3          0128*       di
0426A5             0129*   ; print a playing breadcrumb
0426A5 3E 2E       0130*       ld a,'.'
0426A7 5B D7       0131*       rst.lil 10h
0426A9             0132*   ; Read a block of data from a file
0426A9             0133*   ;   C: Filehandle
0426A9             0134*   ; HLU: Pointer to where to write the data to
0426A9             0135*   ; DEU: Number of bytes to read
0426A9             0136*   ; Returns:
0426A9             0137*   ; DEU: Number of bytes read
0426A9 3A E2 24 04 0138*       ld a,(ps_filehandle_cur)
0426AD 4F          0139*       ld c,a
0426AE 21 00 00 05 0140*       ld hl,ps_wav_data_start
0426B2 ED 5B 14 26 0141*       ld de,(ps_wav_sample_rate)
       04          
0426B7             0142*       MOSCALL mos_fread
                       M1 Args: function=mos_fread 
0426B7 3E 1A       0001*M1 			LD	A, function
0426B9 5B CF       0002*M1 			RST.LIL	08h
0426BB             0143*   ; test de for zero bytes read
0426BB 21 00 00 00 0144*       ld hl,0
0426BF AF          0145*       xor a ; clear carry
0426C0 ED 52       0146*       sbc hl,de ; hl = 0-chunksize
0426C2 C2 CE 26 04 0147*       jp nz,@load ; we read some data
0426C6             0148*   ; no data read so close file and play a random song
0426C6 CD 09 27 04 0149*       call ps_close_file
0426CA C3 E8 28 04 0150*       jp ps_play_random
0426CE             0151*   ; load a vdu buffer from local memory
0426CE             0152*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0426CE             0153*   @load:
0426CE 3A 6D 22 04 0154*       ld a,(ps_channel)
0426D2 3C          0155*       inc a
0426D3 E6 01       0156*       and 1
0426D5 32 6D 22 04 0157*       ld (ps_channel),a
0426D9 21 00 30 00 0158*       ld hl,ch0_buffer
0426DD 6F          0159*       ld l,a
0426DE 22 71 22 04 0160*       ld (ps_sampleId),hl
0426E2 CD BE 1A 04 0161*       call vdu_clear_buffer
0426E6 2A 71 22 04 0162*       ld hl,(ps_sampleId)
0426EA D5          0163*       push de ; chunksize
0426EB C1          0164*       pop bc ; how much data to load
0426EC 11 00 00 05 0165*       ld de,ps_wav_data_start ; pointer to data
0426F0 CD A9 18 04 0166*       call vdu_load_buffer
0426F4 C9          0167*       ret
0426F5             0168*   ; end ps_read_file
0426F5             0169*   
0426F5             0170*   ; this is called by the PRT timer interrupt
0426F5             0171*   ps_play_sample:
0426F5             0172*   ; call the command buffer to play the sound
0426F5 2A 71 22 04 0173*       ld hl,(ps_sampleId)
0426F9 2C          0174*       inc l
0426FA 2C          0175*       inc l
0426FB 22 6E 22 04 0176*       ld (ps_cmdId),hl ; TODO: perhaps not needed
0426FF CD A3 1A 04 0177*       call vdu_call_buffer
042703             0178*   ; load the next chunk of data
042703 CD A4 26 04 0179*       call ps_read_file
042707             0180*   ; reenable interrupts and return to the user input loop
042707 FB          0181*       ei
042708 C9          0182*       ret
042709             0183*   ; end ps_play_sample
042709             0184*   
042709             0185*   ; close the file
042709             0186*   ps_close_file:
042709 CD DD 29 04 0187*       call ps_prt_stop ; stop the PRT timer
04270D 3A E2 24 04 0188*       ld a,(ps_filehandle_cur)
042711             0189*       MOSCALL mos_fclose
                       M1 Args: function=mos_fclose 
042711 3E 0B       0001*M1 			LD	A, function
042713 5B CF       0002*M1 			RST.LIL	08h
042715 C9          0190*       ret
042716             0191*   ; end ps_close_file
042716             0192*   
042716             0193*   ps_get_dir:
042716             0194*   ; reset filecounter
042716 21 00 00 00 0195*       ld hl,0
04271A 22 74 24 04 0196*       ld (ps_dir_num_files),hl
04271E             0197*   ; initialize pointers to store directory info
04271E 21 74 22 04 0198*       ld hl,ps_dir_path  ; where to store result
042722 01 FF 00 00 0199*       ld bc,255          ; max length
042726             0200*       MOSCALL ffs_getcwd ; MOS api get current working directory
                       M1 Args: function=ffs_getcwd 
042726 3E 9E       0001*M1 			LD	A, function
042728 5B CF       0002*M1 			RST.LIL	08h
04272A             0201*   ; now get dir info
04272A 21 C3 24 04 0202*       ld hl,ps_dir_struct ; define where to store directory info
04272E 11 74 22 04 0203*       ld de,ps_dir_path   ; this is pointer to the path to the directory
042732             0204*       MOSCALL ffs_dopen   ; open dir
                       M1 Args: function=ffs_dopen 
042732 3E 91       0001*M1 			LD	A, function
042734 5B CF       0002*M1 			RST.LIL	08h
042736             0205*   @readFileInfo:               ; we will loop here until all files have been processed
042736 21 C3 24 04 0206*       ld hl,ps_dir_struct      ; HL is where to get directory info
04273A 11 E6 24 04 0207*       ld de,ps_filinfo_struct  ; define where to store current file info
04273E             0208*       MOSCALL ffs_dread        ; read next item from dir
                       M1 Args: function=ffs_dread 
04273E 3E 93       0001*M1 			LD	A, function
042740 5B CF       0002*M1 			RST.LIL	08h
042742 3A FC 24 04 0209*       ld a,(ps_filinfo_fname)  ; get first char of file name
042746 FE 00       0210*       cp 0                     ; if 0 then we are at the end of the listing
042748 28 27       0211*       jr z,@allDone
04274A ED 5B 74 24 0212*       ld de,(ps_dir_num_files) ; get the current file counter
       04          
04274F 21 00 01 00 0213*       ld hl,256 ; bytes per filename
042753 CD 67 03 04 0214*       call umul24 ; hl = offset into the filename table
042757 13          0215*       inc de                  ; increment the counter
042758 ED 53 74 24 0216*       ld (ps_dir_num_files),de
       04          
04275D 11 00 00 06 0217*       ld de,ps_dir_fil_list ; get the address of the filename table
042761 19          0218*       add hl,de ; add the offset to the base address
042762 EB          0219*       ex de,hl ; de is the destination address to copy the filename
042763 21 FC 24 04 0220*       ld hl,ps_filinfo_fname   ; this is pointer to the name of current file
042767 01 00 01 00 0221*       ld bc,256 ; bytes per filename
04276B ED B0       0222*       ldir ; copy the filename to the filename table
04276D C3 36 27 04 0223*       jp @readFileInfo         ; loop around to check next entry
042771             0224*   @allDone:
042771             0225*   ; compute page statistics
042771 2A 74 24 04 0226*       ld hl,(ps_dir_num_files) ; get the number of files
042775 11 0A 00 00 0227*       ld de,10 ; max files per page
042779 CD 80 03 04 0228*       call udiv24 ; de = hl/10, hl = mod(hl,10)
04277D             0229*       SIGN_HLU ; check remainder for zero
                       M1 Args: none
04277D 19          0001*M1     add hl,de ; 1 cycle
04277E B7          0002*M1     or a ; clear flags ; 1 cycle
04277F ED 52       0003*M1     sbc hl,de ; 2 cycles
042781             0004*M1     ; 4 cycles total
042781 CA 86 27 04 0230*       jp z,@F ; if zero then we have exactly 10 files
042785 13          0231*       inc de ; bump the page count
042786             0232*   @@:
042786 ED 53 77 24 0233*       ld (ps_dir_num_pages),de ; save the number of pages
       04          
04278B 22 7D 24 04 0234*       ld (ps_pagelast_num_files),hl ; save the number of files on the last page
04278F             0235*   ; reset the song index and page to zero and populate the page filename pointers
04278F AF          0236*       xor a
042790 32 83 24 04 0237*       ld (ps_song_idx_cur),a
042794 21 00 00 00 0238*       ld hl,0
042798 22 80 24 04 0239*       ld (ps_page_cur),hl
04279C CD A9 27 04 0240*       call ps_fill_page_fn_ptrs
0427A0             0241*   ; close the directory
0427A0 21 C3 24 04 0242*       ld hl,ps_dir_struct      ; load H: with address of the DIR struct
0427A4             0243*       MOSCALL ffs_dclose       ; close dir
                       M1 Args: function=ffs_dclose 
0427A4 3E 92       0001*M1 			LD	A, function
0427A6 5B CF       0002*M1 			RST.LIL	08h
0427A8 C9          0244*       ret
0427A9             0245*   ; end ps_get_dir
0427A9             0246*   
0427A9             0247*   ; populate the page filename pointers for the current directory page
0427A9             0248*   ; inputs: ps_page_cur
0427A9             0249*   ; prerequisites: ps_get_dir called on a valid directory
0427A9             0250*   ; outputs: a populated filename pointer list for the current page
0427A9             0251*   ; destroys: a, hl, bc, de, ix
0427A9             0252*   ps_fill_page_fn_ptrs:
0427A9 2A 80 24 04 0253*       ld hl,(ps_page_cur) ; get the current page number
0427AD 11 00 0A 00 0254*       ld de,10*256 ; records/page * 256 bytes/record
0427B1 CD 67 03 04 0255*       call umul24 ; hl = offset into the filename table
0427B5 11 00 00 06 0256*       ld de,ps_dir_fil_list ; base address of filename table
0427B9 19          0257*       add hl,de ; add the offset to the base address
0427BA DD 21 87 24 0258*       ld ix,ps_page_fn_ptrs ; get the address of the page filename pointer table
       04          
0427BF 11 00 01 00 0259*       ld de,256 ; bytes per filename record
0427C3 06 0A       0260*       ld b,10 ; number of files per page
0427C5             0261*   @loop:
0427C5 DD 2F 00    0262*       ld (ix),hl ; store the filename pointer
0427C8 ED 32 03    0263*       lea ix,ix+3 ; bump the index pointer
0427CB 19          0264*       add hl,de ; add the record size to the filename pointer
0427CC 10 F7       0265*       djnz @loop
0427CE C9          0266*       ret
0427CF             0267*   ; end ps_fill_page_fn_ptrs
0427CF             0268*   
0427CF             0269*   ps_get_page_num_files:
0427CF             0270*   ; check whether we're at last page
0427CF 2A 80 24 04 0271*       ld hl,(ps_page_cur)
0427D3 ED 5B 77 24 0272*       ld de,(ps_dir_num_pages)
       04          
0427D8 1B          0273*       dec de ; zero-based
0427D9 B7          0274*       or a ; clear carry
0427DA ED 52       0275*       sbc hl,de
0427DC 06 0A       0276*       ld b,10 ; b = default number of files per page
0427DE C0          0277*       ret nz ; not the last page
0427DF 3A 7D 24 04 0278*       ld a,(ps_pagelast_num_files) ; get the number of files on the last page
0427E3 47          0279*       ld b,a ; b = number of files on the last page
0427E4 C9          0280*       ret
0427E5             0281*   ; end ps_get_page_num_files
0427E5             0282*   
0427E5             0283*   ps_print_dir_page:
0427E5             0284*   ; set text viewport for directory listing
0427E5 CD 8A 1E 04 0285*       call vp_dir
0427E9 CD 04 17 04 0286*       call vdu_cls
0427ED             0287*   ; loop through the filename pointer table and print out the filenames
0427ED CD CF 27 04 0288*       call ps_get_page_num_files ; b = loop counter
0427F1 AF          0289*       xor a ; song index
0427F2 DD 21 87 24 0290*       ld ix,ps_page_fn_ptrs
       04          
0427F7             0291*   @loop:
0427F7 C5          0292*       push bc ; save loop counter
0427F8 F5          0293*       push af ; save song index
0427F9 CD 2D 2A 04 0294*       call printHexA ; print the song index
0427FD DD 27 00    0295*       ld hl,(ix) ; get the filename pointer
042800 CD 67 00 04 0296*       call printString ; print the filename
042804 CD 7C 00 04 0297*       call printNewLine
042808 ED 32 03    0298*       lea ix,ix+3 ; bump the filename pointer
04280B F1          0299*       pop af ; restore song index
04280C 3C          0300*       inc a ; increment the song index
04280D C1          0301*       pop bc ; restore loop counter
04280E 10 E7       0302*       djnz @loop
042810             0303*   ; print the bottom border
042810 CD 97 1E 04 0304*       call print_dir_border_bottom
042814 C9          0305*       ret
042815             0306*   ; end ps_print_dir_page
042815             0307*   
042815             0308*   ps_print_dir:
042815             0309*   ; loop through the filename table and print out the filenames
042815 DD 21 00 00 0310*       ld ix,ps_dir_fil_list      ; get the address of the filename table
       06          
04281A 2A 74 24 04 0311*       ld hl,(ps_dir_num_files)   ; get the number of files
04281E E5          0312*       push hl ; save loop counter
04281F             0313*   @print_loop:
04281F DD E5       0314*       push ix
042821 E1          0315*       pop hl ; get the address of the filename
042822 CD 67 00 04 0316*       call printString
042826 CD 7C 00 04 0317*       call printNewLine
04282A ED 32 7F    0318*       lea ix,ix+127 ; bump the pointer
04282D ED 32 7F    0319*       lea ix,ix+127 ; to the next file
042830 ED 32 02    0320*       lea ix,ix+2   ; 256 bytes
042833 E1          0321*       pop hl ; get the loop counter
042834 2B          0322*       dec hl ; decrement the loop counter
042835 E5          0323*       push hl ; save loop counter
042836             0324*       SIGN_HLU ; check for zero
                       M1 Args: none
042836 19          0001*M1     add hl,de ; 1 cycle
042837 B7          0002*M1     or a ; clear flags ; 1 cycle
042838 ED 52       0003*M1     sbc hl,de ; 2 cycles
04283A             0004*M1     ; 4 cycles total
04283A 20 E3       0325*       jr nz,@print_loop
04283C E1          0326*       pop hl ; dummy pop to balance stack
04283D C9          0327*       ret
04283E             0328*   ; end ps_print_dir
04283E             0329*   
04283E             0330*   ps_highlight_song:
04283E             0331*   ; refresh the directory listing
04283E CD E5 27 04 0332*       call ps_print_dir_page
042842             0333*   ; highlight the song being played in the directory listing
042842 3A 83 24 04 0334*       ld a,(ps_song_idx_cur)
042846 16 1E       0335*       ld d,vp_dir_top
042848 82          0336*       add a,d
042849 0E 00       0337*       ld c,vp_dir_left
04284B 57          0338*       ld d,a
04284C 1E 3F       0339*       ld e,vp_dir_right
04284E 47          0340*       ld b,a
04284F CD 5D 17 04 0341*       call vdu_set_txt_viewport
042853             0342*   ; set text background color
042853 3E 8F       0343*       ld a,c_white+128
042855 CD 35 17 04 0344*       call vdu_colour_text
042859             0345*   ; set text foreground color
042859 3E 04       0346*       ld a,c_blue_dk
04285B CD 35 17 04 0347*       call vdu_colour_text
04285F             0348*   ; print the index and song filename
04285F 3A 83 24 04 0349*       ld a,(ps_song_idx_cur)
042863 CD 2D 2A 04 0350*       call printHexA
042867 2A 84 24 04 0351*       ld hl,(ps_song_fn_cur)
04286B CD 67 00 04 0352*       call printString
04286F             0353*   ; set text background color
04286F 3E 84       0354*       ld a,c_blue_dk+128
042871 CD 35 17 04 0355*       call vdu_colour_text
042875             0356*   ; set text foreground color
042875 3E 0F       0357*       ld a,c_white
042877 CD 35 17 04 0358*       call vdu_colour_text
04287B C9          0359*       ret
04287C             0360*   ; end ps_highlight_song
04287C             0361*   
04287C             0362*   ps_dir_next_page:
04287C             0363*   ; advance the page number
04287C 2A 80 24 04 0364*       ld hl,(ps_page_cur) ; get the current page number
042880 23          0365*       inc hl ; increment the page number
042881 ED 5B 77 24 0366*       ld de,(ps_dir_num_pages) ; get the number of pages
       04          
042886 CD 80 03 04 0367*       call udiv24 ; hl = mod(ps_page_cur+1,ps_dir_num_pages)
04288A 22 80 24 04 0368*       ld (ps_page_cur),hl ; save the new page number
04288E             0369*   ; populate the page filename pointers
04288E CD A9 27 04 0370*       call ps_fill_page_fn_ptrs
042892             0371*   ; print the new page and reset text viewport to now playing breadcrumbs
042892 CD E5 27 04 0372*       call ps_print_dir_page
042896 CD 7D 1E 04 0373*       call vp_breadcrumbs
04289A             0374*   ; enable interrupts and jump back to the user input loop
04289A FB          0375*       ei
04289B C3 A7 21 04 0376*       jp get_input
04289F             0377*   ; end ps_dir_next_page
04289F             0378*   
04289F             0379*   ps_dir_prev_page:
04289F             0380*   ; decrement the page number
04289F 2A 80 24 04 0381*       ld hl,(ps_page_cur) ; get the current page number
0428A3 2B          0382*       dec hl ; decrement the page number
0428A4             0383*       SIGN_HLU ; check for zero
                       M1 Args: none
0428A4 19          0001*M1     add hl,de ; 1 cycle
0428A5 B7          0002*M1     or a ; clear flags ; 1 cycle
0428A6 ED 52       0003*M1     sbc hl,de ; 2 cycles
0428A8             0004*M1     ; 4 cycles total
0428A8 F2 B1 28 04 0384*       jp p,@F ; >= 0 so we're good
0428AC 2A 77 24 04 0385*       ld hl,(ps_dir_num_pages) ; get the number of pages
0428B0 2B          0386*       dec hl ; zero-based
0428B1             0387*   @@:
0428B1 22 80 24 04 0388*       ld (ps_page_cur),hl ; save the new page number
0428B5             0389*   ; populate the page filename pointers
0428B5 CD A9 27 04 0390*       call ps_fill_page_fn_ptrs
0428B9             0391*   ; print the new page and reset text viewport to now playing breadcrumbs
0428B9 CD E5 27 04 0392*       call ps_print_dir_page
0428BD CD 7D 1E 04 0393*       call vp_breadcrumbs
0428C1             0394*   ; enable interrupts and jump back to the user input loop
0428C1 FB          0395*       ei
0428C2 C3 A7 21 04 0396*       jp get_input
0428C6             0397*   ; end ps_dir_prev_page
0428C6             0398*   
0428C6             0399*   ; get the filename of the song at the current index
0428C6             0400*   ; inputs: a = song index
0428C6             0401*   ; returns: carry set if song index in range, new filemame in hl and ps_song_idx_cur, ps_song_fn_cur set to new index
0428C6             0402*   ;          carry reset if song index out of range, current filename in hl, ps_song_idx_cur, ps_song_fn_cur unchanged
0428C6             0403*   ; destroys: af, bc, de
0428C6             0404*   ps_get_song_fn_from_pg_idx:
0428C6 F5          0405*       push af ; save song index
0428C7 CD CF 27 04 0406*       call ps_get_page_num_files ; b = number of files on the page
0428CB F1          0407*       pop af ; restore song index
0428CC B8          0408*       cp b ; compare song index to number of files on the page
0428CD 2A 84 24 04 0409*       ld hl,(ps_song_fn_cur) ; get the current song filename
0428D1 D0          0410*       ret nc ; requested song index is out of range so return current filename and no carry
0428D2 32 83 24 04 0411*       ld (ps_song_idx_cur),a ; save the song index
0428D6 21 87 24 04 0412*       ld hl,ps_page_fn_ptrs ; get the address of the page filename pointer table
0428DA 47          0413*       ld b,a ; song index
0428DB 0E 03       0414*       ld c,3 ; 3 bytes per filename pointer
0428DD ED 4C       0415*       mlt bc ; index into the filename pointer table
0428DF 09          0416*       add hl,bc ; hl points to the filename pointer
0428E0 ED 27       0417*       ld hl,(hl) ; hl points to the filename
0428E2 22 84 24 04 0418*       ld (ps_song_fn_cur),hl ; save the new song filename
0428E6 37          0419*       scf ; set carry to indicate success
0428E7 C9          0420*       ret
0428E8             0421*   ; end ps_get_song_fn_from_pg_idx
0428E8             0422*   
0428E8             0423*   ; queue a random song on the current page to play next
0428E8             0424*   ps_play_random:
0428E8             0425*   ; back up current song index
0428E8 2A 84 24 04 0426*       ld hl,(ps_song_fn_cur)
0428EC 22 15 29 04 0427*       ld (@songFn),hl
0428F0             0428*   ; get the number of songs in the current directory
0428F0 CD CF 27 04 0429*       call ps_get_page_num_files
0428F4             0430*   ; get a random song index
0428F4 CD 38 05 04 0431*       call rand_8 ; a = 0-255
0428F8 67          0432*       ld h,a
0428F9 2E 0A       0433*       ld l,10 ; modulo 10
0428FB CD 74 05 04 0434*       call udiv8 ; a = mod(a,10)
0428FF CD C6 28 04 0435*       call ps_get_song_fn_from_pg_idx
042903 EB          0436*       ex de,hl ; setting up cp hl,de
042904 2A 15 29 04 0437*       ld hl,(@songFn) ; don't play the same song twice in a row
042908 B7          0438*       or a ; clear carry
042909 ED 52       0439*       sbc hl,de
04290B CA E8 28 04 0440*       jp z,ps_play_random ; same song, try again
04290F EB          0441*       ex de,hl ; pointer back to hl
042910 CD 48 26 04 0442*       call play_song ; hit it
042914 C9          0443*       ret
042915 00 00 00    0444*   @songFn: dl 0
042918             0445*   ; end ps_play_random
042918             0446*   
042918             0447*   ps_read_wav_header:
042918             0448*   ; Read a block of data from a file
042918             0449*   ;   C: Filehandle
042918             0450*   ; HLU: Pointer to where to write the data to
042918             0451*   ; DEU: Number of bytes to read
042918             0452*   ; Returns:
042918             0453*   ; DEU: Number of bytes read
042918 3A E2 24 04 0454*       ld a,(ps_filehandle_cur)
04291C 4F          0455*       ld c,a
04291D 21 FC 25 04 0456*       ld hl,ps_wav_header
042921 11 4C 00 00 0457*       ld de,wav_header_size
042925             0458*       MOSCALL mos_fread
                       M1 Args: function=mos_fread 
042925 3E 1A       0001*M1 			LD	A, function
042927 5B CF       0002*M1 			RST.LIL	08h
042929             0459*   ; test de for zero bytes read
042929 21 00 00 00 0460*       ld hl,0
04292D AF          0461*       xor a ; clear carry
04292E ED 52       0462*       sbc hl,de ; hl = 0-chunksize
042930 C8          0463*       ret z ; no data read so return zero to caller
042931             0464*   ; data read so initialize song variables
042931             0465*   ; load play sample command buffers (namely the sample rate for now)
042931 CD 36 29 04 0466*       call ps_load_command_buffers
042935 C9          0467*       ret
042936             0468*   ; end ps_read_wav_header
042936             0469*   
042936             0470*   ps_load_command_buffers:
042936 21 02 30 00 0471*       ld hl,cmd0_buffer
04293A CD BE 1A 04 0472*       call vdu_clear_buffer
04293E 2A 14 26 04 0473*       ld hl,(ps_wav_sample_rate)
042942 22 8C 29 04 0474*       ld (ps_sr0),hl
042946 3E 17       0475*       ld a,23
042948 32 8E 29 04 0476*       ld (ps_sr0+2),a
04294C 21 02 30 00 0477*       ld hl,cmd0_buffer
042950 01 1D 00 00 0478*       ld bc,ps_cmd0_end-ps_cmd0
042954 11 83 29 04 0479*       ld de,ps_cmd0
042958 CD 7B 1A 04 0480*       call vdu_write_block_to_buffer
04295C             0481*   
04295C 21 03 30 00 0482*       ld hl,cmd1_buffer
042960 CD BE 1A 04 0483*       call vdu_clear_buffer
042964 2A 14 26 04 0484*       ld hl,(ps_wav_sample_rate)
042968 22 A9 29 04 0485*       ld (ps_sr1),hl
04296C 3E 17       0486*       ld a,23
04296E 32 AB 29 04 0487*       ld (ps_sr1+2),a
042972 21 03 30 00 0488*       ld hl,cmd1_buffer
042976 01 1D 00 00 0489*       ld bc,ps_cmd1_end-ps_cmd1
04297A 11 A0 29 04 0490*       ld de,ps_cmd1
04297E CD 7B 1A 04 0491*       call vdu_write_block_to_buffer
042982 C9          0492*       ret
042983             0493*   ps_cmd0:
042983             0494*   ; vdu_buffer_to_sound command string
042983             0495*   ; Command 5: Buffer to sound
042983             0496*   ; VDU 23, 0, &85, channel (ignored), 5, 2, bufferId; format, [sampleRate;]
042983 17 00 85    0497*       db 23,0,0x85 ; vdu sound command header
042986 00          0498*       db 0x00 ; channel (ignored)
042987 05          0499*       db 0x05 ; buffer to sound command
042988 02          0500*       db 0x02 ; command 2 create sample
042989 00 30       0501*       dw ch0_buffer
04298B 09          0502*       db 1+8 ; 8-bit unsigned PCM mono, 8 = sample rate argument follows
04298C             0503*   ps_sr0:
04298C 00 00       0504*       dw 0x0000 ; sample rate Hz
04298E             0505*   ; vdu_play_sfx command string
04298E             0506*   ; Command 4: Set waveform
04298E             0507*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
04298E 17 00 85    0508*       db 23,0,$85 ; vdu sound command header
042991 00          0509*       db 0 ; channel
042992 04          0510*       db 4 ; set waveform command
042993 08          0511*       db 8 ; waveform 8 = sample
042994 00 30       0512*       dw ch0_buffer ; sample bufferId
042996             0513*   ; Command 0: Play note
042996             0514*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
042996 17 00 85    0515*       db 23,0,$85 ; vdu sound command header
042999 00          0516*       db 0 ; channel
04299A 00          0517*       db 0 ; play note command
04299B 7F          0518*       db 127  ; volume 127 = max
04299C 00 00       0519*       dw 0 ; frequency (relevant only for tuneable samples)
04299E 00 00       0520*       dw 0 ; duration (ms), zero means play one time in full
0429A0             0521*   ps_cmd0_end:
0429A0             0522*   
0429A0             0523*   ps_cmd1:
0429A0             0524*   ; vdu_buffer_to_sound command string
0429A0             0525*   ; Command 5: Buffer to sound
0429A0             0526*   ; VDU 23, 0, &85, channel (ignored), 5, 2, bufferId; format, [sampleRate;]
0429A0 17 00 85    0527*       db 23,0,0x85 ; vdu sound command header
0429A3 00          0528*       db 0x00 ; channel (ignored)
0429A4 05          0529*       db 0x05 ; buffer to sound command
0429A5 02          0530*       db 0x02 ; command 2 create sample
0429A6 01 30       0531*       dw ch1_buffer
0429A8 09          0532*       db 1+8 ; 8-bit unsigned PCM mono, 8 = sample rate argument follows
0429A9             0533*   ps_sr1:
0429A9 00 00       0534*       dw 0x0000 ; sample rate Hz
0429AB             0535*   ; vdu_play_sfx command string
0429AB             0536*   ; Command 4: Set waveform
0429AB             0537*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
0429AB 17 00 85    0538*       db 23,0,$85 ; vdu sound command header
0429AE 01          0539*       db 1 ; channel
0429AF 04          0540*       db 4 ; set waveform command
0429B0 08          0541*       db 8 ; waveform 8 = sample
0429B1 01 30       0542*       dw ch1_buffer ; sample bufferId
0429B3             0543*   ; Command 0: Play note
0429B3             0544*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
0429B3 17 00 85    0545*       db 23,0,$85 ; vdu sound command header
0429B6 01          0546*       db 1 ; channel
0429B7 00          0547*       db 0 ; play note command
0429B8 7F          0548*       db 127  ; volume 127 = max
0429B9 00 00       0549*       dw 0 ; frequency (relevant only for tuneable samples)
0429BB 00 00       0550*       dw 0 ; duration (ms), zero means play one time in full
0429BD             0551*   ps_cmd1_end:
0429BD             0552*   ; end ps_load_command_buffers
0429BD             0050        include "timer_jukebox.inc"
0429BD A0 8C 00    0001*   ps_prt_reload: dl [72000/2] ; 36000 = 2 ticks per second at 18.432 MHz with a 256 clock divider
0429C0             0002*   
0429C0             0003*   ; start PRT timer
0429C0             0004*   ps_prt_start:
0429C0 21 00 00 00 0005*       ld hl,0
0429C4 22 FF 29 04 0006*       ld (ps_prt_irq_counter),hl
0429C8 2A BD 29 04 0007*       ld hl,(ps_prt_reload)
0429CC ED 29 84    0008*       out0 (TMR1_CTL+TMR_RES_LOW),l
0429CF ED 21 85    0009*   	out0 (TMR1_CTL+TMR_RES_HIGH),h
0429D2             0010*   ; disable timer (in effect, reset it)
0429D2 3E 0E       0011*       ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_256 | RST_EN_1 | PRT_EN_0
0429D4 ED 39 83    0012*   	out0 (TMR1_CTL+TMR_REG_CTL),a
0429D7             0013*   ; enable timer,with interrupt and CONTINUOUS mode,clock divider 256
0429D7 3E 5F       0014*       ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_256 | RST_EN_1 | PRT_EN_1
0429D9 ED 39 83    0015*   	out0 (TMR1_CTL+TMR_REG_CTL),a
0429DC C9          0016*       ret
0429DD             0017*   
0429DD             0018*   ; stop PRT timer
0429DD             0019*   ps_prt_stop:
0429DD 3E 0E       0020*       ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_256 | RST_EN_1 | PRT_EN_0
0429DF ED 39 83    0021*   	out0 (TMR1_CTL+TMR_REG_CTL),a
0429E2 C9          0022*       ret
0429E3             0023*   
0429E3             0024*   ; ===============================================
0429E3             0025*   ; PRT Timer Interrupt Handling
0429E3             0026*   ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.asm
0429E3             0027*   ; -----------------------------------------------
0429E3             0028*   ps_prt_irq_init:
0429E3             0029*       ; set up interrupt vector table 2
0429E3 21 00 00 00 0030*   	ld hl,0
0429E7 3A 0C 01 00 0031*   	ld a,($10c)
0429EB 6F          0032*   	ld l,a
0429EC 3A 0D 01 00 0033*   	ld a,($10d)
0429F0 67          0034*   	ld h,a
0429F1             0035*   
0429F1             0036*   	; skip over CALL ($c3)
0429F1 23          0037*   	inc hl
0429F2             0038*   	; load address of jump into vector table 2 (in ram)
0429F2 ED 27       0039*   	ld hl,(hl)
0429F4             0040*   
0429F4             0041*   	; write CALL ps_prt_irq_handler to vector table 2
0429F4 3E C3       0042*   	ld a,$c3
0429F6 77          0043*   	ld (hl),a
0429F7 23          0044*   	inc hl
0429F8 11 00 2A 04 0045*   	ld de,ps_prt_irq_handler
0429FC ED 1F       0046*   	ld (hl),de
0429FE             0047*   
0429FE C9          0048*       ret
0429FF             0049*   ; end ps_prt_irq_init
0429FF             0050*   
0429FF             0051*   ; interrupt routine for playing the next sample
0429FF             0052*   ps_prt_irq_counter:
0429FF 00          0053*   	db 0
042A00             0054*   ps_prt_irq_handler:
042A00 F3          0055*       di
042A01 08          0056*       ex af,af'
042A02 D9          0057*       exx
042A03             0058*   ; clear sysvar_keyascii
042A03             0059*   	MOSCALL mos_sysvars
                       M1 Args: function=mos_sysvars 
042A03 3E 08       0001*M1 			LD	A, function
042A05 5B CF       0002*M1 			RST.LIL	08h
042A07 AF          0060*   	xor a
042A08 DD 77 05    0061*   	ld (IX+sysvar_keyascii),a
042A0B             0062*   ; read the timer interrupt and bump the counter
042A0B ED 38 83    0063*       in0 a,(TMR1_CTL+TMR_REG_CTL)
042A0E 3A FF 29 04 0064*       ld a,(ps_prt_irq_counter)
042A12 3C          0065*       inc a
042A13 E6 01       0066*       and 1 ; modulo 2
042A15 32 FF 29 04 0067*       ld (ps_prt_irq_counter),a
042A19             0068*   ; if counter zero, play the next sample
042A19 C2 27 2A 04 0069*       jp nz,@F
042A1D 21 6C 22 04 0070*       ld hl,ps_mode
042A21 CB 4E       0071*       bit ps_mode_playing,(hl)
042A23 C4 F5 26 04 0072*       call nz,ps_play_sample
042A27             0073*   @@:
042A27 D9          0074*       exx
042A28 08          0075*       ex af,af'
042A29 FB          0076*       ei
042A2A 5B ED 4D    0077*       reti.l
042A2D             0078*   ; end ps_prt_irq_handler
042A2D             0051        include "wav.inc"
042A2D             0001*   ; WAV File Structure Offsets and Descriptions
042A2D             0002*   wav_riff:          EQU 0    ; 4 bytes: "RIFF" identifier
042A2D             0003*   wav_file_size:     EQU 4    ; 4 bytes: Total file size minus 8 bytes for RIFF header
042A2D             0004*   wav_wave:          EQU 8    ; 4 bytes: "WAVE" identifier
042A2D             0005*   wav_fmt_marker:    EQU 12   ; 4 bytes: "fmt " subchunk marker
042A2D             0006*   wav_fmt_size:      EQU 16   ; 4 bytes: Format chunk size (16 for PCM)
042A2D             0007*   wav_audio_format:  EQU 20   ; 2 bytes: Audio format (1 = PCM)
042A2D             0008*   wav_num_channels:  EQU 22   ; 2 bytes: Number of channels (1 = mono, 2 = stereo)
042A2D             0009*   wav_sample_rate:   EQU 24   ; 4 bytes: Sample rate in Hz (e.g., 32768)
042A2D             0010*   wav_byte_rate:     EQU 28   ; 4 bytes: Bytes per second (SampleRate * NumChannels * BitsPerSample / 8)
042A2D             0011*   wav_block_align:   EQU 32   ; 2 bytes: Bytes per sample block (NumChannels * BitsPerSample / 8)
042A2D             0012*   wav_bits_per_sample: EQU 34 ; 2 bytes: Bits per sample (e.g., 8 or 16)
042A2D             0013*   
042A2D             0014*   ; LIST Chunk (Extra Metadata)
042A2D             0015*   wav_list_marker:   EQU 36   ; 4 bytes: "LIST" marker
042A2D             0016*   wav_list_size:     EQU 40   ; 4 bytes: Size of the LIST chunk (e.g., 26)
042A2D             0017*   wav_info_marker:   EQU 44   ; 4 bytes: "INFO" marker
042A2D             0018*   wav_isft_marker:   EQU 48   ; 4 bytes: "ISFT" marker (software identifier)
042A2D             0019*   wav_isft_data:     EQU 52   ; 14 bytes: Software info string (e.g., "Lavf59.27.100")
042A2D             0020*   wav_isft_padding:  EQU 66   ; 2 bytes: Padding/NULL terminator for alignment
042A2D             0021*   
042A2D             0022*   ; Data Chunk
042A2D             0023*   wav_data_marker:   EQU 68   ; 4 bytes: "data" subchunk marker
042A2D             0024*   wav_data_size:     EQU 72   ; 4 bytes: Size of the audio data in bytes
042A2D             0025*   wav_data_start:    EQU 76   ; Start of audio data
042A2D             0026*   wav_header_size:   EQU wav_data_start ; Total Header Size: 76 bytes
042A2D             0052        include "debug.inc"
042A2D             0001*   printHexA:
042A2D F5          0002*       push af
042A2E C5          0003*       push bc
042A2F CD AE 00 04 0004*       call printHex8
042A33 3E 20       0005*       ld a,' '
042A35 5B D7       0006*       rst.lil 10h
042A37 C1          0007*       pop bc
042A38 F1          0008*       pop af
042A39 C9          0009*       ret
042A3A             0010*   
042A3A             0011*   printHexHL:
042A3A F5          0012*       push af
042A3B C5          0013*       push bc
042A3C CD A8 00 04 0014*       call printHex16
042A40 3E 20       0015*       ld a,' '
042A42 5B D7       0016*       rst.lil 10h
042A44 C1          0017*       pop bc
042A45 F1          0018*       pop af
042A46 C9          0019*       ret
042A47             0020*   
042A47             0021*   printHexUHL:
042A47 F5          0022*       push af
042A48 C5          0023*       push bc
042A49 CD A0 00 04 0024*       call printHex24
042A4D 3E 20       0025*       ld a,' '
042A4F 5B D7       0026*       rst.lil 10h
042A51 C1          0027*       pop bc
042A52 F1          0028*       pop af
042A53 C9          0029*       ret
042A54             0030*   
042A54             0031*   printHexAUHL:
042A54 F5          0032*       push af
042A55 C5          0033*       push bc
042A56 CD AE 00 04 0034*       call printHex8
042A5A 3E 2E       0035*       ld a,'.'
042A5C 5B D7       0036*       rst.lil 10h
042A5E CD A0 00 04 0037*       call printHex24
042A62 3E 20       0038*       ld a,' '
042A64 5B D7       0039*       rst.lil 10h
042A66 C1          0040*       pop bc
042A67 F1          0041*       pop af
042A68 C9          0042*       ret
042A69             0043*   
042A69             0044*   printHexABHL:
042A69             0045*   ; preserve registers
042A69 C5          0046*       push bc ; b will be ok c will not
042A6A F5          0047*       push af ; will get totally destroyed
042A6B             0048*   ; print a
042A6B CD AE 00 04 0049*       call printHex8
042A6F             0050*   ; print b
042A6F 78          0051*       ld a,b
042A70 CD AE 00 04 0052*       call printHex8
042A74             0053*   ; print hl
042A74 CD A8 00 04 0054*       call printHex16
042A78             0055*   ; restore registers
042A78 F1          0056*       pop af
042A79 C1          0057*       pop bc
042A7A C9          0058*       ret
042A7B             0059*   
042A7B             0060*   printHexBHL:
042A7B             0061*   ; preserve registers
042A7B C5          0062*       push bc ; b will be ok c will not
042A7C F5          0063*       push af ; will get totally destroyed
042A7D             0064*   ; print b
042A7D 78          0065*       ld a,b
042A7E CD AE 00 04 0066*       call printHex8
042A82             0067*   ; print hl
042A82 CD A8 00 04 0068*       call printHex16
042A86             0069*   ; restore registers
042A86 F1          0070*       pop af
042A87 C1          0071*       pop bc
042A88 C9          0072*       ret
042A89             0073*   
042A89             0074*   printHexCDE:
042A89             0075*   ; preserve registers
042A89 C5          0076*       push bc ; b will be ok c will not
042A8A F5          0077*       push af ; will get totally destroyed
042A8B             0078*   ; print c
042A8B 79          0079*       ld a,c
042A8C CD AE 00 04 0080*       call printHex8
042A90             0081*   ; print de
042A90 EB          0082*       ex de,hl
042A91 CD A8 00 04 0083*       call printHex16
042A95 EB          0084*       ex de,hl
042A96             0085*   ; restore registers
042A96 F1          0086*       pop af
042A97 C1          0087*       pop bc
042A98 C9          0088*       ret
042A99             0089*   
042A99             0090*   printHexUIX:
042A99             0091*   ; store everything in scratch
042A99 22 35 03 04 0092*       ld (uhl),hl
042A9D ED 43 38 03 0093*       ld (ubc),bc
       04          
042AA2 ED 53 3B 03 0094*       ld (ude),de
       04          
042AA7 DD 22 3E 03 0095*       ld (uix),ix
       04          
042AAC FD 22 41 03 0096*       ld (uiy),iy
       04          
042AB1 F5          0097*       push af ; fml
042AB2             0098*   
042AB2 21 CC 02 04 0099*       ld hl,str_ixu
042AB6 CD 67 00 04 0100*       call printString
042ABA 2A 3E 03 04 0101*       ld hl,(uix)
042ABE CD A0 00 04 0102*       call printHex24
042AC2 CD 7C 00 04 0103*       call printNewLine
042AC6             0104*   
042AC6             0105*   ; restore everything
042AC6 2A 35 03 04 0106*       ld hl, (uhl)
042ACA ED 4B 38 03 0107*       ld bc, (ubc)
       04          
042ACF ED 5B 3B 03 0108*       ld de, (ude)
       04          
042AD4 DD 2A 3E 03 0109*       ld ix, (uix)
       04          
042AD9 FD 2A 41 03 0110*       ld iy, (uiy)
       04          
042ADE F1          0111*       pop af
042ADF             0112*   ; all done
042ADF C9          0113*       ret
042AE0             0114*   
042AE0             0115*   
042AE0             0116*   ; print registers to screen in hexidecimal format
042AE0             0117*   ; inputs: none
042AE0             0118*   ; outputs: values of every register printed to screen
042AE0             0119*   ;    values of each register in global scratch memory
042AE0             0120*   ; destroys: nothing
042AE0             0121*   stepRegistersHex:
042AE0             0122*   ; store everything in scratch
042AE0 22 35 03 04 0123*       ld (uhl),hl
042AE4 ED 43 38 03 0124*       ld (ubc),bc
       04          
042AE9 ED 53 3B 03 0125*       ld (ude),de
       04          
042AEE DD 22 3E 03 0126*       ld (uix),ix
       04          
042AF3 FD 22 41 03 0127*       ld (uiy),iy
       04          
042AF8 F5          0128*       push af ; fml
042AF9 E1          0129*       pop hl ; thanks, zilog
042AFA 22 32 03 04 0130*       ld (uaf),hl
042AFE F5          0131*       push af ; dammit
042AFF             0132*   
042AFF             0133*   ; home the cursor
042AFF             0134*       ; call vdu_home_cursor
042AFF             0135*   
042AFF             0136*   ; print each register
042AFF 21 B8 02 04 0137*       ld hl,str_afu
042B03 CD 67 00 04 0138*       call printString
042B07 2A 32 03 04 0139*       ld hl,(uaf)
042B0B CD A0 00 04 0140*       call printHex24
042B0F CD 7C 00 04 0141*       call printNewLine
042B13             0142*   
042B13 21 BD 02 04 0143*       ld hl,str_hlu
042B17 CD 67 00 04 0144*       call printString
042B1B 2A 35 03 04 0145*       ld hl,(uhl)
042B1F CD A0 00 04 0146*       call printHex24
042B23 CD 7C 00 04 0147*       call printNewLine
042B27             0148*   
042B27 21 C2 02 04 0149*       ld hl,str_bcu
042B2B CD 67 00 04 0150*       call printString
042B2F 2A 38 03 04 0151*       ld hl,(ubc)
042B33 CD A0 00 04 0152*       call printHex24
042B37 CD 7C 00 04 0153*       call printNewLine
042B3B             0154*   
042B3B 21 C7 02 04 0155*       ld hl,str_deu
042B3F CD 67 00 04 0156*       call printString
042B43 2A 3B 03 04 0157*       ld hl,(ude)
042B47 CD A0 00 04 0158*       call printHex24
042B4B CD 7C 00 04 0159*       call printNewLine
042B4F             0160*   
042B4F 21 CC 02 04 0161*       ld hl,str_ixu
042B53 CD 67 00 04 0162*       call printString
042B57 2A 3E 03 04 0163*       ld hl,(uix)
042B5B CD A0 00 04 0164*       call printHex24
042B5F CD 7C 00 04 0165*       call printNewLine
042B63             0166*   
042B63 21 D1 02 04 0167*       ld hl,str_iyu
042B67 CD 67 00 04 0168*       call printString
042B6B 2A 41 03 04 0169*       ld hl,(uiy)
042B6F CD A0 00 04 0170*       call printHex24
042B73 CD 7C 00 04 0171*       call printNewLine
042B77             0172*   
042B77             0173*       ; call vsync
042B77             0174*   
042B77 CD 7C 00 04 0175*       call printNewLine
042B7B             0176*   
042B7B             0177*   ; check for right shift key and quit if pressed
042B7B             0178*       MOSCALL mos_getkbmap
                       M1 Args: function=mos_getkbmap 
042B7B 3E 1E       0001*M1 			LD	A, function
042B7D 5B CF       0002*M1 			RST.LIL	08h
042B7F             0179*   @stayhere:
042B7F             0180*   ; 7 RightShift
042B7F DD CB 00 76 0181*       bit 6,(ix+0)
042B83 20 02       0182*       jr nz,@RightShift
042B85 18 F8       0183*       jr @stayhere
042B87             0184*   @RightShift:
042B87 DD CB 0E 86 0185*       res 0,(ix+14) ; debounce the key (hopefully)
042B8B 3E 80       0186*       ld a,%10000000
042B8D             0187*       ; call multiPurposeDelay
042B8D             0188*   
042B8D             0189*   ; restore everything
042B8D 2A 35 03 04 0190*       ld hl, (uhl)
042B91 ED 4B 38 03 0191*       ld bc, (ubc)
       04          
042B96 ED 5B 3B 03 0192*       ld de, (ude)
       04          
042B9B DD 2A 3E 03 0193*       ld ix, (uix)
       04          
042BA0 FD 2A 41 03 0194*       ld iy, (uiy)
       04          
042BA5 F1          0195*       pop af
042BA6             0196*   ; all done
042BA6 C9          0197*       ret
042BA7             0198*   
042BA7             0199*   ; print registers to screen in hexidecimal format
042BA7             0200*   ; inputs: none
042BA7             0201*   ; outputs: values of every register printed to screen
042BA7             0202*   ;    values of each register in global scratch memory
042BA7             0203*   ; destroys: nothing
042BA7             0204*   dumpRegistersHex:
042BA7             0205*   ; store everything in scratch
042BA7 22 35 03 04 0206*       ld (uhl),hl
042BAB ED 43 38 03 0207*       ld (ubc),bc
       04          
042BB0 ED 53 3B 03 0208*       ld (ude),de
       04          
042BB5 DD 22 3E 03 0209*       ld (uix),ix
       04          
042BBA FD 22 41 03 0210*       ld (uiy),iy
       04          
042BBF F5          0211*       push af ; fml
042BC0 E1          0212*       pop hl ; thanks, zilog
042BC1 22 32 03 04 0213*       ld (uaf),hl
042BC5 F5          0214*       push af ; dammit
042BC6             0215*   
042BC6             0216*   ; home the cursor
042BC6             0217*       ; call vdu_home_cursor
042BC6             0218*       ; call printNewLine
042BC6             0219*   
042BC6             0220*   ; print each register
042BC6 21 B8 02 04 0221*       ld hl,str_afu
042BCA CD 67 00 04 0222*       call printString
042BCE 2A 32 03 04 0223*       ld hl,(uaf)
042BD2 CD A0 00 04 0224*       call printHex24
042BD6 CD 7C 00 04 0225*       call printNewLine
042BDA             0226*   
042BDA 21 BD 02 04 0227*       ld hl,str_hlu
042BDE CD 67 00 04 0228*       call printString
042BE2 2A 35 03 04 0229*       ld hl,(uhl)
042BE6 CD A0 00 04 0230*       call printHex24
042BEA CD 7C 00 04 0231*       call printNewLine
042BEE             0232*   
042BEE 21 C2 02 04 0233*       ld hl,str_bcu
042BF2 CD 67 00 04 0234*       call printString
042BF6 2A 38 03 04 0235*       ld hl,(ubc)
042BFA CD A0 00 04 0236*       call printHex24
042BFE CD 7C 00 04 0237*       call printNewLine
042C02             0238*   
042C02 21 C7 02 04 0239*       ld hl,str_deu
042C06 CD 67 00 04 0240*       call printString
042C0A 2A 3B 03 04 0241*       ld hl,(ude)
042C0E CD A0 00 04 0242*       call printHex24
042C12 CD 7C 00 04 0243*       call printNewLine
042C16             0244*   
042C16 21 CC 02 04 0245*       ld hl,str_ixu
042C1A CD 67 00 04 0246*       call printString
042C1E 2A 3E 03 04 0247*       ld hl,(uix)
042C22 CD A0 00 04 0248*       call printHex24
042C26 CD 7C 00 04 0249*       call printNewLine
042C2A             0250*   
042C2A 21 D1 02 04 0251*       ld hl,str_iyu
042C2E CD 67 00 04 0252*       call printString
042C32 2A 41 03 04 0253*       ld hl,(uiy)
042C36 CD A0 00 04 0254*       call printHex24
042C3A             0255*   
042C3A CD 7C 00 04 0256*       call printNewLine
042C3E CD 7C 00 04 0257*       call printNewLine
042C42             0258*   ; restore everything
042C42 2A 35 03 04 0259*       ld hl, (uhl)
042C46 ED 4B 38 03 0260*       ld bc, (ubc)
       04          
042C4B ED 5B 3B 03 0261*       ld de, (ude)
       04          
042C50 DD 2A 3E 03 0262*       ld ix, (uix)
       04          
042C55 FD 2A 41 03 0263*       ld iy, (uiy)
       04          
042C5A F1          0264*       pop af
042C5B             0265*   ; all done
042C5B C9          0266*       ret
042C5C             0267*   
042C5C             0268*   dumpRegistersHexPrime:
042C5C D9          0269*       exx
042C5D 08          0270*       ex af,af'
042C5E CD A7 2B 04 0271*       call dumpRegistersHex
042C62 08          0272*       ex af,af'
042C63 D9          0273*       exx
042C64 C9          0274*       ret
042C65             0275*   
042C65             0276*   ; additionally dump prime registers
042C65             0277*   ; inputs: none
042C65             0278*   ; outputs: values of every register printed to screen
042C65             0279*   ; destroys: nothing
042C65             0280*   dumpRegistersHexAll:
042C65 CD A7 2B 04 0281*       call dumpRegistersHex
042C69 08          0282*       ex af,af'
042C6A D9          0283*       exx
042C6B CD A7 2B 04 0284*       call dumpRegistersHex
042C6F 08          0285*       ex af,af'
042C70 D9          0286*       exx
042C71 C9          0287*       ret
042C72             0288*   
042C72             0289*   ; print hlu to screen in hexidecimal format
042C72             0290*   ; inputs: none
042C72             0291*   ; destroys: nothing
042C72             0292*   print_hex_hl:
042C72 F5          0293*       push af
042C73 E5          0294*       push hl
042C74 21 BD 02 04 0295*       ld hl,str_hlu
042C78 CD 67 00 04 0296*       call printString
042C7C E1          0297*       pop hl
042C7D E5          0298*       push hl
042C7E CD A0 00 04 0299*       call printHex24
042C82 3E 20       0300*       ld a,' '
042C84 5B D7       0301*       rst.lil 10h
042C86 E1          0302*       pop hl
042C87 F1          0303*       pop af
042C88 C9          0304*       ret
042C89             0305*   
042C89             0306*   ; print bcu to screen in hexidecimal format
042C89             0307*   ; inputs: none
042C89             0308*   ; destroys: nothing
042C89             0309*   print_hex_bc:
042C89 F5          0310*       push af
042C8A E5          0311*       push hl
042C8B C5          0312*       push bc
042C8C 21 C2 02 04 0313*       ld hl,str_bcu
042C90 CD 67 00 04 0314*       call printString
042C94 E1          0315*       pop hl
042C95 E5          0316*       push hl
042C96 CD A0 00 04 0317*       call printHex24
042C9A 3E 20       0318*       ld a,' '
042C9C 5B D7       0319*       rst.lil 10h
042C9E C1          0320*       pop bc
042C9F E1          0321*       pop hl
042CA0 F1          0322*       pop af
042CA1 C9          0323*       ret
042CA2             0324*   
042CA2             0325*   ; print deu to screen in hexidecimal format
042CA2             0326*   ; inputs: none
042CA2             0327*   ; destroys: nothing
042CA2             0328*   print_hex_de:
042CA2 F5          0329*       push af
042CA3 E5          0330*       push hl
042CA4 D5          0331*       push de
042CA5 21 C7 02 04 0332*       ld hl,str_deu
042CA9 CD 67 00 04 0333*       call printString
042CAD E1          0334*       pop hl
042CAE E5          0335*       push hl
042CAF CD A0 00 04 0336*       call printHex24
042CB3 3E 20       0337*       ld a,' '
042CB5 5B D7       0338*       rst.lil 10h
042CB7 D1          0339*       pop de
042CB8 E1          0340*       pop hl
042CB9 F1          0341*       pop af
042CBA C9          0342*       ret
042CBB             0343*   
042CBB             0344*   
042CBB             0345*   ; inputs: whatever is in the flags register
042CBB             0346*   ; outputs: binary representation of flags
042CBB             0347*   ;          with a header so we know which is what
042CBB             0348*   ; destroys: nothing
042CBB             0349*   ; preserves: everything
042CBB             0350*   dumpFlags:
042CBB             0351*   ; first we curse zilog for not giving direct access to flags
042CBB F5          0352*       push af ; this is so we can send it back unharmed
042CBC F5          0353*       push af ; this is so we can pop it to hl
042CBD             0354*   ; store everything in scratch
042CBD 22 35 03 04 0355*       ld (uhl),hl
042CC1 ED 43 38 03 0356*       ld (ubc),bc
       04          
042CC6 ED 53 3B 03 0357*       ld (ude),de
       04          
042CCB DD 22 3E 03 0358*       ld (uix),ix
       04          
042CD0 FD 22 41 03 0359*       ld (uiy),iy
       04          
042CD5             0360*   ; next we print the header
042CD5 21 01 2D 04 0361*       ld hl,@header
042CD9 CD 67 00 04 0362*       call printString
042CDD E1          0363*       pop hl ; flags are now in l
042CDE 7D          0364*       ld a,l ; flags are now in a
042CDF CD 6E 02 04 0365*       call printBin8
042CE3 CD 7C 00 04 0366*       call printNewLine
042CE7             0367*   ; restore everything
042CE7 2A 35 03 04 0368*       ld hl, (uhl)
042CEB ED 4B 38 03 0369*       ld bc, (ubc)
       04          
042CF0 ED 5B 3B 03 0370*       ld de, (ude)
       04          
042CF5 DD 2A 3E 03 0371*       ld ix, (uix)
       04          
042CFA FD 2A 41 03 0372*       ld iy, (uiy)
       04          
042CFF F1          0373*       pop af ; send her home the way she came
042D00 C9          0374*       ret
042D01             0375*   ; Bit 7 (S): Sign flag
042D01             0376*   ; Bit 6 (Z): Zero flag
042D01             0377*   ; Bit 5 (5): Reserved (copy of bit 5 of the result)
042D01             0378*   ; Bit 4 (H): Half Carry flag
042D01             0379*   ; Bit 3 (3): Reserved (copy of bit 3 of the result)
042D01             0380*   ; Bit 2 (PV): Parity/Overflow flag
042D01             0381*   ; Bit 1 (N): Subtract flag
042D01             0382*   ; Bit 0 (C): Carry flag
042D01 53 5A 78 48 0383*   @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
042D0C             0384*   
042D0C             0385*   
042D0C             0386*   ; print bytes from an address to the screen in hexidecimal format
042D0C             0387*   ; inputs: hl = address of first byte to print, a = number of bytes to print
042D0C             0388*   ; outputs: values of each byte printed to screen separated by spaces
042D0C             0389*   ; destroys: nothing
042D0C             0390*   dumpMemoryHex:
042D0C             0391*   ; save registers to the stack
042D0C C5          0392*       push bc
042D0D E5          0393*       push hl
042D0E F5          0394*       push af
042D0F             0395*   
042D0F             0396*   ; print the address and separator
042D0F CD A0 00 04 0397*       call printHex24
042D13 3E 3A       0398*       ld a,':'
042D15 5B D7       0399*       rst.lil 10h
042D17 3E 20       0400*       ld a,' '
042D19 5B D7       0401*       rst.lil 10h
042D1B             0402*   
042D1B             0403*   ; set b to be our loop counter
042D1B F1          0404*       pop af
042D1C 47          0405*       ld b,a
042D1D E1          0406*       pop hl
042D1E E5          0407*       push hl
042D1F F5          0408*       push af
042D20             0409*   @loop:
042D20             0410*   ; print the byte
042D20 7E          0411*       ld a,(hl)
042D21 CD AE 00 04 0412*       call printHex8
042D25             0413*   ; print a space
042D25 3E 20       0414*       ld a,' '
042D27 5B D7       0415*       rst.lil 10h
042D29 23          0416*       inc hl
042D2A 10 F4       0417*       djnz @loop
042D2C CD 7C 00 04 0418*       call printNewLine
042D30             0419*   
042D30             0420*   ; restore everything
042D30 F1          0421*       pop af
042D31 E1          0422*       pop hl
042D32 C1          0423*       pop bc
042D33             0424*   
042D33             0425*   ; all done
042D33 C9          0426*       ret
042D34             0427*   
042D34             0428*   
042D34             0429*   ; print bytes from an address to the screen in binary format
042D34             0430*   ; inputs: hl = address of first byte to print, a = number of bytes to print
042D34             0431*   ; outputs: values of each byte printed to screen separated by spaces
042D34             0432*   ; destroys: nothing
042D34             0433*   dumpMemoryBin:
042D34             0434*   ; save all registers to the stack
042D34 F5          0435*       push af
042D35 C5          0436*       push bc
042D36 D5          0437*       push de
042D37 E5          0438*       push hl
042D38 DD E5       0439*       push ix
042D3A FD E5       0440*       push iy
042D3C             0441*   
042D3C             0442*   ; set b to be our loop counter
042D3C 47          0443*       ld b,a
042D3D             0444*   @loop:
042D3D             0445*   ; print the byte
042D3D 7E          0446*       ld a,(hl)
042D3E E5          0447*       push hl
042D3F C5          0448*       push bc
042D40 CD 6E 02 04 0449*       call printBin8
042D44 C1          0450*       pop bc
042D45             0451*   ; print a space
042D45 3E 20       0452*       ld a,' '
042D47 5B D7       0453*       rst.lil 10h
042D49 E1          0454*       pop hl
042D4A 23          0455*       inc hl
042D4B 10 F0       0456*       djnz @loop
042D4D CD 7C 00 04 0457*       call printNewLine
042D51             0458*   
042D51             0459*   ; restore everything
042D51 FD E1       0460*       pop iy
042D53 DD E1       0461*       pop ix
042D55 E1          0462*       pop hl
042D56 D1          0463*       pop de
042D57 C1          0464*       pop bc
042D58 F1          0465*       pop af
042D59             0466*   ; all done
042D59 C9          0467*       ret
042D5A             0468*   
042D5A             0469*   ; print bytes from an address to the screen in binary format
042D5A             0470*   ; with the bits of each byte in reverse order (lsb first)
042D5A             0471*   ; inputs: hl = address of first byte to print, a = number of bytes to print
042D5A             0472*   ; outputs: values of each byte printed to screen separated by spaces
042D5A             0473*   ; destroys: nothing
042D5A             0474*   dumpMemoryBinRev:
042D5A             0475*   ; save all registers to the stack
042D5A F5          0476*       push af
042D5B C5          0477*       push bc
042D5C D5          0478*       push de
042D5D E5          0479*       push hl
042D5E DD E5       0480*       push ix
042D60 FD E5       0481*       push iy
042D62             0482*   
042D62             0483*   ; set b to be our loop counter
042D62 47          0484*       ld b,a
042D63             0485*   @loop:
042D63             0486*   ; print the byte
042D63 7E          0487*       ld a,(hl)
042D64 E5          0488*       push hl
042D65 C5          0489*       push bc
042D66 CD 93 02 04 0490*       call printBin8Rev
042D6A C1          0491*       pop bc
042D6B             0492*   ; print a space
042D6B 3E 20       0493*       ld a,' '
042D6D 5B D7       0494*       rst.lil 10h
042D6F E1          0495*       pop hl
042D70 23          0496*       inc hl
042D71 10 F0       0497*       djnz @loop
042D73 CD 7C 00 04 0498*       call printNewLine
042D77             0499*   
042D77             0500*   ; restore everything
042D77 FD E1       0501*       pop iy
042D79 DD E1       0502*       pop ix
042D7B E1          0503*       pop hl
042D7C D1          0504*       pop de
042D7D C1          0505*       pop bc
042D7E F1          0506*       pop af
042D7F             0507*   ; all done
042D7F C9          0508*       ret
042D80             0509*   
042D80             0510*   DEBUG_PRINT:
042D80             0511*       PUSH_ALL
                       M1 Args: none
042D80 08          0001*M1     ex af,af'
042D81 D9          0002*M1     exx
042D82 F5          0003*M1     push af
042D83 E5          0004*M1     push hl
042D84 C5          0005*M1     push bc
042D85 D5          0006*M1     push de
042D86             0007*M1 
042D86 08          0008*M1     ex af,af'
042D87 D9          0009*M1     exx
042D88 F5          0010*M1     push af
042D89 E5          0011*M1     push hl
042D8A C5          0012*M1     push bc
042D8B D5          0013*M1     push de
042D8C DD E5       0014*M1     push ix
042D8E FD E5       0015*M1     push iy
042D90             0512*       ; ld c,0 ; X
042D90             0513*       ; ld b,0 ; Y
042D90             0514*       ; call vdu_move_cursor
042D90 CD 7C 00 04 0515*       call printNewLine
042D94             0516*       POP_ALL
                       M1 Args: none
042D94 FD E1       0001*M1     pop iy
042D96 DD E1       0002*M1     pop ix
042D98 D1          0003*M1     pop de
042D99 C1          0004*M1     pop bc
042D9A E1          0005*M1     pop hl
042D9B F1          0006*M1     pop af
042D9C 08          0007*M1     ex af,af'
042D9D D9          0008*M1     exx
042D9E             0009*M1 
042D9E D1          0010*M1     pop de
042D9F C1          0011*M1     pop bc
042DA0 E1          0012*M1     pop hl
042DA1 F1          0013*M1     pop af
042DA2 08          0014*M1     ex af,af'
042DA3 D9          0015*M1     exx
042DA4             0517*       PUSH_ALL
                       M1 Args: none
042DA4 08          0001*M1     ex af,af'
042DA5 D9          0002*M1     exx
042DA6 F5          0003*M1     push af
042DA7 E5          0004*M1     push hl
042DA8 C5          0005*M1     push bc
042DA9 D5          0006*M1     push de
042DAA             0007*M1 
042DAA 08          0008*M1     ex af,af'
042DAB D9          0009*M1     exx
042DAC F5          0010*M1     push af
042DAD E5          0011*M1     push hl
042DAE C5          0012*M1     push bc
042DAF D5          0013*M1     push de
042DB0 DD E5       0014*M1     push ix
042DB2 FD E5       0015*M1     push iy
042DB4 CD BB 2C 04 0518*       call dumpFlags
042DB8             0519*       POP_ALL
                       M1 Args: none
042DB8 FD E1       0001*M1     pop iy
042DBA DD E1       0002*M1     pop ix
042DBC D1          0003*M1     pop de
042DBD C1          0004*M1     pop bc
042DBE E1          0005*M1     pop hl
042DBF F1          0006*M1     pop af
042DC0 08          0007*M1     ex af,af'
042DC1 D9          0008*M1     exx
042DC2             0009*M1 
042DC2 D1          0010*M1     pop de
042DC3 C1          0011*M1     pop bc
042DC4 E1          0012*M1     pop hl
042DC5 F1          0013*M1     pop af
042DC6 08          0014*M1     ex af,af'
042DC7 D9          0015*M1     exx
042DC8             0520*       PUSH_ALL
                       M1 Args: none
042DC8 08          0001*M1     ex af,af'
042DC9 D9          0002*M1     exx
042DCA F5          0003*M1     push af
042DCB E5          0004*M1     push hl
042DCC C5          0005*M1     push bc
042DCD D5          0006*M1     push de
042DCE             0007*M1 
042DCE 08          0008*M1     ex af,af'
042DCF D9          0009*M1     exx
042DD0 F5          0010*M1     push af
042DD1 E5          0011*M1     push hl
042DD2 C5          0012*M1     push bc
042DD3 D5          0013*M1     push de
042DD4 DD E5       0014*M1     push ix
042DD6 FD E5       0015*M1     push iy
042DD8 CD A7 2B 04 0521*       call dumpRegistersHex
042DDC             0522*       ; call waitKeypress
042DDC CD 7C 00 04 0523*       call printNewLine
042DE0             0524*       POP_ALL
                       M1 Args: none
042DE0 FD E1       0001*M1     pop iy
042DE2 DD E1       0002*M1     pop ix
042DE4 D1          0003*M1     pop de
042DE5 C1          0004*M1     pop bc
042DE6 E1          0005*M1     pop hl
042DE7 F1          0006*M1     pop af
042DE8 08          0007*M1     ex af,af'
042DE9 D9          0008*M1     exx
042DEA             0009*M1 
042DEA D1          0010*M1     pop de
042DEB C1          0011*M1     pop bc
042DEC E1          0012*M1     pop hl
042DED F1          0013*M1     pop af
042DEE 08          0014*M1     ex af,af'
042DEF D9          0015*M1     exx
042DF0 C9          0525*       ret
042DF1             0526*   DEBUG_WAITKEYPRESS:
042DF1             0527*       PUSH_ALL
                       M1 Args: none
042DF1 08          0001*M1     ex af,af'
042DF2 D9          0002*M1     exx
042DF3 F5          0003*M1     push af
042DF4 E5          0004*M1     push hl
042DF5 C5          0005*M1     push bc
042DF6 D5          0006*M1     push de
042DF7             0007*M1 
042DF7 08          0008*M1     ex af,af'
042DF8 D9          0009*M1     exx
042DF9 F5          0010*M1     push af
042DFA E5          0011*M1     push hl
042DFB C5          0012*M1     push bc
042DFC D5          0013*M1     push de
042DFD DD E5       0014*M1     push ix
042DFF FD E5       0015*M1     push iy
042E01 CD 5A 03 04 0528*       call waitKeypress
042E05             0529*       POP_ALL
                       M1 Args: none
042E05 FD E1       0001*M1     pop iy
042E07 DD E1       0002*M1     pop ix
042E09 D1          0003*M1     pop de
042E0A C1          0004*M1     pop bc
042E0B E1          0005*M1     pop hl
042E0C F1          0006*M1     pop af
042E0D 08          0007*M1     ex af,af'
042E0E D9          0008*M1     exx
042E0F             0009*M1 
042E0F D1          0010*M1     pop de
042E10 C1          0011*M1     pop bc
042E11 E1          0012*M1     pop hl
042E12 F1          0013*M1     pop af
042E13 08          0014*M1     ex af,af'
042E14 D9          0015*M1     exx
042E15 C9          0530*       RET
042E16             0531*   
042E16             0532*   dumpVduCmdStr:
042E16             0533*       PUSH_ALL
                       M1 Args: none
042E16 08          0001*M1     ex af,af'
042E17 D9          0002*M1     exx
042E18 F5          0003*M1     push af
042E19 E5          0004*M1     push hl
042E1A C5          0005*M1     push bc
042E1B D5          0006*M1     push de
042E1C             0007*M1 
042E1C 08          0008*M1     ex af,af'
042E1D D9          0009*M1     exx
042E1E F5          0010*M1     push af
042E1F E5          0011*M1     push hl
042E20 C5          0012*M1     push bc
042E21 D5          0013*M1     push de
042E22 DD E5       0014*M1     push ix
042E24 FD E5       0015*M1     push iy
042E26 79          0534*       ld a,c
042E27 CD 0C 2D 04 0535*       call dumpMemoryHex
042E2B CD 5A 03 04 0536*       call waitKeypress
042E2F             0537*       POP_ALL
                       M1 Args: none
042E2F FD E1       0001*M1     pop iy
042E31 DD E1       0002*M1     pop ix
042E33 D1          0003*M1     pop de
042E34 C1          0004*M1     pop bc
042E35 E1          0005*M1     pop hl
042E36 F1          0006*M1     pop af
042E37 08          0007*M1     ex af,af'
042E38 D9          0008*M1     exx
042E39             0009*M1 
042E39 D1          0010*M1     pop de
042E3A C1          0011*M1     pop bc
042E3B E1          0012*M1     pop hl
042E3C F1          0013*M1     pop af
042E3D 08          0014*M1     ex af,af'
042E3E D9          0015*M1     exx
042E3F C9          0538*       ret
042E40             0539*   ; end dumpVduCmdStr
042E40             0053    
042E40             0054    ; --- MAIN PROGRAM FILE ---
042E40 00          0055    original_screen_mode: db 0
042E41             0056    
042E41             0057    init:
042E41             0058    ; change directory to music
042E41 21 31 2F 04 0059        ld hl,cmd_cd_music
042E45             0060        MOSCALL mos_oscli
                       M1 Args: function=mos_oscli 
042E45 3E 10       0001M1  			LD	A, function
042E47 5B CF       0002M1  			RST.LIL	08h
042E49             0061    ; call directory page listing
042E49 CD 16 27 04 0062        call ps_get_dir
042E4D             0063    ; get current screen mode and save it so we can return to it on exit
042E4D CD E3 17 04 0064        call vdu_get_screen_mode
042E51 32 40 2E 04 0065        ld (original_screen_mode),a
042E55             0066    ; set up display for gameplay
042E55 3E 14       0067        ld a,20
042E57 CD D2 17 04 0068        call vdu_set_screen_mode
042E5B AF          0069        xor a
042E5C CD EB 17 04 0070        call vdu_set_scaling
042E60             0071    ; set text background color
042E60 3E 84       0072        ld a,c_blue_dk+128
042E62 CD 35 17 04 0073        call vdu_colour_text
042E66             0074    ; set text foreground color
042E66 3E 0F       0075        ld a,c_white
042E68 CD 35 17 04 0076        call vdu_colour_text
042E6C             0077    ; set the cursor off
042E6C CD CC 16 04 0078        call vdu_cursor_off
042E70             0079    ; clear the screen
042E70 CD 04 17 04 0080        call vdu_cls
042E74             0081    ; clear all buffers
042E74 CD D9 1A 04 0082        call vdu_clear_all_buffers
042E78             0083    ; load fonts
042E78 CD 82 05 04 0084    	call fonts_load
042E7C             0085    ; select font
042E7C 21 10 FA 00 0086        ld hl,Lat2_VGA8_8x8
042E80 3E 01       0087        ld a,1 ; flags
042E82 CD 4B 1B 04 0088        call vdu_font_select
042E86             0089    ; print ascii art splash screen
042E86 CD 04 17 04 0090        call vdu_cls
042E8A 0E 00       0091        ld c,0 ; x
042E8C 06 04       0092        ld b,4 ; y
042E8E CD F0 16 04 0093        call vdu_move_cursor
042E92 CD 60 00 04 0094        call printInline
042E96 57 65 6C 63 0095        asciz "Welcome to...\r\n"
       6F 6D 65 20 
       74 6F 2E 2E 
       2E 0D 0A 00 
042EA6 21 D6 1E 04 0096        ld hl,agon_jukebox_ascii
042EAA CD 67 00 04 0097        call printString
042EAE             0098    ; print out current directory path
042EAE CD 7C 00 04 0099        call printNewLine
042EB2 21 80 2F 04 0100        ld hl,str_thick_dashes
042EB6 CD 67 00 04 0101        call printString
042EBA CD 60 00 04 0102        call printInline
042EBE 0D 0A 4F 75 0103        asciz "\r\nOur current directory is:\r\n"
       72 20 63 75 
       72 72 65 6E 
       74 20 64 69 
       72 65 63 74 
       6F 72 79 20 
       69 73 3A 0D 
       0A 00       
042EDC 21 74 22 04 0104        ld hl,ps_dir_path
042EE0 CD 67 00 04 0105        call printString
042EE4 CD 7C 00 04 0106        call printNewLine
042EE8 21 80 2F 04 0107        ld hl,str_thick_dashes
042EEC CD 67 00 04 0108        call printString
042EF0             0109    ; print instructions
042EF0 CD 60 00 04 0110        call printInline
042EF4 0D 0A 50 72 0111        asciz "\r\nPress keys 0-9 to play a song:\r\n"
       65 73 73 20 
       6B 65 79 73 
       20 30 2D 39 
       20 74 6F 20 
       70 6C 61 79 
       20 61 20 73 
       6F 6E 67 3A 
       0D 0A 00    
042F17 21 40 2F 04 0112        ld hl,str_dashes
042F1B CD 67 00 04 0113        call printString
042F1F             0114    ; print first 10 files in the directory
042F1F AF          0115        xor a ; song index to 0
042F20 32 83 24 04 0116        ld (ps_song_idx_cur),a
042F24 CD 7C 00 04 0117        call printNewLine
042F28 CD E5 27 04 0118        call ps_print_dir_page
042F2C             0119        ; call print_dir_border_bottom
042F2C             0120    ; initialize play sample timer interrupt handler
042F2C CD E3 29 04 0121        call ps_prt_irq_init
042F30 C9          0122        ret
042F31             0123    ; end init
042F31             0124    
042F31 63 64 20 6D 0125    cmd_cd_music: asciz "cd music"
       75 73 69 63 
       00          
042F3A 63 64 20 2E 0126    cmd_cd_up: asciz "cd .."
       2E 00       
042F40 2D 2D 2D 2D 0127    str_dashes: asciz "---------------------------------------------------------------"
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 00 
042F80 3D 3D 3D 3D 0128    str_thick_dashes: asciz "==============================================================="
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 00 
042FC0             0129    
042FC0             0130    main:
042FC0             0131    ; call get_input to start player
042FC0 CD A7 21 04 0132        call get_input
042FC4             0133    ; user pressed ESC to quit so shut down everytyhing and gracefully exit to MOS
042FC4 CD DD 29 04 0134        call ps_prt_stop ; stop the PRT timer
042FC8 FB          0135        ei ; interrupts were disabled by get_input
042FC9             0136    ; restore original screen mode
042FC9 3A 40 2E 04 0137        ld a,(original_screen_mode)
042FCD CD D2 17 04 0138        call vdu_set_screen_mode
042FD1 CD CD 17 04 0139        call vdu_reset_viewports
042FD5 CD 04 17 04 0140        call vdu_cls
042FD9             0141    ; change back to directory containing the program
042FD9 21 3A 2F 04 0142        ld hl,cmd_cd_up
042FDD             0143        MOSCALL mos_oscli
                       M1 Args: function=mos_oscli 
042FDD 3E 10       0001M1  			LD	A, function
042FDF 5B CF       0002M1  			RST.LIL	08h
042FE1             0144    ; print thanks for playing message
042FE1 CD 60 00 04 0145        call printInline
042FE5 54 68 61 6E 0146        asciz "Thank you for using\r\n"
       6B 20 79 6F 
       75 20 66 6F 
       72 20 75 73 
       69 6E 67 0D 
       0A 00       
042FFB 21 D6 1E 04 0147        ld hl,agon_jukebox_ascii
042FFF CD 67 00 04 0148        call printString
043003 CD BE 16 04 0149        call vdu_cursor_on
043007 C9          0150        ret ; back to MOS
043008             0151    ; end main
043008             0152    
043008             0153    ; must be final include in program so file data does not stomp on program code or other data
043008             0154        include "files.inc"
043008             0001*   ; THIS MUST BE LAST INCLUDE SO FILE DATA DOES NOT OVERWRITE OTHER CODE OR DATA
043008             0002*   
043008             0003*   ; buffer for loading files unrelated to audio
043008             0004*   ; e.g.: fonts, sprites, etc. (limited to 8k)
043008             0005*   filedata: equ 0xB7E000 ; address of onboard 8k sram
043008             0006*   
043008             0007*   ;     align 256 ; make things nice for indexing into especially ps_dir_fil_list
043008             0008*   ; ; buffer for sound data
043008             0009*   ps_wav_data_start: equ 0x050000 ;    equ $   ; (042E00) Start of audio data
043008             0010*   
043008             0011*   ; this list can grow as large as necessary to hold all the files in the directory
043008             0012*   ; each entry will be 256 bytes long, the max filename size MOS/FFS supports
043008             0013*   ps_dir_fil_list: equ 0x060000 ; equ ps_wav_data_start+65536 ; (052E00) max file data we can load in one chunk is 64k
