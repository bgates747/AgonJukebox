PC     Output      Line
040000             0001        assume adl=1
040000             0002        org 0x040000
040000 C3 45 00 04 0003        jp start
040004 FF FF FF FF 0004        align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0005        db "MOS"
040043 00          0006        db 00h
040044 01          0007        db 01h
040045             0008    
040045             0009    start:
040045 F5          0010        push af
040046 C5          0011        push bc
040047 D5          0012        push de
040048 DD E5       0013        push ix
04004A FD E5       0014        push iy
04004C             0015    
04004C CD 7F 27 04 0016        call init
040050 CD C3 28 04 0017        call main
040054             0018    
040054             0019    exit:
040054 FD E1       0020        pop iy
040056 DD E1       0021        pop ix
040058 D1          0022        pop de
040059 C1          0023        pop bc
04005A F1          0024        pop af
04005B 21 00 00 00 0025        ld hl,0
04005F             0026    
04005F C9          0027        ret
040060             0028    
040060             0029    ; API INCLUDES
040060             0030        include "mos_api.inc"
040060             0001*   ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.inc
040060             0002*   ; Title:	AGON MOS - API for user projects
040060             0003*   ; Author:	Dean Belfield
040060             0004*   ;			Adapted for agon-ez80asm by Jeroen Venema
040060             0005*   ;			Added MOS error codes for return in HL
040060             0006*   ; Created:	03/08/2022
040060             0007*   ; Last Updated:	10/08/2023
040060             0008*   ;
040060             0009*   ; Modinfo:
040060             0010*   ; 05/08/2022:	Added mos_feof
040060             0011*   ; 09/08/2022:	Added system variables: cursorX, cursorY
040060             0012*   ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040060             0013*   ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040060             0014*   ; 24/09/2022:	Added mos_getError, mos_mkdir
040060             0015*   ; 13/10/2022:	Added mos_oscli
040060             0016*   ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040060             0017*   ; 04/03/2023:	Added sysvar_scrpixelIndex
040060             0018*   ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040060             0019*   ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040060             0020*   ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040060             0021*   ; 22/03/2023:	The VDP commands are now indexed from 0x80
040060             0022*   ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040060             0023*   ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040060             0024*   ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040060             0025*   ; 19/05/2023:	Added sysvar_scrMode
040060             0026*   ; 05/06/2023:	Added sysvar_rtcEnable
040060             0027*   ; 03/08/2023:	Added mos_setkbvector
040060             0028*   ; 10/08/2023:	Added mos_getkbmap
040060             0029*   
040060             0030*   ; VDP control (VDU 23, 0, n)
040060             0031*   ;
040060             0032*   vdp_gp:				EQU 80h
040060             0033*   vdp_keycode:		EQU 81h
040060             0034*   vdp_cursor:			EQU	82h
040060             0035*   vdp_scrchar:		EQU	83h
040060             0036*   vdp_scrpixel:		EQU	84h
040060             0037*   vdp_audio:			EQU	85h
040060             0038*   vdp_mode:			EQU	86h
040060             0039*   vdp_rtc:			EQU	87h
040060             0040*   vdp_keystate:		EQU	88h
040060             0041*   vdp_logicalcoords:	EQU	C0h
040060             0042*   vdp_terminalmode:	EQU	FFh
040060             0043*   
040060             0044*   ; MOS high level functions
040060             0045*   ;
040060             0046*   mos_getkey:			EQU	00h
040060             0047*   mos_load:			EQU	01h
040060             0048*   mos_save:			EQU	02h
040060             0049*   mos_cd:				EQU	03h
040060             0050*   mos_dir:			EQU	04h
040060             0051*   mos_del:			EQU	05h
040060             0052*   mos_ren:			EQU	06h
040060             0053*   mos_mkdir:			EQU	07h
040060             0054*   mos_sysvars:		EQU	08h
040060             0055*   mos_editline:		EQU	09h
040060             0056*   mos_fopen:			EQU	0Ah
040060             0057*   mos_fclose:			EQU	0Bh
040060             0058*   mos_fgetc:			EQU	0Ch
040060             0059*   mos_fputc:			EQU	0Dh
040060             0060*   mos_feof:			EQU	0Eh
040060             0061*   mos_getError:		EQU	0Fh
040060             0062*   mos_oscli:			EQU	10h
040060             0063*   mos_copy:			EQU	11h
040060             0064*   mos_getrtc:			EQU	12h
040060             0065*   mos_setrtc:			EQU	13h
040060             0066*   mos_setintvector:	EQU	14h
040060             0067*   mos_uopen:			EQU	15h
040060             0068*   mos_uclose:			EQU	16h
040060             0069*   mos_ugetc:			EQU	17h
040060             0070*   mos_uputc:			EQU	18h
040060             0071*   mos_getfil:			EQU	19h
040060             0072*   mos_fread:			EQU	1Ah
040060             0073*   mos_fwrite:			EQU	1Bh
040060             0074*   mos_flseek:			EQU	1Ch
040060             0075*   mos_setkbvector:	EQU	1Dh
040060             0076*   mos_getkbmap:		EQU	1Eh
040060             0077*   
040060             0078*   ; MOS program exit codes
040060             0079*   ;
040060             0080*   EXIT_OK:				EQU  0;	"OK",
040060             0081*   EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
040060             0082*   EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
040060             0083*   EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
040060             0084*   EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
040060             0085*   EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
040060             0086*   EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
040060             0087*   EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
040060             0088*   EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
040060             0089*   EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
040060             0090*   EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
040060             0091*   EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
040060             0092*   EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
040060             0093*   EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
040060             0094*   EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
040060             0095*   EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
040060             0096*   EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
040060             0097*   EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
040060             0098*   EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
040060             0099*   EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
040060             0100*   EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
040060             0101*   EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
040060             0102*   ; FatFS file access functions
040060             0103*   ;
040060             0104*   ffs_fopen:			EQU	80h
040060             0105*   ffs_fclose:			EQU	81h
040060             0106*   ffs_fread:			EQU	82h
040060             0107*   ffs_fwrite:			EQU	83h
040060             0108*   ffs_flseek:			EQU	84h
040060             0109*   ffs_ftruncate:		EQU	85h
040060             0110*   ffs_fsync:			EQU	86h
040060             0111*   ffs_fforward:		EQU	87h
040060             0112*   ffs_fexpand:		EQU	88h
040060             0113*   ffs_fgets:			EQU	89h
040060             0114*   ffs_fputc:			EQU	8Ah
040060             0115*   ffs_fputs:			EQU	8Bh
040060             0116*   ffs_fprintf:		EQU	8Ch
040060             0117*   ffs_ftell:			EQU	8Dh
040060             0118*   ffs_feof:			EQU	8Eh
040060             0119*   ffs_fsize:			EQU	8Fh
040060             0120*   ffs_ferror:			EQU	90h
040060             0121*   
040060             0122*   ; FatFS directory access functions
040060             0123*   ;
040060             0124*   ffs_dopen:			EQU	91h
040060             0125*   ffs_dclose:			EQU	92h
040060             0126*   ffs_dread:			EQU	93h
040060             0127*   ffs_dfindfirst:		EQU	94h
040060             0128*   ffs_dfindnext:		EQU	95h
040060             0129*   
040060             0130*   ; FatFS file and directory management functions
040060             0131*   ;
040060             0132*   ffs_stat:			EQU	96h
040060             0133*   ffs_unlink:			EQU	97h
040060             0134*   ffs_rename:			EQU	98h
040060             0135*   ffs_chmod:			EQU	99h
040060             0136*   ffs_utime:			EQU	9Ah
040060             0137*   ffs_mkdir:			EQU	9Bh
040060             0138*   ffs_chdir:			EQU	9Ch
040060             0139*   ffs_chdrive:		EQU	9Dh
040060             0140*   ffs_getcwd:			EQU	9Eh
040060             0141*   
040060             0142*   ; FatFS volume management and system configuration functions
040060             0143*   ;
040060             0144*   ffs_mount:			EQU	9Fh
040060             0145*   ffs_mkfs:			EQU	A0h
040060             0146*   ffs_fdisk:			EQU	A1h
040060             0147*   ffs_getfree:		EQU	A2h
040060             0148*   ffs_getlabel:		EQU	A3h
040060             0149*   ffs_setlabel:		EQU	A4h
040060             0150*   ffs_setcp:			EQU	A5h
040060             0151*   
040060             0152*   ; File access modes
040060             0153*   ;
040060             0154*   fa_read:			EQU	01h
040060             0155*   fa_write:			EQU	02h
040060             0156*   fa_open_existing:	EQU	00h
040060             0157*   fa_create_new:		EQU	04h
040060             0158*   fa_create_always:	EQU	08h
040060             0159*   fa_open_always:		EQU	10h
040060             0160*   fa_open_append:		EQU	30h
040060             0161*   
040060             0162*   ; System variable indexes for api_sysvars
040060             0163*   ; Index into _sysvars in globals.inc
040060             0164*   ;
040060             0165*   sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040060             0166*   sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
040060             0167*   sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040060             0168*   sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
040060             0169*   sysvar_cursorX:			EQU	07h	; 1: Cursor X position
040060             0170*   sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
040060             0171*   sysvar_scrchar:			EQU	09h	; 1: Character read from screen
040060             0172*   sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040060             0173*   sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040060             0174*   sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040060             0175*   sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
040060             0176*   sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
040060             0177*   sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
040060             0178*   sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
040060             0179*   sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
040060             0180*   sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040060             0181*   sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
040060             0182*   sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040060             0183*   sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
040060             0184*   sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
040060             0185*   sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
040060             0186*   sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
040060             0187*   sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
040060             0188*   sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
040060             0189*   sysvar_scrMode:			EQU	27h	; 1: Screen mode
040060             0190*   sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040060             0191*   
040060             0192*   ; Flags for the VPD protocol
040060             0193*   ;
040060             0194*   vdp_pflag_cursor:		EQU	00000001b
040060             0195*   vdp_pflag_scrchar:		EQU	00000010b
040060             0196*   vdp_pflag_point:		EQU	00000100b
040060             0197*   vdp_pflag_audio:		EQU	00001000b
040060             0198*   vdp_pflag_mode:			EQU	00010000b
040060             0199*   vdp_pflag_rtc:			EQU	00100000b
040060             0200*   
040060             0201*   ;
040060             0202*   ; FatFS structures
040060             0203*   ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040060             0204*   ;
040060             0205*   ; Object ID and allocation information (FFOBJID)
040060             0206*   ;
040060             0207*   ; Indexes into FFOBJID structure
040060             0208*   ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
040060             0209*   ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
040060             0210*   ffobjid_attr:		EQU	5	; 1: Object attribute
040060             0211*   ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040060             0212*   ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
040060             0213*   ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
040060             0214*   ;
040060             0215*   ; File object structure (FIL)
040060             0216*   ;
040060             0217*   ; Indexes into FIL structure
040060             0218*   fil_obj:		EQU 0	; 15: Object identifier
040060             0219*   fil_flag:		EQU	15 	;  1: File status flags
040060             0220*   fil_err:		EQU	16	;  1: Abort flag (error code)
040060             0221*   fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
040060             0222*   fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
040060             0223*   fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
040060             0224*   fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
040060             0225*   fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
040060             0226*   ;
040060             0227*   ; Directory object structure (DIR)
040060             0228*   ; Indexes into DIR structure
040060             0229*   dir_obj:		EQU  0	; 15: Object identifier
040060             0230*   dir_dptr:		EQU	15	;  4: Current read/write offset
040060             0231*   dir_clust:		EQU	19	;  4: Current cluster
040060             0232*   dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
040060             0233*   dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
040060             0234*   dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
040060             0235*   dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040060             0236*   ;
040060             0237*   ; File information structure (FILINFO)
040060             0238*   ;
040060             0239*   ; Indexes into FILINFO structure
040060             0240*   filinfo_fsize:		EQU 0	;   4: File size
040060             0241*   filinfo_fdate:		EQU	4	;   2: Modified date
040060             0242*   filinfo_ftime:		EQU	6	;   2: Modified time
040060             0243*   filinfo_fattrib:	EQU	8	;   1: File attribute
040060             0244*   filinfo_altname:	EQU	9	;  13: Alternative file name
040060             0245*   filinfo_fname:		EQU	22	; 256: Primary file name
040060             0246*   ;
040060             0247*   ; Macro for calling the API
040060             0248*   ; Parameters:
040060             0249*   ; - function: One of the function numbers listed above
040060             0250*   ;
040060             0251*   	MACRO	MOSCALL	function
040060             0252*   			LD	A, function
040060             0253*   			RST.LIL	08h
040060             0254*   	ENDMACRO
040060             0031        include "macros.inc"
040060             0001*   
040060             0002*   ; test the sign of HL
040060             0003*   ; inputs: HL obviously
040060             0004*   ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
040060             0005*   ; destroys: flags
040060             0006*       MACRO SIGN_HLU
040060             0007*       add hl,de ; 1 cycle
040060             0008*       or a ; clear flags ; 1 cycle
040060             0009*       sbc hl,de ; 2 cycles
040060             0010*       ; 4 cycles total
040060             0011*       ENDMACRO
040060             0012*   
040060             0013*   ; put the value in A into HLU
040060             0014*   ; affects: HLU
040060             0015*   ; destroys: nothing
040060             0016*   ; note: $ instead of @@ b/c anon labels deprecated in ez80asm
040060             0017*       MACRO A_TO_HLU
040060             0018*       xor a ; 1 cycle
040060             0019*       ld ($+8+1),hl ; 7 cycles
040060             0020*       ld ($+4+3),a ; 5 cycles
040060             0021*       ld hl,0x000000 ; 4 cycles
040060             0022*       ; 17 cycles total
040060             0023*       ENDMACRO
040060             0024*   
040060             0025*   ; alternative: https://discord.com/channels/1158535358624039014/1282290921815408681/1318315567102300220
040060             0026*   ; one cycle less but burns flags
040060             0027*       MACRO A_TO_HLU_ALT
040060             0028*       push hl ; 4 cycles
040060             0029*       ld hl,2 ; 4 cycles
040060             0030*       add hl,sp ; 1 cycle
040060             0031*       ld (hl),a ; 2 cycles
040060             0032*       pop hl ; 4 cycles
040060             0033*       ; 15 cycles total
040060             0034*       ENDMACRO
040060             0035*   
040060             0036*       MACRO hlu_mul256
040060             0037*       add hl,hl ; * 2
040060             0038*       add hl,hl ; * 4
040060             0039*       add hl,hl ; * 8
040060             0040*       add hl,hl ; * 16
040060             0041*       add hl,hl ; * 32
040060             0042*       add hl,hl ; * 64
040060             0043*       add hl,hl ; * 128
040060             0044*       add hl,hl ; * 256
040060             0045*       ENDMACRO
040060             0046*   
040060             0047*   ; https://discord.com/channels/1158535358624039014/1282290921815408681/1317793870070812715
040060             0048*       MACRO SRL_UHL
040060             0049*       dec sp ; 1 cycle
040060             0050*       push hl ; 4 cycles
040060             0051*       inc sp ; 1 cycle
040060             0052*       pop hl ; 4 cycles
040060             0053*       inc hl ; 1 cycle
040060             0054*       dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
040060             0055*       ; 13 cycles total
040060             0056*       ENDMACRO
040060             0057*   
040060             0058*       MACRO printChar char
040060             0059*       LD A, char
040060             0060*       RST.LIL 10h
040060             0061*       ENDMACRO
040060             0062*   
040060             0063*   ; Simulated call to subroutine at HL
040060             0064*   ; inputs: HL pointing to the subroutine address plus whatever the called function expects
040060             0065*   ; outputs: whatever the subroutine does, including HL and BC
040060             0066*   ; destroys: only what the subroutine does, but always BC
040060             0067*       MACRO CALL_HL
040060             0068*       ld bc,$+6 ; Address of first instruction after the jump
040060             0069*       push bc ; which constitutes the return address
040060             0070*       jp (hl) ; Jump to the address in HL
040060             0071*       ENDMACRO
040060             0072*   
040060             0073*   ; Simulated call to subroutine at IX
040060             0074*   ; inputs: IX pointing to the subroutine address plus whatever the called function expects
040060             0075*   ; outputs: whatever the subroutine does, including IX and BC
040060             0076*   ; destroys: only what the subroutine does, but always BC
040060             0077*       MACRO CALL_IX
040060             0078*       ld bc,$+6 ; Address of first instruction after the jump
040060             0079*       push bc ; which constitutes the return address
040060             0080*       jp (ix) ; Jump to the address in IX
040060             0081*       ENDMACRO
040060             0082*   
040060             0083*   ; Simulated call to soubroutinte at IY
040060             0084*   ; inputs: IY pointing to the subroutine address plus whatever the called function expects
040060             0085*   ; outputs: whatever the subroutine does, including IY and BC
040060             0086*   ; destroys: only what the subroutine does, but always BC
040060             0087*       MACRO CALL_IY
040060             0088*       ld bc,$+6 ; Address of first instruction after the jump
040060             0089*       push bc ; which constitutes the return address
040060             0090*       jp (iy) ; Jump to the address in IY
040060             0091*       ENDMACRO
040060             0092*   
040060             0093*   ; put the value in HLU into A
040060             0094*   ; destroys: af
040060             0095*       MACRO HLU_TO_A
040060             0096*       dec sp ; 1 cycle
040060             0097*       push hl ; 4 cycles
040060             0098*       inc sp ; 1 cycle
040060             0099*       pop af ; 4 cycles
040060             0100*       ; 10 cycles total
040060             0101*       ENDMACRO
040060             0102*   
040060             0103*       MACRO PUSH_ALL
040060             0104*       ex af,af'
040060             0105*       exx
040060             0106*       push af
040060             0107*       push hl
040060             0108*       push bc
040060             0109*       push de
040060             0110*   
040060             0111*       ex af,af'
040060             0112*       exx
040060             0113*       push af
040060             0114*       push hl
040060             0115*       push bc
040060             0116*       push de
040060             0117*       push ix
040060             0118*       push iy
040060             0119*       ENDMACRO
040060             0120*   
040060             0121*       MACRO POP_ALL
040060             0122*       pop iy
040060             0123*       pop ix
040060             0124*       pop de
040060             0125*       pop bc
040060             0126*       pop hl
040060             0127*       pop af
040060             0128*       ex af,af'
040060             0129*       exx
040060             0130*   
040060             0131*       pop de
040060             0132*       pop bc
040060             0133*       pop hl
040060             0134*       pop af
040060             0135*       ex af,af'
040060             0136*       exx
040060             0137*       ENDMACRO
040060             0032        include "functions.inc"
040060             0001*   ; Print a zero-terminated string inline with code, e.g.:
040060             0002*   ;
040060             0003*   ;    call printInline
040060             0004*   ;    ASCIZ "Hello, world!\r\n"
040060             0005*   ;
040060             0006*   ; Destroys: HL,AF
040060             0007*   printInline:
040060 E1          0008*       pop hl ; get the return address = pointer to start of string
040061 CD 67 00 04 0009*       call printString ; HL advances to end of string
040065 E5          0010*       push hl ; restore the return address = pointer to end of string
040066 C9          0011*       ret
040067             0012*   
040067             0013*   ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
040067             0014*   ; Print a zero-terminated string
040067             0015*   ; HL: Pointer to string
040067             0016*   printString:
040067 C5          0017*       PUSH BC
040068 01 00 00 00 0018*       LD BC,0
04006C 3E 00       0019*       LD A,0
04006E 5B DF       0020*       RST.LIL 18h
040070 C1          0021*       POP BC
040071 C9          0022*       RET
040072             0023*   ; print a VDU sequence
040072             0024*   ; HL: Pointer to VDU sequence - <1 byte length> <data>
040072             0025*   sendVDUsequence:
040072 C5          0026*       PUSH BC
040073 01 00 00 00 0027*       LD BC, 0
040077 4E          0028*       LD C, (HL)
040078 5B DF       0029*       RST.LIL 18h
04007A C1          0030*       POP BC
04007B C9          0031*       RET
04007C             0032*   ; Print Newline sequence to VDP
04007C             0033*   ; destroys bc
04007C             0034*   printNewLine:
04007C F5          0035*       push af ; for some reason rst.lil 10h sets carry flag
04007D 3E 0D       0036*       LD A, '\r'
04007F 5B D7       0037*       RST.LIL 10h
040081 3E 0A       0038*       LD A, '\n'
040083 5B D7       0039*       RST.LIL 10h
040085 F1          0040*       pop af
040086 C9          0041*       RET
040087             0042*   
040087             0043*   ; print a zero-terminated string at a graphics coordinate
040087             0044*   ; Inputs: HL Pointer to string, BC,DE x,y position (in pixels)
040087             0045*   printStringGfx:
040087 E5          0046*       push hl ; preserve string pointer
040088             0047*   ; move graphics cursor to x,y location
040088 3E 44       0048*       ld a,plot_pt+mv_abs
04008A CD B0 1B 04 0049*       call vdu_plot
04008E             0050*   ; print string
04008E E1          0051*       pop hl ; restore string pointer
04008F             0052*   @print_loop:
04008F 7E          0053*       ld a,(hl)
040090 B7          0054*       or a ; check for end of string
040091 C8          0055*       ret z ; if zero, we're done
040092 08          0056*       ex af,af' ; preserve character
040093 3E 05       0057*       ld a,5 ; VDU 5 char to gfx cursor
040095 5B D7       0058*       rst.lil 10h ; send it
040097 08          0059*       ex af,af' ; restore character
040098 5B D7       0060*       rst.lil 10h ; print character
04009A 23          0061*       inc hl
04009B C3 8F 00 04 0062*       jp @print_loop
04009F C9          0063*       ret
0400A0             0064*   ; end printStringGfx
0400A0             0065*   
0400A0             0066*   ; Print a 24-bit HEX number
0400A0             0067*   ; HLU: Number to print
0400A0             0068*   printHex24:
0400A0             0069*       HLU_TO_A
0400A0 3B          0001*M1     dec sp ; 1 cycle
0400A1 E5          0002*M1     push hl ; 4 cycles
0400A2 33          0003*M1     inc sp ; 1 cycle
0400A3 F1          0004*M1     pop af ; 4 cycles
0400A4             0005*M1     ; 10 cycles total
0400A4 CD AE 00 04 0070*       CALL printHex8
0400A8             0071*   ; Print a 16-bit HEX number
0400A8             0072*   ; HL: Number to print
0400A8             0073*   printHex16:
0400A8 7C          0074*       LD A,H
0400A9 CD AE 00 04 0075*       CALL printHex8
0400AD 7D          0076*       LD A,L
0400AE             0077*   ; Print an 8-bit HEX number
0400AE             0078*   ; A: Number to print
0400AE             0079*   printHex8:
0400AE 4F          0080*       LD C,A
0400AF 1F          0081*       RRA
0400B0 1F          0082*       RRA
0400B1 1F          0083*       RRA
0400B2 1F          0084*       RRA
0400B3 CD B8 00 04 0085*       CALL @F
0400B7 79          0086*       LD A,C
0400B8             0087*   @@:
0400B8 E6 0F       0088*       AND 0Fh
0400BA C6 90       0089*       ADD A,90h
0400BC 27          0090*       DAA
0400BD CE 40       0091*       ADC A,40h
0400BF 27          0092*       DAA
0400C0 5B D7       0093*       RST.LIL 10h
0400C2 C9          0094*       RET
0400C3             0095*   
0400C3             0096*   ; Print a 0x HEX prefix
0400C3             0097*   DisplayHexPrefix:
0400C3 3E 30       0098*       LD A, '0'
0400C5 5B D7       0099*       RST.LIL 10h
0400C7 3E 78       0100*       LD A, 'x'
0400C9 5B D7       0101*       RST.LIL 10h
0400CB C9          0102*       RET
0400CC             0103*   
0400CC             0104*       MACRO printDecBC
0400CC             0105*       push hl
0400CC             0106*       push bc
0400CC             0107*       pop hl
0400CC             0108*       call printDec
0400CC             0109*       pop hl
0400CC             0110*       ENDMACRO
0400CC             0111*   
0400CC             0112*       MACRO printDecDE
0400CC             0113*       push hl
0400CC             0114*       push de
0400CC             0115*       pop hl
0400CC             0116*       call printDec
0400CC             0117*       pop hl
0400CC             0118*       ENDMACRO
0400CC             0119*   
0400CC             0120*       MACRO printDecHL
0400CC             0121*       call printDec
0400CC             0122*       ENDMACRO
0400CC             0123*   
0400CC             0124*       MACRO printDecIX
0400CC             0125*       push hl
0400CC             0126*       push ix
0400CC             0127*       pop hl
0400CC             0128*       call printDec
0400CC             0129*       pop hl
0400CC             0130*       ENDMACRO
0400CC             0131*   
0400CC             0132*       MACRO printDecIY
0400CC             0133*       push hl
0400CC             0134*       push iy
0400CC             0135*       pop hl
0400CC             0136*       call printDec
0400CC             0137*       pop hl
0400CC             0138*       ENDMACRO
0400CC             0139*   
0400CC             0140*   
0400CC             0141*   ; Prints the right justified decimal value in HL without leading zeroes
0400CC             0142*   ; HL : Value to print
0400CC             0143*   ; preserves all registers and flags
0400CC             0144*   printDec:
0400CC             0145*   ; BEGIN MY CODE
0400CC             0146*   ; back up all the things
0400CC F5          0147*       push af
0400CD C5          0148*       push bc
0400CE D5          0149*       push de
0400CF E5          0150*       push hl
0400D0             0151*   ; END MY CODE
0400D0 11 F8 00 04 0152*       LD DE, _printDecBuffer
0400D4 CD 08 01 04 0153*       CALL u24_to_ascii
0400D8             0154*   ; BEGIN MY CODE
0400D8             0155*   ; replace leading zeroes with spaces
0400D8 21 F8 00 04 0156*       LD HL, _printDecBuffer
0400DC 06 07       0157*       ld B, 7 ; if HL was 0, we want to keep the final zero
0400DE             0158*   @loop:
0400DE 7E          0159*       LD A, (HL)
0400DF FE 30       0160*       CP '0'
0400E1 C2 EB 00 04 0161*       JP NZ, @done
0400E5 3E 20       0162*       LD A, ' '
0400E7 77          0163*       LD (HL), A
0400E8 23          0164*       INC HL
0400E9             0165*       ; CALL vdu_cursor_forward
0400E9 10 F3       0166*       DJNZ @loop
0400EB             0167*   @done:
0400EB             0168*   ; END MY CODE
0400EB 21 F8 00 04 0169*       LD HL, _printDecBuffer
0400EF CD 67 00 04 0170*       CALL printString
0400F3             0171*   ; BEGIN MY CODE
0400F3             0172*   ; restore all the things
0400F3 E1          0173*       pop hl
0400F4 D1          0174*       pop de
0400F5 C1          0175*       pop bc
0400F6 F1          0176*       pop af
0400F7             0177*   ; END MY CODE
0400F7 C9          0178*       RET
0400F8 00 00 00 00 0179*   _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040108             0180*   
040108             0181*   ; This routine converts the unsigned 24-bit value in HLU into its ASCII representation,
040108             0182*   ; starting to memory location pointing by DE, in decimal form and with leading zeroes
040108             0183*   ; so it will allways be 8 characters length
040108             0184*   ; HL : Value to convert to string
040108             0185*   ; DE : pointer to buffer, at least 8 byte + 0
040108             0186*   u24_to_ascii:
040108 01 80 69 67 0187*       LD BC,-10000000
04010C CD 3F 01 04 0188*       CALL @one_digit
040110 01 C0 BD F0 0189*       LD BC,-1000000
040114 CD 3F 01 04 0190*       CALL @one_digit
040118 01 60 79 FE 0191*       LD BC,-100000
04011C CD 3F 01 04 0192*       CALL @one_digit
040120 01 F0 D8 FF 0193*       LD BC,-10000
040124 CD 3F 01 04 0194*       CALL @one_digit
040128 01 18 FC FF 0195*       LD BC,-1000
04012C CD 3F 01 04 0196*       CALL @one_digit
040130 01 9C FF FF 0197*       LD BC,-100
040134 CD 3F 01 04 0198*       CALL @one_digit
040138 0E F6       0199*       LD C,-10
04013A CD 3F 01 04 0200*       CALL @one_digit
04013E 48          0201*       LD C,B
04013F             0202*   @one_digit:
04013F 3E 2F       0203*       LD A,'0'-1
040141             0204*   @divide_me:
040141 3C          0205*       INC A
040142 09          0206*       ADD HL,BC
040143 38 FC       0207*       JR C,@divide_me
040145 ED 42       0208*       SBC HL,BC
040147 12          0209*       LD (DE),A
040148 13          0210*       INC DE
040149 C9          0211*       RET
04014A             0212*   
04014A             0213*   print_u24:
04014A D5          0214*       push de
04014B E5          0215*       push hl
04014C 11 F8 00 04 0216*       ld de,_printDecBuffer
040150 CD 08 01 04 0217*       call u24_to_ascii
040154 21 F8 00 04 0218*       ld hl,_printDecBuffer
040158 CD 67 00 04 0219*       call printString
04015C 3E 20       0220*       ld a,' '
04015E 5B D7       0221*       rst.lil 10h
040160 E1          0222*       pop hl
040161 D1          0223*       pop de
040162 C9          0224*       ret
040163             0225*   
040163             0226*   ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
040163             0227*   ; HL : Value to convert to string (integer part in H, fractional part in L)
040163             0228*   ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
040163             0229*   u168_to_ascii:
040163             0230*   ; add a leading space to make room for sign flag if needed
040163 3E 20       0231*       ld a,' '
040165 12          0232*       ld (de),a
040166 13          0233*       inc de
040167             0234*   ; Convert integer part
040167 E5          0235*       push hl ; Save HL (weâ€™ll need the fractional part later)
040168             0236*       ; call hlu_udiv256 ; Shift to get integer portion in HL
040168             0237*       SRL_UHL ; Shift to get integer portion in HL
040168 3B          0001*M1     dec sp ; 1 cycle
040169 E5          0002*M1     push hl ; 4 cycles
04016A 33          0003*M1     inc sp ; 1 cycle
04016B E1          0004*M1     pop hl ; 4 cycles
04016C 23          0005*M1     inc hl ; 1 cycle
04016D 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
04016F             0007*M1     ; 13 cycles total
04016F 01 F0 D8 FF 0238*       ld bc, -10000
040173 CD 96 01 04 0239*       call @one_int
040177 01 18 FC FF 0240*       ld bc, -1000
04017B CD 96 01 04 0241*       call @one_int
04017F 01 9C FF FF 0242*       ld bc, -100
040183 CD 96 01 04 0243*       call @one_int
040187 0E F6       0244*       ld c, -10
040189 CD 96 01 04 0245*       call @one_int
04018D 48          0246*       ld c, b
04018E CD 96 01 04 0247*       call @one_int
040192 C3 A1 01 04 0248*       jp @frac ; Jump to fractional part conversion
040196             0249*   @one_int:
040196 3E 2F       0250*       ld a, '0' - 1 ; Start ASCII character at '0'
040198             0251*   @divide_me:
040198 3C          0252*       inc a
040199 09          0253*       add hl, bc ; Accumulate until overflow
04019A 38 FC       0254*       jr c, @divide_me
04019C ED 42       0255*       sbc hl, bc ; Remove excess after overflow
04019E 12          0256*       ld (de), a ; Store ASCII digit
04019F 13          0257*       inc de
0401A0 C9          0258*       ret
0401A1             0259*   ; Convert fractional part
0401A1             0260*   @frac:
0401A1 3E 2E       0261*       ld a, '.' ; Decimal point
0401A3 12          0262*       ld (de), a
0401A4 13          0263*       inc de
0401A5 E1          0264*       pop hl ; Restore HL with original fraction
0401A6 06 03       0265*       ld b, 3 ; Loop counter for 3 fractional digits
0401A8             0266*   @frac_loop:
0401A8 26 0A       0267*       ld h, 10 ; Load multiplier for fractional part
0401AA ED 6C       0268*       mlt hl ; Multiply by 10, result in HL (H holds the integer part)
0401AC 3E 30       0269*       ld a, '0'
0401AE 84          0270*       add a, h ; Convert integer part to ASCII
0401AF 12          0271*       ld (de), a
0401B0 13          0272*       inc de
0401B1 10 F5       0273*       djnz @frac_loop ; Repeat for each fractional digit
0401B3             0274*   ; Add null terminator
0401B3 AF          0275*       xor a ; Null terminator
0401B4 12          0276*       ld (de), a
0401B5 C9          0277*       ret
0401B6             0278*   
0401B6             0279*   print_u168:
0401B6 D5          0280*       push de
0401B7 E5          0281*       push hl
0401B8 11 F8 00 04 0282*       ld de,_printDecBuffer
0401BC CD 63 01 04 0283*       call u168_to_ascii
0401C0 21 F8 00 04 0284*       ld hl,_printDecBuffer
0401C4 CD 67 00 04 0285*       call printString
0401C8 E1          0286*       pop hl
0401C9 D1          0287*       pop de
0401CA C9          0288*       ret
0401CB             0289*   
0401CB             0290*   ; signed version of u168_to_ascii
0401CB             0291*   s168_to_ascii:
0401CB D5          0292*       push de ; save starting address of buffer
0401CC CD 70 04 04 0293*       call hlu_abs
0401D0 F5          0294*       push af ; save sign flag
0401D1 CD 63 01 04 0295*       call u168_to_ascii
0401D5 F1          0296*       pop af ; restore sign flag
0401D6 D1          0297*       pop de ; restore starting address of buffer
0401D7 F0          0298*       ret p ; hlu was positive so nothing to do
0401D8 3E 2D       0299*       ld a,'-'
0401DA 12          0300*       ld (de),a
0401DB C9          0301*       ret
0401DC             0302*   
0401DC             0303*   print_s168:
0401DC D5          0304*       push de
0401DD E5          0305*       push hl
0401DE 11 F8 00 04 0306*       ld de,_printDecBuffer
0401E2 CD CB 01 04 0307*       call s168_to_ascii
0401E6 21 F8 00 04 0308*       ld hl,_printDecBuffer
0401EA CD 67 00 04 0309*       call printString
0401EE E1          0310*       pop hl
0401EF D1          0311*       pop de
0401F0 C9          0312*       ret
0401F1             0313*   
0401F1             0314*   print_s168_hl:
0401F1 F5          0315*       push af
0401F2 E5          0316*       push hl
0401F3 CD DC 01 04 0317*       call print_s168
0401F7 3E 20       0318*       ld a,' '
0401F9 5B D7       0319*       rst.lil 10h
0401FB E1          0320*       pop hl
0401FC F1          0321*       pop af
0401FD C9          0322*       ret
0401FE             0323*   
0401FE             0324*   print_s168_bc:
0401FE F5          0325*       push af
0401FF C5          0326*       push bc
040200 E5          0327*       push hl
040201 C5          0328*       push bc
040202 E1          0329*       pop hl
040203 CD DC 01 04 0330*       call print_s168
040207 3E 20       0331*       ld a,' '
040209 5B D7       0332*       rst.lil 10h
04020B E1          0333*       pop hl
04020C C1          0334*       pop bc
04020D F1          0335*       pop af
04020E C9          0336*       ret
04020F             0337*   
04020F             0338*   print_s168_de:
04020F F5          0339*       push af
040210 D5          0340*       push de
040211 E5          0341*       push hl
040212 EB          0342*       ex de,hl
040213 CD DC 01 04 0343*       call print_s168
040217 3E 20       0344*       ld a,' '
040219 5B D7       0345*       rst.lil 10h
04021B E1          0346*       pop hl
04021C D1          0347*       pop de
04021D F1          0348*       pop af
04021E C9          0349*       ret
04021F             0350*   
04021F             0351*   print_s168_hl_bc_de:
04021F F5          0352*       push af
040220 C5          0353*       push bc
040221 D5          0354*       push de
040222 E5          0355*       push hl
040223 CD DC 01 04 0356*       call print_s168
040227 3E 20       0357*       ld a,' '
040229 5B D7       0358*       rst.lil 10h
04022B C5          0359*       push bc
04022C E1          0360*       pop hl
04022D CD DC 01 04 0361*       call print_s168
040231 3E 20       0362*       ld a,' '
040233 5B D7       0363*       rst.lil 10h
040235 EB          0364*       ex de,hl
040236 CD DC 01 04 0365*       call print_s168
04023A 3E 20       0366*       ld a,' '
04023C 5B D7       0367*       rst.lil 10h
04023E E1          0368*       pop hl
04023F D1          0369*       pop de
040240 C1          0370*       pop bc
040241 F1          0371*       pop af
040242 C9          0372*       ret
040243             0373*   
040243             0374*   print_s168_bc_de:
040243 F5          0375*       push af
040244 C5          0376*       push bc
040245 D5          0377*       push de
040246 C5          0378*       push bc
040247 E1          0379*       pop hl
040248 CD DC 01 04 0380*       call print_s168
04024C 3E 20       0381*       ld a,' '
04024E 5B D7       0382*       rst.lil 10h
040250 EB          0383*       ex de,hl
040251 CD DC 01 04 0384*       call print_s168
040255 3E 20       0385*       ld a,' '
040257 5B D7       0386*       rst.lil 10h
040259 E1          0387*       pop hl
04025A D1          0388*       pop de
04025B C1          0389*       pop bc
04025C F1          0390*       pop af
04025D C9          0391*       ret
04025E             0392*   
04025E             0393*   print_s168_a:
04025E F5          0394*       push af
04025F C5          0395*       push bc
040260 E5          0396*       push hl
040261 21 00 00 00 0397*       ld hl,0
040265 6F          0398*       ld l,a
040266 CD F1 01 04 0399*       call print_s168_hl
04026A E1          0400*       pop hl
04026B C1          0401*       pop bc
04026C F1          0402*       pop af
04026D C9          0403*       ret
04026E             0404*   
04026E             0405*   ; #### new functions added by Brandon R. Gates ####
04026E             0406*   
04026E             0407*   ; print the binary representation of the 8-bit value in a
04026E             0408*   ; destroys a, hl, bc
04026E             0409*   printBin8:
04026E 06 08       0410*       ld b,8 ; loop counter for 8 bits
040270 21 8B 02 04 0411*       ld hl,@cmd ; set hl to the low byte of the output string
040274             0412*       ; (which will be the high bit of the value in a)
040274             0413*   @loop:
040274 07          0414*       rlca ; put the next highest bit into carry
040275 38 04       0415*       jr c,@one
040277 36 30       0416*       ld (hl),'0'
040279 18 02       0417*       jr @next_bit
04027B             0418*   @one:
04027B 36 31       0419*       ld (hl),'1'
04027D             0420*   @next_bit:
04027D 23          0421*       inc hl
04027E 10 F4       0422*       djnz @loop
040280             0423*   ; print it
040280 21 8B 02 04 0424*       ld hl,@cmd
040284 01 08 00 00 0425*       ld bc,@end-@cmd
040288 5B DF       0426*       rst.lil $18
04028A C9          0427*       ret
04028B             0428*   @cmd: ds 8 ; eight bytes for eight bits
040293             0429*   @end:
040293             0430*   
040293             0431*   ; print the binary representation of the 8-bit value in a
040293             0432*   ; in reverse order (lsb first)
040293             0433*   ; destroys a, hl, bc
040293             0434*   printBin8Rev:
       FF FF FF FF 
       FF FF FF FF 
040293 06 08       0435*       ld b,8 ; loop counter for 8 bits
040295 21 B0 02 04 0436*       ld hl,@cmd ; set hl to the low byte of the output string
040299             0437*       ; (which will be the high bit of the value in a)
040299             0438*   @loop:
040299 0F          0439*       rrca ; put the next lowest bit into carry
04029A 38 04       0440*       jr c,@one
04029C 36 30       0441*       ld (hl),'0'
04029E 18 02       0442*       jr @next_bit
0402A0             0443*   @one:
0402A0 36 31       0444*       ld (hl),'1'
0402A2             0445*   @next_bit:
0402A2 23          0446*       inc hl
0402A3 10 F4       0447*       djnz @loop
0402A5             0448*   ; print it
0402A5 21 B0 02 04 0449*       ld hl,@cmd
0402A9 01 08 00 00 0450*       ld bc,@end-@cmd
0402AD 5B DF       0451*       rst.lil $18
0402AF C9          0452*       ret
0402B0             0453*   @cmd: ds 8 ; eight bytes for eight bits
0402B8             0454*   @end:
0402B8             0455*   
       FF FF FF FF 
       FF FF FF FF 
0402B8 20 61 66 3D 0456*   str_afu: db " af=",0
       00          
0402BD 20 68 6C 3D 0457*   str_hlu: db " hl=",0
       00          
0402C2 20 62 63 3D 0458*   str_bcu: db " bc=",0
       00          
0402C7 20 64 65 3D 0459*   str_deu: db " de=",0
       00          
0402CC 20 69 78 3D 0460*   str_ixu: db " ix=",0
       00          
0402D1 20 69 79 3D 0461*   str_iyu: db " iy=",0
       00          
0402D6             0462*   
0402D6             0463*   ; print udeuhl to screen in hexidecimal format
0402D6             0464*   ; inputs: none
0402D6             0465*   ; outputs: concatenated hexidecimal udeuhl
0402D6             0466*   ; destroys: nothing
0402D6             0467*   dumpUDEUHLHex:
0402D6             0468*   ; store everything in scratch
0402D6 22 35 03 04 0469*       ld (uhl),hl
0402DA ED 43 38 03 0470*       ld (ubc),bc
       04          
0402DF ED 53 3B 03 0471*       ld (ude),de
       04          
0402E4 DD 22 3E 03 0472*       ld (uix),ix
       04          
0402E9 FD 22 41 03 0473*       ld (uiy),iy
       04          
0402EE F5          0474*       push af
0402EF             0475*   
0402EF             0476*   ; print each register
0402EF             0477*   
0402EF 21 29 03 04 0478*       ld hl,str_udeuhl
0402F3 CD 67 00 04 0479*       call printString
0402F7 2A 3B 03 04 0480*       ld hl,(ude)
0402FB CD A0 00 04 0481*       call printHex24
0402FF 3E 2E       0482*       ld a,'.' ; print a dot to separate the values
040301 5B D7       0483*       rst.lil 10h
040303 2A 35 03 04 0484*       ld hl,(uhl)
040307 CD A0 00 04 0485*       call printHex24
04030B CD 7C 00 04 0486*       call printNewLine
04030F             0487*   
04030F             0488*   ; restore everything
04030F 2A 35 03 04 0489*       ld hl, (uhl)
040313 ED 4B 38 03 0490*       ld bc, (ubc)
       04          
040318 ED 5B 3B 03 0491*       ld de, (ude)
       04          
04031D DD 2A 3E 03 0492*       ld ix, (uix)
       04          
040322 FD 2A 41 03 0493*       ld iy, (uiy)
       04          
040327 F1          0494*       pop af
040328             0495*   ; all done
040328 C9          0496*       ret
040329             0497*   
040329 75 64 65 2E 0498*   str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
040332             0499*   
040332             0500*   ; global scratch memory for registers
040332 00 00 00    0501*   uaf: dl 0
040335 00 00 00    0502*   uhl: dl 0
040338 00 00 00    0503*   ubc: dl 0
04033B 00 00 00    0504*   ude: dl 0
04033E 00 00 00    0505*   uix: dl 0
040341 00 00 00    0506*   uiy: dl 0
040344 00 00 00    0507*   usp: dl 0
040347 00 00 00    0508*   upc: dl 0
04034A             0509*   
04034A             0510*   
04034A             0511*   ; set all the bits in the flag register
04034A             0512*   ; more of an academic exercise than anything useful
04034A             0513*   ; inputs; none
04034A             0514*   ; outputs; a=0,f=255
04034A             0515*   ; destroys: flags, hl
04034A             0516*   ; preserves: a, because why not
04034A             0517*   setAllFlags:
04034A 21 FF 00 00 0518*       ld hl,255
04034E 67          0519*       ld h,a ; four cycles to preserve a is cheap
04034F E5          0520*       push hl
040350 F1          0521*       pop af
040351 C9          0522*       ret
040352             0523*   
040352             0524*   ; reset all the bits in the flag register
040352             0525*   ; unlike its inverse counterpart, this may actually be useful
040352             0526*   ; inputs; none
040352             0527*   ; outputs; a=0,f=0
040352             0528*   ; destroys: flags, hl
040352             0529*   ; preserves: a, because why not
040352             0530*   resetAllFlags:
040352 21 00 00 00 0531*       ld hl,0
040356 67          0532*       ld h,a ; four cycles to preserve a is cheap
040357 E5          0533*       push hl
040358 F1          0534*       pop af
040359 C9          0535*       ret
04035A             0536*   
04035A             0537*   ; wait until user presses a key
04035A             0538*   ; inputs: none
04035A             0539*   ; outputs: ascii code of key pressed in a
04035A             0540*   ; destroys: af,ix
04035A             0541*   waitKeypress:
04035A             0542*       MOSCALL mos_getkey
04035A 3E 00       0001*M1 			LD	A, function
04035C 5B CF       0002*M1 			RST.LIL	08h
04035E C9          0543*       ret
04035F             0544*   
04035F             0545*   ; clear a block of memory by writing a prescribed value to each byte in the range
04035F             0546*   ; inputs: a = value to write, hl = address of first byte, bc = number of bytes
04035F             0547*   ; outputs: memory block is cleared
04035F             0548*   ; destroys: hl, de
04035F             0549*   clear_mem:
04035F 0B          0550*       dec bc ; we do this because we will increment de before writing the first byte
040360 77          0551*       ld (hl),a
040361 E5          0552*       push hl
040362 D1          0553*       pop de
040363 13          0554*       inc de ; target address
040364 ED B0       0555*       ldir
040366 C9          0556*       ret
040367             0033        include "arith24.inc"
040367             0001*   ;------------------------------------------------------------------------
040367             0002*   ;  arith24.asm
040367             0003*   ;  24-bit ez80 arithmetic routines
040367             0004*   ;  Copyright (c) Shawn Sijnstra 2024
040367             0005*   ;  MIT license
040367             0006*   ;
040367             0007*   ;  This library was created as a tool to help make ez80
040367             0008*   ;  24-bit native assembly routines for simple mathematical problems
040367             0009*   ;  more widely available.
040367             0010*   ;
040367             0011*   ;------------------------------------------------------------------------
040367             0012*   
040367             0013*   ;------------------------------------------------------------------------
040367             0014*   ; umul24:	HL = HL*DE (unsigned)
040367             0015*   ; Preserves AF, BC, DE
040367             0016*   ; Uses a fast multiply routine.
040367             0017*   ;------------------------------------------------------------------------
040367             0018*   umul24:
040367 D5          0019*   	push	DE
040368 C5          0020*   	push	BC
040369 F5          0021*   	push	AF
04036A E5          0022*   	push	HL
04036B C1          0023*   	pop		BC
04036C 3E 18       0024*       ld	 	a, 24 ; No. of bits to process
04036E 21 00 00 00 0025*       ld	 	hl, 0 ; Result
040372             0026*   umul24_lp:
040372 29          0027*   	add	hl,hl
040373 EB          0028*   	ex	de,hl
040374 29          0029*   	add	hl,hl
040375 EB          0030*   	ex	de,hl
040376 30 01       0031*   	jr	nc,umul24_nc
040378 09          0032*   	add	hl,bc
040379             0033*   umul24_nc:
040379 3D          0034*   	dec	a
04037A 20 F6       0035*   	jr	nz,umul24_lp
04037C F1          0036*   	pop	af
04037D C1          0037*   	pop	bc
04037E D1          0038*   	pop	de
04037F C9          0039*   	ret
040380             0040*   
040380             0041*   
040380             0042*   ;------------------------------------------------------------------------
040380             0043*   ; udiv24
040380             0044*   ; Unsigned 24-bit division
040380             0045*   ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
040380             0046*   ;
040380             0047*   ; Uses AF BC DE HL
040380             0048*   ; Uses Restoring Division algorithm
040380             0049*   ;------------------------------------------------------------------------
040380             0050*   
040380             0051*   udiv24:
040380 E5          0052*   	push	hl
040381 C1          0053*   	pop		bc	;move dividend to BCU
040382 21 00 00 00 0054*   	ld		hl,0	;result
040386 A7          0055*   	and		a
040387 ED 52       0056*   	sbc		hl,de	;test for div by 0
040389 C8          0057*   	ret		z		;it's zero, carry flag is clear
04038A 19          0058*   	add		hl,de	;HL is 0 again
04038B 3E 18       0059*   	ld		a,24	;number of loops through.
04038D             0060*   udiv1:
04038D C5          0061*   	push	bc	;complicated way of doing this because of lack of access to top bits
04038E E3          0062*   	ex		(sp),hl
04038F 37          0063*   	scf
040390 ED 6A       0064*   	adc	hl,hl
040392 E3          0065*   	ex	(sp),hl
040393 C1          0066*   	pop	bc		;we now have bc = (bc * 2) + 1
040394             0067*   
040394 ED 6A       0068*   	adc	hl,hl
040396 A7          0069*   	and	a		;is this the bug
040397 ED 52       0070*   	sbc	hl,de
040399 30 02       0071*   	jr	nc,udiv2
04039B 19          0072*   	add	hl,de
04039C             0073*   ;	dec	c
04039C 0B          0074*   	dec	bc
04039D             0075*   udiv2:
04039D 3D          0076*   	dec	a
04039E 20 ED       0077*   	jr	nz,udiv1
0403A0 37          0078*   	scf		;flag used for div0 error
0403A1 C5          0079*   	push	bc
0403A2 D1          0080*   	pop		de	;remainder
0403A3 C9          0081*   	ret
0403A4             0082*   
0403A4             0083*   
0403A4             0084*   
0403A4             0085*   ;------------------------------------------------------------------------
0403A4             0086*   ; neg24
0403A4             0087*   ; Returns: HLU = 0-HLU
0403A4             0088*   ; preserves all other registers
0403A4             0089*   ;------------------------------------------------------------------------
0403A4             0090*   neg24:
0403A4 D5          0091*   	push	de
0403A5 EB          0092*   	ex		de,hl
0403A6 21 00 00 00 0093*   	ld		hl,0
0403AA B7          0094*   	or		a
0403AB ED 52       0095*   	sbc		hl,de
0403AD D1          0096*   	pop		de
0403AE C9          0097*   	ret
0403AF             0098*   
0403AF             0099*   ;------------------------------------------------------------------------
0403AF             0100*   ; or_hlu_deu: 24 bit bitwise OR
0403AF             0101*   ; Returns: hlu = hlu OR deu
0403AF             0102*   ; preserves all other registers
0403AF             0103*   ;------------------------------------------------------------------------
0403AF             0104*   or_hlu_deu:
0403AF 22 38 04 04 0105*   	ld	(bitbuf1),hl
0403B3 ED 53 3B 04 0106*   	ld	(bitbuf2),de
       04          
0403B8 D5          0107*   	push	de	;preserve DEU
0403B9 C5          0108*   	push	bc	;preserve BCU
0403BA 06 03       0109*   	ld		b,3
0403BC 21 38 04 04 0110*   	ld	hl,bitbuf1
0403C0 11 38 04 04 0111*   	ld	de,bitbuf1
0403C4             0112*   orloop_24:
0403C4 1A          0113*   	ld	a,(de)
0403C5 B6          0114*   	or	(hl)
0403C6 12          0115*   	ld	(de),a
0403C7 13          0116*   	inc	de
0403C8 23          0117*   	inc	hl
0403C9 10 F9       0118*   	djnz	orloop_24
0403CB 2A 3B 04 04 0119*   	ld	hl,(bitbuf2)
0403CF C1          0120*   	pop		bc	;restore BC
0403D0 D1          0121*   	pop		de	;restore DE
0403D1             0122*   
0403D1             0123*   ;------------------------------------------------------------------------
0403D1             0124*   ; and_hlu_deu: 24 bit bitwise AND
0403D1             0125*   ; Returns: hlu = hlu AND deu
0403D1             0126*   ; preserves all other registers
0403D1             0127*   ;------------------------------------------------------------------------
0403D1             0128*   and_hlu_deu:
0403D1 22 38 04 04 0129*   	ld	(bitbuf1),hl
0403D5 ED 53 3B 04 0130*   	ld	(bitbuf2),de
       04          
0403DA D5          0131*   	push	de	;preserve DEU
0403DB C5          0132*   	push	bc	;preserve BCU
0403DC 06 03       0133*   	ld		b,3
0403DE 21 38 04 04 0134*   	ld	hl,bitbuf1
0403E2 11 38 04 04 0135*   	ld	de,bitbuf1
0403E6             0136*   andloop_24:
0403E6 1A          0137*   	ld	a,(de)
0403E7 A6          0138*   	and	(hl)
0403E8 12          0139*   	ld	(de),a
0403E9 13          0140*   	inc	de
0403EA 23          0141*   	inc	hl
0403EB 10 F9       0142*   	djnz	andloop_24
0403ED 2A 3B 04 04 0143*   	ld	hl,(bitbuf2)
0403F1 C1          0144*   	pop		bc	;restore BC
0403F2 D1          0145*   	pop		de	;restore DE
0403F3             0146*   
0403F3             0147*   ;------------------------------------------------------------------------
0403F3             0148*   ; xor_hlu_deu: 24 bit bitwise XOR
0403F3             0149*   ; Returns: hlu = hlu XOR deu
0403F3             0150*   ; preserves all other registers
0403F3             0151*   ;------------------------------------------------------------------------
0403F3             0152*   xor_hlu_deu:
0403F3 22 38 04 04 0153*   	ld	(bitbuf1),hl
0403F7 ED 53 3B 04 0154*   	ld	(bitbuf2),de
       04          
0403FC D5          0155*   	push	de	;preserve DEU
0403FD C5          0156*   	push	bc	;preserve BCU
0403FE 06 03       0157*   	ld		b,3
040400 21 38 04 04 0158*   	ld	hl,bitbuf1
040404 11 38 04 04 0159*   	ld	de,bitbuf1
040408             0160*   xorloop_24:
040408 1A          0161*   	ld	a,(de)
040409 AE          0162*   	xor	(hl)
04040A 12          0163*   	ld	(de),a
04040B 13          0164*   	inc	de
04040C 23          0165*   	inc	hl
04040D 10 F9       0166*   	djnz	xorloop_24
04040F 2A 3B 04 04 0167*   	ld	hl,(bitbuf2)
040413 C1          0168*   	pop		bc	;restore BC
040414 D1          0169*   	pop		de	;restore DE
040415             0170*   
040415             0171*   ;------------------------------------------------------------------------
040415             0172*   ; shl_hlu: 24 bit shift left hlu by a positions
040415             0173*   ; Returns: hlu = hlu << a
040415             0174*   ;		   a = 0
040415             0175*   ; NOTE: only considers a up to 16 bits.
040415             0176*   ; preserves all other registers
040415             0177*   ; modified by Brandon R. Gates to use a instead of de
040415             0178*   ;------------------------------------------------------------------------
040415             0179*   shl_hlu:
040415 B7          0180*   	or a
040416 C8          0181*   	ret		z		;we're done
040417 29          0182*   	add		hl,hl	;shift HLU left
040418 3D          0183*   	dec a
040419 18 FA       0184*   	jr		shl_hlu
04041B             0185*   
04041B             0186*   ;------------------------------------------------------------------------
04041B             0187*   ; shr_hlu: 24 bit shift right hlu by a positions
04041B             0188*   ; Returns: hlu = hlu >> a
04041B             0189*   ;		   a = 0
04041B             0190*   ; NOTE: only considers a up to 16 bits.
04041B             0191*   ; preserves all other registers
04041B             0192*   ; modified by Brandon R. Gates to use a instead of de
04041B             0193*   ;------------------------------------------------------------------------
04041B             0194*   shr_hlu:
04041B 22 38 04 04 0195*   	ld		(bitbuf1),hl
04041F 21 3A 04 04 0196*   	ld		hl,bitbuf1+2
040423             0197*   @shr_loop:
040423 B7          0198*   	or a
040424 28 0D       0199*   	jr		z,@shr_done		;we're done
040426             0200*   ;carry is clear from or instruction
040426 CB 1E       0201*   	rr		(hl)
040428 2B          0202*   	dec		hl
040429 CB 1E       0203*   	rr		(hl)
04042B 2B          0204*   	dec		hl
04042C CB 1E       0205*   	rr		(hl)
04042E 23          0206*   	inc		hl
04042F 23          0207*   	inc		hl
040430 3D          0208*   	dec a
040431 18 F0       0209*   	jr		@shr_loop
040433             0210*   @shr_done:
040433 2A 38 04 04 0211*   	ld		hl,(bitbuf1)	;collect result
040437 C9          0212*   	ret
040438             0213*   
040438             0214*   ;------------------------------------------------------------------------
040438             0215*   ; Scratch area for calculations
040438             0216*   ;------------------------------------------------------------------------
040438 00 00 00    0217*   bitbuf1:	dw24	0	;bit manipulation buffer 1
04043B 00 00 00    0218*   bitbuf2:	dw24	0	;bit manipulation buffer 2
04043E             0219*   
04043E             0220*   ; -----------------------------------------------------------------------
04043E             0221*   ; Functions added by Brandon R. Gates
04043E             0222*   ; -----------------------------------------------------------------------
04043E             0223*   
04043E             0224*   ;------------------------------------------------------------------------
04043E             0225*   ; shr_hlu_div: Quick division by powers of two based on log2 of A
04043E             0226*   ;              Determines the LSB of A and shifts HLU accordingly.
04043E             0227*   ;              HLU = HLU >> LSB(A)
04043E             0228*   ; Returns: HLU = HLU >> LSB(A)
04043E             0229*   ; Destroys: af
04043E             0230*   ;------------------------------------------------------------------------
04043E             0231*   shr_hlu_log2a:
04043E B7          0232*   	or a    ; check for zero
04043F C8          0233*   	ret z   ; nothing to shift so we're done
040440 C5          0234*   	push 	bc ; preserve
040441 06 00       0235*   	ld		b,0 ; clear b
040443             0236*   @find_bit:
040443 0F          0237*   	rrca ; bit 0 to carry
040444 DA 4D 04 04 0238*   	jp c,@found_bit
040448 04          0239*   	inc b ; next bit
040449 C3 43 04 04 0240*   	jp @find_bit
04044D             0241*   @found_bit:
04044D 78          0242*   	ld a,b
04044E CD 1B 04 04 0243*   	call shr_hlu
040452 C1          0244*   	pop 	bc ; restore
040453 C9          0245*   	ret
040454             0246*   ; end shr_hlu_log2a
040454             0247*   
040454             0248*   ;------------------------------------------------------------------------
040454             0249*   ; shl_hlu_log2a: Quick multiplication by powers of two based on log2 of A
040454             0250*   ;                Determines the LSB of A and shifts HLU accordingly.
040454             0251*   ;                HLU = HLU << LSB(A)
040454             0252*   ; Returns: HLU = HLU << LSB(A)
040454             0253*   ; Destroys: af
040454             0254*   ;------------------------------------------------------------------------
040454             0255*   shl_hlu_log2a:
040454 B7          0256*   	or a    ; check for zero
040455 C8          0257*   	ret z   ; nothing to shift so we're done
040456 C5          0258*   	push 	bc ; preserve
040457 06 00       0259*   	ld		b,0 ; clear b
040459             0260*   @find_bit:
040459 0F          0261*   	rrca ; bit 0 to carry
04045A DA 63 04 04 0262*   	jp c,@found_bit
04045E 04          0263*   	inc b ; next bit
04045F C3 59 04 04 0264*   	jp @find_bit
040463             0265*   @found_bit:
040463 78          0266*   	ld a,b
040464 CD 15 04 04 0267*   	call shl_hlu
040468 C1          0268*   	pop 	bc ; restore
040469 C9          0269*   	ret
04046A             0270*   ; end shl_hlu_log2a
04046A             0034        include "maths.inc"
04046A             0001*   ;------------------------------------------------------------------------
04046A             0002*   ; Scratch area for calculations
04046A             0003*   ;------------------------------------------------------------------------
04046A 00 00 00    0004*   scratch1: dw24 0 ;bit manipulation buffer 1
04046D 00 00 00    0005*   scratch2: dw24 0 ;bit manipulation buffer 2
040470             0006*   
040470             0007*   ; absolute value of hlu
040470             0008*   ; returns: abs(hlu), flags set according to the incoming sign of hlu:
040470             0009*   ;         s1,z0,pv0,n1,c0 if hlu was negative
040470             0010*   ;         s0,z1,pv0,n1,c0 if hlu was zero
040470             0011*   ;         s0,z0,pv0,n1,c0 if hlu was positive
040470             0012*   ; destroys: a
040470             0013*   hlu_abs:
040470 19          0014*       add hl,de
040471 B7          0015*       or a
040472 ED 52       0016*       sbc hl,de
040474 FA 79 04 04 0017*       jp m,@is_neg
040478 C9          0018*       ret ; hlu is positive or zero so we're done
040479             0019*   @is_neg:
040479 F5          0020*       push af ; otherwise, save current flags for return
04047A CD 80 04 04 0021*       call neg_hlu ; negate hlu
04047E F1          0022*       pop af ; get back flags
04047F C9          0023*       ret
040480             0024*   
040480             0025*   ; flip the sign of hlu
040480             0026*   ; inputs: hlu
040480             0027*   ; returns: 0-hlu, flags set appropriately for the result:
040480             0028*   ;         s1,z0,pv0,n1,c1 if result is negative
040480             0029*   ;         s0,z1,pv0,n1,c0 if result is zero
040480             0030*   ;         s0,z0,pv0,n1,c1 if result is positive
040480             0031*   ; destroys a
040480             0032*   neg_hlu:
040480 D5          0033*       push de ; save de
040481 EB          0034*       ex de,hl ; put hl into de
040482 21 00 00 00 0035*       ld hl,0 ; clear hl
040486 AF          0036*       xor a ; clear carry
040487 ED 52       0037*       sbc hl,de ; 0-hlu = -hlu
040489 D1          0038*       pop de ; get de back
04048A C9          0039*       ret ; easy peasy
04048B             0040*   
04048B             0041*   ;------------------------------------------------------------------------
04048B             0042*   ; divide hlu by 2, inspired by above
04048B             0043*   ;------------------------------------------------------------------------
04048B             0044*   hlu_div2:
04048B 22 6A 04 04 0045*       ld (scratch1),hl
04048F 21 6C 04 04 0046*       ld hl,scratch1+2
040493 CB 1E       0047*       rr (hl)
040495 2B          0048*       dec hl
040496 CB 1E       0049*       rr (hl)
040498 2B          0050*       dec hl
040499 CB 1E       0051*       rr (hl)
04049B 23          0052*       inc hl
04049C 23          0053*       inc hl
04049D 2A 6A 04 04 0054*       ld hl,(scratch1)
0404A1 C9          0055*       ret
0404A2             0056*   
0404A2             0057*   ; this is my little hack to divide by 16
0404A2             0058*   hlu_div16:
0404A2 AF          0059*       xor a
0404A3 29          0060*       add hl,hl
0404A4 17          0061*       rla
0404A5 29          0062*       add hl,hl
0404A6 17          0063*       rla
0404A7 29          0064*       add hl,hl
0404A8 17          0065*       rla
0404A9 29          0066*       add hl,hl
0404AA 17          0067*       rla
0404AB 22 B8 04 04 0068*       ld (@scratch),hl
0404AF 32 BB 04 04 0069*       ld (@scratch+3),a
0404B3 2A B9 04 04 0070*       ld hl,(@scratch+1)
0404B7 C9          0071*       ret
0404B8             0072*   @scratch: ds 4
0404BC             0073*   
0404BC             0074*   ; hlu signed division by 256
0404BC             0075*   ; returns: hlu / 256
0404BC             0076*   ; destroys: af
0404BC             0077*   hlu_sdiv256:
       FF FF FF FF 
0404BC AF          0078*       xor a ; assume hl is positive
0404BD 22 D3 04 04 0079*       ld (@buffer),hl
0404C1             0080*       SIGN_HLU
0404C1 19          0001*M1     add hl,de ; 1 cycle
0404C2 B7          0002*M1     or a ; clear flags ; 1 cycle
0404C3 ED 52       0003*M1     sbc hl,de ; 2 cycles
0404C5             0004*M1     ; 4 cycles total
0404C5 F2 CA 04 04 0081*       jp p,@hl_pos
0404C9 3D          0082*       dec a
0404CA             0083*   @hl_pos:
0404CA 32 D6 04 04 0084*       ld (@buffer+3),a
0404CE 2A D4 04 04 0085*       ld hl,(@buffer+1)
0404D2 C9          0086*       ret
0404D3             0087*   @buffer: ds 4
0404D7             0088*   
0404D7             0089*   ; hlu 1 byte right shift, unsigned
0404D7             0090*   ; returns: hlu / 256, fractional portion in a
0404D7             0091*   ; destroys: af
0404D7             0092*   hlu_udiv256:
       FF FF FF FF 
0404D7 AF          0093*       xor a
0404D8 32 E9 04 04 0094*       ld (@buffer+3),a
0404DC 7D          0095*       ld a,l ; save the fractional portion
0404DD 22 E6 04 04 0096*       ld (@buffer),hl
0404E1 2A E7 04 04 0097*       ld hl,(@buffer+1)
0404E5 C9          0098*       ret
0404E6             0099*   @buffer: ds 4
0404EA             0100*   
       FF FF FF FF 
0404EA 00 00 00 00 0101*   add_bcd_arg1: db #00,#00,#00,#00
0404EE 00 00 00 00 0102*   add_bcd_arg2: db #00,#00,#00,#00
0404F2             0103*   
0404F2             0104*   ; set bcd values in a scratch memory address from registers bcde
0404F2             0105*   ; input: hl; scratch address,bcde; 8-place bcd number
0404F2             0106*   ; destroys ; hl
0404F2             0107*   set_bcd:
0404F2 73          0108*       ld (hl),e
0404F3 23          0109*       inc hl
0404F4 72          0110*       ld (hl),d
0404F5 23          0111*       inc hl
0404F6 71          0112*       ld (hl),c
0404F7 23          0113*       inc hl
0404F8 70          0114*       ld (hl),b
0404F9 C9          0115*       ret
0404FA             0116*   
0404FA             0117*   ; load bcd values from a scratch memory address to bcde
0404FA             0118*   ; input: hl; scratch address
0404FA             0119*   ; output: bcde; 8-place bcd number
0404FA             0120*   ; destroys: hl
0404FA             0121*   get_bcd:
0404FA 5E          0122*       ld e,(hl)
0404FB 23          0123*       inc hl
0404FC 56          0124*       ld d,(hl)
0404FD 23          0125*       inc hl
0404FE 4E          0126*       ld c,(hl)
0404FF 23          0127*       inc hl
040500 46          0128*       ld b,(hl)
040501 C9          0129*       ret
040502             0130*   
040502             0131*   ; BCD addition
040502             0132*   ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
040502             0133*   ;       a is the number of bytes holding each number (number of places/2)
040502             0134*   ; outputs: (hl) + (de) --> (hl)
040502             0135*   ; destroys: a,b,de,hl
040502             0136*   add_bcd:
040502 47          0137*       ld b,a ; loop counter
040503 AF          0138*       xor a ; reset a, clear carry flag
040504             0139*   adcec:
040504 1A          0140*       ld a,(de) ; addend to acc
040505 8E          0141*       adc a,(hl) ; add (hl) to acc
040506 27          0142*       daa ; adjust result to bcd
040507 77          0143*       ld (hl),a ; store result
040508 23          0144*       inc hl ; advance memory pointers
040509 13          0145*       inc de
04050A 10 F8       0146*       djnz adcec ; loop until b == 0
04050C C9          0147*       ret
04050D             0148*   
04050D             0149*   ; BCD subtraction
04050D             0150*   ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
04050D             0151*   ;       a is the number of bytes holding each number (number of places/2)
04050D             0152*   ; outputs: (hl) - (de) --> (hl)
04050D             0153*   ; destroys: a,b,de,hl
04050D             0154*   sub_bcd:
04050D 47          0155*       ld b,a ; loop counter
04050E AF          0156*       xor a ; reset a,clear carry flag
04050F             0157*   subdec:
04050F 1A          0158*       ld a,(de) ; subtrahend to acc
040510 9E          0159*       sbc a,(hl) ; subtract (hl) from acc
040511 27          0160*       daa ; adjust result to bcd
040512 77          0161*       ld (hl),a ; store result
040513 23          0162*       inc hl ; advance memory pointers
040514 13          0163*       inc de
040515 10 F8       0164*       djnz subdec ; loop until b == 0
040517 C9          0165*       ret
040518             0166*   
040518             0167*   ; http://www.z80.info/pseudo-random.txt
040518             0168*   rand_8:
040518 C5          0169*       push bc
040519 3A 2C 05 04 0170*       ld a,(r_seed)
04051D 4F          0171*       ld c,a
04051E             0172*   
04051E 0F          0173*       rrca ; multiply by 32
04051F 0F          0174*       rrca
040520 0F          0175*       rrca
040521 EE 1F       0176*       xor 0x1f
040523             0177*   
040523 81          0178*       add a,c
040524 DE FF       0179*       sbc a,255 ; carry
040526             0180*   
040526 32 2C 05 04 0181*       ld (r_seed),a
04052A C1          0182*       pop bc
04052B C9          0183*       ret
04052C 50          0184*   r_seed: defb $50
04052D             0185*   
04052D             0186*   ; https://www.omnimaga.org/asm-language/ez80-optimized-routines/msg399325/#msg399325
04052D             0187*   prng24:
04052D             0188*   ;;Expects ADL mode.
04052D             0189*   ;;Output: HL
04052D             0190*   ;;50cc
04052D             0191*   ;;33 bytes
04052D             0192*   ;;cycle length: 281,474,959,933,440 (about 2.8 trillion)
04052D ED 5B 4E 05 0193*       ld de,(seed1)
       04          
040532 B7          0194*       or a
040533 ED 62       0195*       sbc hl,hl
040535 19          0196*       add hl,de
040536 29          0197*       add hl,hl
040537 29          0198*       add hl,hl
040538 2C          0199*       inc l
040539 19          0200*       add hl,de
04053A 22 4E 05 04 0201*       ld (seed1),hl
04053E 2A 51 05 04 0202*       ld hl,(seed2)
040542 29          0203*       add hl,hl
040543 9F          0204*       sbc a,a
040544 E6 1B       0205*       and %00011011
040546 AD          0206*       xor l
040547 6F          0207*       ld l,a
040548 22 51 05 04 0208*       ld (seed2),hl
04054C 19          0209*       add hl,de
04054D C9          0210*       ret
04054E 00 00 00    0211*   seed1: dl 0
040551 00 00 00    0212*   seed2: dl 0
040554             0035        include "fonts.inc"
040554             0001*   fonts_load:
040554 DD 21 85 05 0002*       ld ix,font_list ; pointer to font list lookup
       04          
040559 06 1D       0003*       ld b,num_fonts ; loop counter
04055B             0004*   
04055B             0005*   @load_loop:
04055B C5          0006*       push bc ; save loop counter
04055C             0007*   
04055C             0008*   ; load font into a buffer
04055C DD 27 06    0009*       ld hl,(ix+font_list_bufferId)
04055F DD 31 09    0010*       ld iy,(ix+font_list_filename)
040562 CD E4 18 04 0011*       call vdu_load_buffer_from_file
040566             0012*   
040566             0013*   ; create font from buffer
040566 DD 27 06    0014*       ld hl,(ix+font_list_bufferId)
040569 DD 5E 00    0015*       ld e,(ix+font_list_width)
04056C DD 56 03    0016*       ld d,(ix+font_list_height)
04056F 3E 00       0017*       ld a,0 ; flags
040571 CD 37 1B 04 0018*       call vdu_font_create
040575             0019*   
040575             0020*   ; select font
040575 DD 27 06    0021*       ld hl,(ix+font_list_bufferId)
040578 3E 01       0022*       ld a,1 ; flags
04057A CD 1D 1B 04 0023*       call vdu_font_select
04057E             0024*   
04057E             0025*   ; ; debug print filename
04057E             0026*   ;     call printNewLine
04057E             0027*   ;     ld hl,(ix+font_list_filename)
04057E             0028*   ;     call printString
04057E             0029*   
04057E             0030*   ; advance font_list pointer to next record
04057E ED 32 0C    0031*       lea ix,ix+font_list_record_size
040581             0032*   
040581             0033*   ; restore loop counter
040581 C1          0034*       pop bc
040582 10 D7       0035*       djnz @load_loop
040584             0036*   
040584             0037*   ; all done
040584 C9          0038*       ret
040585             0036        include "fonts_list.inc"
040585             0001*   ; Generated by asm_config_editor.py
040585             0002*   font_list_record_size: equ 12
040585             0003*   font_list_width: equ 0
040585             0004*   font_list_height: equ 3
040585             0005*   font_list_bufferId: equ 6
040585             0006*   font_list_filename: equ 9
040585             0007*   
040585             0008*   num_fonts: equ 29
040585             0009*   
040585             0010*   ; Index list:
040585             0011*   amiga_forever_16x16: equ 64000
040585             0012*   amiga_forever_16x24: equ 64001
040585             0013*   amiga_forever_8x16: equ 64002
040585             0014*   amiga_forever_8x8: equ 64003
040585             0015*   computer_pixel_7_10x15: equ 64004
040585             0016*   computer_pixel_7_10x24: equ 64005
040585             0017*   computer_pixel_7_8x12: equ 64006
040585             0018*   computer_pixel_7_8x14: equ 64007
040585             0019*   computer_pixel_7_8x16: equ 64008
040585             0020*   dopecre_8x8: equ 64009
040585             0021*   gamer_2_8x8: equ 64010
040585             0022*   Lat15_VGA8_8x8: equ 64011
040585             0023*   Lat2_Terminus12x6_6x12: equ 64012
040585             0024*   Lat2_TerminusBold14_8x14: equ 64013
040585             0025*   Lat2_VGA14_8x14: equ 64014
040585             0026*   Lat2_VGA16_8x16: equ 64015
040585             0027*   Lat2_VGA8_8x8: equ 64016
040585             0028*   Lat38_VGA8_8x8: equ 64017
040585             0029*   Lat7_Fixed13_8x13: equ 64018
040585             0030*   Lat7_Terminus12x6_6x12: equ 64019
040585             0031*   Lat7_TerminusBold16_8x16: equ 64020
040585             0032*   Lat7_VGA14_8x14: equ 64021
040585             0033*   Lat7_VGA16_8x16: equ 64022
040585             0034*   Lat7_VGA8_8x8: equ 64023
040585             0035*   planetary_contact_8x8: equ 64024
040585             0036*   scriptorium_12x14: equ 64025
040585             0037*   Squarewave_Bold_8x12: equ 64026
040585             0038*   super_mario_bros_2_8x8: equ 64027
040585             0039*   wendy_neue_6x6: equ 64028
040585             0040*   
040585             0041*   font_list: ; width; height; bufferId; filename;:
040585 10 00 00 10 0042*   	dl 16, 16, 64000, fn_amiga_forever_16x16
       00 00 00 FA 
       00 E1 06 04 
040591 10 00 00 18 0043*   	dl 16, 24, 64001, fn_amiga_forever_16x24
       00 00 01 FA 
       00 FF 06 04 
04059D 08 00 00 10 0044*   	dl 8, 16, 64002, fn_amiga_forever_8x16
       00 00 02 FA 
       00 1D 07 04 
0405A9 08 00 00 08 0045*   	dl 8, 8, 64003, fn_amiga_forever_8x8
       00 00 03 FA 
       00 3A 07 04 
0405B5 0A 00 00 0F 0046*   	dl 10, 15, 64004, fn_computer_pixel_7_10x15
       00 00 04 FA 
       00 56 07 04 
0405C1 0A 00 00 18 0047*   	dl 10, 24, 64005, fn_computer_pixel_7_10x24
       00 00 05 FA 
       00 77 07 04 
0405CD 08 00 00 0C 0048*   	dl 8, 12, 64006, fn_computer_pixel_7_8x12
       00 00 06 FA 
       00 98 07 04 
0405D9 08 00 00 0E 0049*   	dl 8, 14, 64007, fn_computer_pixel_7_8x14
       00 00 07 FA 
       00 B8 07 04 
0405E5 08 00 00 10 0050*   	dl 8, 16, 64008, fn_computer_pixel_7_8x16
       00 00 08 FA 
       00 D8 07 04 
0405F1 08 00 00 08 0051*   	dl 8, 8, 64009, fn_dopecre_8x8
       00 00 09 FA 
       00 F8 07 04 
0405FD 08 00 00 08 0052*   	dl 8, 8, 64010, fn_gamer_2_8x8
       00 00 0A FA 
       00 0E 08 04 
040609 08 00 00 08 0053*   	dl 8, 8, 64011, fn_Lat15_VGA8_8x8
       00 00 0B FA 
       00 24 08 04 
040615 06 00 00 0C 0054*   	dl 6, 12, 64012, fn_Lat2_Terminus12x6_6x12
       00 00 0C FA 
       00 3D 08 04 
040621 08 00 00 0E 0055*   	dl 8, 14, 64013, fn_Lat2_TerminusBold14_8x14
       00 00 0D FA 
       00 5E 08 04 
04062D 08 00 00 0E 0056*   	dl 8, 14, 64014, fn_Lat2_VGA14_8x14
       00 00 0E FA 
       00 81 08 04 
040639 08 00 00 10 0057*   	dl 8, 16, 64015, fn_Lat2_VGA16_8x16
       00 00 0F FA 
       00 9B 08 04 
040645 08 00 00 08 0058*   	dl 8, 8, 64016, fn_Lat2_VGA8_8x8
       00 00 10 FA 
       00 B5 08 04 
040651 08 00 00 08 0059*   	dl 8, 8, 64017, fn_Lat38_VGA8_8x8
       00 00 11 FA 
       00 CD 08 04 
04065D 08 00 00 0D 0060*   	dl 8, 13, 64018, fn_Lat7_Fixed13_8x13
       00 00 12 FA 
       00 E6 08 04 
040669 06 00 00 0C 0061*   	dl 6, 12, 64019, fn_Lat7_Terminus12x6_6x12
       00 00 13 FA 
       00 02 09 04 
040675 08 00 00 10 0062*   	dl 8, 16, 64020, fn_Lat7_TerminusBold16_8x16
       00 00 14 FA 
       00 23 09 04 
040681 08 00 00 0E 0063*   	dl 8, 14, 64021, fn_Lat7_VGA14_8x14
       00 00 15 FA 
       00 46 09 04 
04068D 08 00 00 10 0064*   	dl 8, 16, 64022, fn_Lat7_VGA16_8x16
       00 00 16 FA 
       00 60 09 04 
040699 08 00 00 08 0065*   	dl 8, 8, 64023, fn_Lat7_VGA8_8x8
       00 00 17 FA 
       00 7A 09 04 
0406A5 08 00 00 08 0066*   	dl 8, 8, 64024, fn_planetary_contact_8x8
       00 00 18 FA 
       00 92 09 04 
0406B1 0C 00 00 0E 0067*   	dl 12, 14, 64025, fn_scriptorium_12x14
       00 00 19 FA 
       00 B2 09 04 
0406BD 08 00 00 0C 0068*   	dl 8, 12, 64026, fn_Squarewave_Bold_8x12
       00 00 1A FA 
       00 CE 09 04 
0406C9 08 00 00 08 0069*   	dl 8, 8, 64027, fn_super_mario_bros_2_8x8
       00 00 1B FA 
       00 ED 09 04 
0406D5 06 00 00 06 0070*   	dl 6, 6, 64028, fn_wendy_neue_6x6
       00 00 1C FA 
       00 0E 0A 04 
0406E1             0071*   
0406E1             0072*   ; files_list: ; filename:
0406E1 66 6F 6E 74 0073*   fn_amiga_forever_16x16: db "fontsamiga_forever_16x16.font",0
       73 61 6D 69 
       67 61 5F 66 
       6F 72 65 76 
       65 72 5F 31 
       36 78 31 36 
       2E 66 6F 6E 
       74 00       
0406FF 66 6F 6E 74 0074*   fn_amiga_forever_16x24: db "fontsamiga_forever_16x24.font",0
       73 61 6D 69 
       67 61 5F 66 
       6F 72 65 76 
       65 72 5F 31 
       36 78 32 34 
       2E 66 6F 6E 
       74 00       
04071D 66 6F 6E 74 0075*   fn_amiga_forever_8x16: db "fontsamiga_forever_8x16.font",0
       73 61 6D 69 
       67 61 5F 66 
       6F 72 65 76 
       65 72 5F 38 
       78 31 36 2E 
       66 6F 6E 74 
       00          
04073A 66 6F 6E 74 0076*   fn_amiga_forever_8x8: db "fontsamiga_forever_8x8.font",0
       73 61 6D 69 
       67 61 5F 66 
       6F 72 65 76 
       65 72 5F 38 
       78 38 2E 66 
       6F 6E 74 00 
040756 66 6F 6E 74 0077*   fn_computer_pixel_7_10x15: db "fontscomputer_pixel_7_10x15.font",0
       73 63 6F 6D 
       70 75 74 65 
       72 5F 70 69 
       78 65 6C 5F 
       37 5F 31 30 
       78 31 35 2E 
       66 6F 6E 74 
       00          
040777 66 6F 6E 74 0078*   fn_computer_pixel_7_10x24: db "fontscomputer_pixel_7_10x24.font",0
       73 63 6F 6D 
       70 75 74 65 
       72 5F 70 69 
       78 65 6C 5F 
       37 5F 31 30 
       78 32 34 2E 
       66 6F 6E 74 
       00          
040798 66 6F 6E 74 0079*   fn_computer_pixel_7_8x12: db "fontscomputer_pixel_7_8x12.font",0
       73 63 6F 6D 
       70 75 74 65 
       72 5F 70 69 
       78 65 6C 5F 
       37 5F 38 78 
       31 32 2E 66 
       6F 6E 74 00 
0407B8 66 6F 6E 74 0080*   fn_computer_pixel_7_8x14: db "fontscomputer_pixel_7_8x14.font",0
       73 63 6F 6D 
       70 75 74 65 
       72 5F 70 69 
       78 65 6C 5F 
       37 5F 38 78 
       31 34 2E 66 
       6F 6E 74 00 
0407D8 66 6F 6E 74 0081*   fn_computer_pixel_7_8x16: db "fontscomputer_pixel_7_8x16.font",0
       73 63 6F 6D 
       70 75 74 65 
       72 5F 70 69 
       78 65 6C 5F 
       37 5F 38 78 
       31 36 2E 66 
       6F 6E 74 00 
0407F8 66 6F 6E 74 0082*   fn_dopecre_8x8: db "fontsdopecre_8x8.font",0
       73 64 6F 70 
       65 63 72 65 
       5F 38 78 38 
       2E 66 6F 6E 
       74 00       
04080E 66 6F 6E 74 0083*   fn_gamer_2_8x8: db "fontsgamer_2_8x8.font",0
       73 67 61 6D 
       65 72 5F 32 
       5F 38 78 38 
       2E 66 6F 6E 
       74 00       
040824 66 6F 6E 74 0084*   fn_Lat15_VGA8_8x8: db "fontsLat15-VGA8_8x8.font",0
       73 4C 61 74 
       31 35 2D 56 
       47 41 38 5F 
       38 78 38 2E 
       66 6F 6E 74 
       00          
04083D 66 6F 6E 74 0085*   fn_Lat2_Terminus12x6_6x12: db "fontsLat2-Terminus12x6_6x12.font",0
       73 4C 61 74 
       32 2D 54 65 
       72 6D 69 6E 
       75 73 31 32 
       78 36 5F 36 
       78 31 32 2E 
       66 6F 6E 74 
       00          
04085E 66 6F 6E 74 0086*   fn_Lat2_TerminusBold14_8x14: db "fontsLat2-TerminusBold14_8x14.font",0
       73 4C 61 74 
       32 2D 54 65 
       72 6D 69 6E 
       75 73 42 6F 
       6C 64 31 34 
       5F 38 78 31 
       34 2E 66 6F 
       6E 74 00    
040881 66 6F 6E 74 0087*   fn_Lat2_VGA14_8x14: db "fontsLat2-VGA14_8x14.font",0
       73 4C 61 74 
       32 2D 56 47 
       41 31 34 5F 
       38 78 31 34 
       2E 66 6F 6E 
       74 00       
04089B 66 6F 6E 74 0088*   fn_Lat2_VGA16_8x16: db "fontsLat2-VGA16_8x16.font",0
       73 4C 61 74 
       32 2D 56 47 
       41 31 36 5F 
       38 78 31 36 
       2E 66 6F 6E 
       74 00       
0408B5 66 6F 6E 74 0089*   fn_Lat2_VGA8_8x8: db "fontsLat2-VGA8_8x8.font",0
       73 4C 61 74 
       32 2D 56 47 
       41 38 5F 38 
       78 38 2E 66 
       6F 6E 74 00 
0408CD 66 6F 6E 74 0090*   fn_Lat38_VGA8_8x8: db "fontsLat38-VGA8_8x8.font",0
       73 4C 61 74 
       33 38 2D 56 
       47 41 38 5F 
       38 78 38 2E 
       66 6F 6E 74 
       00          
0408E6 66 6F 6E 74 0091*   fn_Lat7_Fixed13_8x13: db "fontsLat7-Fixed13_8x13.font",0
       73 4C 61 74 
       37 2D 46 69 
       78 65 64 31 
       33 5F 38 78 
       31 33 2E 66 
       6F 6E 74 00 
040902 66 6F 6E 74 0092*   fn_Lat7_Terminus12x6_6x12: db "fontsLat7-Terminus12x6_6x12.font",0
       73 4C 61 74 
       37 2D 54 65 
       72 6D 69 6E 
       75 73 31 32 
       78 36 5F 36 
       78 31 32 2E 
       66 6F 6E 74 
       00          
040923 66 6F 6E 74 0093*   fn_Lat7_TerminusBold16_8x16: db "fontsLat7-TerminusBold16_8x16.font",0
       73 4C 61 74 
       37 2D 54 65 
       72 6D 69 6E 
       75 73 42 6F 
       6C 64 31 36 
       5F 38 78 31 
       36 2E 66 6F 
       6E 74 00    
040946 66 6F 6E 74 0094*   fn_Lat7_VGA14_8x14: db "fontsLat7-VGA14_8x14.font",0
       73 4C 61 74 
       37 2D 56 47 
       41 31 34 5F 
       38 78 31 34 
       2E 66 6F 6E 
       74 00       
040960 66 6F 6E 74 0095*   fn_Lat7_VGA16_8x16: db "fontsLat7-VGA16_8x16.font",0
       73 4C 61 74 
       37 2D 56 47 
       41 31 36 5F 
       38 78 31 36 
       2E 66 6F 6E 
       74 00       
04097A 66 6F 6E 74 0096*   fn_Lat7_VGA8_8x8: db "fontsLat7-VGA8_8x8.font",0
       73 4C 61 74 
       37 2D 56 47 
       41 38 5F 38 
       78 38 2E 66 
       6F 6E 74 00 
040992 66 6F 6E 74 0097*   fn_planetary_contact_8x8: db "fontsplanetary_contact_8x8.font",0
       73 70 6C 61 
       6E 65 74 61 
       72 79 5F 63 
       6F 6E 74 61 
       63 74 5F 38 
       78 38 2E 66 
       6F 6E 74 00 
0409B2 66 6F 6E 74 0098*   fn_scriptorium_12x14: db "fontsscriptorium_12x14.font",0
       73 73 63 72 
       69 70 74 6F 
       72 69 75 6D 
       5F 31 32 78 
       31 34 2E 66 
       6F 6E 74 00 
0409CE 66 6F 6E 74 0099*   fn_Squarewave_Bold_8x12: db "fontsSquarewave_Bold_8x12.font",0
       73 53 71 75 
       61 72 65 77 
       61 76 65 5F 
       42 6F 6C 64 
       5F 38 78 31 
       32 2E 66 6F 
       6E 74 00    
0409ED 66 6F 6E 74 0100*   fn_super_mario_bros_2_8x8: db "fontssuper_mario_bros_2_8x8.font",0
       73 73 75 70 
       65 72 5F 6D 
       61 72 69 6F 
       5F 62 72 6F 
       73 5F 32 5F 
       38 78 38 2E 
       66 6F 6E 74 
       00          
040A0E 66 6F 6E 74 0101*   fn_wendy_neue_6x6: db "fontswendy_neue_6x6.font",0
       73 77 65 6E 
       64 79 5F 6E 
       65 75 65 5F 
       36 78 36 2E 
       66 6F 6E 74 
       00          
040A27             0037        include "fixed168.inc"
040A27             0001*   ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
040A27             0002*   ; uses EZ80 MLT instruction for speed
040A27             0003*   ; operation: UHL * A --> UHL
040A27             0004*   ; destroys: AF, HL
040A27             0005*   smul24x8:
040A27             0006*   ; make hl positive and store sign flag
040A27 CD 70 04 04 0007*       call hlu_abs
040A2B F5          0008*       push af
040A2C             0009*   ; do the division
040A2C CD 37 0A 04 0010*       call mul24x8 ; hl = product
040A30             0011*   ; adjust sign of result
040A30 F1          0012*       pop af ; sign de
040A31 F0          0013*       ret p ; hl was positive, nothing to do
040A32 CD 80 04 04 0014*       call neg_hlu ; result is negative
040A36 C9          0015*       ret
040A37             0016*   
040A37             0017*   ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
040A37             0018*   ; uses EZ80 MLT instruction for speed
040A37             0019*   ; operation: UHL * A --> AUHL
040A37             0020*   ; destroys: AF, HL
040A37             0021*   mul24x8:
040A37 D5          0022*       push de ; preserve de
040A38             0023*   ; low byte
040A38 5D          0024*       ld e,l
040A39 57          0025*       ld d,a
040A3A ED 5C       0026*       mlt de
040A3C 6B          0027*       ld l,e ; product low byte
040A3D 08          0028*       ex af,af' ; save multiplier
040A3E 7A          0029*       ld a,d ; carry
040A3F 08          0030*       ex af,af' ; save carry, restore multiplier
040A40             0031*   ; high byte
040A40 5C          0032*       ld e,h
040A41 57          0033*       ld d,a
040A42 ED 5C       0034*       mlt de
040A44 08          0035*       ex af,af' ; save multiplier, restore carry
040A45 83          0036*       add a,e ; add carry
040A46 67          0037*       ld h,a ; product middle byte
040A47 7A          0038*       ld a,d ; carry
040A48 08          0039*       ex af,af' ; save carry, restore multiplier
040A49             0040*   ; upper byte
040A49 22 64 0A 04 0041*       ld (@scratch),hl ; 7 cycles
040A4D 5F          0042*       ld e,a
040A4E 3A 66 0A 04 0043*       ld a,(@scratch+2)
040A52 57          0044*       ld d,a
040A53 ED 5C       0045*       mlt de
040A55 08          0046*       ex af,af' ; restore carry
040A56 8B          0047*       adc a,e ; add carry
040A57 32 66 0A 04 0048*       ld (@scratch+2),a ; 5 cycles
040A5B 2A 64 0A 04 0049*       ld hl,(@scratch) ; 7 cycles
040A5F             0050*   ; highest byte
040A5F 3E 00       0051*       ld a,0 ; preserve carry flag
040A61 8A          0052*       adc a,d ; product highest byte
040A62 D1          0053*       pop de ; restore de
040A63 C9          0054*       ret
040A64             0055*   @scratch: ds 3
040A67             0056*   
       FF FF FF 
040A67 00 00 00 00 0057*   mul24out: blkb 6,0
       00 00       
040A6D             0058*   
040A6D             0059*   ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
040A6D             0060*   ; operation: UHL * UDE --> mul24out
040A6D             0061*   mul24:
040A6D DD E5       0062*       push ix ; preserve
040A6F             0063*   ; point to output buffer and clear it
040A6F DD 21 67 0A 0064*       ld ix,mul24out
       04          
040A74 C5          0065*       push bc
040A75 01 00 00 00 0066*       ld bc,0
040A79 DD 0F 00    0067*       ld (ix),bc
040A7C DD 0F 03    0068*       ld (ix+3),bc
040A7F C1          0069*       pop bc
040A80             0070*   ; STEP 1: UHL * E
040A80 7B          0071*       ld a,e
040A81 E5          0072*       push hl
040A82 CD 37 0A 04 0073*       call mul24x8
040A86 DD 2F 00    0074*       ld (ix+0),hl
040A89 DD 77 03    0075*       ld (ix+3),a
040A8C             0076*   ; STEP 2: UHL * D
040A8C E1          0077*       pop hl
040A8D E5          0078*       push hl
040A8E 7A          0079*       ld a,d
040A8F CD 37 0A 04 0080*       call mul24x8
040A93 CD AC 0A 04 0081*       call @accumulate
040A97             0082*   ; STEP 3: UHL * DEU
040A97 E1          0083*       pop hl
040A98 ED 53 DC 0A 0084*       ld (@de),de
       04          
040A9D 3A DE 0A 04 0085*       ld a,(@de+2)
040AA1 CD 37 0A 04 0086*       call mul24x8
040AA5 CD AC 0A 04 0087*       call @accumulate
040AA9             0088*   ; all done
040AA9 DD E1       0089*       pop ix ; restore
040AAB C9          0090*       ret
040AAC             0091*   @accumulate:
040AAC DD 23       0092*       inc ix
040AAE             0093*   ; highest byte of product to carry
040AAE DD 77 03    0094*       ld (ix+3),a
040AB1             0095*   ; low byte of product
040AB1 7D          0096*       ld a,l
040AB2 DD 86 00    0097*       add a,(ix+0)
040AB5 DD 77 00    0098*       ld (ix+0),a
040AB8             0099*   ; high byte of product
040AB8 7C          0100*       ld a,h
040AB9 DD 8E 01    0101*       adc a,(ix+1)
040ABC DD 77 01    0102*       ld (ix+1),a
040ABF             0103*   ; uppper byte of product
040ABF 22 D9 0A 04 0104*       ld (@hl),hl
040AC3 3A DB 0A 04 0105*       ld a,(@hl+2)
040AC7 DD 8E 02    0106*       adc a,(ix+2)
040ACA DD 77 02    0107*       ld (ix+2),a
040ACD             0108*   ; carry
040ACD 3E 00       0109*       ld a,0 ; preserve flags
040ACF DD 8E 03    0110*       adc a,(ix+3)
040AD2 DD 77 03    0111*       ld (ix+3),a
040AD5 C9          0112*       ret
040AD6             0113*   
040AD6 00 00 00    0114*   @ix: dl 0
040AD9 00 00 00    0115*   @hl: dl 0
040ADC 00 00 00    0116*   @de: dl 0
040ADF             0117*   
040ADF             0118*   ; ; UHL * UDE --> UHL (unsigned)
040ADF             0119*   ; umul24:
040ADF             0120*   ;     call mul24
040ADF             0121*   ;     ld hl,(mul24out)
040ADF             0122*   ;     ret
040ADF             0123*   
040ADF             0124*   ; UH.L = UH.L*UD.E (unsigned)
040ADF             0125*   umul168:
040ADF CD 6D 0A 04 0126*       call mul24
040AE3 2A 68 0A 04 0127*       ld hl,(mul24out+1)
040AE7 C9          0128*       ret
040AE8             0129*   
040AE8             0130*   ; UH.L * UD.E --> UH.L (signed)
040AE8             0131*   smul168:
040AE8             0132*   ; make everything positive and store sign flags
040AE8 CD 70 04 04 0133*       call hlu_abs
040AEC F5          0134*       push af
040AED EB          0135*       ex de,hl
040AEE CD 70 04 04 0136*       call hlu_abs
040AF2 EB          0137*       ex de,hl
040AF3 F5          0138*       push af
040AF4             0139*   ; do the division
040AF4 CD DF 0A 04 0140*       call umul168 ; hl = product
040AF8             0141*   ; adjust sign of result
040AF8 F1          0142*       pop af ; sign de
040AF9 FA 04 0B 04 0143*       jp m,@de_neg
040AFD F1          0144*       pop af ; sign hl
040AFE F0          0145*       ret p ; both positive, nothing to do
040AFF             0146*   @hl_neg:
040AFF CD 80 04 04 0147*       call neg_hlu ; de pos, hl neg, result is negative
040B03 C9          0148*       ret
040B04             0149*   @de_neg:
040B04 F1          0150*       pop af
040B05 F8          0151*       ret m ; both negative, nothing to do
040B06 CD 80 04 04 0152*       call neg_hlu ; result is negative
040B0A C9          0153*       ret
040B0B             0154*   
040B0B             0155*   ; UH.L / UD.E --> UD.E rem UHL (unsigned)
040B0B             0156*   ; perform unsigned division of 16.8 fixed place values
040B0B             0157*   ; with an unsigned 16.8 fixed place result and 24-bit remainder
040B0B             0158*   udiv168:
040B0B             0159*   ; back up divisor
040B0B ED 53 42 0B 0160*       ld (@ude),de
       04          
040B10             0161*   ; get the 16-bit integer part of the quotient
040B10 CD 80 03 04 0162*       call udiv24 ; de = quotient, hl = remainder
040B14             0163*   ; load quotient to upper three bytes of output
040B14 ED 53 49 0B 0164*       ld (div168_out+1),de
       04          
040B19             0165*   @div256:
040B19             0166*   ; multiply remainder by 256
040B19             0167*       hlu_mul256
040B19 29          0001*M1     add hl,hl ; * 2
040B1A 29          0002*M1     add hl,hl ; * 4
040B1B 29          0003*M1     add hl,hl ; * 8
040B1C 29          0004*M1     add hl,hl ; * 16
040B1D 29          0005*M1     add hl,hl ; * 32
040B1E 29          0006*M1     add hl,hl ; * 64
040B1F 29          0007*M1     add hl,hl ; * 128
040B20 29          0008*M1     add hl,hl ; * 256
040B21             0168*   ; skip fractional computation if remainder is zero
040B21             0169*       SIGN_HLU
040B21 19          0001*M1     add hl,de ; 1 cycle
040B22 B7          0002*M1     or a ; clear flags ; 1 cycle
040B23 ED 52       0003*M1     sbc hl,de ; 2 cycles
040B25             0004*M1     ; 4 cycles total
040B25 20 03       0170*       jr nz,@div_frac
040B27 AF          0171*       xor a
040B28 18 0A       0172*       jr @write_frac
040B2A             0173*   ; now divide the shifted remainder by the divisor
040B2A             0174*   @div_frac:
040B2A ED 5B 42 0B 0175*       ld de,(@ude) ; get back divisor
       04          
040B2F CD 80 03 04 0176*       call udiv24 ; de = quotient, hl = remainder
040B33             0177*   ; load low byte of quotient to low byte of output
040B33 7B          0178*       ld a,e
040B34             0179*   @write_frac:
040B34 32 48 0B 04 0180*       ld (div168_out),a
040B38             0181*   ; load de with return value
040B38 ED 5B 48 0B 0182*       ld de,(div168_out)
       04          
040B3D             0183*   ; load a with any overflow
040B3D 3A 4B 0B 04 0184*       ld a,(div168_out+3)
040B41 C9          0185*       ret ; ud.e is the 16.8 result
040B42             0186*   @ude: ds 6
040B48             0187*   div168_out: ds 4 ; the extra byte is for overflow
040B4C             0188*   
040B4C             0189*   ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
040B4C             0190*   ; perform signed division of 16.8 fixed place values
040B4C             0191*   ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
040B4C             0192*   sdiv168:
040B4C             0193*   ; make everything positive and store sign flags
       FF FF FF FF 
       FF FF FF FF 
       FF FF 
040B4C CD 70 04 04 0194*       call hlu_abs
040B50 F5          0195*       push af
040B51 EB          0196*       ex de,hl
040B52 CD 70 04 04 0197*       call hlu_abs
040B56 EB          0198*       ex de,hl
040B57 F5          0199*       push af
040B58             0200*   ; do the division
040B58 CD 0B 0B 04 0201*       call udiv168 ; de = quotient, hl = remainder
040B5C             0202*   ; adjust sign of result
040B5C F1          0203*       pop af ; sign de
040B5D FA 6A 0B 04 0204*       jp m,@de_neg
040B61 F1          0205*       pop af ; sign hl
040B62 F0          0206*       ret p ; both positive, nothing to do
040B63             0207*   @hl_neg:
040B63 EB          0208*       ex de,hl ; hl = quotient, de = remainder
040B64 CD 80 04 04 0209*       call neg_hlu ; de pos, hl neg, result is negative
040B68 EB          0210*       ex de,hl ; de = negated quotient, hl = remainder
040B69 C9          0211*       ret
040B6A             0212*   @de_neg:
040B6A F1          0213*       pop af
040B6B F8          0214*       ret m ; both negative, nothing to do
040B6C EB          0215*       ex de,hl ; hl = quotient, de = remainder
040B6D CD 80 04 04 0216*       call neg_hlu ; result is negative
040B71 EB          0217*       ex de,hl ; de = negated quotient, hl = remainder
040B72 C9          0218*       ret
040B73             0219*   
040B73             0220*   ; convert signed angles from a 360 to 256 degree circle
040B73             0221*   ; inputs: uh.l is the angle360 in 16.8 fixed format
040B73             0222*   ; outputs: uh.l is the angle256 in 16.8 fixed format
040B73             0223*   ; destroys: TODO
040B73             0224*   deg_360_to_256:
040B73 D5          0225*       push de ; preserve de
040B74             0226*   ; make angle positive and store sign flag
040B74 CD 70 04 04 0227*       call hlu_abs
040B78 F5          0228*       push af
040B79             0229*   ; multiply by coversion factor of 256/360
040B79 11 B6 00 00 0230*       ld de,0x0000B6 ; 0.711
040B7D CD DF 0A 04 0231*       call umul168 ; uh.l = uh.l * 0.711
040B81             0232*   ; restore sign flag and adjust output accordingly
040B81 F1          0233*       pop af
040B82 F2 8A 0B 04 0234*       jp p,@pos ; positive number
040B86 CD 80 04 04 0235*       call neg_hlu
040B8A             0236*   @pos:
040B8A             0237*   ; restore de and return uh.l as the result
040B8A D1          0238*       pop de
040B8B C9          0239*       ret
040B8C             0240*   
040B8C             0241*   ; convert signed angles from a 256 to 360 degree circle
040B8C             0242*   ; inputs: uh.l is the angle256 in 16.8 fixed format
040B8C             0243*   ; outputs: uh.l is the angle360 in 16.8 fixed format
040B8C             0244*   ; destroys: TODO
040B8C             0245*   deg_256_to_360:
040B8C D5          0246*       push de ; preserve de
040B8D             0247*   ; make angle positive and store sign flag
040B8D CD 70 04 04 0248*       call hlu_abs
040B91 F5          0249*       push af
040B92             0250*   ; multiply by coversion factor of 360/256
040B92 11 68 01 00 0251*       ld de,0x000168 ; 1.406
040B96 CD DF 0A 04 0252*       call umul168 ; uh.l = uh.l * 1.406
040B9A             0253*   ; restore sign flag and adjust output accordingly
040B9A F1          0254*       pop af
040B9B F2 A3 0B 04 0255*       jp p,@pos ; positive number
040B9F CD 80 04 04 0256*       call neg_hlu
040BA3             0257*   @pos:
040BA3             0258*   ; restore de and return uh.l as the result
040BA3 D1          0259*       pop de
040BA4 C9          0260*       ret
040BA5             0261*   
040BA5             0262*   ; fixed 16.8 routine
040BA5             0263*   ; cos(uh.l) --> uh.l
040BA5             0264*   ; destroys: f, hl
040BA5             0265*   cos168:
040BA5 D5          0266*       push de ; preserve de
040BA6             0267*   ; for cos we simply increment the angle by 90 degrees
040BA6             0268*   ; or 0x004000 in 16.8 degrees256
040BA6             0269*   ; which makes it a sin problem
040BA6 11 00 40 00 0270*       ld de,0x004000
040BAA 19          0271*       add hl,de ; modulo 256 happens below
040BAB D1          0272*       pop de ; restore de
040BAC             0273*   ; fall through to sin168
040BAC             0274*   
040BAC             0275*   ; ---------------------
040BAC             0276*   ; fixed 16.8 routine
040BAC             0277*   ; sin(uh.l) --> uh.l
040BAC             0278*   ; destroys: f, hl
040BAC             0279*   sin168:
040BAC D5          0280*       push de
040BAD             0281*   ; handle negative angles appropriately
040BAD CD 70 04 04 0282*       call hlu_abs
040BB1 F2 BA 0B 04 0283*       jp p,@F
040BB5 11 00 00 FF 0284*       ld de,-256*256
040BB9 19          0285*       add hl,de
040BBA             0286*   @@:
040BBA 2E 03       0287*       ld l,3 ; multiply by 3 to get our lookup index
040BBC ED 6C       0288*       mlt hl
040BBE 11 72 0E 04 0289*       ld de,sin_lut_168 ; grab the lut address
040BC2 19          0290*       add hl,de ; bump hl by the index
040BC3 ED 27       0291*       ld hl,(hl) ; don't try this on a z80!
040BC5 D1          0292*       pop de
040BC6 C9          0293*       ret
040BC7             0294*   
040BC7             0295*   ; 16.8 fixed inputs / outputs
040BC7             0296*   ; takes: uh.l as angle in degrees 256
040BC7             0297*   ;        ud.e as radius
040BC7             0298*   ; returns ub.c as dx, ud.e as dy, uh.l as radius
040BC7             0299*   ;        displacements from origin (0,0)
040BC7             0300*   ; destroys: everything except indexes
040BC7             0301*   polar_to_cartesian:
040BC7             0302*   ; back up input parameters
040BC7 22 F6 0B 04 0303*       ld (@angle), hl
040BCB ED 53 F9 0B 0304*       ld (@radius), de
       04          
040BD0             0305*   ; compute dx = sin(uh.l) * ud.e
040BD0 CD AC 0B 04 0306*       call sin168 ; uh.l = sin(uh.l)
040BD4 ED 5B F9 0B 0307*       ld de,(@radius)
       04          
040BD9 CD E8 0A 04 0308*       call smul168 ; uh.l = dx
040BDD E5          0309*       push hl
040BDE             0310*   ; compute dy = -cos(uh.l) * ud.e
040BDE 2A F6 0B 04 0311*       ld hl,(@angle)
040BE2 CD A5 0B 04 0312*       call cos168 ; uh.l = cos(uh.l)
040BE6 ED 5B F9 0B 0313*       ld de,(@radius)
       04          
040BEB CD E8 0A 04 0314*       call smul168 ; uh.l = dy
040BEF CD 80 04 04 0315*       call neg_hlu ; invert dy for screen coords convention
040BF3 EB          0316*       ex de,hl ; de = dy for output
040BF4 C1          0317*       pop bc ; bc = dx for output
040BF5             0318*   ; and out
040BF5 C9          0319*       ret
040BF6             0320*   @angle: ds 3
040BF9             0321*   @radius: ds 3
040BFC             0322*   
040BFC             0323*   ; 16.8 fixed inputs / outputs
040BFC             0324*   ; inputs: ub.c as dx, ud.e as dy
040BFC             0325*   ;        displacements from origin (0,0)
040BFC             0326*   ; returns: uh.l as angle in degrees 256
040BFC             0327*   ;        ud.e as radius
040BFC             0328*   ; destroys: everything except indexes
040BFC             0329*   cartesian_to_polar:
       FF FF FF FF 
       FF FF 
040BFC ED 43 55 0C 0330*       ld (dx168),bc ; dx argument for distance168
       04          
040C01 ED 53 5B 0C 0331*       ld (dy168),de ; dy argument for distance168
       04          
040C06             0332*   ; compute radius
040C06 CD 61 0C 04 0333*       call distance168 ; uh.l = radius
040C0A E5          0334*       push hl ; save radius
040C0B             0335*   ; compute angle
040C0B ED 4B 55 0C 0336*       ld bc,(dx168) ; dx argument for atan2_168fast
       04          
040C10 ED 5B 5B 0C 0337*       ld de,(dy168) ; dy argument for atan2_168fast
       04          
040C15 CD C1 0C 04 0338*       call atan2_168fast ; uh.l = angle
040C19             0339*   ; return result
040C19 D1          0340*       pop de ; de = radius (was hl)
040C1A C9          0341*       ret
040C1B             0342*   ; end cartesian_to_polar
040C1B             0343*   
040C1B             0344*   ; 16.8 fixed inputs / outputs
040C1B             0345*   ; inputs: ub.c as dx, ud.e as dy
040C1B             0346*   ;        displacements from origin (0,0)
040C1B             0347*   ; returns: uh.l as angle in degrees 256
040C1B             0348*   ;        ud.e as radius
040C1B             0349*   ; destroys: everything except indexes
040C1B             0350*   ; note: uses distance168sm which is more accurate for small deltas
040C1B             0351*   cartesian_to_polar_sm:
040C1B ED 43 55 0C 0352*       ld (dx168),bc ; dx argument for distance168
       04          
040C20 ED 53 5B 0C 0353*       ld (dy168),de ; dy argument for distance168
       04          
040C25             0354*   ; compute radius
040C25 CD 9C 0C 04 0355*       call distance168sm ; uh.l = radius
040C29 E5          0356*       push hl ; save radius
040C2A             0357*   ; compute angle
040C2A ED 4B 55 0C 0358*       ld bc,(dx168) ; dx argument for atan2_168fast
       04          
040C2F ED 5B 5B 0C 0359*       ld de,(dy168) ; dy argument for atan2_168fast
       04          
040C34 CD C1 0C 04 0360*       call atan2_168fast ; uh.l = angle
040C38             0361*   ; return result
040C38 D1          0362*       pop de ; de = radius (was hl)
040C39 C9          0363*       ret
040C3A             0364*   ; end cartesian_to_polar
040C3A             0365*   
040C3A             0366*   ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
040C3A             0367*   ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
040C3A             0368*   ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
040C3A             0369*   ;         also populates scratch locations dx168 and dy168
040C3A             0370*   ; destroys: a,hl,bc,de
040C3A             0371*   dxy168:
040C3A             0372*   ; compute dx = x1-x0
040C3A AF          0373*       xor a ; clear carry
040C3B DD E5       0374*       push ix ; move ix to hl via the stack
040C3D E1          0375*       pop hl ; hl = x1
040C3E ED 42       0376*       sbc hl,bc ; hl = dx
040C40 22 55 0C 04 0377*       ld (dx168),hl ; dx to scratch
040C44             0378*   ; compute dy = y1-y0
040C44 AF          0379*       xor a ; clear carry
040C45 FD E5       0380*       push iy ; move iy to hl via the stack
040C47 E1          0381*       pop hl ; hl = y1
040C48 ED 52       0382*       sbc hl,de ; hl = dy
040C4A 22 5B 0C 04 0383*       ld (dy168),hl ; dy to scratch
040C4E             0384*   ; populate output registers and return
040C4E EB          0385*       ex de,hl ; ud.e = dy
040C4F ED 4B 55 0C 0386*       ld bc,(dx168) ; ub.c = dx
       04          
040C54 C9          0387*       ret
040C55 00 00 00 00 0388*   dx168: blkb 6,0
       00 00       
040C5B 00 00 00 00 0389*   dy168: blkb 6,0
       00 00       
040C61             0390*   
040C61             0391*   ; compute the euclidian distance between two cartesian coordinates
040C61             0392*   ; using the formula d = sqrt(dx^2+dy^2)
040C61             0393*   ; inputs: dx168 and dy168 are dx and dy in 16.8 fixed format
040C61             0394*   ; output; uh.l is the 16.8 fixed format distance
040C61             0395*   ;         also populates scratch locations dx168 and dy168
040C61             0396*   ; destroys: a,hl,bc,de
040C61             0397*   ; NOTE: rounds both deltas down to the nearest integer to avoid overflow when squaring,
040C61             0398*   ;       thus the result will always be an integer, albeit in 16.8 format
040C61             0399*   distance168:
040C61             0400*   ; compute dy^2
040C61 2A 5B 0C 04 0401*       ld hl,(dy168)
040C65 CD 70 04 04 0402*       call hlu_abs
040C69             0403*       ; call hlu_udiv256 ; make integer to avoid overflow
040C69             0404*       SRL_UHL ; make integer to avoid overflow
040C69 3B          0001*M1     dec sp ; 1 cycle
040C6A E5          0002*M1     push hl ; 4 cycles
040C6B 33          0003*M1     inc sp ; 1 cycle
040C6C E1          0004*M1     pop hl ; 4 cycles
040C6D 23          0005*M1     inc hl ; 1 cycle
040C6E 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
040C70             0007*M1     ; 13 cycles total
040C70 E5          0405*       push hl
040C71 D1          0406*       pop de
040C72 CD 67 03 04 0407*       call umul24 ; hl = dy^2
040C76 E5          0408*       push hl ; save dy^2
040C77             0409*   ; compute dx^2
040C77 2A 55 0C 04 0410*       ld hl,(dx168)
040C7B CD 70 04 04 0411*       call hlu_abs
040C7F             0412*       ; call hlu_udiv256 ; make integer to avoid overflow
040C7F             0413*       SRL_UHL ; make integer to avoid overflow
040C7F 3B          0001*M1     dec sp ; 1 cycle
040C80 E5          0002*M1     push hl ; 4 cycles
040C81 33          0003*M1     inc sp ; 1 cycle
040C82 E1          0004*M1     pop hl ; 4 cycles
040C83 23          0005*M1     inc hl ; 1 cycle
040C84 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
040C86             0007*M1     ; 13 cycles total
040C86 E5          0414*       push hl
040C87 D1          0415*       pop de
040C88 CD 67 03 04 0416*       call umul24 ; hl = dx^2
040C8C             0417*   ; add dx^2 and dy^2
040C8C D1          0418*       pop de ; de = dy^2 (was hl)
040C8D 19          0419*       add hl,de ; hl = dx^2 + dy^2
040C8E             0420*   ; compute the square root
040C8E CD 8C 0D 04 0421*       call sqrt24 ; de = sqrt(dx^2 + dy^2)
040C92 EB          0422*       ex de,hl ; hl = distance
040C93             0423*       hlu_mul256 ; convert back to 16.8 fixed
040C93 29          0001*M1     add hl,hl ; * 2
040C94 29          0002*M1     add hl,hl ; * 4
040C95 29          0003*M1     add hl,hl ; * 8
040C96 29          0004*M1     add hl,hl ; * 16
040C97 29          0005*M1     add hl,hl ; * 32
040C98 29          0006*M1     add hl,hl ; * 64
040C99 29          0007*M1     add hl,hl ; * 128
040C9A 29          0008*M1     add hl,hl ; * 256
040C9B C9          0424*       ret
040C9C             0425*   
040C9C             0426*   ; compute the euclidian distance between two cartesian coordinates
040C9C             0427*   ; using the formula d = sqrt(dx^2+dy^2)
040C9C             0428*   ; inputs: dx168 and dy168 are dx and dy in 16.8 fixed format
040C9C             0429*   ; output; uh.l is the 16.8 fixed format distance
040C9C             0430*   ;         also populates scratch locations dx168 and dy168
040C9C             0431*   ; destroys: a,hl,bc,de
040C9C             0432*   ; NOTE: sm means 'small' because it doesn't round down the deltas
040C9C             0433*   ;       making it more accurate for small deltas,
040C9C             0434*   ;       but will overflow if used for screen-sized deltas
040C9C             0435*   distance168sm:
040C9C             0436*   ; compute dy^2
040C9C 2A 5B 0C 04 0437*       ld hl,(dy168)
040CA0 CD 70 04 04 0438*       call hlu_abs
040CA4 E5          0439*       push hl
040CA5 D1          0440*       pop de
040CA6 CD 67 03 04 0441*       call umul24 ; hl = dy^2
040CAA E5          0442*       push hl ; save dy^2
040CAB             0443*   ; compute dx^2
040CAB 2A 55 0C 04 0444*       ld hl,(dx168)
040CAF CD 70 04 04 0445*       call hlu_abs
040CB3 E5          0446*       push hl
040CB4 D1          0447*       pop de
040CB5 CD 67 03 04 0448*       call umul24 ; hl = dx^2
040CB9             0449*   ; add dx^2 and dy^2
040CB9 D1          0450*       pop de ; de = dy^2 (was hl)
040CBA 19          0451*       add hl,de ; hl = dx^2 + dy^2
040CBB             0452*   ; compute the square root
040CBB CD 8C 0D 04 0453*       call sqrt24 ; de = sqrt(dx^2 + dy^2)
040CBF EB          0454*       ex de,hl ; hl = distance
040CC0 C9          0455*       ret
040CC1             0456*   
040CC1             0457*   ; atan2_(ub.c,ud.e) --> uh.l
040CC1             0458*   ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040CC1             0459*   ;   whether inputs are integers or fractional doesn't matter
040CC1             0460*   ;   so long as the sign bit of the upper byte is correct
040CC1             0461*   ; output: uh.l is the 16.8 fixed angle in degrees 256
040CC1             0462*   ; angles are COMPASS HEADINGS based on
040CC1             0463*   ; screen coordinate conventions,where the y axis is flipped
040CC1             0464*   ; #E0 224      0       32 #20
040CC1             0465*   ;        -x,-y | +x,-y
040CC1             0466*   ; #C0 192------+------ 64 #40
040CC1             0467*   ;        -x,+y | +x,+y
040CC1             0468*   ; #A0 160   128 #80   96 #60
040CC1             0469*   atan2_168fast:
040CC1             0470*   ; get signs and make everything positive
040CC1             0471*   ; get abs(x) and store its original sign
040CC1 C5          0472*       push bc
040CC2 E1          0473*       pop hl
040CC3 CD 70 04 04 0474*       call hlu_abs ; if x was negative this also sets the sign flag
040CC7 E5          0475*       push hl ; store abs(x)
040CC8 C1          0476*       pop bc ; bc = abs(x)
040CC9 F5          0477*       push af ; store sign of x
040CCA             0478*   ; get abs(y) and store its original sign
040CCA EB          0479*       ex de,hl ; hl = y
040CCB CD 70 04 04 0480*       call hlu_abs ; if y was negative this also sets the sign flag
040CCF EB          0481*       ex de,hl ; de = abs(y)
040CD0 F5          0482*       push af ; store sign of y
040CD1             0483*   ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
040CD1             0484*   ; this ensures that our lookup value is between 0 and 1 inclusive
040CD1 AF          0485*       xor a ; clear the carry flag
040CD2 D5          0486*       push de
040CD3 E1          0487*       pop hl
040CD4 ED 42       0488*       sbc hl,bc
040CD6 F5          0489*       push af ; save sign of de - bc
040CD7 F2 E0 0C 04 0490*       jp p,@1 ; bc <= de, so we skip ahead
040CDB             0491*   ; otherwise we swap bc and de
040CDB C5          0492*       push bc
040CDC E1          0493*       pop hl
040CDD EB          0494*       ex de,hl
040CDE E5          0495*       push hl
040CDF C1          0496*       pop bc
040CE0             0497*   @1:
040CE0             0498*   ; now we're ready to snag our preliminary result
040CE0 C5          0499*       push bc
040CE1 E1          0500*       pop hl
040CE2 CD 50 0D 04 0501*       call atan_168fast ; uh.l comes back with prelim result
040CE6             0502*   ; now we adjust uh.l based on sign of de - bc
040CE6 F1          0503*       pop af
040CE7 F2 F3 0C 04 0504*       jp p,@2 ; bc <= de,so we skip ahead
040CEB EB          0505*       ex de,hl
040CEC 21 00 40 00 0506*       ld hl,64*256 ; subtract from 64 (90) degrees
040CF0 AF          0507*       xor a ; clear the carry flag
040CF1 ED 52       0508*       sbc hl,de
040CF3             0509*   @2:
040CF3             0510*   ; adjust the result based on quadrant
040CF3             0511*   ; #E0 224      0       32 #20
040CF3             0512*   ;        -x,-y | +x,-y
040CF3             0513*   ; #C0 192------+------ 64 #40
040CF3             0514*   ;        -x,+y | +x,+y
040CF3             0515*   ; #A0 160   128 #80   96 #60
040CF3 F1          0516*       pop af ; sign of y
040CF4 CA 31 0D 04 0517*       jp z,@y_zero
040CF8 F2 11 0D 04 0518*       jp p,@y_pos
040CFC             0519*   ; y neg,check x
040CFC F1          0520*       pop af ; sign of x
040CFD CA 0B 0D 04 0521*       jp z,@y_neg_x_zero
040D01 F2 10 0D 04 0522*       jp p,@y_neg_x_pos
040D05             0523*   ; y neg,x neg
040D05             0524*   ; angle is 128 to 256 (270 to 360)
040D05             0525*   ; negating the intermediate does the trick
040D05 CD 80 04 04 0526*       call neg_hlu
040D09 18 31       0527*       jr @zero_hlu
040D0B             0528*   
040D0B             0529*   @y_neg_x_zero:
040D0B             0530*   ; y neg,x zero
040D0B             0531*   ; angle is 0
040D0B 21 00 00 00 0532*       ld hl,0
040D0F C9          0533*       ret
040D10             0534*   @y_neg_x_pos:
040D10             0535*   ; y neg,x pos
040D10             0536*   ; angle is 0 to 64 (0 to 90)
040D10             0537*   ; so we're good
040D10 C9          0538*       ret
040D11             0539*   
040D11             0540*   @y_pos:
040D11 F1          0541*       pop af ; sign of x
040D12 CA 21 0D 04 0542*       jp z,@y_pos_x_zero
040D16 F2 26 0D 04 0543*       jp p,@y_pos_x_pos
040D1A             0544*   ; y pos,x neg
040D1A             0545*   ; angle is 128 to 192 (180-270)
040D1A             0546*   ; so we add 128 to intermediate
040D1A 11 00 80 00 0547*       ld de,128*256
040D1E 19          0548*       add hl,de
040D1F 18 1B       0549*       jr @zero_hlu
040D21             0550*   @y_pos_x_zero:
040D21             0551*   ; y pos,x zero
040D21             0552*   ; angle is 128 (180)
040D21 21 00 80 00 0553*       ld hl,128*256
040D25 C9          0554*       ret
040D26             0555*   @y_pos_x_pos:
040D26             0556*   ; y pos,x pos
040D26             0557*   ; angle is 64 to 128 (90 to 180)
040D26             0558*   ; neg the intermediate and add 180 degrees
040D26 CD 80 04 04 0559*       call neg_hlu
040D2A 11 00 80 00 0560*       ld de,128*256
040D2E 19          0561*       add hl,de
040D2F 18 0B       0562*       jr @zero_hlu
040D31             0563*   
040D31             0564*   @y_zero:
040D31 F1          0565*       pop af ; sign of x
040D32 FA 37 0D 04 0566*       jp m,@y_zero_x_neg
040D36             0567*   ; y zero,x pos
040D36             0568*   ; angle is 64 (90),nothing to do
040D36 C9          0569*       ret
040D37             0570*   @y_zero_x_neg:
040D37             0571*   ; y zero ,x neg
040D37             0572*   ; angle is 192 (270)
040D37 21 00 C0 00 0573*       ld hl,192*256
040D3B C9          0574*       ret
040D3C             0575*   @zero_hlu:
040D3C AF          0576*       xor a
040D3D 22 4A 0D 04 0577*       ld (@scratch),hl
040D41 32 4C 0D 04 0578*       ld (@scratch+2),a
040D45 2A 4A 0D 04 0579*       ld hl,(@scratch)
040D49 C9          0580*       ret
040D4A             0581*   @scratch: ds 6
040D50             0582*   
040D50             0583*   ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040D50             0584*   ; output: uh.l is the 16.8 fixed format angle in degrees 256
040D50             0585*   ; destroys: a,hl,bc,de
040D50             0586*   ; note: only works for angles from 0 to 32 (45) degrees
040D50             0587*   ;   use atan2_168fast (which calls this proc) to handle the full 256 (360) degrees
040D50             0588*   atan_168fast:
040D50             0589*   ; because we use compass headings instead of geometric angles
040D50             0590*   ; we compute dx/dy which is 1/tan(theta) in the maths world
040D50             0591*   ; we can do faster unsigned division here because we know dx and dy are positive
       FF FF FF FF 
       FF FF 
040D50 CD 0B 0B 04 0592*       call udiv168 ; ud.e = dx/dy
040D54 EB          0593*       ex de,hl ; uh.l = dx/dy
040D55             0594*   ; test uh.l for 0
040D55 19          0595*       add hl,de
040D56 B7          0596*       or a
040D57 ED 52       0597*       sbc hl,de
040D59 28 22       0598*       jr z,@is_zero
040D5B             0599*   ; test uh.l for 1
040D5B AF          0600*       xor a ; clear carry
040D5C EB          0601*       ex de,hl
040D5D 21 00 01 00 0602*       ld hl,1*256 ; 1 in 16.8 fixed format
040D61 ED 52       0603*       sbc hl,de
040D63 28 13       0604*       jr z,@is_45
040D65 EB          0605*       ex de,hl
040D66             0606*   ; no special cases so we move on
040D66             0607*   ; l contains the fractional portion of tan(uh.l)
040D66             0608*   ; we multiply it by three to get our lookup table index
040D66 26 03       0609*       ld h,3
040D68 ED 6C       0610*       mlt hl ; index into lut
040D6A 11 00 00 00 0611*       ld de,0 ; clear deu
040D6E 54          0612*       ld d,h ; copy hl to de
040D6F 5D          0613*       ld e,l ; de contains our index
040D70 21 75 11 04 0614*       ld hl,atan_lut_168 ; grab the lut address
040D74 19          0615*       add hl,de ; bump hl by the index
040D75 ED 27       0616*       ld hl,(hl) ; don't try this on a z80!
040D77 C9          0617*       ret ; and out
040D78             0618*   @is_45:
040D78 21 00 20 00 0619*       ld hl,32*256
040D7C C9          0620*       ret
040D7D             0621*   ; for the case tan(0)
040D7D             0622*   @is_zero:
040D7D 21 00 00 00 0623*       ld hl,0*256
040D81 C9          0624*       ret
040D82             0625*   
040D82             0626*   ; Expects  ADL mode
040D82             0627*   ; Inputs:  UH.L
040D82             0628*   ; Outputs: UH.L is the 16.8 square root
040D82             0629*   ;          UDE is the integer difference inputHL-DE^2
040D82             0630*   sqrt168:
040D82 CD 8C 0D 04 0631*       call sqrt24
040D86 EB          0632*       ex de,hl
040D87 29          0633*       add hl,hl
040D88 29          0634*       add hl,hl
040D89 29          0635*       add hl,hl
040D8A 29          0636*       add hl,hl
040D8B C9          0637*       ret
040D8C             0638*   
040D8C             0639*   ; credit: xeda112358
040D8C             0640*   ; https://www.cemetech.net/forum/viewtopic.php?t=11178&postdays=0&postorder=asc&start=0
040D8C             0641*   sqrt24:
040D8C             0642*   ; Expects ADL mode
040D8C             0643*   ; Inputs: HL
040D8C             0644*   ; Outputs: DE is the integer square root
040D8C             0645*   ;  HL is the difference inputHL-DE^2
040D8C             0646*   ;  c flag reset
040D8C 01 00 00 00 0647*       ld bc,0 ; clear bcu
040D90 11 00 00 00 0648*       ld de,0 ; clear deu
040D94 AF          0649*       xor a
040D95 45          0650*       ld b,l
040D96 C5          0651*       push bc
040D97 47          0652*       ld b,a
040D98 6F          0653*       ld l,a
040D99             0654*   ; Iteration 1
040D99 29          0655*       add hl,hl
040D9A CB 11       0656*       rl c
040D9C 29          0657*       add hl,hl
040D9D CB 11       0658*       rl c
040D9F 91          0659*       sub c
040DA0 30 04       0660*       jr nc,$+6
040DA2 1C          0661*       inc e
040DA3 1C          0662*       inc e
040DA4 2F          0663*       cpl
040DA5 4F          0664*       ld c,a
040DA6             0665*   ; Iteration 2
040DA6 29          0666*       add hl,hl
040DA7 CB 11       0667*       rl c
040DA9 29          0668*       add hl,hl
040DAA CB 11       0669*       rl c
040DAC CB 13       0670*       rl e
040DAE 7B          0671*       ld a,e
040DAF 91          0672*       sub c
040DB0 30 04       0673*       jr nc,$+6
040DB2 1C          0674*       inc e
040DB3 1C          0675*       inc e
040DB4 2F          0676*       cpl
040DB5 4F          0677*       ld c,a
040DB6             0678*   ; Iteration 3
040DB6 29          0679*       add hl,hl
040DB7 CB 11       0680*       rl c
040DB9 29          0681*       add hl,hl
040DBA CB 11       0682*       rl c
040DBC CB 13       0683*       rl e
040DBE 7B          0684*       ld a,e
040DBF 91          0685*       sub c
040DC0 30 04       0686*       jr nc,$+6
040DC2 1C          0687*       inc e
040DC3 1C          0688*       inc e
040DC4 2F          0689*       cpl
040DC5 4F          0690*       ld c,a
040DC6             0691*   ; Iteration 4
040DC6 29          0692*       add hl,hl
040DC7 CB 11       0693*       rl c
040DC9 29          0694*       add hl,hl
040DCA CB 11       0695*       rl c
040DCC CB 13       0696*       rl e
040DCE 7B          0697*       ld a,e
040DCF 91          0698*       sub c
040DD0 30 04       0699*       jr nc,$+6
040DD2 1C          0700*       inc e
040DD3 1C          0701*       inc e
040DD4 2F          0702*       cpl
040DD5 4F          0703*       ld c,a
040DD6             0704*   ; Iteration 5
040DD6 29          0705*       add hl,hl
040DD7 CB 11       0706*       rl c
040DD9 29          0707*       add hl,hl
040DDA CB 11       0708*       rl c
040DDC CB 13       0709*       rl e
040DDE 7B          0710*       ld a,e
040DDF 91          0711*       sub c
040DE0 30 04       0712*       jr nc,$+6
040DE2 1C          0713*       inc e
040DE3 1C          0714*       inc e
040DE4 2F          0715*       cpl
040DE5 4F          0716*       ld c,a
040DE6             0717*   ; Iteration 6
040DE6 29          0718*       add hl,hl
040DE7 CB 11       0719*       rl c
040DE9 29          0720*       add hl,hl
040DEA CB 11       0721*       rl c
040DEC CB 13       0722*       rl e
040DEE 7B          0723*       ld a,e
040DEF 91          0724*       sub c
040DF0 30 04       0725*       jr nc,$+6
040DF2 1C          0726*       inc e
040DF3 1C          0727*       inc e
040DF4 2F          0728*       cpl
040DF5 4F          0729*       ld c,a
040DF6             0730*   ; Iteration 7
040DF6 29          0731*       add hl,hl
040DF7 CB 11       0732*       rl c
040DF9 29          0733*       add hl,hl
040DFA CB 11       0734*       rl c
040DFC CB 10       0735*       rl b
040DFE EB          0736*       ex de,hl
040DFF 29          0737*       add hl,hl
040E00 E5          0738*       push hl
040E01 ED 42       0739*       sbc hl,bc
040E03 30 06       0740*       jr nc,$+8
040E05 7C          0741*       ld a,h
040E06 2F          0742*       cpl
040E07 47          0743*       ld b,a
040E08 7D          0744*       ld a,l
040E09 2F          0745*       cpl
040E0A 4F          0746*       ld c,a
040E0B E1          0747*       pop hl
040E0C 30 02       0748*       jr nc,$+4
040E0E 23          0749*       inc hl
040E0F 23          0750*       inc hl
040E10 EB          0751*       ex de,hl
040E11             0752*   ; Iteration 8
040E11 29          0753*       add hl,hl
040E12 69          0754*       ld l,c
040E13 60          0755*       ld h,b
040E14 ED 6A       0756*       adc hl,hl
040E16 ED 6A       0757*       adc hl,hl
040E18 EB          0758*       ex de,hl
040E19 29          0759*       add hl,hl
040E1A ED 52       0760*       sbc hl,de
040E1C 19          0761*       add hl,de
040E1D EB          0762*       ex de,hl
040E1E 30 04       0763*       jr nc,$+6
040E20 ED 52       0764*       sbc hl,de
040E22 13          0765*       inc de
040E23 13          0766*       inc de
040E24             0767*   ; Iteration 9
040E24 F1          0768*       pop af
040E25 17          0769*       rla
040E26 ED 6A       0770*       adc hl,hl
040E28 17          0771*       rla
040E29 ED 6A       0772*       adc hl,hl
040E2B EB          0773*       ex de,hl
040E2C 29          0774*       add hl,hl
040E2D ED 52       0775*       sbc hl,de
040E2F 19          0776*       add hl,de
040E30 EB          0777*       ex de,hl
040E31 30 04       0778*       jr nc,$+6
040E33 ED 52       0779*       sbc hl,de
040E35 13          0780*       inc de
040E36 13          0781*       inc de
040E37             0782*   ; Iteration 10
040E37 17          0783*       rla
040E38 ED 6A       0784*       adc hl,hl
040E3A 17          0785*       rla
040E3B ED 6A       0786*       adc hl,hl
040E3D EB          0787*       ex de,hl
040E3E 29          0788*       add hl,hl
040E3F ED 52       0789*       sbc hl,de
040E41 19          0790*       add hl,de
040E42 EB          0791*       ex de,hl
040E43 30 04       0792*       jr nc,$+6
040E45 ED 52       0793*       sbc hl,de
040E47 13          0794*       inc de
040E48 13          0795*       inc de
040E49             0796*   ; Iteration 11
040E49 17          0797*       rla
040E4A ED 6A       0798*       adc hl,hl
040E4C 17          0799*       rla
040E4D ED 6A       0800*       adc hl,hl
040E4F EB          0801*       ex de,hl
040E50 29          0802*       add hl,hl
040E51 ED 52       0803*       sbc hl,de
040E53 19          0804*       add hl,de
040E54 EB          0805*       ex de,hl
040E55 30 04       0806*       jr nc,$+6
040E57 ED 52       0807*       sbc hl,de
040E59 13          0808*       inc de
040E5A 13          0809*       inc de
040E5B             0810*   ; Iteration 12
040E5B 17          0811*       rla
040E5C ED 6A       0812*       adc hl,hl
040E5E 17          0813*       rla
040E5F ED 6A       0814*       adc hl,hl
040E61 EB          0815*       ex de,hl
040E62 29          0816*       add hl,hl
040E63 ED 52       0817*       sbc hl,de
040E65 19          0818*       add hl,de
040E66 EB          0819*       ex de,hl
040E67 30 04       0820*       jr nc,$+6
040E69 ED 52       0821*       sbc hl,de
040E6B 13          0822*       inc de
040E6C 13          0823*       inc de
040E6D CB 1A       0824*       rr d
040E6F CB 1B       0825*       rr e
040E71 C9          0826*       ret
040E72             0827*   
040E72             0828*   sin_lut_168:
040E72 00 00 00    0829*       dl 0x000000 ; 0.000 00, 0.000
040E75 06 00 00    0830*       dl 0x000006 ; 1.406 01, 0.025
040E78 0C 00 00    0831*       dl 0x00000C ; 2.813 02, 0.049
040E7B 12 00 00    0832*       dl 0x000012 ; 4.219 03, 0.074
040E7E 19 00 00    0833*       dl 0x000019 ; 5.625 04, 0.098
040E81 1F 00 00    0834*       dl 0x00001F ; 7.031 05, 0.122
040E84 25 00 00    0835*       dl 0x000025 ; 8.438 06, 0.147
040E87 2B 00 00    0836*       dl 0x00002B ; 9.844 07, 0.171
040E8A 31 00 00    0837*       dl 0x000031 ; 11.250 08, 0.195
040E8D 38 00 00    0838*       dl 0x000038 ; 12.656 09, 0.219
040E90 3E 00 00    0839*       dl 0x00003E ; 14.063 0A, 0.243
040E93 44 00 00    0840*       dl 0x000044 ; 15.469 0B, 0.267
040E96 4A 00 00    0841*       dl 0x00004A ; 16.875 0C, 0.290
040E99 50 00 00    0842*       dl 0x000050 ; 18.281 0D, 0.314
040E9C 56 00 00    0843*       dl 0x000056 ; 19.688 0E, 0.337
040E9F 5C 00 00    0844*       dl 0x00005C ; 21.094 0F, 0.360
040EA2 61 00 00    0845*       dl 0x000061 ; 22.500 10, 0.383
040EA5 67 00 00    0846*       dl 0x000067 ; 23.906 11, 0.405
040EA8 6D 00 00    0847*       dl 0x00006D ; 25.313 12, 0.428
040EAB 73 00 00    0848*       dl 0x000073 ; 26.719 13, 0.450
040EAE 78 00 00    0849*       dl 0x000078 ; 28.125 14, 0.471
040EB1 7E 00 00    0850*       dl 0x00007E ; 29.531 15, 0.493
040EB4 83 00 00    0851*       dl 0x000083 ; 30.938 16, 0.514
040EB7 88 00 00    0852*       dl 0x000088 ; 32.344 17, 0.535
040EBA 8E 00 00    0853*       dl 0x00008E ; 33.750 18, 0.556
040EBD 93 00 00    0854*       dl 0x000093 ; 35.156 19, 0.576
040EC0 98 00 00    0855*       dl 0x000098 ; 36.563 1A, 0.596
040EC3 9D 00 00    0856*       dl 0x00009D ; 37.969 1B, 0.615
040EC6 A2 00 00    0857*       dl 0x0000A2 ; 39.375 1C, 0.634
040EC9 A7 00 00    0858*       dl 0x0000A7 ; 40.781 1D, 0.653
040ECC AB 00 00    0859*       dl 0x0000AB ; 42.188 1E, 0.672
040ECF B0 00 00    0860*       dl 0x0000B0 ; 43.594 1F, 0.690
040ED2 B5 00 00    0861*       dl 0x0000B5 ; 45.000 20, 0.707
040ED5 B9 00 00    0862*       dl 0x0000B9 ; 46.406 21, 0.724
040ED8 BD 00 00    0863*       dl 0x0000BD ; 47.813 22, 0.741
040EDB C1 00 00    0864*       dl 0x0000C1 ; 49.219 23, 0.757
040EDE C5 00 00    0865*       dl 0x0000C5 ; 50.625 24, 0.773
040EE1 C9 00 00    0866*       dl 0x0000C9 ; 52.031 25, 0.788
040EE4 CD 00 00    0867*       dl 0x0000CD ; 53.438 26, 0.803
040EE7 D1 00 00    0868*       dl 0x0000D1 ; 54.844 27, 0.818
040EEA D4 00 00    0869*       dl 0x0000D4 ; 56.250 28, 0.831
040EED D8 00 00    0870*       dl 0x0000D8 ; 57.656 29, 0.845
040EF0 DB 00 00    0871*       dl 0x0000DB ; 59.063 2A, 0.858
040EF3 DE 00 00    0872*       dl 0x0000DE ; 60.469 2B, 0.870
040EF6 E1 00 00    0873*       dl 0x0000E1 ; 61.875 2C, 0.882
040EF9 E4 00 00    0874*       dl 0x0000E4 ; 63.281 2D, 0.893
040EFC E7 00 00    0875*       dl 0x0000E7 ; 64.688 2E, 0.904
040EFF EA 00 00    0876*       dl 0x0000EA ; 66.094 2F, 0.914
040F02 EC 00 00    0877*       dl 0x0000EC ; 67.500 30, 0.924
040F05 EE 00 00    0878*       dl 0x0000EE ; 68.906 31, 0.933
040F08 F1 00 00    0879*       dl 0x0000F1 ; 70.313 32, 0.942
040F0B F3 00 00    0880*       dl 0x0000F3 ; 71.719 33, 0.950
040F0E F4 00 00    0881*       dl 0x0000F4 ; 73.125 34, 0.957
040F11 F6 00 00    0882*       dl 0x0000F6 ; 74.531 35, 0.964
040F14 F8 00 00    0883*       dl 0x0000F8 ; 75.938 36, 0.970
040F17 F9 00 00    0884*       dl 0x0000F9 ; 77.344 37, 0.976
040F1A FB 00 00    0885*       dl 0x0000FB ; 78.750 38, 0.981
040F1D FC 00 00    0886*       dl 0x0000FC ; 80.156 39, 0.985
040F20 FD 00 00    0887*       dl 0x0000FD ; 81.563 3A, 0.989
040F23 FE 00 00    0888*       dl 0x0000FE ; 82.969 3B, 0.992
040F26 FE 00 00    0889*       dl 0x0000FE ; 84.375 3C, 0.995
040F29 FF 00 00    0890*       dl 0x0000FF ; 85.781 3D, 0.997
040F2C FF 00 00    0891*       dl 0x0000FF ; 87.188 3E, 0.999
040F2F FF 00 00    0892*       dl 0x0000FF ; 88.594 3F, 1.000
040F32 00 01 00    0893*       dl 0x000100 ; 90.000 40, 1.000
040F35 FF 00 00    0894*       dl 0x0000FF ; 91.406 41, 1.000
040F38 FF 00 00    0895*       dl 0x0000FF ; 92.813 42, 0.999
040F3B FF 00 00    0896*       dl 0x0000FF ; 94.219 43, 0.997
040F3E FE 00 00    0897*       dl 0x0000FE ; 95.625 44, 0.995
040F41 FE 00 00    0898*       dl 0x0000FE ; 97.031 45, 0.992
040F44 FD 00 00    0899*       dl 0x0000FD ; 98.438 46, 0.989
040F47 FC 00 00    0900*       dl 0x0000FC ; 99.844 47, 0.985
040F4A FB 00 00    0901*       dl 0x0000FB ; 101.250 48, 0.981
040F4D F9 00 00    0902*       dl 0x0000F9 ; 102.656 49, 0.976
040F50 F8 00 00    0903*       dl 0x0000F8 ; 104.063 4A, 0.970
040F53 F6 00 00    0904*       dl 0x0000F6 ; 105.469 4B, 0.964
040F56 F4 00 00    0905*       dl 0x0000F4 ; 106.875 4C, 0.957
040F59 F3 00 00    0906*       dl 0x0000F3 ; 108.281 4D, 0.950
040F5C F1 00 00    0907*       dl 0x0000F1 ; 109.688 4E, 0.942
040F5F EE 00 00    0908*       dl 0x0000EE ; 111.094 4F, 0.933
040F62 EC 00 00    0909*       dl 0x0000EC ; 112.500 50, 0.924
040F65 EA 00 00    0910*       dl 0x0000EA ; 113.906 51, 0.914
040F68 E7 00 00    0911*       dl 0x0000E7 ; 115.313 52, 0.904
040F6B E4 00 00    0912*       dl 0x0000E4 ; 116.719 53, 0.893
040F6E E1 00 00    0913*       dl 0x0000E1 ; 118.125 54, 0.882
040F71 DE 00 00    0914*       dl 0x0000DE ; 119.531 55, 0.870
040F74 DB 00 00    0915*       dl 0x0000DB ; 120.938 56, 0.858
040F77 D8 00 00    0916*       dl 0x0000D8 ; 122.344 57, 0.845
040F7A D4 00 00    0917*       dl 0x0000D4 ; 123.750 58, 0.831
040F7D D1 00 00    0918*       dl 0x0000D1 ; 125.156 59, 0.818
040F80 CD 00 00    0919*       dl 0x0000CD ; 126.563 5A, 0.803
040F83 C9 00 00    0920*       dl 0x0000C9 ; 127.969 5B, 0.788
040F86 C5 00 00    0921*       dl 0x0000C5 ; 129.375 5C, 0.773
040F89 C1 00 00    0922*       dl 0x0000C1 ; 130.781 5D, 0.757
040F8C BD 00 00    0923*       dl 0x0000BD ; 132.188 5E, 0.741
040F8F B9 00 00    0924*       dl 0x0000B9 ; 133.594 5F, 0.724
040F92 B5 00 00    0925*       dl 0x0000B5 ; 135.000 60, 0.707
040F95 B0 00 00    0926*       dl 0x0000B0 ; 136.406 61, 0.690
040F98 AB 00 00    0927*       dl 0x0000AB ; 137.813 62, 0.672
040F9B A7 00 00    0928*       dl 0x0000A7 ; 139.219 63, 0.653
040F9E A2 00 00    0929*       dl 0x0000A2 ; 140.625 64, 0.634
040FA1 9D 00 00    0930*       dl 0x00009D ; 142.031 65, 0.615
040FA4 98 00 00    0931*       dl 0x000098 ; 143.438 66, 0.596
040FA7 93 00 00    0932*       dl 0x000093 ; 144.844 67, 0.576
040FAA 8E 00 00    0933*       dl 0x00008E ; 146.250 68, 0.556
040FAD 88 00 00    0934*       dl 0x000088 ; 147.656 69, 0.535
040FB0 83 00 00    0935*       dl 0x000083 ; 149.063 6A, 0.514
040FB3 7E 00 00    0936*       dl 0x00007E ; 150.469 6B, 0.493
040FB6 78 00 00    0937*       dl 0x000078 ; 151.875 6C, 0.471
040FB9 73 00 00    0938*       dl 0x000073 ; 153.281 6D, 0.450
040FBC 6D 00 00    0939*       dl 0x00006D ; 154.688 6E, 0.428
040FBF 67 00 00    0940*       dl 0x000067 ; 156.094 6F, 0.405
040FC2 61 00 00    0941*       dl 0x000061 ; 157.500 70, 0.383
040FC5 5C 00 00    0942*       dl 0x00005C ; 158.906 71, 0.360
040FC8 56 00 00    0943*       dl 0x000056 ; 160.313 72, 0.337
040FCB 50 00 00    0944*       dl 0x000050 ; 161.719 73, 0.314
040FCE 4A 00 00    0945*       dl 0x00004A ; 163.125 74, 0.290
040FD1 44 00 00    0946*       dl 0x000044 ; 164.531 75, 0.267
040FD4 3E 00 00    0947*       dl 0x00003E ; 165.938 76, 0.243
040FD7 38 00 00    0948*       dl 0x000038 ; 167.344 77, 0.219
040FDA 31 00 00    0949*       dl 0x000031 ; 168.750 78, 0.195
040FDD 2B 00 00    0950*       dl 0x00002B ; 170.156 79, 0.171
040FE0 25 00 00    0951*       dl 0x000025 ; 171.563 7A, 0.147
040FE3 1F 00 00    0952*       dl 0x00001F ; 172.969 7B, 0.122
040FE6 19 00 00    0953*       dl 0x000019 ; 174.375 7C, 0.098
040FE9 12 00 00    0954*       dl 0x000012 ; 175.781 7D, 0.074
040FEC 0C 00 00    0955*       dl 0x00000C ; 177.188 7E, 0.049
040FEF 06 00 00    0956*       dl 0x000006 ; 178.594 7F, 0.025
040FF2 00 00 00    0957*       dl 0x000000 ; 180.000 80, 0.000
040FF5 FA FF FF    0958*       dl 0xFFFFFA ; 181.406 81, -0.025
040FF8 F4 FF FF    0959*       dl 0xFFFFF4 ; 182.813 82, -0.049
040FFB EE FF FF    0960*       dl 0xFFFFEE ; 184.219 83, -0.074
040FFE E7 FF FF    0961*       dl 0xFFFFE7 ; 185.625 84, -0.098
041001 E1 FF FF    0962*       dl 0xFFFFE1 ; 187.031 85, -0.122
041004 DB FF FF    0963*       dl 0xFFFFDB ; 188.438 86, -0.147
041007 D5 FF FF    0964*       dl 0xFFFFD5 ; 189.844 87, -0.171
04100A CF FF FF    0965*       dl 0xFFFFCF ; 191.250 88, -0.195
04100D C8 FF FF    0966*       dl 0xFFFFC8 ; 192.656 89, -0.219
041010 C2 FF FF    0967*       dl 0xFFFFC2 ; 194.063 8A, -0.243
041013 BC FF FF    0968*       dl 0xFFFFBC ; 195.469 8B, -0.267
041016 B6 FF FF    0969*       dl 0xFFFFB6 ; 196.875 8C, -0.290
041019 B0 FF FF    0970*       dl 0xFFFFB0 ; 198.281 8D, -0.314
04101C AA FF FF    0971*       dl 0xFFFFAA ; 199.688 8E, -0.337
04101F A4 FF FF    0972*       dl 0xFFFFA4 ; 201.094 8F, -0.360
041022 9F FF FF    0973*       dl 0xFFFF9F ; 202.500 90, -0.383
041025 99 FF FF    0974*       dl 0xFFFF99 ; 203.906 91, -0.405
041028 93 FF FF    0975*       dl 0xFFFF93 ; 205.313 92, -0.428
04102B 8D FF FF    0976*       dl 0xFFFF8D ; 206.719 93, -0.450
04102E 88 FF FF    0977*       dl 0xFFFF88 ; 208.125 94, -0.471
041031 82 FF FF    0978*       dl 0xFFFF82 ; 209.531 95, -0.493
041034 7D FF FF    0979*       dl 0xFFFF7D ; 210.938 96, -0.514
041037 78 FF FF    0980*       dl 0xFFFF78 ; 212.344 97, -0.535
04103A 72 FF FF    0981*       dl 0xFFFF72 ; 213.750 98, -0.556
04103D 6D FF FF    0982*       dl 0xFFFF6D ; 215.156 99, -0.576
041040 68 FF FF    0983*       dl 0xFFFF68 ; 216.563 9A, -0.596
041043 63 FF FF    0984*       dl 0xFFFF63 ; 217.969 9B, -0.615
041046 5E FF FF    0985*       dl 0xFFFF5E ; 219.375 9C, -0.634
041049 59 FF FF    0986*       dl 0xFFFF59 ; 220.781 9D, -0.653
04104C 55 FF FF    0987*       dl 0xFFFF55 ; 222.188 9E, -0.672
04104F 50 FF FF    0988*       dl 0xFFFF50 ; 223.594 9F, -0.690
041052 4B FF FF    0989*       dl 0xFFFF4B ; 225.000 A0, -0.707
041055 47 FF FF    0990*       dl 0xFFFF47 ; 226.406 A1, -0.724
041058 43 FF FF    0991*       dl 0xFFFF43 ; 227.813 A2, -0.741
04105B 3F FF FF    0992*       dl 0xFFFF3F ; 229.219 A3, -0.757
04105E 3B FF FF    0993*       dl 0xFFFF3B ; 230.625 A4, -0.773
041061 37 FF FF    0994*       dl 0xFFFF37 ; 232.031 A5, -0.788
041064 33 FF FF    0995*       dl 0xFFFF33 ; 233.438 A6, -0.803
041067 2F FF FF    0996*       dl 0xFFFF2F ; 234.844 A7, -0.818
04106A 2C FF FF    0997*       dl 0xFFFF2C ; 236.250 A8, -0.831
04106D 28 FF FF    0998*       dl 0xFFFF28 ; 237.656 A9, -0.845
041070 25 FF FF    0999*       dl 0xFFFF25 ; 239.063 AA, -0.858
041073 22 FF FF    1000*       dl 0xFFFF22 ; 240.469 AB, -0.870
041076 1F FF FF    1001*       dl 0xFFFF1F ; 241.875 AC, -0.882
041079 1C FF FF    1002*       dl 0xFFFF1C ; 243.281 AD, -0.893
04107C 19 FF FF    1003*       dl 0xFFFF19 ; 244.688 AE, -0.904
04107F 16 FF FF    1004*       dl 0xFFFF16 ; 246.094 AF, -0.914
041082 14 FF FF    1005*       dl 0xFFFF14 ; 247.500 B0, -0.924
041085 12 FF FF    1006*       dl 0xFFFF12 ; 248.906 B1, -0.933
041088 0F FF FF    1007*       dl 0xFFFF0F ; 250.313 B2, -0.942
04108B 0D FF FF    1008*       dl 0xFFFF0D ; 251.719 B3, -0.950
04108E 0C FF FF    1009*       dl 0xFFFF0C ; 253.125 B4, -0.957
041091 0A FF FF    1010*       dl 0xFFFF0A ; 254.531 B5, -0.964
041094 08 FF FF    1011*       dl 0xFFFF08 ; 255.938 B6, -0.970
041097 07 FF FF    1012*       dl 0xFFFF07 ; 257.344 B7, -0.976
04109A 05 FF FF    1013*       dl 0xFFFF05 ; 258.750 B8, -0.981
04109D 04 FF FF    1014*       dl 0xFFFF04 ; 260.156 B9, -0.985
0410A0 03 FF FF    1015*       dl 0xFFFF03 ; 261.563 BA, -0.989
0410A3 02 FF FF    1016*       dl 0xFFFF02 ; 262.969 BB, -0.992
0410A6 02 FF FF    1017*       dl 0xFFFF02 ; 264.375 BC, -0.995
0410A9 01 FF FF    1018*       dl 0xFFFF01 ; 265.781 BD, -0.997
0410AC 01 FF FF    1019*       dl 0xFFFF01 ; 267.188 BE, -0.999
0410AF 01 FF FF    1020*       dl 0xFFFF01 ; 268.594 BF, -1.000
0410B2 00 FF FF    1021*       dl 0xFFFF00 ; 270.000 C0, -1.000
0410B5 01 FF FF    1022*       dl 0xFFFF01 ; 271.406 C1, -1.000
0410B8 01 FF FF    1023*       dl 0xFFFF01 ; 272.813 C2, -0.999
0410BB 01 FF FF    1024*       dl 0xFFFF01 ; 274.219 C3, -0.997
0410BE 02 FF FF    1025*       dl 0xFFFF02 ; 275.625 C4, -0.995
0410C1 02 FF FF    1026*       dl 0xFFFF02 ; 277.031 C5, -0.992
0410C4 03 FF FF    1027*       dl 0xFFFF03 ; 278.438 C6, -0.989
0410C7 04 FF FF    1028*       dl 0xFFFF04 ; 279.844 C7, -0.985
0410CA 05 FF FF    1029*       dl 0xFFFF05 ; 281.250 C8, -0.981
0410CD 07 FF FF    1030*       dl 0xFFFF07 ; 282.656 C9, -0.976
0410D0 08 FF FF    1031*       dl 0xFFFF08 ; 284.063 CA, -0.970
0410D3 0A FF FF    1032*       dl 0xFFFF0A ; 285.469 CB, -0.964
0410D6 0C FF FF    1033*       dl 0xFFFF0C ; 286.875 CC, -0.957
0410D9 0D FF FF    1034*       dl 0xFFFF0D ; 288.281 CD, -0.950
0410DC 0F FF FF    1035*       dl 0xFFFF0F ; 289.688 CE, -0.942
0410DF 12 FF FF    1036*       dl 0xFFFF12 ; 291.094 CF, -0.933
0410E2 14 FF FF    1037*       dl 0xFFFF14 ; 292.500 D0, -0.924
0410E5 16 FF FF    1038*       dl 0xFFFF16 ; 293.906 D1, -0.914
0410E8 19 FF FF    1039*       dl 0xFFFF19 ; 295.313 D2, -0.904
0410EB 1C FF FF    1040*       dl 0xFFFF1C ; 296.719 D3, -0.893
0410EE 1F FF FF    1041*       dl 0xFFFF1F ; 298.125 D4, -0.882
0410F1 22 FF FF    1042*       dl 0xFFFF22 ; 299.531 D5, -0.870
0410F4 25 FF FF    1043*       dl 0xFFFF25 ; 300.938 D6, -0.858
0410F7 28 FF FF    1044*       dl 0xFFFF28 ; 302.344 D7, -0.845
0410FA 2C FF FF    1045*       dl 0xFFFF2C ; 303.750 D8, -0.831
0410FD 2F FF FF    1046*       dl 0xFFFF2F ; 305.156 D9, -0.818
041100 33 FF FF    1047*       dl 0xFFFF33 ; 306.563 DA, -0.803
041103 37 FF FF    1048*       dl 0xFFFF37 ; 307.969 DB, -0.788
041106 3B FF FF    1049*       dl 0xFFFF3B ; 309.375 DC, -0.773
041109 3F FF FF    1050*       dl 0xFFFF3F ; 310.781 DD, -0.757
04110C 43 FF FF    1051*       dl 0xFFFF43 ; 312.188 DE, -0.741
04110F 47 FF FF    1052*       dl 0xFFFF47 ; 313.594 DF, -0.724
041112 4B FF FF    1053*       dl 0xFFFF4B ; 315.000 E0, -0.707
041115 50 FF FF    1054*       dl 0xFFFF50 ; 316.406 E1, -0.690
041118 55 FF FF    1055*       dl 0xFFFF55 ; 317.813 E2, -0.672
04111B 59 FF FF    1056*       dl 0xFFFF59 ; 319.219 E3, -0.653
04111E 5E FF FF    1057*       dl 0xFFFF5E ; 320.625 E4, -0.634
041121 63 FF FF    1058*       dl 0xFFFF63 ; 322.031 E5, -0.615
041124 68 FF FF    1059*       dl 0xFFFF68 ; 323.438 E6, -0.596
041127 6D FF FF    1060*       dl 0xFFFF6D ; 324.844 E7, -0.576
04112A 72 FF FF    1061*       dl 0xFFFF72 ; 326.250 E8, -0.556
04112D 78 FF FF    1062*       dl 0xFFFF78 ; 327.656 E9, -0.535
041130 7D FF FF    1063*       dl 0xFFFF7D ; 329.063 EA, -0.514
041133 82 FF FF    1064*       dl 0xFFFF82 ; 330.469 EB, -0.493
041136 88 FF FF    1065*       dl 0xFFFF88 ; 331.875 EC, -0.471
041139 8D FF FF    1066*       dl 0xFFFF8D ; 333.281 ED, -0.450
04113C 93 FF FF    1067*       dl 0xFFFF93 ; 334.688 EE, -0.428
04113F 99 FF FF    1068*       dl 0xFFFF99 ; 336.094 EF, -0.405
041142 9F FF FF    1069*       dl 0xFFFF9F ; 337.500 F0, -0.383
041145 A4 FF FF    1070*       dl 0xFFFFA4 ; 338.906 F1, -0.360
041148 AA FF FF    1071*       dl 0xFFFFAA ; 340.313 F2, -0.337
04114B B0 FF FF    1072*       dl 0xFFFFB0 ; 341.719 F3, -0.314
04114E B6 FF FF    1073*       dl 0xFFFFB6 ; 343.125 F4, -0.290
041151 BC FF FF    1074*       dl 0xFFFFBC ; 344.531 F5, -0.267
041154 C2 FF FF    1075*       dl 0xFFFFC2 ; 345.938 F6, -0.243
041157 C8 FF FF    1076*       dl 0xFFFFC8 ; 347.344 F7, -0.219
04115A CF FF FF    1077*       dl 0xFFFFCF ; 348.750 F8, -0.195
04115D D5 FF FF    1078*       dl 0xFFFFD5 ; 350.156 F9, -0.171
041160 DB FF FF    1079*       dl 0xFFFFDB ; 351.563 FA, -0.147
041163 E1 FF FF    1080*       dl 0xFFFFE1 ; 352.969 FB, -0.122
041166 E7 FF FF    1081*       dl 0xFFFFE7 ; 354.375 FC, -0.098
041169 EE FF FF    1082*       dl 0xFFFFEE ; 355.781 FD, -0.074
04116C F4 FF FF    1083*       dl 0xFFFFF4 ; 357.188 FE, -0.049
04116F FA FF FF    1084*       dl 0xFFFFFA ; 358.594 FF, -0.025
041172 00 00 00    1085*       dl 0x000000 ; 0.000 00, 0.000 for interpolation
041175             1086*   
041175             1087*   atan_lut_168:
041175 00 00 00    1088*       dl 0x000000 ; 000000, 0.000
041178 28 00 00    1089*       dl 0x000028 ; 000001, 0.224
04117B 51 00 00    1090*       dl 0x000051 ; 000002, 0.448
04117E 7A 00 00    1091*       dl 0x00007A ; 000003, 0.671
041181 A2 00 00    1092*       dl 0x0000A2 ; 000004, 0.895
041184 CB 00 00    1093*       dl 0x0000CB ; 000005, 1.119
041187 F4 00 00    1094*       dl 0x0000F4 ; 000006, 1.343
04118A 1D 01 00    1095*       dl 0x00011D ; 000007, 1.566
04118D 45 01 00    1096*       dl 0x000145 ; 000008, 1.790
041190 6E 01 00    1097*       dl 0x00016E ; 000009, 2.013
041193 97 01 00    1098*       dl 0x000197 ; 00000A, 2.237
041196 BF 01 00    1099*       dl 0x0001BF ; 00000B, 2.460
041199 E8 01 00    1100*       dl 0x0001E8 ; 00000C, 2.684
04119C 11 02 00    1101*       dl 0x000211 ; 00000D, 2.907
04119F 39 02 00    1102*       dl 0x000239 ; 00000E, 3.130
0411A2 62 02 00    1103*       dl 0x000262 ; 00000F, 3.353
0411A5 8B 02 00    1104*       dl 0x00028B ; 000010, 3.576
0411A8 B3 02 00    1105*       dl 0x0002B3 ; 000011, 3.799
0411AB DC 02 00    1106*       dl 0x0002DC ; 000012, 4.022
0411AE 04 03 00    1107*       dl 0x000304 ; 000013, 4.245
0411B1 2D 03 00    1108*       dl 0x00032D ; 000014, 4.467
0411B4 55 03 00    1109*       dl 0x000355 ; 000015, 4.690
0411B7 7E 03 00    1110*       dl 0x00037E ; 000016, 4.912
0411BA A6 03 00    1111*       dl 0x0003A6 ; 000017, 5.134
0411BD CE 03 00    1112*       dl 0x0003CE ; 000018, 5.356
0411C0 F7 03 00    1113*       dl 0x0003F7 ; 000019, 5.578
0411C3 1F 04 00    1114*       dl 0x00041F ; 00001A, 5.799
0411C6 48 04 00    1115*       dl 0x000448 ; 00001B, 6.021
0411C9 70 04 00    1116*       dl 0x000470 ; 00001C, 6.242
0411CC 98 04 00    1117*       dl 0x000498 ; 00001D, 6.463
0411CF C0 04 00    1118*       dl 0x0004C0 ; 00001E, 6.684
0411D2 E8 04 00    1119*       dl 0x0004E8 ; 00001F, 6.905
0411D5 11 05 00    1120*       dl 0x000511 ; 000020, 7.125
0411D8 39 05 00    1121*       dl 0x000539 ; 000021, 7.345
0411DB 61 05 00    1122*       dl 0x000561 ; 000022, 7.565
0411DE 89 05 00    1123*       dl 0x000589 ; 000023, 7.785
0411E1 B1 05 00    1124*       dl 0x0005B1 ; 000024, 8.005
0411E4 D9 05 00    1125*       dl 0x0005D9 ; 000025, 8.224
0411E7 01 06 00    1126*       dl 0x000601 ; 000026, 8.443
0411EA 28 06 00    1127*       dl 0x000628 ; 000027, 8.662
0411ED 50 06 00    1128*       dl 0x000650 ; 000028, 8.881
0411F0 78 06 00    1129*       dl 0x000678 ; 000029, 9.099
0411F3 A0 06 00    1130*       dl 0x0006A0 ; 00002A, 9.317
0411F6 C7 06 00    1131*       dl 0x0006C7 ; 00002B, 9.535
0411F9 EF 06 00    1132*       dl 0x0006EF ; 00002C, 9.752
0411FC 16 07 00    1133*       dl 0x000716 ; 00002D, 9.970
0411FF 3E 07 00    1134*       dl 0x00073E ; 00002E, 10.187
041202 65 07 00    1135*       dl 0x000765 ; 00002F, 10.403
041205 8D 07 00    1136*       dl 0x00078D ; 000030, 10.620
041208 B4 07 00    1137*       dl 0x0007B4 ; 000031, 10.836
04120B DB 07 00    1138*       dl 0x0007DB ; 000032, 11.051
04120E 03 08 00    1139*       dl 0x000803 ; 000033, 11.267
041211 2A 08 00    1140*       dl 0x00082A ; 000034, 11.482
041214 51 08 00    1141*       dl 0x000851 ; 000035, 11.697
041217 78 08 00    1142*       dl 0x000878 ; 000036, 11.911
04121A 9F 08 00    1143*       dl 0x00089F ; 000037, 12.125
04121D C6 08 00    1144*       dl 0x0008C6 ; 000038, 12.339
041220 ED 08 00    1145*       dl 0x0008ED ; 000039, 12.553
041223 13 09 00    1146*       dl 0x000913 ; 00003A, 12.766
041226 3A 09 00    1147*       dl 0x00093A ; 00003B, 12.978
041229 61 09 00    1148*       dl 0x000961 ; 00003C, 13.191
04122C 87 09 00    1149*       dl 0x000987 ; 00003D, 13.403
04122F AE 09 00    1150*       dl 0x0009AE ; 00003E, 13.614
041232 D4 09 00    1151*       dl 0x0009D4 ; 00003F, 13.825
041235 FB 09 00    1152*       dl 0x0009FB ; 000040, 14.036
041238 21 0A 00    1153*       dl 0x000A21 ; 000041, 14.247
04123B 47 0A 00    1154*       dl 0x000A47 ; 000042, 14.457
04123E 6D 0A 00    1155*       dl 0x000A6D ; 000043, 14.666
041241 94 0A 00    1156*       dl 0x000A94 ; 000044, 14.876
041244 BA 0A 00    1157*       dl 0x000ABA ; 000045, 15.085
041247 E0 0A 00    1158*       dl 0x000AE0 ; 000046, 15.293
04124A 05 0B 00    1159*       dl 0x000B05 ; 000047, 15.501
04124D 2B 0B 00    1160*       dl 0x000B2B ; 000048, 15.709
041250 51 0B 00    1161*       dl 0x000B51 ; 000049, 15.916
041253 77 0B 00    1162*       dl 0x000B77 ; 00004A, 16.123
041256 9C 0B 00    1163*       dl 0x000B9C ; 00004B, 16.329
041259 C2 0B 00    1164*       dl 0x000BC2 ; 00004C, 16.535
04125C E7 0B 00    1165*       dl 0x000BE7 ; 00004D, 16.740
04125F 0C 0C 00    1166*       dl 0x000C0C ; 00004E, 16.945
041262 32 0C 00    1167*       dl 0x000C32 ; 00004F, 17.150
041265 57 0C 00    1168*       dl 0x000C57 ; 000050, 17.354
041268 7C 0C 00    1169*       dl 0x000C7C ; 000051, 17.558
04126B A1 0C 00    1170*       dl 0x000CA1 ; 000052, 17.761
04126E C6 0C 00    1171*       dl 0x000CC6 ; 000053, 17.964
041271 EB 0C 00    1172*       dl 0x000CEB ; 000054, 18.166
041274 0F 0D 00    1173*       dl 0x000D0F ; 000055, 18.368
041277 34 0D 00    1174*       dl 0x000D34 ; 000056, 18.569
04127A 58 0D 00    1175*       dl 0x000D58 ; 000057, 18.770
04127D 7D 0D 00    1176*       dl 0x000D7D ; 000058, 18.970
041280 A1 0D 00    1177*       dl 0x000DA1 ; 000059, 19.170
041283 C6 0D 00    1178*       dl 0x000DC6 ; 00005A, 19.370
041286 EA 0D 00    1179*       dl 0x000DEA ; 00005B, 19.569
041289 0E 0E 00    1180*       dl 0x000E0E ; 00005C, 19.767
04128C 32 0E 00    1181*       dl 0x000E32 ; 00005D, 19.965
04128F 56 0E 00    1182*       dl 0x000E56 ; 00005E, 20.163
041292 7A 0E 00    1183*       dl 0x000E7A ; 00005F, 20.360
041295 9E 0E 00    1184*       dl 0x000E9E ; 000060, 20.556
041298 C1 0E 00    1185*       dl 0x000EC1 ; 000061, 20.752
04129B E5 0E 00    1186*       dl 0x000EE5 ; 000062, 20.947
04129E 08 0F 00    1187*       dl 0x000F08 ; 000063, 21.142
0412A1 2C 0F 00    1188*       dl 0x000F2C ; 000064, 21.337
0412A4 4F 0F 00    1189*       dl 0x000F4F ; 000065, 21.531
0412A7 72 0F 00    1190*       dl 0x000F72 ; 000066, 21.724
0412AA 95 0F 00    1191*       dl 0x000F95 ; 000067, 21.917
0412AD B8 0F 00    1192*       dl 0x000FB8 ; 000068, 22.109
0412B0 DB 0F 00    1193*       dl 0x000FDB ; 000069, 22.301
0412B3 FE 0F 00    1194*       dl 0x000FFE ; 00006A, 22.493
0412B6 21 10 00    1195*       dl 0x001021 ; 00006B, 22.683
0412B9 44 10 00    1196*       dl 0x001044 ; 00006C, 22.874
0412BC 66 10 00    1197*       dl 0x001066 ; 00006D, 23.063
0412BF 89 10 00    1198*       dl 0x001089 ; 00006E, 23.253
0412C2 AB 10 00    1199*       dl 0x0010AB ; 00006F, 23.441
0412C5 CD 10 00    1200*       dl 0x0010CD ; 000070, 23.629
0412C8 EF 10 00    1201*       dl 0x0010EF ; 000071, 23.817
0412CB 11 11 00    1202*       dl 0x001111 ; 000072, 24.004
0412CE 33 11 00    1203*       dl 0x001133 ; 000073, 24.191
0412D1 55 11 00    1204*       dl 0x001155 ; 000074, 24.376
0412D4 77 11 00    1205*       dl 0x001177 ; 000075, 24.562
0412D7 99 11 00    1206*       dl 0x001199 ; 000076, 24.747
0412DA BA 11 00    1207*       dl 0x0011BA ; 000077, 24.931
0412DD DC 11 00    1208*       dl 0x0011DC ; 000078, 25.115
0412E0 FD 11 00    1209*       dl 0x0011FD ; 000079, 25.298
0412E3 1E 12 00    1210*       dl 0x00121E ; 00007A, 25.481
0412E6 3F 12 00    1211*       dl 0x00123F ; 00007B, 25.663
0412E9 60 12 00    1212*       dl 0x001260 ; 00007C, 25.844
0412EC 81 12 00    1213*       dl 0x001281 ; 00007D, 26.025
0412EF A2 12 00    1214*       dl 0x0012A2 ; 00007E, 26.206
0412F2 C3 12 00    1215*       dl 0x0012C3 ; 00007F, 26.386
0412F5 E4 12 00    1216*       dl 0x0012E4 ; 000080, 26.565
0412F8 04 13 00    1217*       dl 0x001304 ; 000081, 26.744
0412FB 25 13 00    1218*       dl 0x001325 ; 000082, 26.922
0412FE 45 13 00    1219*       dl 0x001345 ; 000083, 27.100
041301 65 13 00    1220*       dl 0x001365 ; 000084, 27.277
041304 85 13 00    1221*       dl 0x001385 ; 000085, 27.453
041307 A5 13 00    1222*       dl 0x0013A5 ; 000086, 27.629
04130A C5 13 00    1223*       dl 0x0013C5 ; 000087, 27.805
04130D E5 13 00    1224*       dl 0x0013E5 ; 000088, 27.979
041310 05 14 00    1225*       dl 0x001405 ; 000089, 28.154
041313 24 14 00    1226*       dl 0x001424 ; 00008A, 28.327
041316 44 14 00    1227*       dl 0x001444 ; 00008B, 28.501
041319 63 14 00    1228*       dl 0x001463 ; 00008C, 28.673
04131C 83 14 00    1229*       dl 0x001483 ; 00008D, 28.845
04131F A2 14 00    1230*       dl 0x0014A2 ; 00008E, 29.017
041322 C1 14 00    1231*       dl 0x0014C1 ; 00008F, 29.187
041325 E0 14 00    1232*       dl 0x0014E0 ; 000090, 29.358
041328 FF 14 00    1233*       dl 0x0014FF ; 000091, 29.527
04132B 1E 15 00    1234*       dl 0x00151E ; 000092, 29.697
04132E 3C 15 00    1235*       dl 0x00153C ; 000093, 29.865
041331 5B 15 00    1236*       dl 0x00155B ; 000094, 30.033
041334 79 15 00    1237*       dl 0x001579 ; 000095, 30.201
041337 98 15 00    1238*       dl 0x001598 ; 000096, 30.368
04133A B6 15 00    1239*       dl 0x0015B6 ; 000097, 30.534
04133D D4 15 00    1240*       dl 0x0015D4 ; 000098, 30.700
041340 F2 15 00    1241*       dl 0x0015F2 ; 000099, 30.865
041343 10 16 00    1242*       dl 0x001610 ; 00009A, 31.030
041346 2E 16 00    1243*       dl 0x00162E ; 00009B, 31.194
041349 4C 16 00    1244*       dl 0x00164C ; 00009C, 31.357
04134C 6A 16 00    1245*       dl 0x00166A ; 00009D, 31.520
04134F 87 16 00    1246*       dl 0x001687 ; 00009E, 31.682
041352 A5 16 00    1247*       dl 0x0016A5 ; 00009F, 31.844
041355 C2 16 00    1248*       dl 0x0016C2 ; 0000A0, 32.005
041358 DF 16 00    1249*       dl 0x0016DF ; 0000A1, 32.166
04135B FC 16 00    1250*       dl 0x0016FC ; 0000A2, 32.326
04135E 19 17 00    1251*       dl 0x001719 ; 0000A3, 32.486
041361 36 17 00    1252*       dl 0x001736 ; 0000A4, 32.645
041364 53 17 00    1253*       dl 0x001753 ; 0000A5, 32.803
041367 70 17 00    1254*       dl 0x001770 ; 0000A6, 32.961
04136A 8C 17 00    1255*       dl 0x00178C ; 0000A7, 33.118
04136D A9 17 00    1256*       dl 0x0017A9 ; 0000A8, 33.275
041370 C5 17 00    1257*       dl 0x0017C5 ; 0000A9, 33.431
041373 E2 17 00    1258*       dl 0x0017E2 ; 0000AA, 33.587
041376 FE 17 00    1259*       dl 0x0017FE ; 0000AB, 33.742
041379 1A 18 00    1260*       dl 0x00181A ; 0000AC, 33.896
04137C 36 18 00    1261*       dl 0x001836 ; 0000AD, 34.050
04137F 52 18 00    1262*       dl 0x001852 ; 0000AE, 34.203
041382 6E 18 00    1263*       dl 0x00186E ; 0000AF, 34.356
041385 8A 18 00    1264*       dl 0x00188A ; 0000B0, 34.509
041388 A5 18 00    1265*       dl 0x0018A5 ; 0000B1, 34.660
04138B C1 18 00    1266*       dl 0x0018C1 ; 0000B2, 34.811
04138E DC 18 00    1267*       dl 0x0018DC ; 0000B3, 34.962
041391 F7 18 00    1268*       dl 0x0018F7 ; 0000B4, 35.112
041394 13 19 00    1269*       dl 0x001913 ; 0000B5, 35.262
041397 2E 19 00    1270*       dl 0x00192E ; 0000B6, 35.410
04139A 49 19 00    1271*       dl 0x001949 ; 0000B7, 35.559
04139D 64 19 00    1272*       dl 0x001964 ; 0000B8, 35.707
0413A0 7F 19 00    1273*       dl 0x00197F ; 0000B9, 35.854
0413A3 99 19 00    1274*       dl 0x001999 ; 0000BA, 36.001
0413A6 B4 19 00    1275*       dl 0x0019B4 ; 0000BB, 36.147
0413A9 CE 19 00    1276*       dl 0x0019CE ; 0000BC, 36.293
0413AC E9 19 00    1277*       dl 0x0019E9 ; 0000BD, 36.438
0413AF 03 1A 00    1278*       dl 0x001A03 ; 0000BE, 36.582
0413B2 1D 1A 00    1279*       dl 0x001A1D ; 0000BF, 36.726
0413B5 37 1A 00    1280*       dl 0x001A37 ; 0000C0, 36.870
0413B8 51 1A 00    1281*       dl 0x001A51 ; 0000C1, 37.013
0413BB 6B 1A 00    1282*       dl 0x001A6B ; 0000C2, 37.155
0413BE 85 1A 00    1283*       dl 0x001A85 ; 0000C3, 37.297
0413C1 9F 1A 00    1284*       dl 0x001A9F ; 0000C4, 37.439
0413C4 B9 1A 00    1285*       dl 0x001AB9 ; 0000C5, 37.579
0413C7 D2 1A 00    1286*       dl 0x001AD2 ; 0000C6, 37.720
0413CA EC 1A 00    1287*       dl 0x001AEC ; 0000C7, 37.859
0413CD 05 1B 00    1288*       dl 0x001B05 ; 0000C8, 37.999
0413D0 1E 1B 00    1289*       dl 0x001B1E ; 0000C9, 38.137
0413D3 37 1B 00    1290*       dl 0x001B37 ; 0000CA, 38.276
0413D6 50 1B 00    1291*       dl 0x001B50 ; 0000CB, 38.413
0413D9 69 1B 00    1292*       dl 0x001B69 ; 0000CC, 38.550
0413DC 82 1B 00    1293*       dl 0x001B82 ; 0000CD, 38.687
0413DF 9B 1B 00    1294*       dl 0x001B9B ; 0000CE, 38.823
0413E2 B4 1B 00    1295*       dl 0x001BB4 ; 0000CF, 38.959
0413E5 CC 1B 00    1296*       dl 0x001BCC ; 0000D0, 39.094
0413E8 E5 1B 00    1297*       dl 0x001BE5 ; 0000D1, 39.228
0413EB FD 1B 00    1298*       dl 0x001BFD ; 0000D2, 39.362
0413EE 16 1C 00    1299*       dl 0x001C16 ; 0000D3, 39.496
0413F1 2E 1C 00    1300*       dl 0x001C2E ; 0000D4, 39.629
0413F4 46 1C 00    1301*       dl 0x001C46 ; 0000D5, 39.762
0413F7 5E 1C 00    1302*       dl 0x001C5E ; 0000D6, 39.894
0413FA 76 1C 00    1303*       dl 0x001C76 ; 0000D7, 40.025
0413FD 8E 1C 00    1304*       dl 0x001C8E ; 0000D8, 40.156
041400 A5 1C 00    1305*       dl 0x001CA5 ; 0000D9, 40.286
041403 BD 1C 00    1306*       dl 0x001CBD ; 0000DA, 40.416
041406 D5 1C 00    1307*       dl 0x001CD5 ; 0000DB, 40.546
041409 EC 1C 00    1308*       dl 0x001CEC ; 0000DC, 40.675
04140C 04 1D 00    1309*       dl 0x001D04 ; 0000DD, 40.803
04140F 1B 1D 00    1310*       dl 0x001D1B ; 0000DE, 40.931
041412 32 1D 00    1311*       dl 0x001D32 ; 0000DF, 41.059
041415 49 1D 00    1312*       dl 0x001D49 ; 0000E0, 41.186
041418 60 1D 00    1313*       dl 0x001D60 ; 0000E1, 41.312
04141B 77 1D 00    1314*       dl 0x001D77 ; 0000E2, 41.438
04141E 8E 1D 00    1315*       dl 0x001D8E ; 0000E3, 41.564
041421 A5 1D 00    1316*       dl 0x001DA5 ; 0000E4, 41.689
041424 BB 1D 00    1317*       dl 0x001DBB ; 0000E5, 41.814
041427 D2 1D 00    1318*       dl 0x001DD2 ; 0000E6, 41.938
04142A E9 1D 00    1319*       dl 0x001DE9 ; 0000E7, 42.061
04142D FF 1D 00    1320*       dl 0x001DFF ; 0000E8, 42.184
041430 15 1E 00    1321*       dl 0x001E15 ; 0000E9, 42.307
041433 2C 1E 00    1322*       dl 0x001E2C ; 0000EA, 42.429
041436 42 1E 00    1323*       dl 0x001E42 ; 0000EB, 42.551
041439 58 1E 00    1324*       dl 0x001E58 ; 0000EC, 42.672
04143C 6E 1E 00    1325*       dl 0x001E6E ; 0000ED, 42.793
04143F 84 1E 00    1326*       dl 0x001E84 ; 0000EE, 42.913
041442 99 1E 00    1327*       dl 0x001E99 ; 0000EF, 43.033
041445 AF 1E 00    1328*       dl 0x001EAF ; 0000F0, 43.152
041448 C5 1E 00    1329*       dl 0x001EC5 ; 0000F1, 43.271
04144B DA 1E 00    1330*       dl 0x001EDA ; 0000F2, 43.390
04144E F0 1E 00    1331*       dl 0x001EF0 ; 0000F3, 43.508
041451 05 1F 00    1332*       dl 0x001F05 ; 0000F4, 43.625
041454 1B 1F 00    1333*       dl 0x001F1B ; 0000F5, 43.742
041457 30 1F 00    1334*       dl 0x001F30 ; 0000F6, 43.859
04145A 45 1F 00    1335*       dl 0x001F45 ; 0000F7, 43.975
04145D 5A 1F 00    1336*       dl 0x001F5A ; 0000F8, 44.091
041460 6F 1F 00    1337*       dl 0x001F6F ; 0000F9, 44.206
041463 84 1F 00    1338*       dl 0x001F84 ; 0000FA, 44.321
041466 99 1F 00    1339*       dl 0x001F99 ; 0000FB, 44.435
041469 AD 1F 00    1340*       dl 0x001FAD ; 0000FC, 44.549
04146C C2 1F 00    1341*       dl 0x001FC2 ; 0000FD, 44.662
04146F D7 1F 00    1342*       dl 0x001FD7 ; 0000FE, 44.775
041472 EB 1F 00    1343*       dl 0x001FEB ; 0000FF, 44.888
041475 00 20 00    1344*       dl 0x002000 ; 000100, 45.000 only needed for interpolation
041478             0038        include "timer.inc"
041478             0001*   ; Table 32. Timer Control Registers
041478             0002*   TMR0_CTL: equ 80h
041478             0003*   TMR1_CTL: equ 83h
041478             0004*   TMR2_CTL: equ 86h
041478             0005*   TMR3_CTL: equ 89h
041478             0006*   TMR4_CTL: equ 8Ch
041478             0007*   TMR5_CTL: equ 8Fh
041478             0008*   
041478             0009*   ; each timer register takes three bytes:
041478             0010*   ;   0: control register
041478             0011*   ;   1: low byte of timer reset value
041478             0012*   ;   2: high byte of timer reset value
041478             0013*   ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
041478             0014*   ; which correctly force the high and upper bytes of the address bus to zero
041478             0015*   
041478             0016*   TMR_REG_CTL: equ 0
041478             0017*   TMR_RES_LOW: equ 1
041478             0018*   TMR_RES_HIGH: equ 2
041478             0019*   
041478             0020*   ; Timer Control Register Bit Definitions
041478             0021*   PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
041478             0022*                               ; This bit is reset to 0 every time the TMRx_CTL register is read.
041478             0023*   PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
041478             0024*                               ; an interrupt signal is sent to the CPU. This bit remains 1 until
041478             0025*                               ; the TMRx_CTL register is read.
041478             0026*   
041478             0027*   IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
041478             0028*   IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
041478             0029*   
041478             0030*   PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
041478             0031*                               ;  0,and counting stops when the end-of-count value is reached.
041478             0032*   PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
041478             0033*                               ; written to the counter when the end-of-count value is reached.
041478             0034*   
041478             0035*   ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
041478             0036*   CLK_DIV_256:  equ %00001100 ;
041478             0037*   CLK_DIV_64:   equ %00001000 ;
041478             0038*   CLK_DIV_16:   equ %00000100 ;
041478             0039*   CLK_DIV_4:    equ %00000000 ;
041478             0040*   
041478             0041*   RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
041478             0042*   RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
041478             0043*                               ; When a 1 is written to this bit,the values in the reload registers
041478             0044*                               ;  are loaded into the downcounter when the timer restarts. The
041478             0045*                               ; programmer must ensure that this bit is set to 1 each time
041478             0046*                               ; SINGLE-PASS mode is used.
041478             0047*   
041478             0048*   ; disable/enable the programmable reload timer
041478             0049*   PRT_EN_0:     equ %00000000 ;
041478             0050*   PRT_EN_1:     equ %00000001 ;
041478             0051*   
041478             0052*   ; Table 37. Timer Input Source Select Register
041478             0053*   ; Each of the 4 timers are allocated two bits of the 8-bit register
041478             0054*   ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
041478             0055*   ;   00: System clock / CLK_DIV
041478             0056*   ;   01: RTC / CLK_DIV
041478             0057*   ;   NOTE: these are the values given in the manual,but it may be a typo
041478             0058*   ;   10: GPIO port B pin 1.
041478             0059*   ;   11: GPIO port B pin 1.
041478             0060*   TMR_ISS:   equ 92h ; register address
041478             0061*   
041478             0062*   ; Table 51. Real-Time Clock Control Register
041478             0063*   RTC_CTRL: equ EDh ; register address
041478             0064*   
041478             0065*   ; alarm interrupt disable/enable
041478             0066*   RTC_ALARM_0:    equ %00000000
041478             0067*   RTC_ALARM_1:    equ %10000000
041478             0068*   
041478             0069*   ; interrupt on alarm disable/enable
041478             0070*   RTC_INT_ENT_0:  equ %00000000
041478             0071*   RTC_INT_ENT_1:  equ %01000000
041478             0072*   
041478             0073*   RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
041478             0074*   RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
041478             0075*   
041478             0076*   RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
041478             0077*                                   ; On-chip 32768 Hz oscillator is enabled.
041478             0078*   RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
041478             0079*                                   ; On-chip 32768 Hz oscillator is disabled.
041478             0080*   
041478             0081*   RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
041478             0082*   RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
041478             0083*   
041478             0084*   RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
041478             0085*   RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
041478             0086*   
041478             0087*   RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
041478             0088*                                   ; RTC counter is enabled.
041478             0089*   RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
041478             0090*                                   ; RTC counter is disabled.
041478             0091*   
041478             0092*   ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
041478             0093*   
041478             0094*   prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
041478             0095*   prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
041478 00 00 00    0096*   prt_reload: dl 0x000000
04147B             0097*   
04147B             0098*   ; returns: a = 0 if running on hardware,1 if running on emulator
04147B             0099*   ;          de = number PRT interrupts during test interval
04147B             0100*   prt_calibrate:
04147B CD 4A 17 04 0101*       call vdu_vblank
04147F             0102*   ; set a MOS timer
04147F 21 78 00 00 0103*       ld hl,120*1 ; 1 second
041483 FD 21 03 16 0104*       ld iy,tmr_test
       04          
041488 CD E1 15 04 0105*       call tmr_set
04148C             0106*   ; set a PRT timer
04148C             0107*       ; ld hl,prt_reload_hardware
04148C             0108*       ; ld hl,prt_reload_emulator
04148C 21 05 2D 00 0109*       ld hl,prt_reload_emulator + prt_reload_hardware / 2
041490 22 78 14 04 0110*       ld (prt_reload),hl
041494 CD 1C 15 04 0111*       call prt_set
041498             0112*   @loop:
041498             0113*   ; check time remaining on MOS timer
041498 CD EF 15 04 0114*       call tmr_get
04149C CA A6 14 04 0115*       jp z,@done ; time expired,so quit
0414A0 FA A6 14 04 0116*       jp m,@done ; time past expiration (negative),so quit
0414A4 18 F2       0117*       jr @loop
0414A6             0118*   @done:
0414A6 ED 5B 6A 15 0119*       ld de,(prt_irq_counter)
       04          
0414AB 01 0C 2D 00 0120*       ld bc,prt_reload_hardware ; default value for running on hardware
0414AF ED 43 78 14 0121*       ld (prt_reload),bc
       04          
0414B4 21 64 00 00 0122*       ld hl,100 ; halfway between 101 for real hardware and 99 for emulator
0414B8 AF          0123*       xor a ; clear carry,zero is default value for running on hardware
0414B9 32 DB 14 04 0124*       ld (is_emulator),a
0414BD ED 52       0125*       sbc hl,de
0414BF 21 DC 14 04 0126*       ld hl,on_hardware ; default message for running on hardware
0414C3 CA 7B 14 04 0127*       jp z,prt_calibrate ; zero result is indeterminate so we try again
0414C7 F8          0128*       ret m ; negative result means we're on hardware
0414C8 3C          0129*       inc a ; we're on emulator
0414C9 32 DB 14 04 0130*       ld (is_emulator),a
0414CD 01 FF 2C 00 0131*       ld bc,prt_reload_emulator
0414D1 ED 43 78 14 0132*       ld (prt_reload),bc
       04          
0414D6 21 F2 14 04 0133*       ld hl,on_emulator
0414DA C9          0134*       ret
0414DB 00          0135*   is_emulator: db 0
0414DC 52 75 6E 6E 0136*   on_hardware: defb "Running on hardware\r\n",0
       69 6E 67 20 
       6F 6E 20 68 
       61 72 64 77 
       61 72 65 0D 
       0A 00       
0414F2 52 75 6E 6E 0137*   on_emulator: defb "Running on emulator\r\n",0
       69 6E 67 20 
       6F 6E 20 65 
       6D 75 6C 61 
       74 6F 72 0D 
       0A 00       
041508             0138*   
041508 43 61 6C 69 0139*   calibrating_timer: defb "Calibrating timer\r\n",0
       62 72 61 74 
       69 6E 67 20 
       74 69 6D 65 
       72 0D 0A 00 
04151C             0140*   
04151C             0141*   ; set PRT timer
04151C             0142*   prt_set:
04151C 21 00 00 00 0143*       ld hl,0
041520 22 6A 15 04 0144*       ld (prt_irq_counter),hl
041524 2A 78 14 04 0145*       ld hl,(prt_reload)
041528 ED 29 84    0146*       out0 (TMR1_CTL+TMR_RES_LOW),l
04152B ED 21 85    0147*   	out0 (TMR1_CTL+TMR_RES_HIGH),h
04152E             0148*   ; disable timer
04152E 3E 06       0149*       ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
041530 ED 39 83    0150*   	out0 (TMR1_CTL+TMR_REG_CTL),a
041533             0151*   ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
041533 3E 57       0152*       ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
041535 ED 39 83    0153*   	out0 (TMR1_CTL+TMR_REG_CTL),a
041538 C9          0154*       ret
041539             0155*   
041539             0156*   ; ===============================================
041539             0157*   ; PRT Timer Interrupt Handling
041539             0158*   ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.asm
041539             0159*   ; -----------------------------------------------
041539             0160*   prt_irq_init:
041539             0161*       ; set up interrupt vector table 2
041539 21 00 00 00 0162*   	ld hl,0
04153D 3A 0C 01 00 0163*   	ld a,($10c)
041541 6F          0164*   	ld l,a
041542 3A 0D 01 00 0165*   	ld a,($10d)
041546 67          0166*   	ld h,a
041547             0167*   
041547             0168*   	; skip over CALL ($c3)
041547 23          0169*   	inc hl
041548             0170*   	; load address of jump into vector table 2 (in ram)
041548 ED 27       0171*   	ld hl,(hl)
04154A             0172*   
04154A             0173*   	; write CALL prt_irq_handler to vector table 2
04154A 3E C3       0174*   	ld a,$c3
04154C 77          0175*   	ld (hl),a
04154D 23          0176*   	inc hl
04154E 11 55 15 04 0177*   	ld de,prt_irq_handler
041552 ED 1F       0178*   	ld (hl),de
041554             0179*   
041554 C9          0180*       ret
041555             0181*   
041555             0182*   prt_irq_handler:
041555 F3          0183*   	di
041556 F5          0184*   	push af
041557 E5          0185*       push hl
041558 ED 38 83    0186*   	in0 a,(TMR1_CTL+TMR_REG_CTL)
04155B 2A 6A 15 04 0187*   	ld hl,(prt_irq_counter)
04155F 23          0188*   	inc hl
041560 22 6A 15 04 0189*   	ld (prt_irq_counter),hl
041564 E1          0190*       pop hl
041565 F1          0191*   	pop af
041566 FB          0192*   	ei
041567 5B ED 4D    0193*   	reti.l
04156A             0194*   
04156A             0195*   prt_irq_counter:
04156A 00 00 00    0196*   	.dl 0
04156D             0197*   prt_irq_counter_saved:
04156D 00 00 00    0198*       .dl 0
041570             0199*   
041570             0200*   prt_loop_reset:
041570 E5          0201*       push hl
041571 21 00 00 00 0202*   	ld hl,0
041575 22 6A 15 04 0203*   	ld (prt_irq_counter),hl
041579 22 DB 15 04 0204*       ld (prt_loop_counter),hl
04157D 22 DE 15 04 0205*       ld (prt_loops),hl
041581 CD 1C 15 04 0206*       call prt_set
041585 E1          0207*       pop hl
041586 C9          0208*       ret
041587             0209*   
041587             0210*   prt_loop_start:
041587 E5          0211*       push hl
041588 21 00 00 00 0212*   	ld hl,0
04158C 22 6A 15 04 0213*   	ld (prt_irq_counter),hl
041590 E1          0214*       pop hl
041591 C9          0215*       ret
041592             0216*   
041592             0217*   prt_loop_stop:
041592 E5          0218*       push hl
041593 D5          0219*       push de
041594 2A 6A 15 04 0220*       ld hl,(prt_irq_counter)
041598 ED 5B DB 15 0221*       ld de,(prt_loop_counter)
       04          
04159D 19          0222*       add hl,de
04159E 22 DB 15 04 0223*       ld (prt_loop_counter),hl
0415A2 21 00 00 00 0224*       ld hl,0
0415A6 22 6A 15 04 0225*       ld (prt_irq_counter),hl
0415AA 2A DE 15 04 0226*       ld hl,(prt_loops)
0415AE 23          0227*       inc hl
0415AF 22 DE 15 04 0228*       ld (prt_loops),hl
0415B3 D1          0229*       pop de
0415B4 E1          0230*       pop hl
0415B5 C9          0231*       ret
0415B6             0232*   
0415B6             0233*   ; inputs: bc = y,x text coordinates to print
0415B6             0234*   prt_loop_print:
0415B6 F5          0235*       push af
0415B7 E5          0236*       push hl
0415B8 C5          0237*       push bc
0415B9 D5          0238*       push de
0415BA DD E5       0239*       push ix
0415BC FD E5       0240*       push iy
0415BE CD C2 16 04 0241*       call vdu_move_cursor
0415C2             0242*   
0415C2 2A DB 15 04 0243*       ld hl,(prt_loop_counter)
0415C6 CD CC 00 04 0244*       call printDec
0415CA             0245*   
0415CA 2A DE 15 04 0246*       ld hl,(prt_loops)
0415CE CD CC 00 04 0247*       call printDec
0415D2             0248*   
0415D2 FD E1       0249*       pop iy
0415D4 DD E1       0250*       pop ix
0415D6 D1          0251*       pop de
0415D7 C1          0252*       pop bc
0415D8 E1          0253*       pop hl
0415D9 F1          0254*       pop af
0415DA C9          0255*       ret
0415DB             0256*   
0415DB             0257*   prt_loop_counter:
0415DB 00 00 00    0258*       .dl 0
0415DE             0259*   prt_loops:
0415DE 00 00 00    0260*       .dl 0
0415E1             0261*   
0415E1             0262*   ; ===============================================
0415E1             0263*   ; Timer functions
0415E1             0264*   ; -----------------------------------------------
0415E1             0265*   ; set a countdown timer
0415E1             0266*   ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0415E1             0267*   ; returns: hl = current time
0415E1             0268*   tmr_set:
0415E1 FD 2F 03    0269*       ld (iy+3),hl            ; set time remaining
0415E4             0270*       MOSCALL mos_sysvars     ; ix points to syvars table
0415E4 3E 08       0001*M1 			LD	A, function
0415E6 5B CF       0002*M1 			RST.LIL	08h
0415E8 DD 27 00    0271*       ld hl,(ix+sysvar_time)  ; get current time
0415EB FD 2F 00    0272*       ld (iy+0),hl            ; set start time
0415EE C9          0273*       ret
0415EF             0274*   
0415EF             0275*   ; gets time remaining on a countdown timer
0415EF             0276*   ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0415EF             0277*   ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0415EF             0278*   ;          sign flags: pos = time not expired,zero or neg = time expired
0415EF             0279*   tmr_get:
0415EF             0280*       MOSCALL mos_sysvars     ; ix points to syvars table
0415EF 3E 08       0001*M1 			LD	A, function
0415F1 5B CF       0002*M1 			RST.LIL	08h
0415F3 DD 17 00    0281*       ld de,(ix+sysvar_time)  ; get current time
0415F6 FD 27 00    0282*       ld hl,(iy+0)            ; get start time
0415F9 AF          0283*       xor a                   ; clear carry
0415FA ED 52       0284*       sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0415FC FD 17 03    0285*       ld de,(iy+3)            ; get timer set value
0415FF AF          0286*       xor a                   ; clear carry
041600 ED 5A       0287*       adc hl,de               ; hl = time remaining
041602             0288*                               ; (we do adc because add hl,rr doesn't set sign or zero flags)
041602 C9          0289*       ret
041603             0290*   
041603             0291*   tmr_test: ds 6 ; example of a buffer to hold timer data
041609             0292*   
       FF FF FF FF 
       FF FF 
041609 00 00 00    0293*   timestamp_now: dl 0
04160C 00 00 00    0294*   timestamp_old: dl 0
04160F 00 00 00    0295*   timestamp_chg: dl 0
041612             0296*   
041612             0297*   ; update the global timestamp from the system clock
041612             0298*   ; inputs: none
041612             0299*   ; returns: hl = time elapsed in 1/120ths of a second
041612             0300*   ;          de = current time
041612             0301*   ;          ix = pointer to syvars table
041612             0302*   ; destroys: af,hl,de,ix
041612             0303*   timestamp_tick:
041612 ED 5B 09 16 0304*       ld de,(timestamp_now)   ; get previous time
       04          
041617 ED 53 0C 16 0305*       ld (timestamp_old),de   ; save previous time
       04          
04161C             0306*       MOSCALL mos_sysvars     ; ix points to syvars table
04161C 3E 08       0001*M1 			LD	A, function
04161E 5B CF       0002*M1 			RST.LIL	08h
041620 DD 27 00    0307*       ld hl,(ix+sysvar_time)  ; get current time
041623 22 09 16 04 0308*       ld (timestamp_now),hl   ; save current time
041627 AF          0309*       xor a                   ; clear carry
041628 ED 52       0310*       sbc hl,de               ; hl = time elapsed
04162A 22 0F 16 04 0311*       ld (timestamp_chg),hl   ; save elapsed time
04162E C9          0312*       ret
04162F             0313*   
04162F             0314*   ; set a countdown timer
04162F             0315*   ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
04162F             0316*   ; requires: timestamp_tick to be called at least once before this function
04162F             0317*   ; returns: hl = current time
04162F             0318*   ; destroys: hl
04162F             0319*   timestamp_tmr_set:
04162F FD 2F 03    0320*       ld (iy+3),hl            ; set time remaining
041632 2A 09 16 04 0321*       ld hl,(timestamp_now)   ; get current timestamp
041636 FD 2F 00    0322*       ld (iy+0),hl            ; set start time
041639 C9          0323*       ret
04163A             0324*   
04163A             0325*   ; gets time remaining on a countdown timer following the global timestamp
04163A             0326*   ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
04163A             0327*   ; requires: timestamp_tick to be called at least once before this function
04163A             0328*   ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
04163A             0329*   ;          sign flags: pos = time not expired,zero or neg = time expired
04163A             0330*   ; destroys: af,hl,de
04163A             0331*   timestamp_tmr_get:
04163A ED 5B 09 16 0332*       ld de,(timestamp_now)   ; get current timestamp
       04          
04163F FD 27 00    0333*       ld hl,(iy+0)            ; get start time
041642 AF          0334*       xor a                   ; clear carry
041643 ED 52       0335*       sbc hl,de               ; hl = time elapsed (will always be zero or negative)
041645 FD 17 03    0336*       ld de,(iy+3)            ; get timer set value
041648 AF          0337*       xor a                   ; clear carry
041649 ED 5A       0338*       adc hl,de               ; hl = time remaining
04164B             0339*                               ; (we do adc because add hl,rr doesn't set sign or zero flags)
04164B C9          0340*       ret
04164C             0341*   
04164C             0342*   ; set a stopwatch
04164C             0343*   ; returns: hl = start time
04164C             0344*   ; destroys: hl,ix
04164C             0345*   stopwatch_set:
04164C             0346*       MOSCALL mos_sysvars     ; ix points to syvars table
04164C 3E 08       0001*M1 			LD	A, function
04164E 5B CF       0002*M1 			RST.LIL	08h
041650 DD 27 00    0347*       ld hl,(ix+sysvar_time)  ; get current time
041653 22 68 16 04 0348*       ld (stopwatch_started),hl            ; set start time
041657 C9          0349*       ret
041658             0350*   
041658             0351*   ; gets time elapsed on a stopwatch
041658             0352*   ; returns: hl = time elapsed in 1/120ths of a second
041658             0353*   ; destroys: af,hl,de,ix
041658             0354*   stopwatch_get:
041658             0355*       MOSCALL mos_sysvars     ; ix points to syvars table
041658 3E 08       0001*M1 			LD	A, function
04165A 5B CF       0002*M1 			RST.LIL	08h
04165C DD 27 00    0356*       ld hl,(ix+sysvar_time)  ; get current time
04165F ED 5B 68 16 0357*       ld de,(stopwatch_started)            ; get start time
       04          
041664 AF          0358*       xor a                   ; clear carry
041665 ED 52       0359*       sbc hl,de               ; hl = time elapsed (will always be zero or positive)
041667 C9          0360*       ret
041668             0361*   
041668             0362*   stopwatch_started: ds 3 ; buffer to hold stopwatch start time
04166B             0363*   
04166B             0364*   ; ------------------
04166B             0365*   ; delay routine
04166B             0366*   ; Author: Richard Turrnidge
04166B             0367*   ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.asm
04166B             0368*   ; routine waits a fixed time,then returns
04166B             0369*   ; arrive with A =  the delay byte. One bit to be set only.
04166B             0370*   ; eg. ld A,00000100b
04166B             0371*   
04166B             0372*   multiPurposeDelay:
       FF FF FF 
04166B F5          0373*       push af
04166C C5          0374*       push bc
04166D DD E5       0375*       push ix
04166F 47          0376*       ld b,a
041670 3E 08       0377*       ld a,$08
041672 5B CF       0378*       RST.LIL	08h                 ; get IX pointer to sysvars
041674             0379*   
041674             0380*   waitLoop:
041674             0381*   
041674 DD 7E 00    0382*       ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
041677             0383*   
041677             0384*                                   ;   we check if bit set is same as last time we checked.
041677             0385*                                   ;   bit 0 - don't use
041677             0386*                                   ;   bit 1 - changes 64 times per second
041677             0387*                                   ;   bit 2 - changes 32 times per second
041677             0388*                                   ;   bit 3 - changes 16 times per second
041677             0389*   
041677             0390*                                   ;   bit 4 - changes 8 times per second
041677             0391*                                   ;   bit 5 - changes 4 times per second
041677             0392*                                   ;   bit 6 - changes 2 times per second
041677             0393*                                   ;   bit 7 - changes 1 times per second
041677 A0          0394*       and b
041678 4F          0395*       ld c,a
041679 3A 8A 16 04 0396*       ld a,(oldTimeStamp)
04167D B9          0397*       cp c                        ; is A same as last value?
04167E 28 F4       0398*       jr z,waitLoop              ; loop here if it is
041680 79          0399*       ld a,c
041681 32 8A 16 04 0400*       ld (oldTimeStamp),a        ; set new value
041685             0401*   
041685 DD E1       0402*       pop ix
041687 C1          0403*       pop bc
041688 F1          0404*       pop af
041689 C9          0405*       ret
04168A             0406*   
04168A 00          0407*   oldTimeStamp:   .db 00h
04168B             0039        include "vdu.inc"
04168B             0001*   ; VDU 30: Home cursor
04168B             0002*   vdu_home_cursor:
04168B 3E 1E       0003*       ld a,30
04168D 5B D7       0004*   	rst.lil $10
04168F C9          0005*   	ret
041690             0006*   
041690             0007*   vdu_cursor_on:
041690 21 9B 16 04 0008*   	ld hl,@cmd
041694 01 03 00 00 0009*   	ld bc,@end-@cmd
041698 5B DF       0010*   	rst.lil $18
04169A C9          0011*   	ret
04169B             0012*   @cmd:
04169B 17 01 01    0013*   	db 23,1,1
04169E             0014*   @end:
04169E             0015*   
04169E             0016*   vdu_cursor_off:
04169E 21 A9 16 04 0017*   	ld hl,@cmd
0416A2 01 03 00 00 0018*   	ld bc,@end-@cmd
0416A6 5B DF       0019*   	rst.lil $18
0416A8 C9          0020*   	ret
0416A9             0021*   @cmd:
0416A9 17 01 00    0022*   	db 23,1,0
0416AC             0023*   @end:
0416AC             0024*   
0416AC             0025*   ; VDU 5: Write text at graphics cursor
0416AC             0026*   ; inputs: a is the character to write to the screen
0416AC             0027*   ; prerequisites: the graphics cursor at the intended position on screen
0416AC             0028*   ; outputs: see the name of the function
0416AC             0029*   ; destroys: a, hl, bc
0416AC             0030*   vdu_char_to_gfx_cursor:
0416AC 32 BC 16 04 0031*   	ld (@arg),a
0416B0 21 BB 16 04 0032*   	ld hl,@cmd
0416B4 01 02 00 00 0033*   	ld bc,@end-@cmd
0416B8 5B DF       0034*   	rst.lil $18
0416BA C9          0035*   	ret
0416BB 05          0036*   @cmd: db 5
0416BC 00          0037*   @arg: db 0
0416BD             0038*   @end:
0416BD             0039*   ; VDU 9: Move cursor forward one character
0416BD             0040*   vdu_cursor_forward:
0416BD 3E 09       0041*       ld a,9
0416BF 5B D7       0042*   	rst.lil $10
0416C1 C9          0043*   	ret
0416C2             0044*   
0416C2             0045*   ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
0416C2             0046*   ; inputs: c=x, b=y 8-bit unsigned integers
0416C2             0047*   vdu_move_cursor:
0416C2 ED 43 D3 16 0048*       ld (@x0),bc
       04          
0416C7 21 D2 16 04 0049*   	ld hl,@cmd
0416CB 01 03 00 00 0050*   	ld bc,@end-@cmd
0416CF 5B DF       0051*   	rst.lil $18
0416D1 C9          0052*   	ret
0416D2 1F          0053*   @cmd: 	db 31
0416D3 00          0054*   @x0:	db 0
0416D4 00          0055*   @y0: 	db 0
0416D5 00          0056*   @end: 	db 0 ; padding
0416D6             0057*   
0416D6             0058*   ; VDU 12: Clear text area (CLS)
0416D6             0059*   vdu_cls:
0416D6 3E 0C       0060*       ld a,12
0416D8 5B D7       0061*   	rst.lil $10
0416DA C9          0062*   	ret
0416DB             0063*   
0416DB             0064*   vdu_flip:
0416DB 21 E6 16 04 0065*   	ld hl,@cmd
0416DF 01 03 00 00 0066*   	ld bc,@end-@cmd
0416E3 5B DF       0067*   	rst.lil $18
0416E5 C9          0068*   	ret
0416E6 17 00 C3    0069*   @cmd: db 23,0,0xC3
0416E9             0070*   @end:
0416E9             0071*   
0416E9             0072*   ; VDU 16: Clear graphics area (CLG)
0416E9             0073*   vdu_clg:
0416E9 3E 10       0074*       ld a,16
0416EB 5B D7       0075*   	rst.lil $10
0416ED C9          0076*   	ret
0416EE             0077*   
0416EE             0078*   ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
0416EE             0079*   ; VDU 23, 7: Scrolling
0416EE             0080*   ;     VDU 23, 7, extent, direction, speed: Scroll the screen
0416EE             0081*   ; inputs: a, extent; l, direction; h; speed
0416EE             0082*   vdu_scroll_down:
0416EE 32 03 17 04 0083*   	ld (@extent),a
0416F2 22 04 17 04 0084*   	ld (@dir),hl ; implicitly populates @speed
0416F6 21 01 17 04 0085*   	ld hl,@cmd
0416FA 01 05 00 00 0086*   	ld bc,@end-@cmd
0416FE 5B DF       0087*   	rst.lil $18     ;; Sending command to VDP
041700 C9          0088*   	ret
041701 17 07       0089*   @cmd:       db 23,7
041703 00          0090*   @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
041704 00          0091*   @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
041705 00          0092*   @speed:     db 0x00 ; pixels
041706 00          0093*   @end:		db 0x00 ; padding
041707             0094*   
041707             0095*   ; COLOUR MODES
041707             0096*   ; Mode	Effect
041707             0097*   ; 0	Set on-screen pixel to target colour value
041707             0098*   ; 1	OR value with the on-screen pixel
041707             0099*   ; 2	AND value with the on-screen pixel
041707             0100*   ; 3	XOR value with the on-screen pixel
041707             0101*   ; 4	Invert the on-screen pixel
041707             0102*   ; 5	No operation
041707             0103*   ; 6	AND the inverse of the specified colour with the on-screen pixel
041707             0104*   ; 7	OR the inverse of the specified colour with the on-screen pixel
041707             0105*   
041707             0106*   ; VDU 17, colour: Define text colour (COLOUR)
041707             0107*   vdu_colour_text:
041707 32 17 17 04 0108*   	ld (@arg),a
04170B 21 16 17 04 0109*   	ld hl,@cmd
04170F 01 02 00 00 0110*   	ld bc,@end-@cmd
041713 5B DF       0111*   	rst.lil $18
041715 C9          0112*   	ret
041716 11          0113*   @cmd: db 17
041717 00          0114*   @arg: db 0
041718             0115*   @end:
041718             0116*   
041718             0117*   ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
041718             0118*   ; inputs: a=mode, c=colour (add 128 to set background colour)
041718             0119*   vdu_gcol:
041718 32 2D 17 04 0120*   	ld (@mode),a
04171C 79          0121*       ld a,c
04171D 32 2E 17 04 0122*       ld (@col),a
041721 21 2C 17 04 0123*   	ld hl,@cmd
041725 01 03 00 00 0124*   	ld bc,@end-@cmd
041729 5B DF       0125*   	rst.lil $18
04172B C9          0126*   	ret
04172C 12          0127*   @cmd:  db 18
04172D 00          0128*   @mode: db 0
04172E 00          0129*   @col:  db 0
04172F             0130*   @end:
04172F             0131*   
04172F             0132*   
04172F             0133*   ; VDU 28, left, bottom, right, top: Set text viewport **
04172F             0134*   ; MIND THE LITTLE-ENDIANESS
04172F             0135*   ; inputs: c=left,b=bottom,e=right,d=top
04172F             0136*   ; outputs; nothing
04172F             0137*   ; destroys: a might make it out alive
04172F             0138*   vdu_set_txt_viewport:
04172F ED 43 45 17 0139*       ld (@lb),bc
       04          
041734 ED 53 47 17 0140*   	ld (@rt),de
       04          
041739 21 44 17 04 0141*   	ld hl,@cmd
04173D 01 05 00 00 0142*   	ld bc,@end-@cmd
041741 5B DF       0143*   	rst.lil $18
041743 C9          0144*   	ret
041744 1C          0145*   @cmd:   db 28 ; set text viewport command
041745 00 00       0146*   @lb: 	dw 0x0000 ; set by bc
041747 00 00       0147*   @rt: 	dw 0x0000 ; set by de
041749 00          0148*   @end:   db 0x00	  ; padding
04174A             0149*   
04174A             0150*   ; Wait for VBLANK interrupt
04174A             0151*   vdu_vblank:
04174A DD E5       0152*       PUSH 	IX
04174C             0153*   	MOSCALL	mos_sysvars
04174C 3E 08       0001*M1 			LD	A, function
04174E 5B CF       0002*M1 			RST.LIL	08h
041750 DD 7E 00    0154*   	LD	A, (IX + sysvar_time + 0)
041753             0155*   @wait:
041753 DD BE 00    0156*       CP 	A, (IX + sysvar_time + 0)
041756 28 FB       0157*       JR	Z, @wait
041758 DD E1       0158*       POP	IX
04175A C9          0159*       RET
04175B             0160*   
04175B             0161*   ; VDU 29, x; y;: Set graphics origin
04175B             0162*   ; This command sets the graphics origin.
04175B             0163*   ; The origin is the point on the screen where the coordinates (0,0) are located.
04175B             0164*   ; inputs: bc=x0,de=y0
04175B             0165*   ; outputs; nothing
04175B             0166*   ; destroys: a might make it out alive
04175B             0167*   vdu_set_gfx_origin:
04175B ED 43 71 17 0168*       ld (@x0),bc
       04          
041760 ED 53 73 17 0169*       ld (@y0),de
       04          
041765 21 70 17 04 0170*       ld hl,@cmd
041769 01 05 00 00 0171*       ld bc,@end-@cmd
04176D 5B DF       0172*       rst.lil $18
04176F C9          0173*       ret
041770 1D          0174*   @cmd:   db 29 ; set graphics origin command
041771 00 00       0175*   @x0: 	dw 0x0000 ; set by bc
041773 00 00       0176*   @y0: 	dw 0x0000 ; set by de
041775 00          0177*   @end:   db 0x00	  ; padding
041776             0178*   
041776             0179*   ; VDU 24, left; bottom; right; top;: Set graphics viewport
041776             0180*   ; NOTE: the order of the y-coordinate parameters are inverted
041776             0181*   ; 	because we have turned off logical screen scaling
041776             0182*   ; NOTE: coordinates are relative to current gfx origin
041776             0183*   ; inputs: bc=x0,de=y0,ix=x1,iy=y1
041776             0184*   ; outputs; nothing
041776             0185*   ; destroys: a might make it out alive
041776             0186*   vdu_set_gfx_viewport:
041776 ED 43 96 17 0187*       ld (@x0),bc
       04          
04177B FD 22 98 17 0188*       ld (@y1),iy
       04          
041780 DD 22 9A 17 0189*   	ld (@x1),ix
       04          
041785 ED 53 9C 17 0190*   	ld (@y0),de
       04          
04178A 21 95 17 04 0191*   	ld hl,@cmd
04178E 01 09 00 00 0192*   	ld bc,@end-@cmd
041792 5B DF       0193*   	rst.lil $18
041794 C9          0194*   	ret
041795 18          0195*   @cmd:   db 24 ; set graphics viewport command
041796 00 00       0196*   @x0: 	dw 0x0000 ; set by bc
041798 00 00       0197*   @y1: 	dw 0x0000 ; set by iy
04179A 00 00       0198*   @x1: 	dw 0x0000 ; set by ix
04179C 00 00       0199*   @y0: 	dw 0x0000 ; set by de
04179E 00          0200*   @end:   db 0x00	  ; padding
04179F             0201*   
04179F             0202*   ; VDU 26: Reset graphics and text viewports
04179F             0203*   vdu_reset_viewports:
04179F 3E 1A       0204*       ld a,26
0417A1 5B D7       0205*       rst.lil $10
0417A3 C9          0206*       ret
0417A4             0207*   
0417A4             0208*   ; SCREEN MODES
0417A4             0209*   ; ===============================
0417A4             0210*   ; Mode  Horz  Vert  Cols  Refresh
0417A4             0211*   ; ---   ----  ----  ----  -------
0417A4             0212*   ; 11    320   240   2     60hz
0417A4             0213*   ; 139   320   240   2     60hz
0417A4             0214*   ; 23    512   384   2     60hz
0417A4             0215*   ; 151   512   384   2     60hz
0417A4             0216*   ; 6     640   240   2     60hz
0417A4             0217*   ; 134   640   240   2     60hz
0417A4             0218*   ; 2     640   480   2     60hz
0417A4             0219*   ; 130   640   480   2     60hz
0417A4             0220*   ; 17    800   600   2     60hz
0417A4             0221*   ; 145   800   600   2     60hz
0417A4             0222*   ; 18    1024  768   2     60hz
0417A4             0223*   ; 146   1024  768   2     60hz
0417A4             0224*   ; ---   ----  ----  ----  -------
0417A4             0225*   ; 10    320   240   4     60hz
0417A4             0226*   ; 138   320   240   4     60hz
0417A4             0227*   ; 22    512   384   4     60hz
0417A4             0228*   ; 150   512   384   4     60hz
0417A4             0229*   ; 5     640   240   4     60hz
0417A4             0230*   ; 133   640   240   4     60hz
0417A4             0231*   ; 1     640   480   4     60hz
0417A4             0232*   ; 129   640   480   4     60hz
0417A4             0233*   ; 16    800   600   4     60hz
0417A4             0234*   ; 19    1024  768   4     60hz
0417A4             0235*   ; ---   ----  ----  ----  -------
0417A4             0236*   ; 9     320   240   16    60hz
0417A4             0237*   ; 137   320   240   16    60hz
0417A4             0238*   ; 21    512   384   16    60hz
0417A4             0239*   ; 149   512   384   16    60hz
0417A4             0240*   ; 4     640   240   16    60hz
0417A4             0241*   ; 132   640   240   16    60hz
0417A4             0242*   ; 0     640   480   16    60hz
0417A4             0243*   ; 7     n/a   n/a   16    60hz
0417A4             0244*   ; ---   ----  ----  ----  -------
0417A4             0245*   ; 8     320   240   64    60hz
0417A4             0246*   ; 136   320   240   64    60hz
0417A4             0247*   ; 20    512   384   64    60hz
0417A4             0248*   ; 3     640   240   64    60hz
0417A4             0249*   ; ---   ----  ----  ----  -------
0417A4             0250*   vdu_set_screen_mode:
0417A4 32 B4 17 04 0251*   	ld (@arg),a
0417A8 21 B3 17 04 0252*   	ld hl,@cmd
0417AC 01 02 00 00 0253*   	ld bc,@end-@cmd
0417B0 5B DF       0254*   	rst.lil $18
0417B2 C9          0255*   	ret
0417B3 16          0256*   @cmd: db 22 ; set screen mode
0417B4 00          0257*   @arg: db 0  ; screen mode parameter
0417B5             0258*   @end:
0417B5             0259*   
0417B5             0260*   ; get the current screen mode
0417B5             0261*   ; inputs: none
0417B5             0262*   ; outputs: a=screen mode
0417B5             0263*   ; destroys: af, ix
0417B5             0264*   vdu_get_screen_mode:
0417B5             0265*       MOSCALL mos_sysvars
0417B5 3E 08       0001*M1 			LD	A, function
0417B7 5B CF       0002*M1 			RST.LIL	08h
0417B9 DD 7E 27    0266*       ld a,(IX+sysvar_scrMode)
0417BC C9          0267*       ret
0417BD             0268*   ; end vdu_get_screen_mode
0417BD             0269*   
0417BD             0270*   ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
0417BD             0271*   ; inputs: a is scaling mode, 1=on, 0=off
0417BD             0272*   ; note: default setting on boot is scaling ON
0417BD             0273*   vdu_set_scaling:
0417BD 32 CF 17 04 0274*   	ld (@arg),a
0417C1 21 CC 17 04 0275*   	ld hl,@cmd
0417C5 01 04 00 00 0276*   	ld bc,@end-@cmd
0417C9 5B DF       0277*   	rst.lil $18
0417CB C9          0278*   	ret
0417CC 17 00 C0    0279*   @cmd: db 23,0,0xC0
0417CF 00          0280*   @arg: db 0  ; scaling on/off
0417D0             0281*   @end:
0417D0             0282*   
0417D0             0283*   ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
0417D0             0284*   ; inputs: hl=bufferId
0417D0             0285*   vdu_buff_select:
0417D0 22 E2 17 04 0286*   	ld (@bufferId),hl
0417D4 21 DF 17 04 0287*   	ld hl,@cmd
0417D8 01 05 00 00 0288*   	ld bc,@end-@cmd
0417DC 5B DF       0289*   	rst.lil $18
0417DE C9          0290*   	ret
0417DF 17 1B 20    0291*   @cmd: db 23,27,0x20
0417E2 00 00       0292*   @bufferId: dw 0x0000
0417E4 00          0293*   @end: db 0x00 ; padding
0417E5             0294*   
0417E5             0295*   ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
0417E5             0296*   ; inputs: a=format; bc=width; de=height
0417E5             0297*   ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
0417E5             0298*   ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
0417E5             0299*   ; 0 	RGBA8888 (4-bytes per pixel)
0417E5             0300*   ; 1 	RGBA2222 (1-bytes per pixel)
0417E5             0301*   ; 2 	Mono/Mask (1-bit per pixel)
0417E5             0302*   ; 3 	Reserved for internal use by VDP (â€œnativeâ€ format)
0417E5             0303*   vdu_bmp_create:
0417E5 ED 43 01 18 0304*       ld (@width),bc
       04          
0417EA ED 53 03 18 0305*       ld (@height),de
       04          
0417EF 32 05 18 04 0306*       ld (@fmt),a
0417F3 21 FE 17 04 0307*   	ld hl,@cmd
0417F7 01 08 00 00 0308*   	ld bc,@end-@cmd
0417FB 5B DF       0309*   	rst.lil $18
0417FD C9          0310*   	ret
0417FE 17 1B 21    0311*   @cmd:       db 23,27,0x21
041801 00 00       0312*   @width:     dw 0x0000
041803 00 00       0313*   @height:    dw 0x0000
041805 00          0314*   @fmt:       db 0x00
041806             0315*   @end:
041806             0316*   
041806             0317*   ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
041806             0318*   ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
041806             0319*   vdu_load_img_rgba2_to_8:
041806             0320*   ; backup the target buffer id and image dimensions
041806 E5          0321*       push hl
041807 D5          0322*       push de
041808 C5          0323*       push bc
041809             0324*   ; load the rgba2 image to working buffer 65534
041809 21 FE FF 00 0325*       ld hl,65534 ; temporary working buffer id
04180D CD E4 18 04 0326*   	call vdu_load_buffer_from_file
041811             0327*   ; restore the image dimensions and target buffer id
041811 C1          0328*       pop bc
041812 D1          0329*       pop de
041813 E1          0330*       pop hl
041814             0331*   ; fall through to vdu_rgba2_to_8
041814             0332*   
041814             0333*   ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
041814             0334*   ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
041814             0335*   ; the "expand bitmap" command is:
041814             0336*   ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
041814             0337*   ; and then to reverse the byte order to fix endian-ness:
041814             0338*   ; VDU 23,0,&A0,targetBufferID%;24,4,4;
041814             0339*   ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
041814             0340*   ; VDU 23,27,&20,targetBufferID%;
041814             0341*   ; VDU 23,27,&21,width%;height%;0
041814             0342*   ; -------------------------------------------------------------------
041814             0343*   ; inputs: bc,de image width,height ; hl = targetBufferId
041814             0344*   ; prerequisites: rgba2 image data loaded into workingBufferId 65534
041814             0345*   vdu_rgba2_to_8:
041814             0346*   ; load the image dimensions and buffer id parameters
041814 ED 43 70 18 0347*       ld (@width),bc
       04          
041819 ED 53 72 18 0348*       ld (@height),de
       04          
04181E 22 55 18 04 0349*       ld (@bufferId0),hl
041822 22 62 18 04 0350*       ld (@bufferId2),hl
041826 22 6B 18 04 0351*       ld (@bufferId1),hl
04182A             0352*   ; clean up bytes that got stomped on by the ID loads
04182A 3E 48       0353*       ld a,0x48
04182C 32 57 18 04 0354*       ld (@bufferId0+2),a
041830 3E 17       0355*       ld a,23
041832 32 6D 18 04 0356*       ld (@bufferId1+2),a
041836 3E 18       0357*       ld a,24
041838 32 64 18 04 0358*       ld (@bufferId2+2),a
04183C AF          0359*       xor a
04183D 32 74 18 04 0360*       ld (@height+2),a
041841             0361*   ; send the vdu command strings
041841 21 4C 18 04 0362*       ld hl,@beg
041845 01 29 00 00 0363*       ld bc,@end-@beg
041849 5B DF       0364*       rst.lil $18
04184B C9          0365*       ret
04184C             0366*   @beg:
04184C             0367*   ; Command 14: Consolidate blocks in a buffer
04184C             0368*   ; VDU 23, 0, &A0, bufferId; 14
04184C 17 00 A0    0369*       db 23,0,0xA0
04184F FE FF       0370*       dw 65534 ; workingBufferId
041851 0E          0371*       db 14 ; consolidate blocks
041852             0372*   ; the "expand bitmap" command is:
041852             0373*   ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
041852 17 00 A0    0374*       db 23,0,0xA0
041855 00 00       0375*   @bufferId0: dw 0x0000 ; targetBufferId
041857 48          0376*       db 0x48 ; given as decimal command 72 in the docs
041858 02          0377*       db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
041859 FE FF       0378*       dw 65534 ; sourceBufferId
04185B 00 7F BF FF 0379*       db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
04185F             0380*   ; reverse the byte order to fix endian-ness:
04185F             0381*   ; Command 24: Reverse the order of data of blocks within a buffer
04185F             0382*   ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
04185F             0383*   ; VDU 23,0,&A0,targetBufferID%;24,4,4;
04185F 17 00 A0    0384*       db 23,0,0xA0
041862 00 00       0385*   @bufferId2:    dw 0x0000 ; targetBufferId
041864 18          0386*       db 24 ; reverse byte order
041865 04          0387*       db 4 ; option: Reverse data of the value size within chunk of data of the specified size
041866 04 00       0388*       dw 4 ; size (4 bytes)
041868             0389*   ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
041868             0390*   ; VDU 23,27,&20,targetBufferID%;
041868 17 1B 20    0391*       db 23,27,0x20 ; select bitmap
04186B 00 00       0392*   @bufferId1: dw 0x0000 ; targetBufferId
04186D             0393*   ; VDU 23,27,&21,width%;height%;0
04186D 17 1B 21    0394*       db 23,27,0x21 ; create bitmap from buffer
041870 00 00       0395*   @width: dw 0x0000
041872 00 00       0396*   @height: dw 0x0000
041874 00          0397*       db 0x00 ; rgba8888 format
041875             0398*   @end:
041875             0399*   
041875             0400*   ; scratch variables
041875 00 00 00    0401*   bufferId0: dl 0x000000
041878 00 00 00    0402*   bufferId1: dl 0x000000
04187B             0403*   
04187B             0404*   ; load a vdu buffer from local memory
04187B             0405*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
04187B             0406*   vdu_load_buffer:
04187B ED 43 A4 18 0407*       ld (@length),bc
       04          
041880 D5          0408*       push de ; save data pointer
041881             0409*   ; send the vdu command string
041881 7D          0410*       ld a,l
041882 32 A1 18 04 0411*       ld (@bufferId),a
041886 7C          0412*       ld a,h
041887 32 A2 18 04 0413*       ld (@bufferId+1),a
04188B 21 9E 18 04 0414*       ld hl,@cmd
04188F 01 08 00 00 0415*       ld bc,@end-@cmd
041893 5B DF       0416*       rst.lil $18
041895             0417*   ; send the buffer data
041895 E1          0418*       pop hl ; pointer to data
041896 ED 4B A4 18 0419*       ld bc,(@length)
       04          
04189B 5B DF       0420*       rst.lil $18 ; send it
04189D C9          0421*       ret
04189E             0422*   ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04189E 17 00 A0    0423*   @cmd:       db 23,0,0xA0
0418A1 00 00       0424*   @bufferId:	dw 0x0000
0418A3 00          0425*   		    db 0 ; load buffer
0418A4 00 00       0426*   @length:	dw 0x0000
0418A6 00          0427*   @end: db 0 ; padding
0418A7             0428*   
0418A7             0429*   ; Command 14: Consolidate blocks in a buffer
0418A7             0430*   vdu_consolidate_buffer:
0418A7             0431*   ; set parameters for vdu call
0418A7 7D          0432*       ld a,l
0418A8 32 BF 18 04 0433*       ld (@bufferId),a
0418AC 7C          0434*       ld a,h
0418AD 32 C0 18 04 0435*       ld (@bufferId+1),a
0418B1 21 BC 18 04 0436*       ld hl,@beg
0418B5 01 06 00 00 0437*       ld bc,@end-@beg
0418B9 5B DF       0438*       rst.lil $18
0418BB C9          0439*       ret
0418BC             0440*   ; VDU 23, 0, &A0, bufferId; 14
0418BC 17 00 A0    0441*   @beg: db 23,0,0xA0
0418BF 00 00       0442*   @bufferId: dw 0x0000
0418C1 0E          0443*              db 14
0418C2             0444*   @end:
0418C2             0445*   
0418C2             0446*   ; load an image file to a buffer and make it a bitmap
0418C2             0447*   ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
0418C2             0448*   vdu_load_img:
0418C2             0449*   ; back up image type and dimension parameters
0418C2 22 75 18 04 0450*       ld (bufferId0),hl
0418C6 F5          0451*       push af
0418C7 C5          0452*   	push bc
0418C8 D5          0453*   	push de
0418C9             0454*   ; load the image
0418C9 CD E4 18 04 0455*   	call vdu_load_buffer_from_file
0418CD             0456*   ; now make it a bitmap
0418CD 2A 75 18 04 0457*       ld hl,(bufferId0)
0418D1 CD A7 18 04 0458*       call vdu_consolidate_buffer
0418D5 2A 75 18 04 0459*       ld hl,(bufferId0)
0418D9 CD D0 17 04 0460*       call vdu_buff_select
0418DD D1          0461*   	pop de ; image height
0418DE C1          0462*   	pop bc ; image width
0418DF F1          0463*   	pop af ; image type
0418E0 C3 E5 17 04 0464*   	jp vdu_bmp_create ; will return to caller from there
0418E4             0465*   
0418E4             0466*   ; inputs: hl = bufferId; iy = pointer to filename
0418E4             0467*   vdu_load_buffer_from_file:
0418E4 22 75 18 04 0468*       ld (bufferId0),hl
0418E8             0469*   
0418E8             0470*   ; clear target buffer
0418E8 CD 90 1A 04 0471*       call vdu_clear_buffer
0418EC             0472*   
0418EC             0473*   ; open the file in read mode
0418EC             0474*   ; Open a file
0418EC             0475*   ; HLU: Filename
0418EC             0476*   ;   C: Mode
0418EC             0477*   ; Returns:
0418EC             0478*   ;   A: Filehandle, or 0 if couldn't open
0418EC FD E5       0479*   	push iy ; pointer to filename
0418EE E1          0480*   	pop hl
0418EF 0E 01       0481*   	ld c,fa_read
0418F1             0482*       MOSCALL mos_fopen
0418F1 3E 0A       0001*M1 			LD	A, function
0418F3 5B CF       0002*M1 			RST.LIL	08h
0418F5 32 30 19 04 0483*       ld (@filehandle),a
0418F9             0484*   
0418F9             0485*   @read_file:
0418F9             0486*   ; Read a block of data from a file
0418F9             0487*   ;   C: Filehandle
0418F9             0488*   ; HLU: Pointer to where to write the data to
0418F9             0489*   ; DEU: Number of bytes to read
0418F9             0490*   ; Returns:
0418F9             0491*   ; DEU: Number of bytes read
0418F9 3A 30 19 04 0492*       ld a,(@filehandle)
0418FD 4F          0493*       ld c,a
0418FE 21 00 E0 B7 0494*       ld hl,filedata
041902 11 00 20 00 0495*       ld de,8192 ; max we can read into onboard sram at one time
041906             0496*       MOSCALL mos_fread
041906 3E 1A       0001*M1 			LD	A, function
041908 5B CF       0002*M1 			RST.LIL	08h
04190A             0497*   
04190A             0498*   ; test de for zero bytes read
04190A 21 00 00 00 0499*       ld hl,0
04190E AF          0500*       xor a ; clear carry
04190F ED 52       0501*       sbc hl,de
041911 CA 27 19 04 0502*       jp z,@close_file
041915             0503*   
041915             0504*   ; load a vdu buffer from local memory
041915             0505*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
041915 2A 75 18 04 0506*       ld hl,(bufferId0)
041919 D5          0507*       push de ; chunksize
04191A C1          0508*       pop bc
04191B 11 00 E0 B7 0509*       ld de,filedata
04191F CD 7B 18 04 0510*       call vdu_load_buffer
041923             0511*   
041923             0512*   ; read the next block
041923 C3 F9 18 04 0513*       jp @read_file
041927             0514*   
041927             0515*   ; close the file
041927             0516*   @close_file:
041927 3A 30 19 04 0517*       ld a,(@filehandle)
04192B             0518*       MOSCALL mos_fclose
04192B 3E 0B       0001*M1 			LD	A, function
04192D 5B CF       0002*M1 			RST.LIL	08h
04192F C9          0519*       ret ; vdu_load_buffer_from_file
041930             0520*   
041930 00          0521*   @filehandle: db 0 ; file handle
041931 00 00 00    0522*   @fil: dl 0 ; pointer to FIL struct
041934             0523*   
041934 00 00 00    0524*   @chunkpointer: dl 0 ; pointer to current chunk
041937             0525*   
041937             0526*   ; File information structure (FILINFO)
041937             0527*   @filinfo:
041937 00 00 00 00 0528*   @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
04193B 00 00       0529*   @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
04193D 00 00       0530*   @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
04193F 00          0531*   @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
041940 00 00 00 00 0532*   @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
04194D 00 00 00 00 0533*   @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041A4D             0040        include "vdu_buffered_api.inc"
041A4D             0001*   ; https://agonconsole8.github.io/agon-docs/vdp/Buffered-Commands-API/
041A4D             0002*   
041A4D             0003*   ; Command 0: Write block to a buffer
041A4D             0004*   ; VDU 23, 0, &A0, bufferId; 0, length; <buffer-data>
041A4D             0005*   ; inputs: hl = bufferId, bc = length of data, de = pointer to data
041A4D             0006*   vdu_write_block_to_buffer:
041A4D             0007*   ; back up input parameters
041A4D D5          0008*       push de ; pointer to data
041A4E C5          0009*       push bc ; length of data
041A4F             0010*   ; set up the vdu command string
041A4F 22 6F 1A 04 0011*       ld (@bufferId),hl
041A53 ED 43 72 1A 0012*       ld (@length),bc
       04          
041A58 AF          0013*       xor a ; load buffer
041A59 32 71 1A 04 0014*       ld (@bufferId+2),a
041A5D 21 6C 1A 04 0015*       ld hl,@cmd0
041A61 01 08 00 00 0016*       ld bc,@end0-@cmd0
041A65 5B DF       0017*       rst.lil $18
041A67             0018*   ; send the buffer data
041A67 C1          0019*       pop bc ; length of data
041A68 E1          0020*       pop hl ; pointer to data (was de)
041A69 5B DF       0021*       rst.lil $18 ; send it
041A6B C9          0022*       ret
041A6C             0023*   ; command string data
041A6C 17 00 A0    0024*   @cmd0:      db 23,0,0xA0
041A6F 00 00       0025*   @bufferId:	dw 0x0000
041A71 00          0026*               db 0 ; load buffer
041A72 00 00       0027*   @length:	dw 0x0000
041A74 00          0028*   @end0:      db 0x00 ; padding
041A75             0029*   ; end vdu_write_block_to_buffer
041A75             0030*   
041A75             0031*   ; Command 1: Call a buffer
041A75             0032*   ; VDU 23, 0, &A0, bufferId; 1
041A75             0033*   ; inputs: hl = bufferId
041A75             0034*   vdu_call_buffer:
041A75 22 8D 1A 04 0035*       ld (@bufferId),hl
041A79 3E 01       0036*       ld a,1 ; call buffer
041A7B 32 8F 1A 04 0037*       ld (@bufferId+2),a
041A7F 21 8A 1A 04 0038*       ld hl,@cmd
041A83 01 06 00 00 0039*       ld bc,@end-@cmd
041A87 5B DF       0040*       rst.lil $18
041A89 C9          0041*       ret
041A8A 17 00 A0    0042*   @cmd:     db 23,0,0xA0
041A8D 00 00       0043*   @bufferId: dw 0x0000
041A8F 01          0044*              db 1 ; call buffer
041A90             0045*   @end:
041A90             0046*   ; end vdu_call_buffer
041A90             0047*   
041A90             0048*   ; Command 2: Clear a buffer
041A90             0049*   ; VDU 23, 0 &A0, bufferId; 2
041A90             0050*   ; inputs: hl = bufferId
041A90             0051*   vdu_clear_buffer:
041A90 22 A8 1A 04 0052*       ld (@bufferId),hl
041A94 3E 02       0053*       ld a,2 ; clear buffer
041A96 32 AA 1A 04 0054*       ld (@bufferId+2),a
041A9A 21 A5 1A 04 0055*       ld hl,@cmd
041A9E 01 06 00 00 0056*       ld bc,@end-@cmd
041AA2 5B DF       0057*       rst.lil $18
041AA4 C9          0058*       ret
041AA5 17 00 A0    0059*   @cmd:     db 23,0,0xA0
041AA8 00 00       0060*   @bufferId: dw 0x0000
041AAA 02          0061*              db 2 ; clear buffer
041AAB             0062*   @end:
041AAB             0063*   ; end vdu_clear_buffer
041AAB             0064*   
041AAB             0065*   ; Clear all buffers
041AAB             0066*   ; inputs: none
041AAB             0067*   vdu_clear_all_buffers:
041AAB             0068*   ; clear all buffers
041AAB 21 B6 1A 04 0069*       ld hl,@beg
041AAF 01 06 00 00 0070*       ld bc,@end-@beg
041AB3 5B DF       0071*       rst.lil $18
041AB5 C9          0072*       ret
041AB6 17 00 A0    0073*   @beg: db 23,0,$A0
041AB9 FF FF       0074*         dw -1 ; bufferId -1 (65535) means clear all buffers
041ABB 02          0075*         db 2  ; command 2: clear a buffer
041ABC             0076*   @end:
041ABC             0077*   ; end vdu_clear_all_buffers
041ABC             0078*   
041ABC             0079*   ; Command 3: Create a writeable buffer
041ABC             0080*   ; VDU 23, 0 &A0, bufferId; 3, length;
041ABC             0081*   ; inputs: hl = bufferId, bc = length
041ABC             0082*   vdu_create_writeable_buffer:
041ABC 22 D9 1A 04 0083*       ld (@bufferId),hl
041AC0 ED 43 DC 1A 0084*       ld (@length),bc
       04          
041AC5 3E 03       0085*       ld a,3 ; create writeable buffer
041AC7 32 DB 1A 04 0086*       ld (@bufferId+2),a
041ACB 21 D6 1A 04 0087*       ld hl,@cmd
041ACF 01 08 00 00 0088*       ld bc,@end-@cmd
041AD3 5B DF       0089*       rst.lil $18
041AD5 C9          0090*       ret
041AD6 17 00 A0    0091*   @cmd:     db 23,0,0xA0
041AD9 00 00       0092*   @bufferId: dw 0x0000
041ADB 03          0093*              db 3 ; create writeable buffer
041ADC 00 00       0094*   @length: dw 0x0000
041ADE 00          0095*   @end:     db 0x00 ; padding
041ADF             0096*   ; end vdu_create_writeable_buffer
041ADF             0097*   
041ADF             0098*   ; Command 4: Set output stream to a buffer
041ADF             0099*   ; VDU 23, 0 &A0, bufferId; 4
041ADF             0100*   ; inputs: hl = bufferId
041ADF             0101*   vdu_set_output_stream_buffer:
041ADF 22 F7 1A 04 0102*       ld (@bufferId),hl
041AE3 3E 04       0103*       ld a,4 ; set output stream to buffer
041AE5 32 F9 1A 04 0104*       ld (@bufferId+2),a
041AE9 21 F4 1A 04 0105*       ld hl,@cmd
041AED 01 06 00 00 0106*       ld bc,@end-@cmd
041AF1 5B DF       0107*       rst.lil $18
041AF3 C9          0108*       ret
041AF4 17 00 A0    0109*   @cmd:     db 23,0,0xA0
041AF7 00 00       0110*   @bufferId: dw 0x0000
041AF9 04          0111*              db 4 ; set output stream to buffer
041AFA 00          0112*   @end:     db 0x00 ; padding
041AFB             0113*   ; end vdu_set_output_stream_buffer
041AFB             0114*   
041AFB             0115*   ; Command 5: Adjust buffer contents
041AFB             0116*   ; VDU 23, 0, &A0, bufferId; 5, operation, offset; [count;] <operand>, [arguments]
041AFB             0117*   vdu_adjust_buffer:
041AFB C9          0118*       ret ; TODO: implement
041AFC             0119*   ; end vdu_adjust_buffer
041AFC             0120*   
041AFC             0121*   ; Command 6: Conditionally call a buffer
041AFC             0122*   ; VDU 23, 0, &A0, bufferId; 6, operation, checkBufferId; checkOffset; [arguments]
041AFC             0123*   vdu_call_buffer_conditional:
041AFC C9          0124*       ret ; TODO: implement
041AFD             0125*   ; end vdu_call_buffer_conditional
041AFD             0126*   
041AFD             0127*   ; Command 7: Jump to a buffer
041AFD             0128*   ; VDU 23, 0, &A0, bufferId; 7
041AFD             0129*   ; inputs: hl = bufferId
041AFD             0130*   vdu_jump_to_buffer:
041AFD 22 15 1B 04 0131*       ld (@bufferId),hl
041B01 3E 07       0132*       ld a,7 ; jump to buffer
041B03 32 17 1B 04 0133*       ld (@bufferId+2),a
041B07 21 12 1B 04 0134*       ld hl,@cmd
041B0B 01 06 00 00 0135*       ld bc,@end-@cmd
041B0F 5B DF       0136*       rst.lil $18
041B11 C9          0137*       ret
041B12 17 00 A0    0138*   @cmd:     db 23,0,0xA0
041B15 00 00       0139*   @bufferId: dw 0x0000
041B17 07          0140*              db 7 ; jump to buffer
041B18 00          0141*   @end:     db 0x00 ; padding
041B19             0142*   ; end vdu_jump_to_buffer
041B19             0143*   
041B19             0144*   ; Command 8: Conditional Jump to a buffer
041B19             0145*   ; VDU 23, 0, &A0, bufferId; 8, operation, checkBufferId; checkOffset; [arguments]
041B19             0146*   vdu_jump_to_buffer_conditional:
041B19 C9          0147*       ret ; TODO: implement
041B1A             0148*   ; end vdu_jump_to_buffer_conditional
041B1A             0149*   
041B1A             0150*   ; Command 9: Jump to an offset in a buffer
041B1A             0151*   ; VDU 23, 0, &A0, bufferId; 9, offset; offsetHighByte, [blockNumber;]
041B1A             0152*   vdu_jump_to_buffer_offset:
041B1A C9          0153*       ret ; TODO: implement
041B1B             0154*   ; end vdu_jump_to_buffer_offset
041B1B             0155*   
041B1B             0156*   ; Command 10: Conditional jump to an offset in a buffer
041B1B             0157*   ; VDU 23, 0, &A0, bufferId; 10, offset; offsetHighByte, [blockNumber;] [arguments]
041B1B             0158*   vdu_jump_to_buffer_offset_conditional:
041B1B C9          0159*       ret ; TODO: implement
041B1C             0160*   ; end vdu_jump_to_buffer_offset_conditional
041B1C             0161*   
041B1C             0162*   ; Command 11: Call buffer with an offset
041B1C             0163*   ; VDU 23, 0, &A0, bufferId; 11, offset; offsetHighByte, [blockNumber;]
041B1C             0164*   vdu_call_buffer_offset:
041B1C C9          0165*       ret ; TODO: implement
041B1D             0166*   ; end vdu_call_buffer_offset
041B1D             0167*   
041B1D             0041        include "vdu_fonts.inc"
041B1D             0001*   ; select font
041B1D             0002*   ; inputs: hl = bufferId, a = font flags
041B1D             0003*   ; Flags:
041B1D             0004*   ; Bit	Description
041B1D             0005*   ; 0	Adjust cursor position to ensure text baseline is aligned
041B1D             0006*   ;   0: Do not adjust cursor position (best for changing font on a new line)
041B1D             0007*   ;   1: Adjust cursor position (best for changing font in the middle of a line)
041B1D             0008*   ; 1-7	Reserved for future use
041B1D             0009*   ; VDU 23, 0, &95, 0, bufferId; flags: Select font
041B1D             0010*   vdu_font_select:
041B1D 22 34 1B 04 0011*       ld (@bufferId),hl
041B21 32 36 1B 04 0012*       ld (@flags),a
041B25 21 30 1B 04 0013*       ld hl,@cmd
041B29 01 07 00 00 0014*       ld bc,@end-@cmd
041B2D 5B DF       0015*       rst.lil $18
041B2F C9          0016*       ret
041B30 17 00 95 00 0017*   @cmd: db 23, 0, 0x95, 0
041B34 00 00       0018*   @bufferId: dw 0x0000
041B36 00          0019*   @flags: db 0x00
041B37             0020*   @end:
041B37             0021*   
041B37             0022*   ; create font from buffer
041B37             0023*   ; inputs: hl = bufferId, e = width, d = height, d = ascent, a = flags
041B37             0024*   ; VDU 23, 0, &95, 1, bufferId; width, height, ascent, flags: Create font from buffer
041B37             0025*   vdu_font_create:
041B37 22 5C 1B 04 0026*       ld (@bufferId),hl
041B3B ED 53 5E 1B 0027*       ld (@width),de ; also loads height
       04          
041B40 32 61 1B 04 0028*       ld (@flags),a
041B44 7A          0029*       ld a,d ; height
041B45 32 60 1B 04 0030*       ld (@ascent),a ; ascent = height
041B49             0031*   ; consolidate buffer
041B49 CD A7 18 04 0032*       call vdu_consolidate_buffer
041B4D             0033*   ; create font
041B4D 21 58 1B 04 0034*       ld hl,@cmd
041B51 01 0A 00 00 0035*       ld bc,@end-@cmd
041B55 5B DF       0036*       rst.lil $18
041B57 C9          0037*       ret
041B58 17 00 95 01 0038*   @cmd: db 23, 0, 0x95, 1
041B5C 00 00       0039*   @bufferId: dw 0x0000
041B5E 00          0040*   @width: db 0x00
041B5F 00          0041*   @height: db 0x00
041B60 00          0042*   @ascent: db 0x00
041B61 00          0043*   @flags: db 0x00
041B62             0044*   @end:
041B62             0045*   
041B62             0046*   ; set or adjust font property
041B62             0047*   ; inputs: hl = bufferId, a = field, de = value
041B62             0048*   ; VDU 23, 0, &95, 2, bufferId; field, value;: Set or adjust font property
041B62             0049*   vdu_font_property:
041B62 22 7E 1B 04 0050*       ld (@bufferId),hl
041B66 32 80 1B 04 0051*       ld (@field),a
041B6A ED 53 81 1B 0052*       ld (@value),de
       04          
041B6F 21 7A 1B 04 0053*       ld hl,@cmd
041B73 01 09 00 00 0054*       ld bc,@end-@cmd
041B77 5B DF       0055*       rst.lil $18
041B79 C9          0056*       ret
041B7A 17 00 95 02 0057*   @cmd: db 23, 0, 0x95, 2
041B7E 00 00       0058*   @bufferId: dw 0x0000
041B80 00          0059*   @field: db 0x00
041B81 00 00       0060*   @value: dw 0x0000
041B83 00          0061*   @end: db 0x00 ; padding
041B84             0062*   
041B84             0063*   ; VDU 23, 0, &95, 3, bufferId; [<args>]: Reserved
041B84             0064*   
041B84             0065*   ; Clear/Delete font
041B84             0066*   ; inputs: hl = bufferId
041B84             0067*   ; VDU 23, 0, &95, 4, bufferId;: Clear/Delete font
041B84             0068*   vdu_font_clear:
041B84 22 97 1B 04 0069*       ld (@bufferId),hl
041B88 21 93 1B 04 0070*       ld hl,@cmd
041B8C 01 06 00 00 0071*       ld bc,@end-@cmd
041B90 5B DF       0072*       rst.lil $18
041B92 C9          0073*       ret
041B93 17 00 95 04 0074*   @cmd: db 23, 0, 0x95, 4
041B97 00 00       0075*   @bufferId: dw 0x0000
041B99 00          0076*   @end: db 0x00 ; padding
041B9A             0077*   
041B9A             0078*   ; Copy system font to buffer
041B9A             0079*   ; inputs: hl = bufferId
041B9A             0080*   ; VDU 23, 0, &95, 5, bufferId;: Copy system font to buffer
041B9A             0081*   vdu_font_copy_system:
041B9A 22 AD 1B 04 0082*       ld (@bufferId),hl
041B9E 21 A9 1B 04 0083*       ld hl,@cmd
041BA2 01 06 00 00 0084*       ld bc,@end-@cmd
041BA6 5B DF       0085*       rst.lil $18
041BA8 C9          0086*       ret
041BA9 17 00 95 05 0087*   @cmd: db 23, 0, 0x95, 5
041BAD 00 00       0088*   @bufferId: dw 0x0000
041BAF 00          0089*   @end: db 0x00 ; padding
041BB0             0042        include "vdu_plot.inc"
041BB0             0001*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
041BB0             0002*   ; PLOT code 	(Decimal) 	Effect
041BB0             0003*   ; &00-&07 	0-7 	Solid line, includes both ends
041BB0             0004*   plot_sl_both: equ 0x00
041BB0             0005*   
041BB0             0006*   ; &08-&0F 	8-15 	Solid line, final point omitted
041BB0             0007*   plot_sl_first: equ 0x08
041BB0             0008*   
041BB0             0009*   ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
041BB0             0010*   ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
041BB0             0011*   
041BB0             0012*   ; &20-&27 	32-39 	Solid line, first point omitted
041BB0             0013*   plot_sl_last: equ 0x20
041BB0             0014*   
041BB0             0015*   ; &28-&2F 	40-47 	Solid line, both points omitted
041BB0             0016*   plot_sl_none: equ 0x28
041BB0             0017*   
041BB0             0018*   ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
041BB0             0019*   ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
041BB0             0020*   
041BB0             0021*   ; &40-&47 	64-71 	Point plot
041BB0             0022*   plot_pt: equ 0x40
041BB0             0023*   
041BB0             0024*   ; &48-&4F 	72-79 	Line fill left and right to non-background Â§Â§
041BB0             0025*   plot_lf_lr_non_bg: equ 0x48
041BB0             0026*   
041BB0             0027*   ; &50-&57 	80-87 	Triangle fill
041BB0             0028*   plot_tf: equ 0x50
041BB0             0029*   
041BB0             0030*   ; &58-&5F 	88-95 	Line fill right to background Â§Â§
041BB0             0031*   plot_lf_r_bg: equ 0x58
041BB0             0032*   
041BB0             0033*   ; &60-&67 	96-103 	Rectangle fill
041BB0             0034*   plot_rf: equ 0x60
041BB0             0035*   
041BB0             0036*   ; &68-&6F 	104-111 	Line fill left and right to foreground Â§Â§
041BB0             0037*   plot_lf_lr_fg: equ 0x60
041BB0             0038*   
041BB0             0039*   ; &70-&77 	112-119 	Parallelogram fill
041BB0             0040*   plot_pf: equ 0x70
041BB0             0041*   
041BB0             0042*   ; &78-&7F 	120-127 	Line fill right to non-foreground Â§Â§
041BB0             0043*   plot_lf_r_non_fg: equ 0x78
041BB0             0044*   
041BB0             0045*   ; &80-&87 	128-135 	Not supported (Flood until non-background)
041BB0             0046*   ; &88-&8F 	136-143 	Not supported (Flood until foreground)
041BB0             0047*   
041BB0             0048*   ; &90-&97 	144-151 	Circle outline
041BB0             0049*   plot_co: equ 0x90
041BB0             0050*   
041BB0             0051*   ; &98-&9F 	152-159 	Circle fill
041BB0             0052*   plot_cf: equ 0x98
041BB0             0053*   
041BB0             0054*   ; &A0-&A7 	160-167 	Not supported (Circular arc)
041BB0             0055*   ; &A8-&AF 	168-175 	Not supported (Circular segment)
041BB0             0056*   ; &B0-&B7 	176-183 	Not supported (Circular sector)
041BB0             0057*   
041BB0             0058*   ; &B8-&BF 	184-191 	Rectangle copy/move
041BB0             0059*   plot_rcm: equ 0xB8
041BB0             0060*   
041BB0             0061*   ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
041BB0             0062*   ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
041BB0             0063*   ; &D0-&D7 	208-215 	Not defined
041BB0             0064*   ; &D8-&DF 	216-223 	Not defined
041BB0             0065*   ; &E0-&E7 	224-231 	Not defined
041BB0             0066*   
041BB0             0067*   ; &E8-&EF 	232-239 	Bitmap plot Â§
041BB0             0068*   plot_bmp: equ 0xE8
041BB0             0069*   
041BB0             0070*   ; &F0-&F7 	240-247 	Not defined
041BB0             0071*   ; &F8-&FF 	248-255 	Not defined
041BB0             0072*   
041BB0             0073*   ; Â§ Support added in Agon Console8 VDP 2.1.0 Â§Â§ Support added in
041BB0             0074*   ; Agon Console8 VDP 2.2.0
041BB0             0075*   
041BB0             0076*   ; Within each group of eight plot codes, the effects are as follows:
041BB0             0077*   ; Plot code 	Effect
041BB0             0078*   ; 0 	Move relative
041BB0             0079*   mv_rel: equ 0
041BB0             0080*   
041BB0             0081*   ; 1 	Plot relative in current foreground colour
041BB0             0082*   dr_rel_fg: equ 1
041BB0             0083*   
041BB0             0084*   ; 2 	Not supported (Plot relative in logical inverse colour)
041BB0             0085*   ; 3 	Plot relative in current background colour
041BB0             0086*   dr_rel_bg: equ 3
041BB0             0087*   
041BB0             0088*   ; 4 	Move absolute
041BB0             0089*   mv_abs: equ 4
041BB0             0090*   
041BB0             0091*   ; 5 	Plot absolute in current foreground colour
041BB0             0092*   dr_abs_fg: equ 5
041BB0             0093*   
041BB0             0094*   ; 6 	Not supported (Plot absolute in logical inverse colour)
041BB0             0095*   ; 7 	Plot absolute in current background colour
041BB0             0096*   dr_abs_bg: equ 7
041BB0             0097*   
041BB0             0098*   ; Codes 0-3 use the position data provided as part of the command
041BB0             0099*   ; as a relative position, adding the position given to the current
041BB0             0100*   ; graphical cursor position. Codes 4-7 use the position data provided
041BB0             0101*   ; as part of the command as an absolute position, setting the current
041BB0             0102*   ; graphical cursor position to the position given.
041BB0             0103*   
041BB0             0104*   ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
041BB0             0105*   ; current pixel colour. These operations cannot currently be supported
041BB0             0106*   ; by the graphics system the Agon VDP uses, so these codes are not
041BB0             0107*   ; supported. Support for these codes may be added in a future version
041BB0             0108*   ; of the VDP firmware.
041BB0             0109*   
041BB0             0110*   ; 16 colour palette constants
041BB0             0111*   c_black: equ 0
041BB0             0112*   c_red_dk: equ 1
041BB0             0113*   c_green_dk: equ 2
041BB0             0114*   c_yellow_dk: equ 3
041BB0             0115*   c_blue_dk: equ 4
041BB0             0116*   c_magenta_dk: equ 5
041BB0             0117*   c_cyan_dk: equ 6
041BB0             0118*   c_grey: equ 7
041BB0             0119*   c_grey_dk: equ 8
041BB0             0120*   c_red: equ 9
041BB0             0121*   c_green: equ 10
041BB0             0122*   c_yellow: equ 11
041BB0             0123*   c_blue: equ 12
041BB0             0124*   c_magenta: equ 13
041BB0             0125*   c_cyan: equ 14
041BB0             0126*   c_white: equ 15
041BB0             0127*   
041BB0             0128*   ; VDU 25, mode, x; y;: PLOT command
041BB0             0129*   ; inputs: a=mode, bc=x0, de=y0
041BB0             0130*   vdu_plot:
041BB0 32 CA 1B 04 0131*       ld (@mode),a
041BB4 ED 43 CB 1B 0132*       ld (@x0),bc
       04          
041BB9 ED 53 CD 1B 0133*       ld (@y0),de
       04          
041BBE 21 C9 1B 04 0134*   	ld hl,@cmd
041BC2 01 06 00 00 0135*   	ld bc,@end-@cmd
041BC6 5B DF       0136*   	rst.lil $18
041BC8 C9          0137*   	ret
041BC9 19          0138*   @cmd:   db 25
041BCA 00          0139*   @mode:  db 0
041BCB 00 00       0140*   @x0: 	dw 0
041BCD 00 00       0141*   @y0: 	dw 0
041BCF 00          0142*   @end:   db 0 ; extra byte to soak up deu
041BD0             0143*   
041BD0             0144*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
041BD0             0145*   ; &E8-&EF 	232-239 	Bitmap plot Â§
041BD0             0146*   ; VDU 25, mode, x; y;: PLOT command
041BD0             0147*   ; inputs: bc=x0, de=y0
041BD0             0148*   ; prerequisites: vdu_buff_select
041BD0             0149*   vdu_plot_bmp:
041BD0 ED 43 E7 1B 0150*       ld (@x0),bc
       04          
041BD5 ED 53 E9 1B 0151*       ld (@y0),de
       04          
041BDA 21 E5 1B 04 0152*   	ld hl,@cmd
041BDE 01 06 00 00 0153*   	ld bc,@end-@cmd
041BE2 5B DF       0154*   	rst.lil $18
041BE4 C9          0155*   	ret
041BE5 19          0156*   @cmd:   db 25
041BE6 ED          0157*   @mode:  db plot_bmp+dr_abs_fg ; 0xED
041BE7 00 00       0158*   @x0: 	dw 0x0000
041BE9 00 00       0159*   @y0: 	dw 0x0000
041BEB 00          0160*   @end:   db 0x00 ; padding
041BEC             0161*   
041BEC             0162*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
041BEC             0163*   ; &E8-&EF 	232-239 	Bitmap plot Â§
041BEC             0164*   ; VDU 25, mode, x; y;: PLOT command
041BEC             0165*   ; inputs: bc=x0, de=y0
041BEC             0166*   ; USING 16.8 FIXED POINT COORDINATES
041BEC             0167*   ; inputs: ub.c is x coordinate, ud.e is y coordinate
041BEC             0168*   ;   the fractional portiion of the inputs are truncated
041BEC             0169*   ;   leaving only the 16-bit integer portion
041BEC             0170*   ; prerequisites: vdu_buff_select
041BEC             0171*   vdu_plot_bmp168:
041BEC             0172*   ; populate in the reverse of normal to keep the
041BEC             0173*   ; inputs from stomping on each other
041BEC ED 53 0A 1C 0174*       ld (@y0-1),de
       04          
041BF1 ED 43 08 1C 0175*       ld (@x0-1),bc
       04          
041BF6 3E ED       0176*       ld a,plot_bmp+dr_abs_fg ; 0xED
041BF8 32 08 1C 04 0177*       ld (@mode),a ; restore the mode byte that got stomped on by bcu
041BFC 21 07 1C 04 0178*   	ld hl,@cmd
041C00 01 06 00 00 0179*   	ld bc,@end-@cmd
041C04 5B DF       0180*   	rst.lil $18
041C06 C9          0181*   	ret
041C07 19          0182*   @cmd:   db 25
041C08 ED          0183*   @mode:  db plot_bmp+dr_abs_fg ; 0xED
041C09 00 00       0184*   @x0: 	dw 0x0000
041C0B 00 00       0185*   @y0: 	dw 0x0000
041C0D             0186*   @end:  ; no padding required b/c we shifted de right
041C0D             0187*   
041C0D             0188*   ; draw a filled rectangle
041C0D             0189*   vdu_plot_rf:
041C0D ED 43 34 1C 0190*       ld (@x0),bc
       04          
041C12 ED 53 36 1C 0191*       ld (@y0),de
       04          
041C17 DD 22 3A 1C 0192*       ld (@x1),ix
       04          
041C1C FD 22 3C 1C 0193*       ld (@y1),iy
       04          
041C21 3E 19       0194*       ld a,25 ; we have to reload the 2nd plot command
041C23 32 38 1C 04 0195*       ld (@cmd1),a ; because the 24-bit y0 load stomped on it
041C27 21 32 1C 04 0196*   	ld hl,@cmd0
041C2B 01 0C 00 00 0197*   	ld bc,@end-@cmd0
041C2F 5B DF       0198*   	rst.lil $18
041C31 C9          0199*       ret
041C32 19          0200*   @cmd0:  db 25 ; plot
041C33 04          0201*   @arg0:  db plot_sl_both+mv_abs
041C34 00 00       0202*   @x0:    dw 0x0000
041C36 00 00       0203*   @y0:    dw 0x0000
041C38 19          0204*   @cmd1:  db 25 ; plot
041C39 65          0205*   @arg1:  db plot_rf+dr_abs_fg
041C3A 00 00       0206*   @x1:    dw 0x0000
041C3C 00 00       0207*   @y1:    dw 0x0000
041C3E 00          0208*   @end:   db 0x00 ; padding
041C3F             0209*   
041C3F             0210*   ; draw a filled circle
041C3F             0211*   vdu_plot_cf:
041C3F ED 43 66 1C 0212*       ld (@x0),bc
       04          
041C44 ED 53 68 1C 0213*       ld (@y0),de
       04          
041C49 DD 22 6C 1C 0214*       ld (@x1),ix
       04          
041C4E FD 22 6E 1C 0215*       ld (@y1),iy
       04          
041C53 3E 19       0216*       ld a,25 ; we have to reload the 2nd plot command
041C55 32 6A 1C 04 0217*       ld (@cmd1),a ; because the 24-bit y0 load stomped on it
041C59 21 64 1C 04 0218*   	ld hl,@cmd0
041C5D 01 0C 00 00 0219*   	ld bc,@end-@cmd0
041C61 5B DF       0220*   	rst.lil $18
041C63 C9          0221*       ret
041C64 19          0222*   @cmd0:  db 25 ; plot
041C65 04          0223*   @arg0:  db plot_sl_both+mv_abs
041C66 00 00       0224*   @x0:    dw 0x0000
041C68 00 00       0225*   @y0:    dw 0x0000
041C6A 19          0226*   @cmd1:  db 25 ; plot
041C6B 9D          0227*   @arg1:  db plot_cf+dr_abs_fg
041C6C 00 00       0228*   @x1:    dw 0x0000
041C6E 00 00       0229*   @y1:    dw 0x0000
041C70 00          0230*   @end:   db 0x00 ; padding
041C71             0043        include "vdu_sound.inc"
041C71             0001*   ; enable enough additional channels so that total enabled = max_channels
041C71             0002*   ; inputs: max_channels set
041C71             0003*   ; returns: nothing
041C71             0004*   ; destroys: af, bc, hl
041C71             0005*   vdu_enable_channels:
041C71 3E 01       0006*       ld a,max_channels
041C73 D6 03       0007*       sub 3 ; subtract number of default channels already enabled
041C75 F2 7C 1C 04 0008*       jp p,@loop
041C79 C9          0009*       ret
041C7A 3E 03       0010*       ld a,3 ; first non-default channel
041C7C             0011*   @loop:
041C7C 32 97 1C 04 0012*       ld (@channel),a
041C80 21 94 1C 04 0013*       ld hl,@beg
041C84 01 05 00 00 0014*       ld bc,@end-@beg
041C88 F5          0015*       push af
041C89 5B DF       0016*       rst.lil $18
041C8B F1          0017*       pop af
041C8C 3C          0018*       inc a
041C8D FE 01       0019*       cp max_channels
041C8F C2 7C 1C 04 0020*       jp nz,@loop
041C93 C9          0021*       ret
041C94             0022*   @beg:
041C94 17 00 85    0023*               db 23, 0, $85
041C97 00          0024*   @channel:   db 0
041C98 08          0025*               db 8 ; command 8: enable channel
041C99             0026*   @end:
041C99             0027*   
041C99             0028*   ; disable all but the three default sound channels
041C99             0029*   ; inputs: max_channels set
041C99             0030*   ; outputs: none
041C99             0031*   ; destroys: ah,hl,bc
041C99             0032*   vdu_disable_channels:
041C99 3E 01       0033*       ld a,max_channels
041C9B D6 03       0034*       sub 3 ; subtract number of default channels already enabled
041C9D F2 A4 1C 04 0035*       jp p,@loop
041CA1 C9          0036*       ret
041CA2 3E 03       0037*       ld a,3 ; first non-default channel
041CA4             0038*   @loop:
041CA4 32 BF 1C 04 0039*       ld (@channel),a
041CA8 21 BC 1C 04 0040*       ld hl,@beg
041CAC 01 05 00 00 0041*       ld bc,@end-@beg
041CB0 F5          0042*       push af
041CB1 5B DF       0043*       rst.lil $18
041CB3 F1          0044*       pop af
041CB4 3C          0045*       inc a
041CB5 FE 01       0046*       cp max_channels
041CB7 C2 A4 1C 04 0047*       jp nz,@loop
041CBB C9          0048*       ret
041CBC             0049*   @beg:
041CBC 17 00 85    0050*       db 23, 0, $85
041CBF 00          0051*   @channel: db 0
041CC0 09          0052*       db 9 ; command 9: disable channel
041CC1             0053*   @end:
041CC1             0054*   
041CC1             0055*   
041CC1             0056*   ; ############################################################
041CC1             0057*   ; VDU SOUND API
041CC1             0058*   ; ############################################################
041CC1             0059*   ; Command 0: Play note
041CC1             0060*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
041CC1             0061*       MACRO PLAY_NOTE channel, volume, frequency, duration
041CC1             0062*       ld hl, @PLAY_NOTE_CMD        ; Start of command block
041CC1             0063*       ld bc, @PLAY_NOTE_END - @PLAY_NOTE_CMD  ; Command block size
041CC1             0064*       rst.lil $18
041CC1             0065*       jr @PLAY_NOTE_END
041CC1             0066*   @PLAY_NOTE_CMD:  db 23, 0, 0x85               ; Command header
041CC1             0067*                    db channel                  ; Channel, 0 (commented out)
041CC1             0068*                    db 0                        ; Play note command
041CC1             0069*                    db volume                   ; Volume
041CC1             0070*                    dw frequency                ; Frequency
041CC1             0071*                    dw duration                 ; Duration
041CC1             0072*   @PLAY_NOTE_END:
041CC1             0073*       ENDMACRO
041CC1             0074*   
041CC1             0075*       MACRO MUTE_CHANNEL channel
041CC1             0076*       ld hl, @MUTE_CHANNEL_CMD     ; Start of command block
041CC1             0077*       ld bc, @MUTE_CHANNEL_END - @MUTE_CHANNEL_CMD  ; Command block size
041CC1             0078*       rst.lil $18
041CC1             0079*       jr @MUTE_CHANNEL_END
041CC1             0080*   @MUTE_CHANNEL_CMD: db 23, 0, 0x85             ; Command header
041CC1             0081*                      db channel                ; Channel, 0 (commented out)
041CC1             0082*                      db 2                      ; Set volume command
041CC1             0083*                      db 0                      ; Volume (mute)
041CC1             0084*   @MUTE_CHANNEL_END:
041CC1             0085*       ENDMACRO
041CC1             0086*   
041CC1             0087*   ; inputs: c = channel, b = volume, hl = frequency; de = duration;
041CC1             0088*   vdu_play_note:
041CC1 79          0089*       ld a,c
041CC2 32 E2 1C 04 0090*       ld (@channel),a
041CC6 78          0091*       ld a,b
041CC7 32 E4 1C 04 0092*       ld (@volume),a
041CCB 22 E5 1C 04 0093*       ld (@frequency),hl
041CCF ED 53 E7 1C 0094*       ld (@duration),de
       04          
041CD4 21 DF 1C 04 0095*       ld hl,@cmd
041CD8 01 0A 00 00 0096*       ld bc,@end-@cmd
041CDC 5B DF       0097*       rst.lil $18
041CDE C9          0098*       ret
041CDF 17 00 85    0099*   @cmd:       db 23, 0, 0x85
041CE2 00          0100*   @channel:   db 0x00
041CE3 00          0101*               db 0x00 ; play note command
041CE4 00          0102*   @volume:    db 0x00
041CE5 00 00       0103*   @frequency: dw 0x0000
041CE7 00 00       0104*   @duration:  dw 0x0000
041CE9 00          0105*   @end:       db 0x00 ; padding
041CEA             0106*   
041CEA             0107*   ; Command 1: Status
041CEA             0108*   ; VDU 23, 0, &85, channel, 1
041CEA             0109*   ; inputs: a = channel
041CEA             0110*   ; Returns a bit mask indicating the status of the specified channel, or 255 if the channel is not valid, or has been disabled. The bit mask is as follows:
041CEA             0111*   ; Bit 	Name 	Meaning
041CEA             0112*   ; 0 	Active 	When set this indicates the channel is in use (has an active waveform)
041CEA             0113*   ; 1 	Playing 	Indicates the channel is actively playing a note, and thus will reject calls to play a new note
041CEA             0114*   ; 2 	Indefinite 	Set if the channel is playing an indefinite duration note
041CEA             0115*   ; 3 	Has Volume Envelope 	Set if the channel has a volume envelope
041CEA             0116*   ; 4 	Has Frequency Envelope 	Set if the channel has a frequency envelope
041CEA             0117*   
041CEA             0118*   ; Bits 5-7 are reserved for future use and, for enabled channels, will currently always be zero.
041CEA             0119*   vdu_channel_status:
041CEA 32 FC 1C 04 0120*       ld (@channel),a
041CEE 21 F9 1C 04 0121*       ld hl,@cmd
041CF2 01 05 00 00 0122*       ld bc,@end-@cmd
041CF6 5B DF       0123*       rst.lil $18
041CF8 C9          0124*       ret
041CF9 17 00 85    0125*   @cmd:       db 23, 0, 0x85
041CFC 00          0126*   @channel:   db 0x00
041CFD 01          0127*               db 0x01 ; get channel status command
041CFE             0128*   @end:
041CFE             0129*   
041CFE             0130*   ; VDU 23, 0, &85, channel, 2, volume
041CFE             0131*   ; inputs: c = channel, b = volume
041CFE             0132*   ; Sets the volume of the specified channel. The volume is a value from 0 to 127, where 0 is silent and 127 is full volume. Values over 127 will be treated as 127 (with one exception described later).
041CFE             0133*   
041CFE             0134*   ; Specifying a channel of -1 (or 255) will set the global sound system volume level. (Requires Console8 VDP 2.5.0 or later.)
041CFE             0135*   
041CFE             0136*   ; Using this command provides more direct control over a channel than the play note command. It can be used to adjust the volume of a channel that is already playing a note.
041CFE             0137*   vdu_channel_volume:
041CFE 79          0138*       ld a,c
041CFF 32 16 1D 04 0139*       ld (@channel),a
041D03 78          0140*       ld a,b
041D04 32 18 1D 04 0141*       ld (@volume),a
041D08 21 13 1D 04 0142*       ld hl,@cmd
041D0C 01 06 00 00 0143*       ld bc,@end-@cmd
041D10 5B DF       0144*       rst.lil $18
041D12 C9          0145*       ret
041D13 17 00 85    0146*   @cmd:       db 23, 0, 0x85
041D16 00          0147*   @channel:   db 0x00
041D17 02          0148*               db 0x02 ; set volume command
041D18 00          0149*   @volume:    db 0x00
041D19             0150*   @end:
041D19             0151*   
041D19             0152*   ; VDU 23, 0, &85, channel, 3, frequency;
041D19             0153*   
041D19             0154*   ; Sets the frequency of the specified channel. The frequency is a 16-bit value specifying in Hz the frequency of the note to be played.
041D19             0155*   
041D19             0156*   ; Using this command provides more direct control over a channel than the play note command. It can be used to adjust the frequency of a channel that is already playing a note.
041D19             0157*   
041D19             0158*   ; Returns 1 on success, 0 for failure.
041D19             0159*   vdu_channel_frequency:
041D19 79          0160*       ld a,c
041D1A 32 31 1D 04 0161*       ld (@channel),a
041D1E ED 53 33 1D 0162*       ld (@frequency),de
       04          
041D23 21 2E 1D 04 0163*       ld hl,@cmd
041D27 01 07 00 00 0164*       ld bc,@end-@cmd
041D2B 5B DF       0165*       rst.lil $18
041D2D C9          0166*       ret
041D2E 17 00 85    0167*   @cmd:       db 23, 0, 0x85
041D31 00          0168*   @channel:   db 0x00
041D32 03          0169*               db 0x03 ; set frequency command
041D33 00 00       0170*   @frequency: dw 0x0000
041D35 00          0171*   @end:       db 0x00 ; padding
041D36             0172*   
041D36             0173*   
041D36             0174*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
041D36             0175*   ; inputs: c = channel, b = waveformOrSample, [hl = bufferId]
041D36             0176*   ; Sets the waveform type for a channel to use. The waveformOrSample value is a single byte treated as a signed value.
041D36             0177*   
041D36             0178*   ; Using a negative value for the waveform indicates that a sample should be used instead. For more information see the documentation for the sample command.
041D36             0179*   
041D36             0180*   ; By default a channel is set to use waveform 0 (square wave).
041D36             0181*   
041D36             0182*   ; Valid waveform values are as follows:
041D36             0183*   ; Value 	Waveform
041D36             0184*   ; 0 	Square wave
041D36             0185*   ; 1 	Triangle wave
041D36             0186*   ; 2 	Sawtooth wave
041D36             0187*   ; 3 	Sine wave
041D36             0188*   ; 4 	Noise (simple white noise with no frequency support)
041D36             0189*   ; 5 	VIC Noise (emulates a VIC6561; supports frequency)
041D36             0190*   ; 8 	Sample (specifying a 16-bit buffer ID for sample data)
041D36             0191*   
041D36             0192*   vdu_channel_waveform:
041D36 79          0193*       ld a,c
041D37 32 5C 1D 04 0194*       ld (@channel),a
041D3B 78          0195*       ld a,b
041D3C 32 5E 1D 04 0196*       ld (@waveform),a
041D40 FE 08       0197*       cp 8 ; check if the waveform is a sample
041D42 28 06       0198*       jr z, @sample
041D44 01 06 00 00 0199*       ld bc,@bufferId-@cmd
041D48 18 08       0200*       jr @sendToVdu
041D4A             0201*   @sample:
041D4A 22 5F 1D 04 0202*       ld (@bufferId),hl
041D4E 01 08 00 00 0203*       ld bc,@end-@cmd
041D52             0204*   @sendToVdu:
041D52 21 59 1D 04 0205*       ld hl,@cmd
041D56 5B DF       0206*       rst.lil $18
041D58 C9          0207*       ret
041D59 17 00 85    0208*   @cmd:       db 23, 0, 0x85
041D5C 00          0209*   @channel:   db 0x00
041D5D 04          0210*               db 0x04 ; set waveform command
041D5E 00          0211*   @waveform:  db 0x00
041D5F 00 00       0212*   @bufferId:  dw 0x0000
041D61 00          0213*   @end:       db 0x00 ; padding
041D62             0214*   
041D62             0215*   ; VDU 23, 0, &85, channel (ignored), 5, 2, bufferId; format, [sampleRate;]
041D62             0216*   ; inputs: hl = bufferId; a = format, de = sample rate in Hz
041D62             0217*   ; The format is a single byte giving the format of the sample data. The following formats are supported:
041D62             0218*   ; Value	Description
041D62             0219*   ; 0	8-bit signed
041D62             0220*   ; 1	8-bit unsigned
041D62             0221*   ; The format value can also have modifier bits set to modify the behaviour of the sample. The following modifier bits are supported:
041D62             0222*   ; Value	Description
041D62             0223*   ; 8	sample rate is sent in the next 16-bits
041D62             0224*   ; 16	sample is tuneable
041D62             0225*   ; The default sample rate for samples on the VDP is 16kHz (actually 16.384kHz to be precise).
041D62             0226*   vdu_buffer_to_sound:
041D62 22 82 1D 04 0227*       ld (@bufferId),hl
041D66 C6 08       0228*       add a,8 ; modify format byte to indicate sample rate argument is given
041D68 32 84 1D 04 0229*       ld (@format),a
041D6C ED 53 85 1D 0230*       ld (@sampleRate),de
       04          
041D71 21 7C 1D 04 0231*       ld hl,@cmd
041D75 01 0B 00 00 0232*       ld bc,@end-@cmd
041D79 5B DF       0233*       rst.lil $18
041D7B C9          0234*       ret
041D7C 17 00 85    0235*   @cmd:       db 23, 0, 0x85
041D7F 00          0236*   @channel:   db 0x00 ; ignored
041D80 05          0237*               db 0x05 ; buffer to sound command
041D81 02          0238*               db 0x02 ; command 2 create sample
041D82 00 00       0239*   @bufferId:  dw 0x0000
041D84 00          0240*   @format:    db 0x00
041D85 00 00       0241*   @sampleRate: dw 0x0000
041D87 00          0242*   @end:       db 0x00 ; padding
041D88             0243*   
041D88             0244*   ; Command 13: Set sample rate
041D88             0245*   ; VDU 23, 0, &85, channel, 13, sampleRate;
041D88             0246*   ; inputs: c = channel, hl = sampleRate (Hz)
041D88             0247*   vdu_set_sample_rate:
041D88 79          0248*       ld a,c
041D89 32 9F 1D 04 0249*       ld (@channel),a
041D8D 22 A1 1D 04 0250*       ld (@sampleRate),hl
041D91 21 9C 1D 04 0251*       ld hl,@cmd
041D95 01 07 00 00 0252*       ld bc,@end-@cmd
041D99 5B DF       0253*       rst.lil $18
041D9B C9          0254*       ret
041D9C 17 00 85    0255*   @cmd:       db 23, 0, 0x85
041D9F 00          0256*   @channel:   db 0x00
041DA0 0D          0257*               db 13 ; set sample rate command
041DA1 00 00       0258*   @sampleRate: dw 0x0000
041DA3 00          0259*   @end:       db 0x00 ; padding
041DA4             0260*   
041DA4             0261*   ; load a sound file to a buffer
041DA4             0262*   ; inputs: hl = bufferId ; de = sampleRate in Hz ; iy = pointer to filename
041DA4             0263*   vdu_load_sfx:
041DA4             0264*   ; back up input parameters
041DA4 E5          0265*       push hl ; bufferId
041DA5 D5          0266*       push de ; sample rate
041DA6             0267*   ; load the sound
041DA6 CD E4 18 04 0268*       call vdu_load_buffer_from_file
041DAA             0269*   ; now make the buffer a sound sample
041DAA D1          0270*       pop de ; sample rate
041DAB E1          0271*       pop hl ; bufferId
041DAC AF          0272*       xor a ; zero is the magic number for mono 8-bit signed PCM
041DAD CD 62 1D 04 0273*       call vdu_buffer_to_sound
041DB1 C9          0274*       ret
041DB2             0275*   
041DB2             0276*   
041DB2 00          0277*   last_channel: db 0
041DB3             0278*   max_channels: equ 1
041DB3             0279*   
041DB3             0280*   ; play a sound effect from an already loaded buffer
041DB3             0281*   ; inputs: hl = bufferId ; bc = duration in milliseconds
041DB3             0282*   vdu_play_sfx:
041DB3 22 EB 1D 04 0283*       ld (@bufferId),hl
041DB7 ED 43 F5 1D 0284*       ld (@duration),bc
       04          
041DBC 3E 17       0285*       ld a,23
041DBE 32 ED 1D 04 0286*       ld (@bufferId+2),a
041DC2 3A B2 1D 04 0287*       ld a,(last_channel)
041DC6 3C          0288*       inc a
041DC7             0289*       ; and 31 ; modulo 32
041DC7 FE 01       0290*       cp max_channels
041DC9 C2 CE 1D 04 0291*       jp nz,@load_channel
041DCD AF          0292*       xor a
041DCE             0293*   @load_channel:
041DCE 32 B2 1D 04 0294*       ld (last_channel),a
041DD2 32 E8 1D 04 0295*       ld (@channel0),a
041DD6 32 F0 1D 04 0296*       ld (@channel1),a
041DDA 21 E5 1D 04 0297*       ld hl, @sample
041DDE 01 12 00 00 0298*       ld bc, @sample_end - @sample
041DE2 5B DF       0299*       rst.lil $18
041DE4 C9          0300*       ret
041DE5             0301*   @sample:
041DE5             0302*   ; Command 4: Set waveform
041DE5             0303*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
041DE5 17 00 85    0304*       .db 23,0,$85                        ; do sound
041DE8             0305*   @channel0:
041DE8 00 04 08    0306*       .db 0,4,8 ; channel, command, waveform
041DEB             0307*   @bufferId:
041DEB 00 00       0308*       .dw 0x0000
041DED             0309*   ; Command 0: Play note
041DED             0310*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
041DED 17 00 85    0311*       .db 23,0,$85                        ; do sound
041DF0             0312*   @channel1:
041DF0 00 00 7F    0313*       .db 0,0,127                ; channel, volume
041DF3 00 00       0314*       .dw 0
041DF5             0315*   @duration:                              ; freq (tuneable samples only)
041DF5 00 00       0316*       .dw 0x0000                        ; duration
041DF7             0317*   @sample_end:
041DF7 00          0318*       .db 0x00 ; padding
041DF8             0319*   
041DF8             0320*   ; inputs: c = channel, b = volume, de = sample rate; hl = bufferId;
041DF8             0321*   vdu_play_sample:
041DF8             0322*       ; populate input parameters
041DF8 79          0323*       ld a,c
041DF9 32 2B 1E 04 0324*       ld (@channel0),a
041DFD 32 33 1E 04 0325*       ld (@channel1),a
041E01 32 3A 1E 04 0326*       ld (@channel2),a
041E05 78          0327*       ld a,b
041E06 32 3C 1E 04 0328*       ld (@volume),a
041E0A ED 53 35 1E 0329*       ld (@sampleRate),de
       04          
041E0F 22 2E 1E 04 0330*       ld (@bufferId),hl
041E13 3E 17       0331*       ld a,23
041E15 32 30 1E 04 0332*       ld (@cmd1),a
041E19 32 37 1E 04 0333*       ld (@cmd2),a
041E1D             0334*       ; prep the vdu command string
041E1D 21 28 1E 04 0335*       ld hl, @cmd0
041E21 01 19 00 00 0336*       ld bc, @end - @cmd0
041E25 5B DF       0337*       rst.lil $18
041E27 C9          0338*       ret
041E28             0339*   ; set waveform command
041E28 17 00 85    0340*   @cmd0:       db 23, 0, 0x85
041E2B 00          0341*   @channel0:   db 0x00
041E2C 04          0342*                db 0x04 ; set waveform command
041E2D 08          0343*   @waveform:   db 0x08 ; sample
041E2E 00 00       0344*   @bufferId:   dw 0x0000
041E30             0345*   ; set sample rate command
041E30 17 00 85    0346*   @cmd1:       db 23, 0, 0x85
041E33 00          0347*   @channel1:   db 0x00
041E34 0D          0348*               db 13 ; set sample rate command
041E35 00 00       0349*   @sampleRate: dw 0x0000
041E37             0350*   ; play note command
041E37 17 00 85    0351*   @cmd2:       db 23, 0, 0x85
041E3A 00          0352*   @channel2:   db 0x00
041E3B 00          0353*                db 0x00 ; play note command
041E3C 00          0354*   @volume:     db 0x00
041E3D 00 00       0355*   @frequency:  dw 0x00 ; no effect unless buffer has been set to tuneable sample
041E3F 00 00       0356*   @duration:   dw 0x0000 ; milliseconds: set to -1 to loop indefinitely, 0 to play full duration once
041E41 00          0357*   @end:        db 0x00 ; padding
041E42             0044    
041E42             0045    ; APPLICATION INCLUDES
041E42             0046        include "ascii.inc"
041E42             0001*   agon_jukebox_ascii:
041E42 20 20 20 5F 0002*       db 32,32,32,95,95,95,95,95,32,32,32,32,95,95,95,95,95,95,95,95,32,95,95,95,95,95,95,95,95,32,32,32,32,95,95,95,95,95,95,95,13,10
       5F 5F 5F 5F 
       20 20 20 20 
       5F 5F 5F 5F 
       5F 5F 5F 5F 
       20 5F 5F 5F 
       5F 5F 5F 5F 
       5F 20 20 20 
       20 5F 5F 5F 
       5F 5F 5F 5F 
       0D 0A       
041E6C 20 20 2F 20 0003*       db 32,32,47,32,32,95,32,32,92,32,32,47,32,32,95,95,95,95,95,47,32,92,95,95,95,95,95,32,32,92,32,32,32,92,32,32,32,32,32,32,92,13,10
       20 5F 20 20 
       5C 20 20 2F 
       20 20 5F 5F 
       5F 5F 5F 2F 
       20 5C 5F 5F 
       5F 5F 5F 20 
       20 5C 20 20 
       20 5C 20 20 
       20 20 20 20 
       5C 0D 0A    
041E97 20 2F 20 20 0004*       db 32,47,32,32,47,95,92,32,32,92,47,32,32,32,92,32,32,95,95,95,32,32,47,32,32,32,124,32,32,32,92,32,32,47,32,32,32,124,32,32,32,92,13,10
       2F 5F 5C 20 
       20 5C 2F 20 
       20 20 5C 20 
       20 5F 5F 5F 
       20 20 2F 20 
       20 20 7C 20 
       20 20 5C 20 
       20 2F 20 20 
       20 7C 20 20 
       20 5C 0D 0A 
041EC3 2F 20 20 20 0005*       db 47,32,32,32,32,124,32,32,32,32,92,32,32,32,32,92,95,92,32,32,92,47,32,32,32,32,124,32,32,32,32,92,47,32,32,32,32,124,32,32,32,32,92,13,10
       20 7C 20 20 
       20 20 5C 20 
       20 20 20 5C 
       5F 5C 20 20 
       5C 2F 20 20 
       20 20 7C 20 
       20 20 20 5C 
       2F 20 20 20 
       20 7C 20 20 
       20 20 5C 0D 
       0A          
041EF0 5C 5F 5F 5F 0006*       db 92,95,95,95,95,124,95,95,32,32,47,92,95,95,95,95,95,95,32,32,47,92,95,95,95,95,95,95,95,32,32,47,92,95,95,95,95,124,95,95,32,32,47,13,10
       5F 7C 5F 5F 
       20 20 2F 5C 
       5F 5F 5F 5F 
       5F 5F 20 20 
       2F 5C 5F 5F 
       5F 5F 5F 5F 
       5F 20 20 2F 
       5C 5F 5F 5F 
       5F 7C 5F 5F 
       20 20 2F 0D 
       0A          
041F1D 20 20 20 20 0007*       db 32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,32,92,47,13,10
       20 20 20 20 
       5C 2F 20 20 
       20 20 20 20 
       20 20 5C 2F 
       20 20 20 20 
       20 20 20 20 
       20 5C 2F 20 
       20 20 20 20 
       20 20 20 20 
       5C 2F 0D 0A 
041F49 20 20 20 20 0008*       db 32,32,32,32,32,95,95,95,95,32,95,95,95,95,32,95,95,95,32,95,95,95,95,32,32,95,95,32,95,95,95,95,95,95,95,95,95,95,95,13,10
       20 5F 5F 5F 
       5F 20 5F 5F 
       5F 5F 20 5F 
       5F 5F 20 5F 
       5F 5F 5F 20 
       20 5F 5F 20 
       5F 5F 5F 5F 
       5F 5F 5F 5F 
       5F 5F 5F 0D 
       0A          
041F72 20 20 20 20 0009*       db 32,32,32,32,124,32,32,32,32,124,32,32,32,32,124,32,32,32,92,32,32,32,32,124,47,32,95,124,92,95,32,32,32,95,95,95,95,95,47,13,10
       7C 20 20 20 
       20 7C 20 20 
       20 20 7C 20 
       20 20 5C 20 
       20 20 20 7C 
       2F 20 5F 7C 
       5C 5F 20 20 
       20 5F 5F 5F 
       5F 5F 2F 0D 
       0A          
041F9B 20 20 20 20 0010*       db 32,32,32,32,124,32,32,32,32,124,32,32,32,32,124,32,32,32,47,32,32,32,32,32,32,60,32,32,32,124,32,32,32,32,95,95,41,95,13,10
       7C 20 20 20 
       20 7C 20 20 
       20 20 7C 20 
       20 20 2F 20 
       20 20 20 20 
       20 3C 20 20 
       20 7C 20 20 
       20 20 5F 5F 
       29 5F 0D 0A 
041FC3 2F 5C 5F 5F 0011*       db 47,92,95,95,124,32,32,32,32,124,32,32,32,32,124,32,32,47,124,32,32,32,32,124,32,32,92,32,32,124,32,32,32,32,32,32,32,32,92,13,10
       7C 20 20 20 
       20 7C 20 20 
       20 20 7C 20 
       20 2F 7C 20 
       20 20 20 7C 
       20 20 5C 20 
       20 7C 20 20 
       20 20 20 20 
       20 20 5C 0D 
       0A          
041FEC 5C 5F 5F 5F 0012*       db 92,95,95,95,95,95,95,95,95,124,95,95,95,95,95,95,47,32,124,95,95,95,95,124,95,95,32,92,47,95,95,95,95,95,95,95,32,32,47,13,10
       5F 5F 5F 5F 
       5F 7C 5F 5F 
       5F 5F 5F 5F 
       2F 20 7C 5F 
       5F 5F 5F 7C 
       5F 5F 20 5C 
       2F 5F 5F 5F 
       5F 5F 5F 5F 
       20 20 2F 0D 
       0A          
042015 20 20 20 20 0013*       db 32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,92,47,13,10
       20 20 20 20 
       20 20 20 20 
       20 20 20 20 
       20 20 20 20 
       20 20 20 20 
       20 20 5C 2F 
       20 20 20 20 
       20 20 20 20 
       5C 2F 0D 0A 
04203D 20 20 20 20 0014*       db 32,32,32,32,95,95,95,95,95,95,95,95,95,95,32,95,95,95,95,95,95,95,95,32,32,95,95,95,95,32,32,95,95,95,13,10
       5F 5F 5F 5F 
       5F 5F 5F 5F 
       5F 5F 20 5F 
       5F 5F 5F 5F 
       5F 5F 5F 20 
       20 5F 5F 5F 
       5F 20 20 5F 
       5F 5F 0D 0A 
042061 20 20 20 20 0015*       db 32,32,32,32,92,95,95,95,95,95,95,32,32,32,92,92,95,95,95,95,95,32,32,92,32,92,32,32,32,92,47,32,32,47,13,10
       5C 5F 5F 5F 
       5F 5F 5F 20 
       20 20 5C 5C 
       5F 5F 5F 5F 
       5F 20 20 5C 
       20 5C 20 20 
       20 5C 2F 20 
       20 2F 0D 0A 
042085 20 20 20 20 0016*       db 32,32,32,32,32,124,32,32,32,32,124,32,32,95,47,32,47,32,32,32,124,32,32,32,92,32,92,32,32,32,32,32,47,13,10
       20 7C 20 20 
       20 20 7C 20 
       20 5F 2F 20 
       2F 20 20 20 
       7C 20 20 20 
       5C 20 5C 20 
       20 20 20 20 
       2F 0D 0A    
0420A8 20 20 20 20 0017*       db 32,32,32,32,32,124,32,32,32,32,124,32,32,32,92,47,32,32,32,32,124,32,32,32,32,92,47,32,32,32,32,32,92,13,10
       20 7C 20 20 
       20 20 7C 20 
       20 20 5C 2F 
       20 20 20 20 
       7C 20 20 20 
       20 5C 2F 20 
       20 20 20 20 
       5C 0D 0A    
0420CB 20 20 20 20 0018*       db 32,32,32,32,32,124,95,95,95,95,95,95,32,32,47,92,95,95,95,95,95,95,95,32,32,47,95,95,95,47,92,32,32,92,13,10
       20 7C 5F 5F 
       5F 5F 5F 5F 
       20 20 2F 5C 
       5F 5F 5F 5F 
       5F 5F 5F 20 
       20 2F 5F 5F 
       5F 2F 5C 20 
       20 5C 0D 0A 
0420EF 20 20 20 20 0019*       db 32,32,32,32,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,32,32,32,92,47,32,32,32,32,32,32,92,95,47,13,10
       20 20 20 20 
       20 20 20 20 
       5C 2F 20 20 
       20 20 20 20 
       20 20 20 5C 
       2F 20 20 20 
       20 20 20 5C 
       5F 2F 0D 0A 
042113             0047        include "input_dir.inc"
042113             0001*   get_input:
042113             0002*   @loop:
042113             0003*   ; wait for the user to push a button
042113             0004*       MOSCALL mos_getkey ; a = ascii code of key pressed
042113 3E 00       0001*M1 			LD	A, function
042115 5B CF       0002*M1 			RST.LIL	08h
042117 F3          0005*       di ; disable interrupts
042118             0006*       ; rst.lil 10h ; print the key pressed
042118             0007*   ; app control commands
042118 FE 1B       0008*       cp '\e' ; escape
04211A C8          0009*       ret z ; returns to main, which re-enables interrupts and exits app
04211B             0010*   ; song playing commands
04211B FE 72       0011*       cp 'r' ; random song
04211D CA 2B 22 04 0012*       jp z,ps_play_random
042121 FE 30       0013*       cp '0'
042123 DA 4F 21 04 0014*       jp c,@other ; not a song command
042127 FE 3A       0015*       cp '9'+1
042129 D2 4F 21 04 0016*       jp nc,@other ; not a song command
04212D             0017*   ; new song requested so stop playing current one
04212D F5          0018*       push af ; preserve keypress
04212E CD 1E 22 04 0019*       call ps_close_file
042132 F1          0020*       pop af ; restore keypress
042133             0021*   ; get pointer to song filename and play it
042133 D6 30       0022*       sub '0' ; a = index into filename lut
042135 11 00 00 00 0023*       ld de,0
042139 5F          0024*       ld e,a
04213A 21 00 01 00 0025*       ld hl,256 ; 256 bytes per filename index
04213E CD 67 03 04 0026*       call umul24 ; hl index into the filename table
042142 11 00 2E 05 0027*       ld de,ps_dir_fil_list
042146 19          0028*       add hl,de ; hl points to the filename
042147 22 54 21 04 0029*       ld (current_song_filename),hl ; save song request
04214B C3 57 21 04 0030*       jp play_song ; re-enables interrupts and jp's to get_input when finished
04214F             0031*   @other: ; TODO: other commands
04214F FB          0032*       ei ; reenable interrupts
042150 C3 13 21 04 0033*       jp @loop ; no valid commmand so loop
042154             0034*   ; end get_input
042154             0048        include "play_dir.inc"
042154             0001*   ; stream a song from the SD card
042154             0002*   ; inputs: hl = pointer to filename
042154             0003*   ; requirements: the file must be 8-bit signed PCM mono
042154             0004*   ; uses: sound channels 0 and 1, buffers 0x3000 and 0x3001
042154             0005*   ch0_buffer: equ 0x3000
042154             0006*   ch1_buffer: equ 0x3001
042154             0007*   cmd0_buffer: equ 0x3002
042154             0008*   cmd1_buffer: equ 0x3003
042154 00 00 00    0009*   current_song_filename: dl 0 ; pointer to current song filename
042157             0010*   play_song:
042157 22 54 21 04 0011*       ld (current_song_filename),hl
04215B             0012*   ; stop the PRT timer
04215B CD 25 23 04 0013*       call ps_prt_stop
04215F             0014*   ; tell the user what they've won
04215F 0E 00       0015*       ld c,0 ; left
042161 16 00       0016*       ld d,0 ; top
042163 1E 3E       0017*       ld e,62 ; right
042165 06 01       0018*       ld b,1; bottom
042167 CD 2F 17 04 0019*       call vdu_set_txt_viewport
04216B CD D6 16 04 0020*       call vdu_cls
04216F 2A 54 21 04 0021*       ld hl,(current_song_filename)
042173 CD 60 00 04 0022*       call printInline
042177 50 6C 61 79 0023*       asciz "Playing song: "
       69 6E 67 20 
       73 6F 6E 67 
       3A 20 00    
042186 2A 54 21 04 0024*       ld hl,(current_song_filename)
04218A CD 67 00 04 0025*       call printString ; print the song filename
04218E             0026*   ; reset text viewport for playing breadcrumbs
04218E 0E 00       0027*       ld c,0 ; left
042190 16 01       0028*       ld d,1 ; top
042192 1E 3E       0029*       ld e,62 ; right
042194 06 01       0030*       ld b,1; bottom
042196 CD 2F 17 04 0031*       call vdu_set_txt_viewport
04219A             0032*   ; open the file in read mode
04219A             0033*   ; Open a file
04219A             0034*   ; HLU: Filename
04219A             0035*   ;   C: Mode
04219A             0036*   ; Returns:
04219A             0037*   ;   A: Filehandle, or 0 if couldn't open
04219A 2A 54 21 04 0038*       ld hl,(current_song_filename)
04219E 0E 01       0039*   	ld c,fa_read
0421A0             0040*       MOSCALL mos_fopen
0421A0 3E 0A       0001*M1 			LD	A, function
0421A2 5B CF       0002*M1 			RST.LIL	08h
0421A4 32 FF 2B 04 0041*       ld (ps_filehandle_cur),a
0421A8             0042*   ; read the .wav header data and copy it to the buffer
0421A8 CD 5C 22 04 0043*       call ps_read_wav_header
0421AC             0044*   ; read the first block of data
0421AC CD B9 21 04 0045*       call ps_read_file
0421B0             0046*   ; enable interrupts and start the PRT timer
0421B0 FB          0047*       ei
0421B1 CD 08 23 04 0048*       call ps_prt_start
0421B5             0049*   ; jump to user input loop:
0421B5             0050*   ; the play sample interrupt will return to there
0421B5             0051*   ; and exit app will return to main from there as well
0421B5 C3 13 21 04 0052*       jp get_input
0421B9             0053*   ; end play_song
0421B9             0054*   
0421B9             0055*   ; read the next 1-second's worth of sound data from the file
0421B9             0056*   ; and upload it to the sample buffer
0421B9             0057*   ps_read_file:
0421B9             0058*   ; disable interrupts so load is guaranteed to complete
0421B9 F3          0059*       di
0421BA             0060*   ; print a playing breadcrumb
0421BA 3E 2E       0061*       ld a,'.'
0421BC 5B D7       0062*       rst.lil 10h
0421BE             0063*   ; Read a block of data from a file
0421BE             0064*   ;   C: Filehandle
0421BE             0065*   ; HLU: Pointer to where to write the data to
0421BE             0066*   ; DEU: Number of bytes to read
0421BE             0067*   ; Returns:
0421BE             0068*   ; DEU: Number of bytes read
0421BE 3A FF 2B 04 0069*       ld a,(ps_filehandle_cur)
0421C2 4F          0070*       ld c,a
0421C3 21 00 2E 04 0071*       ld hl,ps_wav_data_start
0421C7 ED 5B 31 2D 0072*       ld de,(ps_wav_sample_rate)
       04          
0421CC             0073*       MOSCALL mos_fread
0421CC 3E 1A       0001*M1 			LD	A, function
0421CE 5B CF       0002*M1 			RST.LIL	08h
0421D0             0074*   ; test de for zero bytes read
0421D0 21 00 00 00 0075*       ld hl,0
0421D4 AF          0076*       xor a ; clear carry
0421D5 ED 52       0077*       sbc hl,de ; hl = 0-chunksize
0421D7 C2 E3 21 04 0078*       jp nz,@load ; we read some data
0421DB             0079*   ; no data read so close file and play a random song
0421DB CD 1E 22 04 0080*       call ps_close_file
0421DF C3 2B 22 04 0081*       jp ps_play_random
0421E3             0082*   ; load a vdu buffer from local memory
0421E3             0083*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0421E3             0084*   @load:
0421E3 3A 7A 22 04 0085*       ld a,(ps_channel)
0421E7 3C          0086*       inc a
0421E8 E6 01       0087*       and 1
0421EA 32 7A 22 04 0088*       ld (ps_channel),a
0421EE 21 00 30 00 0089*       ld hl,ch0_buffer
0421F2 6F          0090*       ld l,a
0421F3 22 7E 22 04 0091*       ld (ps_sampleId),hl
0421F7 CD 90 1A 04 0092*       call vdu_clear_buffer
0421FB 2A 7E 22 04 0093*       ld hl,(ps_sampleId)
0421FF D5          0094*       push de ; chunksize
042200 C1          0095*       pop bc ; how much data to load
042201 11 00 2E 04 0096*       ld de,ps_wav_data_start ; pointer to data
042205 CD 7B 18 04 0097*       call vdu_load_buffer
042209 C9          0098*       ret
04220A             0099*   ; end ps_read_file
04220A             0100*   
04220A             0101*   ; this is called by the PRT timer interrupt
04220A             0102*   ps_play_sample:
04220A             0103*   ; call the command buffer to play the sound
04220A 2A 7E 22 04 0104*       ld hl,(ps_sampleId)
04220E 2C          0105*       inc l
04220F 2C          0106*       inc l
042210 22 7B 22 04 0107*       ld (ps_cmdId),hl ; TODO: perhaps not needed
042214 CD 75 1A 04 0108*       call vdu_call_buffer
042218             0109*   ; load the next chunk of data
042218 CD B9 21 04 0110*       call ps_read_file
04221C             0111*   ; reenable interrupts and return to the user input loop
04221C FB          0112*       ei
04221D C9          0113*       ret
04221E             0114*   ; end ps_play_sample
04221E             0115*   
04221E             0116*   ; close the file
04221E             0117*   ps_close_file:
04221E CD 25 23 04 0118*       call ps_prt_stop ; stop the PRT timer
042222 3A FF 2B 04 0119*       ld a,(ps_filehandle_cur)
042226             0120*       MOSCALL mos_fclose
042226 3E 0B       0001*M1 			LD	A, function
042228 5B CF       0002*M1 			RST.LIL	08h
04222A C9          0121*       ret
04222B             0122*   ; end ps_close_file
04222B             0123*   
04222B             0124*   ; queue a random song to play next
04222B             0125*   ps_play_random:
04222B CD 18 05 04 0126*       call rand_8 ; a = 0-255
04222F 21 00 00 00 0127*       ld hl,0 ; clear hlu and h
042233 6F          0128*       ld l,a
042234 ED 5B D7 29 0129*       ld de,(ps_dir_num_files)
       04          
042239 CD 80 03 04 0130*       call udiv24 ; hl = mod(hl,num_files)
04223D 11 00 01 00 0131*       ld de,256 ; 256 bytes per filename record
042241 CD 67 03 04 0132*       call umul24 ; hl = index into the filename table
042245 11 00 2E 05 0133*       ld de,ps_dir_fil_list
042249 19          0134*       add hl,de ; hl points to the filename
04224A EB          0135*       ex de,hl ; setting up cp hl,de
04224B 2A 54 21 04 0136*       ld hl,(current_song_filename) ; don't play the same song twice in a row
04224F B7          0137*       or a ; clear carry
042250 ED 52       0138*       sbc hl,de
042252 CA 2B 22 04 0139*       jp z,ps_play_random ; same song, try again
042256 EB          0140*       ex de,hl ; pointer back to hl
042257 CD 57 21 04 0141*       call play_song ; hit it
04225B C9          0142*       ret
04225C             0143*   ; end ps_play_random
04225C             0144*   
04225C             0145*   ps_read_wav_header:
04225C             0146*   ; Read a block of data from a file
04225C             0147*   ;   C: Filehandle
04225C             0148*   ; HLU: Pointer to where to write the data to
04225C             0149*   ; DEU: Number of bytes to read
04225C             0150*   ; Returns:
04225C             0151*   ; DEU: Number of bytes read
04225C 3A FF 2B 04 0152*       ld a,(ps_filehandle_cur)
042260 4F          0153*       ld c,a
042261 21 19 2D 04 0154*       ld hl,ps_wav_header
042265 11 4C 00 00 0155*       ld de,wav_header_size
042269             0156*       MOSCALL mos_fread
042269 3E 1A       0001*M1 			LD	A, function
04226B 5B CF       0002*M1 			RST.LIL	08h
04226D             0157*   ; test de for zero bytes read
04226D 21 00 00 00 0158*       ld hl,0
042271 AF          0159*       xor a ; clear carry
042272 ED 52       0160*       sbc hl,de ; hl = 0-chunksize
042274 C8          0161*       ret z ; no data read so return zero to caller
042275             0162*   ; data read so initialize song variables
042275             0163*   ; load play sample command buffers (namely the sample rate for now)
042275 CD 81 22 04 0164*       call load_command_buffers
042279 C9          0165*       ret
04227A             0166*   ; end ps_read_wav_header
04227A             0167*   
04227A             0168*   ; current active channel and bufferId's
04227A 00          0169*   ps_channel: db 0 ; channel number
04227B 00 00 00    0170*   ps_cmdId: dl 0 ; command bufferId
04227E 00 00 00    0171*   ps_sampleId: dl 0 ; sample bufferId
042281             0172*   
042281             0173*   ; end play_song
042281             0174*   
042281             0175*   load_command_buffers:
042281 21 02 30 00 0176*       ld hl,cmd0_buffer
042285 CD 90 1A 04 0177*       call vdu_clear_buffer
042289 2A 31 2D 04 0178*       ld hl,(ps_wav_sample_rate)
04228D 22 D7 22 04 0179*       ld (ps_sr0),hl
042291 3E 17       0180*       ld a,23
042293 32 D9 22 04 0181*       ld (ps_sr0+2),a
042297 21 02 30 00 0182*       ld hl,cmd0_buffer
04229B 01 1D 00 00 0183*       ld bc,ps_cmd0_end-ps_cmd0
04229F 11 CE 22 04 0184*       ld de,ps_cmd0
0422A3 CD 4D 1A 04 0185*       call vdu_write_block_to_buffer
0422A7             0186*   
0422A7 21 03 30 00 0187*       ld hl,cmd1_buffer
0422AB CD 90 1A 04 0188*       call vdu_clear_buffer
0422AF 2A 31 2D 04 0189*       ld hl,(ps_wav_sample_rate)
0422B3 22 F4 22 04 0190*       ld (ps_sr1),hl
0422B7 3E 17       0191*       ld a,23
0422B9 32 F6 22 04 0192*       ld (ps_sr1+2),a
0422BD 21 03 30 00 0193*       ld hl,cmd1_buffer
0422C1 01 1D 00 00 0194*       ld bc,ps_cmd1_end-ps_cmd1
0422C5 11 EB 22 04 0195*       ld de,ps_cmd1
0422C9 CD 4D 1A 04 0196*       call vdu_write_block_to_buffer
0422CD C9          0197*       ret
0422CE             0198*   ps_cmd0:
0422CE             0199*   ; vdu_buffer_to_sound command string
0422CE             0200*   ; Command 5: Buffer to sound
0422CE             0201*   ; VDU 23, 0, &85, channel (ignored), 5, 2, bufferId; format, [sampleRate;]
0422CE 17 00 85    0202*       db 23,0,0x85 ; vdu sound command header
0422D1 00          0203*       db 0x00 ; channel (ignored)
0422D2 05          0204*       db 0x05 ; buffer to sound command
0422D3 02          0205*       db 0x02 ; command 2 create sample
0422D4 00 30       0206*       dw ch0_buffer
0422D6 09          0207*       db 1+8 ; 8-bit unsigned PCM mono, 8 = sample rate argument follows
0422D7             0208*   ps_sr0:
0422D7 00 00       0209*       dw 0x0000 ; sample rate Hz
0422D9             0210*   ; vdu_play_sfx command string
0422D9             0211*   ; Command 4: Set waveform
0422D9             0212*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
0422D9 17 00 85    0213*       db 23,0,$85 ; vdu sound command header
0422DC 00          0214*       db 0 ; channel
0422DD 04          0215*       db 4 ; set waveform command
0422DE 08          0216*       db 8 ; waveform 8 = sample
0422DF 00 30       0217*       dw ch0_buffer ; sample bufferId
0422E1             0218*   ; Command 0: Play note
0422E1             0219*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
0422E1 17 00 85    0220*       db 23,0,$85 ; vdu sound command header
0422E4 00          0221*       db 0 ; channel
0422E5 00          0222*       db 0 ; play note command
0422E6 7F          0223*       db 127  ; volume 127 = max
0422E7 00 00       0224*       dw 0 ; frequency (relevant only for tuneable samples)
0422E9 00 00       0225*       dw 0 ; duration (ms), zero means play one time in full
0422EB             0226*   ps_cmd0_end:
0422EB             0227*   
0422EB             0228*   ps_cmd1:
0422EB             0229*   ; vdu_buffer_to_sound command string
0422EB             0230*   ; Command 5: Buffer to sound
0422EB             0231*   ; VDU 23, 0, &85, channel (ignored), 5, 2, bufferId; format, [sampleRate;]
0422EB 17 00 85    0232*       db 23,0,0x85 ; vdu sound command header
0422EE 00          0233*       db 0x00 ; channel (ignored)
0422EF 05          0234*       db 0x05 ; buffer to sound command
0422F0 02          0235*       db 0x02 ; command 2 create sample
0422F1 01 30       0236*       dw ch1_buffer
0422F3 09          0237*       db 1+8 ; 8-bit unsigned PCM mono, 8 = sample rate argument follows
0422F4             0238*   ps_sr1:
0422F4 00 00       0239*       dw 0x0000 ; sample rate Hz
0422F6             0240*   ; vdu_play_sfx command string
0422F6             0241*   ; Command 4: Set waveform
0422F6             0242*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
0422F6 17 00 85    0243*       db 23,0,$85 ; vdu sound command header
0422F9 01          0244*       db 1 ; channel
0422FA 04          0245*       db 4 ; set waveform command
0422FB 08          0246*       db 8 ; waveform 8 = sample
0422FC 01 30       0247*       dw ch1_buffer ; sample bufferId
0422FE             0248*   ; Command 0: Play note
0422FE             0249*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
0422FE 17 00 85    0250*       db 23,0,$85 ; vdu sound command header
042301 01          0251*       db 1 ; channel
042302 00          0252*       db 0 ; play note command
042303 7F          0253*       db 127  ; volume 127 = max
042304 00 00       0254*       dw 0 ; frequency (relevant only for tuneable samples)
042306 00 00       0255*       dw 0 ; duration (ms), zero means play one time in full
042308             0256*   ps_cmd1_end:
042308             0257*   ; end load_command_buffers
042308             0258*   
042308             0049        include "timer_jukebox.inc"
042308             0001*   ps_prt_reload: equ [72000/2]+1 ; 2 ticks per second at 18.432 MHz with a 256 clock divider
042308             0002*   
042308             0003*   ; start PRT timer
042308             0004*   ps_prt_start:
042308 21 00 00 00 0005*       ld hl,0
04230C 22 47 23 04 0006*       ld (ps_prt_irq_counter),hl
042310 21 A1 8C 00 0007*       ld hl,ps_prt_reload
042314 ED 29 84    0008*       out0 (TMR1_CTL+TMR_RES_LOW),l
042317 ED 21 85    0009*   	out0 (TMR1_CTL+TMR_RES_HIGH),h
04231A             0010*   ; disable timer (in effect, reset it)
04231A 3E 0E       0011*       ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_256 | RST_EN_1 | PRT_EN_0
04231C ED 39 83    0012*   	out0 (TMR1_CTL+TMR_REG_CTL),a
04231F             0013*   ; enable timer,with interrupt and CONTINUOUS mode,clock divider 256
04231F 3E 5F       0014*       ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_256 | RST_EN_1 | PRT_EN_1
042321 ED 39 83    0015*   	out0 (TMR1_CTL+TMR_REG_CTL),a
042324 C9          0016*       ret
042325             0017*   
042325             0018*   ; stop PRT timer
042325             0019*   ps_prt_stop:
042325 3E 0E       0020*       ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_256 | RST_EN_1 | PRT_EN_0
042327 ED 39 83    0021*   	out0 (TMR1_CTL+TMR_REG_CTL),a
04232A C9          0022*       ret
04232B             0023*   
04232B             0024*   ; ===============================================
04232B             0025*   ; PRT Timer Interrupt Handling
04232B             0026*   ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.asm
04232B             0027*   ; -----------------------------------------------
04232B             0028*   ps_prt_irq_init:
04232B             0029*       ; set up interrupt vector table 2
04232B 21 00 00 00 0030*   	ld hl,0
04232F 3A 0C 01 00 0031*   	ld a,($10c)
042333 6F          0032*   	ld l,a
042334 3A 0D 01 00 0033*   	ld a,($10d)
042338 67          0034*   	ld h,a
042339             0035*   
042339             0036*   	; skip over CALL ($c3)
042339 23          0037*   	inc hl
04233A             0038*   	; load address of jump into vector table 2 (in ram)
04233A ED 27       0039*   	ld hl,(hl)
04233C             0040*   
04233C             0041*   	; write CALL ps_prt_irq_handler to vector table 2
04233C 3E C3       0042*   	ld a,$c3
04233E 77          0043*   	ld (hl),a
04233F 23          0044*   	inc hl
042340 11 48 23 04 0045*   	ld de,ps_prt_irq_handler
042344 ED 1F       0046*   	ld (hl),de
042346             0047*   
042346 C9          0048*       ret
042347             0049*   ; end ps_prt_irq_init
042347             0050*   
042347             0051*   ; interrupt routine for playing the next sample
042347             0052*   ps_prt_irq_counter:
042347 00          0053*   	db 0
042348             0054*   ps_prt_irq_handler:
042348 F3          0055*       di
042349 08          0056*       ex af,af'
04234A D9          0057*       exx
04234B             0058*   ; clear sysvar_keyascii
04234B             0059*   	MOSCALL mos_sysvars
04234B 3E 08       0001*M1 			LD	A, function
04234D 5B CF       0002*M1 			RST.LIL	08h
04234F AF          0060*   	xor a
042350 DD 77 05    0061*   	ld (IX+sysvar_keyascii),a
042353             0062*   ; read the timer interrupt and bump the counter
042353 ED 38 83    0063*       in0 a,(TMR1_CTL+TMR_REG_CTL)
042356 3A 47 23 04 0064*       ld a,(ps_prt_irq_counter)
04235A 3C          0065*       inc a
04235B E6 01       0066*       and 1 ; modulo 2
04235D 32 47 23 04 0067*       ld (ps_prt_irq_counter),a
042361             0068*   ; if counter zero, play the next sample
042361 CC 0A 22 04 0069*       call z,ps_play_sample
042365 D9          0070*       exx
042366 08          0071*       ex af,af'
042367 FB          0072*       ei
042368 5B ED 4D    0073*       reti.l
04236B             0074*   ; end ps_prt_irq_handler
04236B             0050        include "wav.inc"
04236B             0001*   ; WAV File Structure Offsets and Descriptions
04236B             0002*   wav_riff:          EQU 0    ; 4 bytes: "RIFF" identifier
04236B             0003*   wav_file_size:     EQU 4    ; 4 bytes: Total file size minus 8 bytes for RIFF header
04236B             0004*   wav_wave:          EQU 8    ; 4 bytes: "WAVE" identifier
04236B             0005*   wav_fmt_marker:    EQU 12   ; 4 bytes: "fmt " subchunk marker
04236B             0006*   wav_fmt_size:      EQU 16   ; 4 bytes: Format chunk size (16 for PCM)
04236B             0007*   wav_audio_format:  EQU 20   ; 2 bytes: Audio format (1 = PCM)
04236B             0008*   wav_num_channels:  EQU 22   ; 2 bytes: Number of channels (1 = mono, 2 = stereo)
04236B             0009*   wav_sample_rate:   EQU 24   ; 4 bytes: Sample rate in Hz (e.g., 32768)
04236B             0010*   wav_byte_rate:     EQU 28   ; 4 bytes: Bytes per second (SampleRate * NumChannels * BitsPerSample / 8)
04236B             0011*   wav_block_align:   EQU 32   ; 2 bytes: Bytes per sample block (NumChannels * BitsPerSample / 8)
04236B             0012*   wav_bits_per_sample: EQU 34 ; 2 bytes: Bits per sample (e.g., 8 or 16)
04236B             0013*   
04236B             0014*   ; LIST Chunk (Extra Metadata)
04236B             0015*   wav_list_marker:   EQU 36   ; 4 bytes: "LIST" marker
04236B             0016*   wav_list_size:     EQU 40   ; 4 bytes: Size of the LIST chunk (e.g., 26)
04236B             0017*   wav_info_marker:   EQU 44   ; 4 bytes: "INFO" marker
04236B             0018*   wav_isft_marker:   EQU 48   ; 4 bytes: "ISFT" marker (software identifier)
04236B             0019*   wav_isft_data:     EQU 52   ; 14 bytes: Software info string (e.g., "Lavf59.27.100")
04236B             0020*   wav_isft_padding:  EQU 66   ; 2 bytes: Padding/NULL terminator for alignment
04236B             0021*   
04236B             0022*   ; Data Chunk
04236B             0023*   wav_data_marker:   EQU 68   ; 4 bytes: "data" subchunk marker
04236B             0024*   wav_data_size:     EQU 72   ; 4 bytes: Size of the audio data in bytes
04236B             0025*   wav_data_start:    EQU 76   ; Start of audio data
04236B             0026*   wav_header_size:   EQU wav_data_start ; Total Header Size: 76 bytes
04236B             0051        include "debug.inc"
04236B             0001*   printHexA:
04236B F5          0002*       push af
04236C C5          0003*       push bc
04236D CD AE 00 04 0004*       call printHex8
042371 3E 20       0005*       ld a,' '
042373 5B D7       0006*       rst.lil 10h
042375 C1          0007*       pop bc
042376 F1          0008*       pop af
042377 C9          0009*       ret
042378             0010*   
042378             0011*   printHexHL:
042378 F5          0012*       push af
042379 C5          0013*       push bc
04237A CD A8 00 04 0014*       call printHex16
04237E 3E 20       0015*       ld a,' '
042380 5B D7       0016*       rst.lil 10h
042382 C1          0017*       pop bc
042383 F1          0018*       pop af
042384 C9          0019*       ret
042385             0020*   
042385             0021*   printHexUHL:
042385 F5          0022*       push af
042386 C5          0023*       push bc
042387 CD A0 00 04 0024*       call printHex24
04238B 3E 20       0025*       ld a,' '
04238D 5B D7       0026*       rst.lil 10h
04238F C1          0027*       pop bc
042390 F1          0028*       pop af
042391 C9          0029*       ret
042392             0030*   
042392             0031*   printHexAUHL:
042392 F5          0032*       push af
042393 C5          0033*       push bc
042394 CD AE 00 04 0034*       call printHex8
042398 3E 2E       0035*       ld a,'.'
04239A 5B D7       0036*       rst.lil 10h
04239C CD A0 00 04 0037*       call printHex24
0423A0 3E 20       0038*       ld a,' '
0423A2 5B D7       0039*       rst.lil 10h
0423A4 C1          0040*       pop bc
0423A5 F1          0041*       pop af
0423A6 C9          0042*       ret
0423A7             0043*   
0423A7             0044*   printHexABHL:
0423A7             0045*   ; preserve registers
0423A7 C5          0046*       push bc ; b will be ok c will not
0423A8 F5          0047*       push af ; will get totally destroyed
0423A9             0048*   ; print a
0423A9 CD AE 00 04 0049*       call printHex8
0423AD             0050*   ; print b
0423AD 78          0051*       ld a,b
0423AE CD AE 00 04 0052*       call printHex8
0423B2             0053*   ; print hl
0423B2 CD A8 00 04 0054*       call printHex16
0423B6             0055*   ; restore registers
0423B6 F1          0056*       pop af
0423B7 C1          0057*       pop bc
0423B8 C9          0058*       ret
0423B9             0059*   
0423B9             0060*   printHexBHL:
0423B9             0061*   ; preserve registers
0423B9 C5          0062*       push bc ; b will be ok c will not
0423BA F5          0063*       push af ; will get totally destroyed
0423BB             0064*   ; print b
0423BB 78          0065*       ld a,b
0423BC CD AE 00 04 0066*       call printHex8
0423C0             0067*   ; print hl
0423C0 CD A8 00 04 0068*       call printHex16
0423C4             0069*   ; restore registers
0423C4 F1          0070*       pop af
0423C5 C1          0071*       pop bc
0423C6 C9          0072*       ret
0423C7             0073*   
0423C7             0074*   printHexCDE:
0423C7             0075*   ; preserve registers
0423C7 C5          0076*       push bc ; b will be ok c will not
0423C8 F5          0077*       push af ; will get totally destroyed
0423C9             0078*   ; print c
0423C9 79          0079*       ld a,c
0423CA CD AE 00 04 0080*       call printHex8
0423CE             0081*   ; print de
0423CE EB          0082*       ex de,hl
0423CF CD A8 00 04 0083*       call printHex16
0423D3 EB          0084*       ex de,hl
0423D4             0085*   ; restore registers
0423D4 F1          0086*       pop af
0423D5 C1          0087*       pop bc
0423D6 C9          0088*       ret
0423D7             0089*   
0423D7             0090*   printHexUIX:
0423D7             0091*   ; store everything in scratch
0423D7 22 35 03 04 0092*       ld (uhl),hl
0423DB ED 43 38 03 0093*       ld (ubc),bc
       04          
0423E0 ED 53 3B 03 0094*       ld (ude),de
       04          
0423E5 DD 22 3E 03 0095*       ld (uix),ix
       04          
0423EA FD 22 41 03 0096*       ld (uiy),iy
       04          
0423EF F5          0097*       push af ; fml
0423F0             0098*   
0423F0 21 CC 02 04 0099*       ld hl,str_ixu
0423F4 CD 67 00 04 0100*       call printString
0423F8 2A 3E 03 04 0101*       ld hl,(uix)
0423FC CD A0 00 04 0102*       call printHex24
042400 CD 7C 00 04 0103*       call printNewLine
042404             0104*   
042404             0105*   ; restore everything
042404 2A 35 03 04 0106*       ld hl, (uhl)
042408 ED 4B 38 03 0107*       ld bc, (ubc)
       04          
04240D ED 5B 3B 03 0108*       ld de, (ude)
       04          
042412 DD 2A 3E 03 0109*       ld ix, (uix)
       04          
042417 FD 2A 41 03 0110*       ld iy, (uiy)
       04          
04241C F1          0111*       pop af
04241D             0112*   ; all done
04241D C9          0113*       ret
04241E             0114*   
04241E             0115*   
04241E             0116*   ; print registers to screen in hexidecimal format
04241E             0117*   ; inputs: none
04241E             0118*   ; outputs: values of every register printed to screen
04241E             0119*   ;    values of each register in global scratch memory
04241E             0120*   ; destroys: nothing
04241E             0121*   stepRegistersHex:
04241E             0122*   ; store everything in scratch
04241E 22 35 03 04 0123*       ld (uhl),hl
042422 ED 43 38 03 0124*       ld (ubc),bc
       04          
042427 ED 53 3B 03 0125*       ld (ude),de
       04          
04242C DD 22 3E 03 0126*       ld (uix),ix
       04          
042431 FD 22 41 03 0127*       ld (uiy),iy
       04          
042436 F5          0128*       push af ; fml
042437 E1          0129*       pop hl ; thanks, zilog
042438 22 32 03 04 0130*       ld (uaf),hl
04243C F5          0131*       push af ; dammit
04243D             0132*   
04243D             0133*   ; home the cursor
04243D             0134*       ; call vdu_home_cursor
04243D             0135*   
04243D             0136*   ; print each register
04243D 21 B8 02 04 0137*       ld hl,str_afu
042441 CD 67 00 04 0138*       call printString
042445 2A 32 03 04 0139*       ld hl,(uaf)
042449 CD A0 00 04 0140*       call printHex24
04244D CD 7C 00 04 0141*       call printNewLine
042451             0142*   
042451 21 BD 02 04 0143*       ld hl,str_hlu
042455 CD 67 00 04 0144*       call printString
042459 2A 35 03 04 0145*       ld hl,(uhl)
04245D CD A0 00 04 0146*       call printHex24
042461 CD 7C 00 04 0147*       call printNewLine
042465             0148*   
042465 21 C2 02 04 0149*       ld hl,str_bcu
042469 CD 67 00 04 0150*       call printString
04246D 2A 38 03 04 0151*       ld hl,(ubc)
042471 CD A0 00 04 0152*       call printHex24
042475 CD 7C 00 04 0153*       call printNewLine
042479             0154*   
042479 21 C7 02 04 0155*       ld hl,str_deu
04247D CD 67 00 04 0156*       call printString
042481 2A 3B 03 04 0157*       ld hl,(ude)
042485 CD A0 00 04 0158*       call printHex24
042489 CD 7C 00 04 0159*       call printNewLine
04248D             0160*   
04248D 21 CC 02 04 0161*       ld hl,str_ixu
042491 CD 67 00 04 0162*       call printString
042495 2A 3E 03 04 0163*       ld hl,(uix)
042499 CD A0 00 04 0164*       call printHex24
04249D CD 7C 00 04 0165*       call printNewLine
0424A1             0166*   
0424A1 21 D1 02 04 0167*       ld hl,str_iyu
0424A5 CD 67 00 04 0168*       call printString
0424A9 2A 41 03 04 0169*       ld hl,(uiy)
0424AD CD A0 00 04 0170*       call printHex24
0424B1 CD 7C 00 04 0171*       call printNewLine
0424B5             0172*   
0424B5             0173*       ; call vsync
0424B5             0174*   
0424B5 CD 7C 00 04 0175*       call printNewLine
0424B9             0176*   
0424B9             0177*   ; check for right shift key and quit if pressed
0424B9             0178*       MOSCALL mos_getkbmap
0424B9 3E 1E       0001*M1 			LD	A, function
0424BB 5B CF       0002*M1 			RST.LIL	08h
0424BD             0179*   @stayhere:
0424BD             0180*   ; 7 RightShift
0424BD DD CB 00 76 0181*       bit 6,(ix+0)
0424C1 20 02       0182*       jr nz,@RightShift
0424C3 18 F8       0183*       jr @stayhere
0424C5             0184*   @RightShift:
0424C5 DD CB 0E 86 0185*       res 0,(ix+14) ; debounce the key (hopefully)
0424C9 3E 80       0186*       ld a,%10000000
0424CB             0187*       ; call multiPurposeDelay
0424CB             0188*   
0424CB             0189*   ; restore everything
0424CB 2A 35 03 04 0190*       ld hl, (uhl)
0424CF ED 4B 38 03 0191*       ld bc, (ubc)
       04          
0424D4 ED 5B 3B 03 0192*       ld de, (ude)
       04          
0424D9 DD 2A 3E 03 0193*       ld ix, (uix)
       04          
0424DE FD 2A 41 03 0194*       ld iy, (uiy)
       04          
0424E3 F1          0195*       pop af
0424E4             0196*   ; all done
0424E4 C9          0197*       ret
0424E5             0198*   
0424E5             0199*   ; print registers to screen in hexidecimal format
0424E5             0200*   ; inputs: none
0424E5             0201*   ; outputs: values of every register printed to screen
0424E5             0202*   ;    values of each register in global scratch memory
0424E5             0203*   ; destroys: nothing
0424E5             0204*   dumpRegistersHex:
0424E5             0205*   ; store everything in scratch
0424E5 22 35 03 04 0206*       ld (uhl),hl
0424E9 ED 43 38 03 0207*       ld (ubc),bc
       04          
0424EE ED 53 3B 03 0208*       ld (ude),de
       04          
0424F3 DD 22 3E 03 0209*       ld (uix),ix
       04          
0424F8 FD 22 41 03 0210*       ld (uiy),iy
       04          
0424FD F5          0211*       push af ; fml
0424FE E1          0212*       pop hl ; thanks, zilog
0424FF 22 32 03 04 0213*       ld (uaf),hl
042503 F5          0214*       push af ; dammit
042504             0215*   
042504             0216*   ; home the cursor
042504             0217*       ; call vdu_home_cursor
042504             0218*       ; call printNewLine
042504             0219*   
042504             0220*   ; print each register
042504 21 B8 02 04 0221*       ld hl,str_afu
042508 CD 67 00 04 0222*       call printString
04250C 2A 32 03 04 0223*       ld hl,(uaf)
042510 CD A0 00 04 0224*       call printHex24
042514 CD 7C 00 04 0225*       call printNewLine
042518             0226*   
042518 21 BD 02 04 0227*       ld hl,str_hlu
04251C CD 67 00 04 0228*       call printString
042520 2A 35 03 04 0229*       ld hl,(uhl)
042524 CD A0 00 04 0230*       call printHex24
042528 CD 7C 00 04 0231*       call printNewLine
04252C             0232*   
04252C 21 C2 02 04 0233*       ld hl,str_bcu
042530 CD 67 00 04 0234*       call printString
042534 2A 38 03 04 0235*       ld hl,(ubc)
042538 CD A0 00 04 0236*       call printHex24
04253C CD 7C 00 04 0237*       call printNewLine
042540             0238*   
042540 21 C7 02 04 0239*       ld hl,str_deu
042544 CD 67 00 04 0240*       call printString
042548 2A 3B 03 04 0241*       ld hl,(ude)
04254C CD A0 00 04 0242*       call printHex24
042550 CD 7C 00 04 0243*       call printNewLine
042554             0244*   
042554 21 CC 02 04 0245*       ld hl,str_ixu
042558 CD 67 00 04 0246*       call printString
04255C 2A 3E 03 04 0247*       ld hl,(uix)
042560 CD A0 00 04 0248*       call printHex24
042564 CD 7C 00 04 0249*       call printNewLine
042568             0250*   
042568 21 D1 02 04 0251*       ld hl,str_iyu
04256C CD 67 00 04 0252*       call printString
042570 2A 41 03 04 0253*       ld hl,(uiy)
042574 CD A0 00 04 0254*       call printHex24
042578             0255*   
042578 CD 7C 00 04 0256*       call printNewLine
04257C CD 7C 00 04 0257*       call printNewLine
042580             0258*   ; restore everything
042580 2A 35 03 04 0259*       ld hl, (uhl)
042584 ED 4B 38 03 0260*       ld bc, (ubc)
       04          
042589 ED 5B 3B 03 0261*       ld de, (ude)
       04          
04258E DD 2A 3E 03 0262*       ld ix, (uix)
       04          
042593 FD 2A 41 03 0263*       ld iy, (uiy)
       04          
042598 F1          0264*       pop af
042599             0265*   ; all done
042599 C9          0266*       ret
04259A             0267*   
04259A             0268*   dumpRegistersHexPrime:
04259A D9          0269*       exx
04259B 08          0270*       ex af,af'
04259C CD E5 24 04 0271*       call dumpRegistersHex
0425A0 08          0272*       ex af,af'
0425A1 D9          0273*       exx
0425A2 C9          0274*       ret
0425A3             0275*   
0425A3             0276*   ; additionally dump prime registers
0425A3             0277*   ; inputs: none
0425A3             0278*   ; outputs: values of every register printed to screen
0425A3             0279*   ; destroys: nothing
0425A3             0280*   dumpRegistersHexAll:
0425A3 CD E5 24 04 0281*       call dumpRegistersHex
0425A7 08          0282*       ex af,af'
0425A8 D9          0283*       exx
0425A9 CD E5 24 04 0284*       call dumpRegistersHex
0425AD 08          0285*       ex af,af'
0425AE D9          0286*       exx
0425AF C9          0287*       ret
0425B0             0288*   
0425B0             0289*   ; print hlu to screen in hexidecimal format
0425B0             0290*   ; inputs: none
0425B0             0291*   ; destroys: nothing
0425B0             0292*   print_hex_hl:
0425B0 F5          0293*       push af
0425B1 E5          0294*       push hl
0425B2 21 BD 02 04 0295*       ld hl,str_hlu
0425B6 CD 67 00 04 0296*       call printString
0425BA E1          0297*       pop hl
0425BB E5          0298*       push hl
0425BC CD A0 00 04 0299*       call printHex24
0425C0 3E 20       0300*       ld a,' '
0425C2 5B D7       0301*       rst.lil 10h
0425C4 E1          0302*       pop hl
0425C5 F1          0303*       pop af
0425C6 C9          0304*       ret
0425C7             0305*   
0425C7             0306*   ; print bcu to screen in hexidecimal format
0425C7             0307*   ; inputs: none
0425C7             0308*   ; destroys: nothing
0425C7             0309*   print_hex_bc:
0425C7 F5          0310*       push af
0425C8 E5          0311*       push hl
0425C9 C5          0312*       push bc
0425CA 21 C2 02 04 0313*       ld hl,str_bcu
0425CE CD 67 00 04 0314*       call printString
0425D2 E1          0315*       pop hl
0425D3 E5          0316*       push hl
0425D4 CD A0 00 04 0317*       call printHex24
0425D8 3E 20       0318*       ld a,' '
0425DA 5B D7       0319*       rst.lil 10h
0425DC C1          0320*       pop bc
0425DD E1          0321*       pop hl
0425DE F1          0322*       pop af
0425DF C9          0323*       ret
0425E0             0324*   
0425E0             0325*   ; print deu to screen in hexidecimal format
0425E0             0326*   ; inputs: none
0425E0             0327*   ; destroys: nothing
0425E0             0328*   print_hex_de:
0425E0 F5          0329*       push af
0425E1 E5          0330*       push hl
0425E2 D5          0331*       push de
0425E3 21 C7 02 04 0332*       ld hl,str_deu
0425E7 CD 67 00 04 0333*       call printString
0425EB E1          0334*       pop hl
0425EC E5          0335*       push hl
0425ED CD A0 00 04 0336*       call printHex24
0425F1 3E 20       0337*       ld a,' '
0425F3 5B D7       0338*       rst.lil 10h
0425F5 D1          0339*       pop de
0425F6 E1          0340*       pop hl
0425F7 F1          0341*       pop af
0425F8 C9          0342*       ret
0425F9             0343*   
0425F9             0344*   
0425F9             0345*   ; inputs: whatever is in the flags register
0425F9             0346*   ; outputs: binary representation of flags
0425F9             0347*   ;          with a header so we know which is what
0425F9             0348*   ; destroys: nothing
0425F9             0349*   ; preserves: everything
0425F9             0350*   dumpFlags:
0425F9             0351*   ; first we curse zilog for not giving direct access to flags
0425F9 F5          0352*       push af ; this is so we can send it back unharmed
0425FA F5          0353*       push af ; this is so we can pop it to hl
0425FB             0354*   ; store everything in scratch
0425FB 22 35 03 04 0355*       ld (uhl),hl
0425FF ED 43 38 03 0356*       ld (ubc),bc
       04          
042604 ED 53 3B 03 0357*       ld (ude),de
       04          
042609 DD 22 3E 03 0358*       ld (uix),ix
       04          
04260E FD 22 41 03 0359*       ld (uiy),iy
       04          
042613             0360*   ; next we print the header
042613 21 3F 26 04 0361*       ld hl,@header
042617 CD 67 00 04 0362*       call printString
04261B E1          0363*       pop hl ; flags are now in l
04261C 7D          0364*       ld a,l ; flags are now in a
04261D CD 6E 02 04 0365*       call printBin8
042621 CD 7C 00 04 0366*       call printNewLine
042625             0367*   ; restore everything
042625 2A 35 03 04 0368*       ld hl, (uhl)
042629 ED 4B 38 03 0369*       ld bc, (ubc)
       04          
04262E ED 5B 3B 03 0370*       ld de, (ude)
       04          
042633 DD 2A 3E 03 0371*       ld ix, (uix)
       04          
042638 FD 2A 41 03 0372*       ld iy, (uiy)
       04          
04263D F1          0373*       pop af ; send her home the way she came
04263E C9          0374*       ret
04263F             0375*   ; Bit 7 (S): Sign flag
04263F             0376*   ; Bit 6 (Z): Zero flag
04263F             0377*   ; Bit 5 (5): Reserved (copy of bit 5 of the result)
04263F             0378*   ; Bit 4 (H): Half Carry flag
04263F             0379*   ; Bit 3 (3): Reserved (copy of bit 3 of the result)
04263F             0380*   ; Bit 2 (PV): Parity/Overflow flag
04263F             0381*   ; Bit 1 (N): Subtract flag
04263F             0382*   ; Bit 0 (C): Carry flag
04263F 53 5A 78 48 0383*   @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
04264A             0384*   
04264A             0385*   
04264A             0386*   ; print bytes from an address to the screen in hexidecimal format
04264A             0387*   ; inputs: hl = address of first byte to print, a = number of bytes to print
04264A             0388*   ; outputs: values of each byte printed to screen separated by spaces
04264A             0389*   ; destroys: nothing
04264A             0390*   dumpMemoryHex:
04264A             0391*   ; save registers to the stack
04264A C5          0392*       push bc
04264B E5          0393*       push hl
04264C F5          0394*       push af
04264D             0395*   
04264D             0396*   ; print the address and separator
04264D CD A0 00 04 0397*       call printHex24
042651 3E 3A       0398*       ld a,':'
042653 5B D7       0399*       rst.lil 10h
042655 3E 20       0400*       ld a,' '
042657 5B D7       0401*       rst.lil 10h
042659             0402*   
042659             0403*   ; set b to be our loop counter
042659 F1          0404*       pop af
04265A 47          0405*       ld b,a
04265B E1          0406*       pop hl
04265C E5          0407*       push hl
04265D F5          0408*       push af
04265E             0409*   @loop:
04265E             0410*   ; print the byte
04265E 7E          0411*       ld a,(hl)
04265F CD AE 00 04 0412*       call printHex8
042663             0413*   ; print a space
042663 3E 20       0414*       ld a,' '
042665 5B D7       0415*       rst.lil 10h
042667 23          0416*       inc hl
042668 10 F4       0417*       djnz @loop
04266A CD 7C 00 04 0418*       call printNewLine
04266E             0419*   
04266E             0420*   ; restore everything
04266E F1          0421*       pop af
04266F E1          0422*       pop hl
042670 C1          0423*       pop bc
042671             0424*   
042671             0425*   ; all done
042671 C9          0426*       ret
042672             0427*   
042672             0428*   
042672             0429*   ; print bytes from an address to the screen in binary format
042672             0430*   ; inputs: hl = address of first byte to print, a = number of bytes to print
042672             0431*   ; outputs: values of each byte printed to screen separated by spaces
042672             0432*   ; destroys: nothing
042672             0433*   dumpMemoryBin:
042672             0434*   ; save all registers to the stack
042672 F5          0435*       push af
042673 C5          0436*       push bc
042674 D5          0437*       push de
042675 E5          0438*       push hl
042676 DD E5       0439*       push ix
042678 FD E5       0440*       push iy
04267A             0441*   
04267A             0442*   ; set b to be our loop counter
04267A 47          0443*       ld b,a
04267B             0444*   @loop:
04267B             0445*   ; print the byte
04267B 7E          0446*       ld a,(hl)
04267C E5          0447*       push hl
04267D C5          0448*       push bc
04267E CD 6E 02 04 0449*       call printBin8
042682 C1          0450*       pop bc
042683             0451*   ; print a space
042683 3E 20       0452*       ld a,' '
042685 5B D7       0453*       rst.lil 10h
042687 E1          0454*       pop hl
042688 23          0455*       inc hl
042689 10 F0       0456*       djnz @loop
04268B CD 7C 00 04 0457*       call printNewLine
04268F             0458*   
04268F             0459*   ; restore everything
04268F FD E1       0460*       pop iy
042691 DD E1       0461*       pop ix
042693 E1          0462*       pop hl
042694 D1          0463*       pop de
042695 C1          0464*       pop bc
042696 F1          0465*       pop af
042697             0466*   ; all done
042697 C9          0467*       ret
042698             0468*   
042698             0469*   ; print bytes from an address to the screen in binary format
042698             0470*   ; with the bits of each byte in reverse order (lsb first)
042698             0471*   ; inputs: hl = address of first byte to print, a = number of bytes to print
042698             0472*   ; outputs: values of each byte printed to screen separated by spaces
042698             0473*   ; destroys: nothing
042698             0474*   dumpMemoryBinRev:
042698             0475*   ; save all registers to the stack
042698 F5          0476*       push af
042699 C5          0477*       push bc
04269A D5          0478*       push de
04269B E5          0479*       push hl
04269C DD E5       0480*       push ix
04269E FD E5       0481*       push iy
0426A0             0482*   
0426A0             0483*   ; set b to be our loop counter
0426A0 47          0484*       ld b,a
0426A1             0485*   @loop:
0426A1             0486*   ; print the byte
0426A1 7E          0487*       ld a,(hl)
0426A2 E5          0488*       push hl
0426A3 C5          0489*       push bc
0426A4 CD 93 02 04 0490*       call printBin8Rev
0426A8 C1          0491*       pop bc
0426A9             0492*   ; print a space
0426A9 3E 20       0493*       ld a,' '
0426AB 5B D7       0494*       rst.lil 10h
0426AD E1          0495*       pop hl
0426AE 23          0496*       inc hl
0426AF 10 F0       0497*       djnz @loop
0426B1 CD 7C 00 04 0498*       call printNewLine
0426B5             0499*   
0426B5             0500*   ; restore everything
0426B5 FD E1       0501*       pop iy
0426B7 DD E1       0502*       pop ix
0426B9 E1          0503*       pop hl
0426BA D1          0504*       pop de
0426BB C1          0505*       pop bc
0426BC F1          0506*       pop af
0426BD             0507*   ; all done
0426BD C9          0508*       ret
0426BE             0509*   
0426BE             0510*   DEBUG_PRINT:
0426BE             0511*       PUSH_ALL
0426BE 08          0001*M1     ex af,af'
0426BF D9          0002*M1     exx
0426C0 F5          0003*M1     push af
0426C1 E5          0004*M1     push hl
0426C2 C5          0005*M1     push bc
0426C3 D5          0006*M1     push de
0426C4             0007*M1 
0426C4 08          0008*M1     ex af,af'
0426C5 D9          0009*M1     exx
0426C6 F5          0010*M1     push af
0426C7 E5          0011*M1     push hl
0426C8 C5          0012*M1     push bc
0426C9 D5          0013*M1     push de
0426CA DD E5       0014*M1     push ix
0426CC FD E5       0015*M1     push iy
0426CE             0512*       ; ld c,0 ; X
0426CE             0513*       ; ld b,0 ; Y
0426CE             0514*       ; call vdu_move_cursor
0426CE CD 7C 00 04 0515*       call printNewLine
0426D2             0516*       POP_ALL
0426D2 FD E1       0001*M1     pop iy
0426D4 DD E1       0002*M1     pop ix
0426D6 D1          0003*M1     pop de
0426D7 C1          0004*M1     pop bc
0426D8 E1          0005*M1     pop hl
0426D9 F1          0006*M1     pop af
0426DA 08          0007*M1     ex af,af'
0426DB D9          0008*M1     exx
0426DC             0009*M1 
0426DC D1          0010*M1     pop de
0426DD C1          0011*M1     pop bc
0426DE E1          0012*M1     pop hl
0426DF F1          0013*M1     pop af
0426E0 08          0014*M1     ex af,af'
0426E1 D9          0015*M1     exx
0426E2             0517*       PUSH_ALL
0426E2 08          0001*M1     ex af,af'
0426E3 D9          0002*M1     exx
0426E4 F5          0003*M1     push af
0426E5 E5          0004*M1     push hl
0426E6 C5          0005*M1     push bc
0426E7 D5          0006*M1     push de
0426E8             0007*M1 
0426E8 08          0008*M1     ex af,af'
0426E9 D9          0009*M1     exx
0426EA F5          0010*M1     push af
0426EB E5          0011*M1     push hl
0426EC C5          0012*M1     push bc
0426ED D5          0013*M1     push de
0426EE DD E5       0014*M1     push ix
0426F0 FD E5       0015*M1     push iy
0426F2 CD F9 25 04 0518*       call dumpFlags
0426F6             0519*       POP_ALL
0426F6 FD E1       0001*M1     pop iy
0426F8 DD E1       0002*M1     pop ix
0426FA D1          0003*M1     pop de
0426FB C1          0004*M1     pop bc
0426FC E1          0005*M1     pop hl
0426FD F1          0006*M1     pop af
0426FE 08          0007*M1     ex af,af'
0426FF D9          0008*M1     exx
042700             0009*M1 
042700 D1          0010*M1     pop de
042701 C1          0011*M1     pop bc
042702 E1          0012*M1     pop hl
042703 F1          0013*M1     pop af
042704 08          0014*M1     ex af,af'
042705 D9          0015*M1     exx
042706             0520*       PUSH_ALL
042706 08          0001*M1     ex af,af'
042707 D9          0002*M1     exx
042708 F5          0003*M1     push af
042709 E5          0004*M1     push hl
04270A C5          0005*M1     push bc
04270B D5          0006*M1     push de
04270C             0007*M1 
04270C 08          0008*M1     ex af,af'
04270D D9          0009*M1     exx
04270E F5          0010*M1     push af
04270F E5          0011*M1     push hl
042710 C5          0012*M1     push bc
042711 D5          0013*M1     push de
042712 DD E5       0014*M1     push ix
042714 FD E5       0015*M1     push iy
042716 CD E5 24 04 0521*       call dumpRegistersHex
04271A             0522*       ; call waitKeypress
04271A CD 7C 00 04 0523*       call printNewLine
04271E             0524*       POP_ALL
04271E FD E1       0001*M1     pop iy
042720 DD E1       0002*M1     pop ix
042722 D1          0003*M1     pop de
042723 C1          0004*M1     pop bc
042724 E1          0005*M1     pop hl
042725 F1          0006*M1     pop af
042726 08          0007*M1     ex af,af'
042727 D9          0008*M1     exx
042728             0009*M1 
042728 D1          0010*M1     pop de
042729 C1          0011*M1     pop bc
04272A E1          0012*M1     pop hl
04272B F1          0013*M1     pop af
04272C 08          0014*M1     ex af,af'
04272D D9          0015*M1     exx
04272E C9          0525*       ret
04272F             0526*   DEBUG_WAITKEYPRESS:
04272F             0527*       PUSH_ALL
04272F 08          0001*M1     ex af,af'
042730 D9          0002*M1     exx
042731 F5          0003*M1     push af
042732 E5          0004*M1     push hl
042733 C5          0005*M1     push bc
042734 D5          0006*M1     push de
042735             0007*M1 
042735 08          0008*M1     ex af,af'
042736 D9          0009*M1     exx
042737 F5          0010*M1     push af
042738 E5          0011*M1     push hl
042739 C5          0012*M1     push bc
04273A D5          0013*M1     push de
04273B DD E5       0014*M1     push ix
04273D FD E5       0015*M1     push iy
04273F CD 5A 03 04 0528*       call waitKeypress
042743             0529*       POP_ALL
042743 FD E1       0001*M1     pop iy
042745 DD E1       0002*M1     pop ix
042747 D1          0003*M1     pop de
042748 C1          0004*M1     pop bc
042749 E1          0005*M1     pop hl
04274A F1          0006*M1     pop af
04274B 08          0007*M1     ex af,af'
04274C D9          0008*M1     exx
04274D             0009*M1 
04274D D1          0010*M1     pop de
04274E C1          0011*M1     pop bc
04274F E1          0012*M1     pop hl
042750 F1          0013*M1     pop af
042751 08          0014*M1     ex af,af'
042752 D9          0015*M1     exx
042753 C9          0530*       RET
042754             0531*   
042754             0532*   dumpVduCmdStr:
042754             0533*       PUSH_ALL
042754 08          0001*M1     ex af,af'
042755 D9          0002*M1     exx
042756 F5          0003*M1     push af
042757 E5          0004*M1     push hl
042758 C5          0005*M1     push bc
042759 D5          0006*M1     push de
04275A             0007*M1 
04275A 08          0008*M1     ex af,af'
04275B D9          0009*M1     exx
04275C F5          0010*M1     push af
04275D E5          0011*M1     push hl
04275E C5          0012*M1     push bc
04275F D5          0013*M1     push de
042760 DD E5       0014*M1     push ix
042762 FD E5       0015*M1     push iy
042764 79          0534*       ld a,c
042765 CD 4A 26 04 0535*       call dumpMemoryHex
042769 CD 5A 03 04 0536*       call waitKeypress
04276D             0537*       POP_ALL
04276D FD E1       0001*M1     pop iy
04276F DD E1       0002*M1     pop ix
042771 D1          0003*M1     pop de
042772 C1          0004*M1     pop bc
042773 E1          0005*M1     pop hl
042774 F1          0006*M1     pop af
042775 08          0007*M1     ex af,af'
042776 D9          0008*M1     exx
042777             0009*M1 
042777 D1          0010*M1     pop de
042778 C1          0011*M1     pop bc
042779 E1          0012*M1     pop hl
04277A F1          0013*M1     pop af
04277B 08          0014*M1     ex af,af'
04277C D9          0015*M1     exx
04277D C9          0538*       ret
04277E             0539*   ; end dumpVduCmdStr
04277E             0052    
04277E             0053    ; --- MAIN PROGRAM FILE ---
04277E 00          0054    original_screen_mode: db 0
04277F             0055    
04277F             0056    init:
04277F             0057    ; change directory to music
04277F 21 76 28 04 0058        ld hl,cmd_cd_music
042783             0059        MOSCALL mos_oscli
042783 3E 10       0001M1  			LD	A, function
042785 5B CF       0002M1  			RST.LIL	08h
042787             0060    ; call directory page listing
042787 CD 0B 29 04 0061        call get_dir
04278B             0062    ; get current screen mode and save it so we can return to it on exit
04278B CD B5 17 04 0063        call vdu_get_screen_mode
04278F 32 7E 27 04 0064        ld (original_screen_mode),a
042793             0065    ; set up display for gameplay
042793 3E 14       0066        ld a,20
042795 CD A4 17 04 0067        call vdu_set_screen_mode
042799 AF          0068        xor a
04279A CD BD 17 04 0069        call vdu_set_scaling
04279E             0070    ; set text background color
04279E 3E 84       0071        ld a,c_blue_dk+128
0427A0 CD 07 17 04 0072        call vdu_colour_text
0427A4             0073    ; set text foreground color
0427A4 3E 0F       0074        ld a,c_white
0427A6 CD 07 17 04 0075        call vdu_colour_text
0427AA             0076    ; set the cursor off
0427AA CD 9E 16 04 0077        call vdu_cursor_off
0427AE             0078    ; clear the screen
0427AE CD D6 16 04 0079        call vdu_cls
0427B2             0080    ; clear all buffers
0427B2 CD AB 1A 04 0081        call vdu_clear_all_buffers
0427B6             0082    ; load fonts
0427B6 CD 54 05 04 0083    	call fonts_load
0427BA             0084    ; select font
0427BA 21 10 FA 00 0085        ld hl,Lat2_VGA8_8x8
0427BE 3E 01       0086        ld a,1 ; flags
0427C0 CD 1D 1B 04 0087        call vdu_font_select
0427C4             0088    ; print ascii art splash screen
0427C4 CD D6 16 04 0089        call vdu_cls
0427C8 0E 00       0090        ld c,0 ; x
0427CA 06 04       0091        ld b,4 ; y
0427CC CD C2 16 04 0092        call vdu_move_cursor
0427D0 CD 60 00 04 0093        call printInline
0427D4 57 65 6C 63 0094        asciz "Welcome to...\r\n"
       6F 6D 65 20 
       74 6F 2E 2E 
       2E 0D 0A 00 
0427E4 21 42 1E 04 0095        ld hl,agon_jukebox_ascii
0427E8 CD 67 00 04 0096        call printString
0427EC             0097    ; print out current directory path
0427EC CD 7C 00 04 0098        call printNewLine
0427F0 21 A4 28 04 0099        ld hl,str_thick_dashes
0427F4 CD 67 00 04 0100        call printString
0427F8 CD 60 00 04 0101        call printInline
0427FC 0D 0A 4F 75 0102        asciz "\r\nOur current directory is:\r\n"
       72 20 63 75 
       72 72 65 6E 
       74 20 64 69 
       72 65 63 74 
       6F 72 79 20 
       69 73 3A 0D 
       0A 00       
04281A 21 E0 29 04 0103        ld hl,ps_dir_path
04281E CD 67 00 04 0104        call printString
042822 CD 7C 00 04 0105        call printNewLine
042826 21 A4 28 04 0106        ld hl,str_thick_dashes
04282A CD 67 00 04 0107        call printString
04282E             0108    ; print instructions
04282E CD 60 00 04 0109        call printInline
042832 0D 0A 50 72 0110        asciz "\r\nPress keys 0-9 to play a song:\r\n"
       65 73 73 20 
       6B 65 79 73 
       20 30 2D 39 
       20 74 6F 20 
       70 6C 61 79 
       20 61 20 73 
       6F 6E 67 3A 
       0D 0A 00    
042855 21 85 28 04 0111        ld hl,str_dashes
042859 CD 67 00 04 0112        call printString
04285D             0113    ; print first 10 files in the directory
04285D CD 7C 00 04 0114        call printNewLine
042861 CD 96 29 04 0115        call print_dir_page
042865 21 A4 28 04 0116        ld hl,str_thick_dashes
042869 CD 67 00 04 0117        call printString
04286D CD 7C 00 04 0118        call printNewLine
042871             0119    ; initialize play sample timer interrupt handler
042871 CD 2B 23 04 0120        call ps_prt_irq_init
042875 C9          0121        ret
042876             0122    ; end init
042876             0123    
042876 63 64 20 6D 0124    cmd_cd_music: asciz "cd music"
       75 73 69 63 
       00          
04287F 63 64 20 2E 0125    cmd_cd_up: asciz "cd .."
       2E 00       
042885 2D 2D 2D 2D 0126    str_dashes: asciz "------------------------------"
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 2D 2D 
       2D 2D 00    
0428A4 3D 3D 3D 3D 0127    str_thick_dashes: asciz "=============================="
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 3D 3D 
       3D 3D 00    
0428C3             0128    
0428C3             0129    main:
0428C3             0130    ; call get_input to start player
0428C3 CD 13 21 04 0131        call get_input
0428C7             0132    ; user pressed ESC to quit so shut down everytyhing and gracefully exit to MOS
0428C7 CD 25 23 04 0133        call ps_prt_stop ; stop the PRT timer
0428CB FB          0134        ei ; interrupts were disabled by get_input
0428CC             0135    ; restore original screen mode
0428CC 3A 7E 27 04 0136        ld a,(original_screen_mode)
0428D0 CD A4 17 04 0137        call vdu_set_screen_mode
0428D4 CD 9F 17 04 0138        call vdu_reset_viewports
0428D8 CD D6 16 04 0139        call vdu_cls
0428DC             0140    ; change back to directory containing the program
0428DC 21 7F 28 04 0141        ld hl,cmd_cd_up
0428E0             0142        MOSCALL mos_oscli
0428E0 3E 10       0001M1  			LD	A, function
0428E2 5B CF       0002M1  			RST.LIL	08h
0428E4             0143    ; print thanks for playing message
0428E4 CD 60 00 04 0144        call printInline
0428E8 54 68 61 6E 0145        asciz "Thank you for using\r\n"
       6B 20 79 6F 
       75 20 66 6F 
       72 20 75 73 
       69 6E 67 0D 
       0A 00       
0428FE 21 42 1E 04 0146        ld hl,agon_jukebox_ascii
042902 CD 67 00 04 0147        call printString
042906 CD 90 16 04 0148        call vdu_cursor_on
04290A C9          0149        ret ; back to MOS
04290B             0150    ; end main
04290B             0151    
04290B             0152    
04290B             0153    get_dir:
04290B             0154    ; reset filecounter
04290B 21 00 00 00 0155        ld hl,0
04290F 22 D7 29 04 0156        ld (ps_dir_num_files),hl
042913             0157    
042913             0158    ; initialize pointers to store directory info
042913 21 E0 29 04 0159        ld hl,ps_dir_path  ; where to store result
042917 01 FF 00 00 0160        ld bc,255          ; max length
04291B             0161        MOSCALL ffs_getcwd ; MOS api get current working directory
04291B 3E 9E       0001M1  			LD	A, function
04291D 5B CF       0002M1  			RST.LIL	08h
04291F             0162    
04291F             0163    ; ; print out current directory path
04291F             0164    ;     call printInline
04291F             0165    ;     asciz "\r\nOur current directory is:\r\n"
04291F             0166    ;     ld hl,ps_dir_path
04291F             0167    ;     call printString
04291F             0168    ;     call printNewLine
04291F             0169    
04291F             0170    ; now get dir info
04291F 21 E0 2B 04 0171        ld hl,ps_dir_struct ; define where to store directory info
042923 11 E0 29 04 0172        ld de,ps_dir_path   ; this is pointer to the path to the directory
042927             0173        MOSCALL ffs_dopen   ; open dir
042927 3E 91       0001M1  			LD	A, function
042929 5B CF       0002M1  			RST.LIL	08h
04292B             0174    
04292B             0175    _readFileInfo:               ; we will loop here until all files have been processed
04292B 21 E0 2B 04 0176        ld hl,ps_dir_struct      ; HL is where to get directory info
04292F 11 03 2C 04 0177        ld de,ps_filinfo_struct  ; define where to store current file info
042933             0178        MOSCALL ffs_dread        ; read next item from dir
042933 3E 93       0001M1  			LD	A, function
042935 5B CF       0002M1  			RST.LIL	08h
042937             0179    
042937 3A 19 2C 04 0180        ld a,(ps_filinfo_fname)  ; get first char of file name
04293B FE 00       0181        cp 0                     ; if 0 then we are at the end of the listing
04293D 28 25       0182        jr z,_allDone
04293F             0183    
04293F ED 5B D7 29 0184        ld de,(ps_dir_num_files) ; get the current file counter
       04          
042944 21 00 01 00 0185        ld hl,256 ; bytes per filename
042948 CD 67 03 04 0186        call umul24 ; hl = offset into the filename table
04294C 13          0187        inc de                  ; increment the counter
04294D ED 53 D7 29 0188        ld (ps_dir_num_files),de
       04          
042952 11 00 2E 05 0189        ld de,ps_dir_fil_list ; get the address of the filename table
042956 19          0190        add hl,de ; add the offset to the base address
042957 EB          0191        ex de,hl ; de is the destination address to copy the filename
042958 21 19 2C 04 0192        ld hl,ps_filinfo_fname   ; this is pointer to the name of current file
04295C 01 00 01 00 0193        ld bc,256 ; bytes per filename
042960 ED B0       0194        ldir ; copy the filename to the filename table
042962             0195    
042962 18 C7       0196        jr _readFileInfo         ; loop around to check next entry
042964             0197    
042964             0198    _allDone:
042964 21 E0 2B 04 0199        ld hl,ps_dir_struct      ; load H: with address of the DIR struct
042968             0200        MOSCALL ffs_dclose       ; close dir
042968 3E 92       0001M1  			LD	A, function
04296A 5B CF       0002M1  			RST.LIL	08h
04296C C9          0201        ret
04296D             0202    ; end get_dir
04296D             0203    
04296D             0204    print_dir:
04296D             0205    ; loop through the filename table and print out the filenames
04296D DD 21 00 2E 0206        ld ix,ps_dir_fil_list      ; get the address of the filename table
       05          
042972 2A D7 29 04 0207        ld hl,(ps_dir_num_files)   ; get the number of files
042976 E5          0208        push hl ; save loop counter
042977             0209    @print_loop:
042977 DD E5       0210        push ix
042979 E1          0211        pop hl ; get the address of the filename
04297A CD 67 00 04 0212        call printString
04297E CD 7C 00 04 0213        call printNewLine
042982 ED 32 7F    0214        lea ix,ix+127 ; bump the pointer
042985 ED 32 7F    0215        lea ix,ix+127 ; to the next file
042988 ED 32 02    0216        lea ix,ix+2   ; 256 bytes
04298B E1          0217        pop hl ; get the loop counter
04298C 2B          0218        dec hl ; decrement the loop counter
04298D E5          0219        push hl ; save loop counter
04298E             0220        SIGN_HLU ; check for zero
04298E 19          0001M1      add hl,de ; 1 cycle
04298F B7          0002M1      or a ; clear flags ; 1 cycle
042990 ED 52       0003M1      sbc hl,de ; 2 cycles
042992             0004M1      ; 4 cycles total
042992 20 E3       0221        jr nz,@print_loop
042994 E1          0222        pop hl ; dummy pop to balance stack
042995 C9          0223        ret
042996             0224    ; end print_dir
042996             0225    
042996             0226    print_dir_page:
042996             0227    ; loop through the filename table and print out the filenames
042996 DD 21 00 2E 0228        ld ix,ps_dir_fil_list      ; get the address of the filename table
       05          
04299B ED 5B D7 29 0229        ld de,(ps_dir_num_files)   ; get the number of files
       04          
0429A0 21 0A 00 00 0230        ld hl,10 ; max files per page
0429A4 B7          0231        or a ; clear carry
0429A5 ED 52       0232        sbc hl,de ; subtract number of files from 10
0429A7 F2 AF 29 04 0233        jp p,@F ; if >= 0 then we have <= 10 files
0429AB 11 0A 00 00 0234        ld de,10 ; max files per page
0429AF             0235    @@:
0429AF EB          0236        ex de,hl ; hl = number of files to print
0429B0 E5          0237        push hl ; save loop counter
0429B1             0238    @print_loop:
0429B1 3E 0A       0239        ld a,10
0429B3 95          0240        sub l
0429B4             0241        ; cp 10
0429B4             0242        ; jp z,@end ; stop at 10
0429B4 CD 6B 23 04 0243        call printHexA
0429B8 DD E5       0244        push ix
0429BA E1          0245        pop hl ; get the address of the filename
0429BB CD 67 00 04 0246        call printString
0429BF CD 7C 00 04 0247        call printNewLine
0429C3 ED 32 7F    0248        lea ix,ix+127 ; bump the pointer
0429C6 ED 32 7F    0249        lea ix,ix+127 ; to the next file
0429C9 ED 32 02    0250        lea ix,ix+2   ; 256 bytes
0429CC E1          0251        pop hl ; get the loop counter
0429CD 2B          0252        dec hl ; decrement the loop counter
0429CE E5          0253        push hl ; save loop counter
0429CF             0254        SIGN_HLU ; check for zero
0429CF 19          0001M1      add hl,de ; 1 cycle
0429D0 B7          0002M1      or a ; clear flags ; 1 cycle
0429D1 ED 52       0003M1      sbc hl,de ; 2 cycles
0429D3             0004M1      ; 4 cycles total
0429D3 20 DC       0255        jr nz,@print_loop
0429D5             0256    @end:
0429D5 E1          0257        pop hl ; dummy pop to balance stack
0429D6 C9          0258        ret
0429D7             0259    ; end print_dir
0429D7             0260    
0429D7             0261    ; must be final include in program so file data does not stomp on program code or other data
0429D7             0262        include "files.inc"
0429D7             0001*   ; THIS MUST BE LAST INCLUDE SO FILE DATA DOES NOT OVERWRITE OTHER CODE OR DATA
0429D7             0002*   
0429D7             0003*   ; buffer for loading files unrelated to audio
0429D7             0004*   ; e.g.: fonts, sprites, etc. (limited to 8k)
0429D7             0005*   filedata: equ 0xB7E000 ; address of onboard 8k sram
0429D7             0006*   
0429D7             0007*   ; play_song directory info
0429D7 00 00 00    0008*   ps_dir_num_files: dl 0 ; number of files/directories in the directory (virtually unlimited)
0429DA 00 00 00    0009*   ps_page_num_files: dl 0 ; number of files/directories in the current directory page (max 10)
0429DD 00 00 00    0010*   ps_page_cur: dl 0 ; current directory page number
0429E0 00 00 00 00 0011*   ps_dir_path:   blkw 256,0 ; path of the current directory
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042BE0             0012*   ps_dir_struct:
042BE0 00 00 00 00 0013*   ps_dptr:       blkb  4,0   ; Current read/write offset
042BE4 00 00 00 00 0014*   ps_clust:      blkb  4,0   ; Current cluster
042BE8 00 00 00 00 0015*   ps_sect:       blkb  4,0   ; Current sector (0:Read operation has terminated)
042BEC 00 00 00    0016*   ps_dir:        blkb  3,0   ; Pointer to the directory item in the win[]
042BEF 00 00 00 00 0017*   ps_fn:         blkb  12,0  ; SFN (in/out) {body[8],ext[3],status[1]}
       00 00 00 00 
       00 00 00 00 
042BFB 00 00 00 00 0018*   ps_blk_ofs:    blkb  4,0   ; Offset of current entry block being processed (0xFFFFFFFF:Invalid)
042BFF             0019*   
042BFF             0020*   ; play_song file info
042BFF 00          0021*   ps_filehandle_cur: db 0 ; file handle
042C00 00 00 00    0022*   ps_chunkpointer: dl 0 ; pointer to current chunk
042C03             0023*   ; File information structure (FILINFO)
042C03             0024*   ps_filinfo_struct:
042C03 00 00 00 00 0025*   ps_filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
042C07 00 00       0026*   ps_filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
042C09 00 00       0027*   ps_filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
042C0B 00          0028*   ps_filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
042C0C 00 00 00 00 0029*   ps_filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
042C19 00 00 00 00 0030*   ps_filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042D19             0031*   
042D19             0032*   ; buffer for play_song sound data
042D19             0033*   ps_wav_header: ; marker for top of the wav file header and song data
042D19             0034*   ; (must be last so buffer doesn't overwrite other program code or data)
042D19             0035*   ; .wav header data
042D19             0036*   ; WAV File Structure in Memory with LIST Chunk
042D19 00 00 00 00 0037*   ps_wav_riff:          blkb 4,0   ; 4 bytes: "RIFF" identifier
042D1D 00 00 00 00 0038*   ps_wav_file_size:     blkb 4,0   ; 4 bytes: Total file size minus 8 bytes for RIFF header
042D21 00 00 00 00 0039*   ps_wav_wave:          blkb 4,0   ; 4 bytes: "WAVE" identifier
042D25 00 00 00 00 0040*   ps_wav_fmt_marker:    blkb 4,0   ; 4 bytes: "fmt " subchunk marker
042D29 00 00 00 00 0041*   ps_wav_fmt_size:      blkb 4,0   ; 4 bytes: Format chunk size (16 for PCM)
042D2D 00 00       0042*   ps_wav_audio_format:  blkb 2,0   ; 2 bytes: Audio format (1 = PCM)
042D2F 00 00       0043*   ps_wav_num_channels:  blkb 2,0   ; 2 bytes: Number of channels (1 = mono, 2 = stereo)
042D31 00 00 00 00 0044*   ps_wav_sample_rate:   blkb 4,0   ; 4 bytes: Sample rate in Hz (e.g., 32768)
042D35 00 00 00 00 0045*   ps_wav_byte_rate:     blkb 4,0   ; 4 bytes: Bytes per second (SampleRate * NumChannels * BitsPerSample / 8)
042D39 00 00       0046*   ps_wav_block_align:   blkb 2,0   ; 2 bytes: Bytes per sample block (NumChannels * BitsPerSample / 8)
042D3B 00 00       0047*   ps_wav_bits_per_sample: blkb 2,0 ; 2 bytes: Bits per sample (e.g., 8 or 16)
042D3D             0048*   
042D3D             0049*   ; LIST Chunk (Extra Metadata)
042D3D 00 00 00 00 0050*   ps_wav_list_marker:   blkb 4,0   ; 4 bytes: "LIST" marker
042D41 00 00 00 00 0051*   ps_wav_list_size:     blkb 4,0   ; 4 bytes: Size of the LIST chunk (e.g., 26)
042D45 00 00 00 00 0052*   ps_wav_info_marker:   blkb 4,0   ; 4 bytes: "INFO" marker
042D49 00 00 00 00 0053*   ps_wav_isft_marker:   blkb 4,0   ; 4 bytes: "ISFT" marker (software identifier)
042D4D 00 00 00 00 0054*   ps_wav_isft_data:     blkb 14,0  ; 14 bytes: Software info string (e.g., "Lavf59.27.100")
       00 00 00 00 
       00 00 00 00 
       00 00       
042D5B 00 00       0055*   ps_wav_isft_padding:  blkb 2,0   ; 2 bytes: Padding/NULL terminator for alignment
042D5D             0056*   
042D5D             0057*   ; Data Chunk
042D5D 00 00 00 00 0058*   ps_wav_data_marker:   blkb 4,0   ; 4 bytes: "data" subchunk marker
042D61 00 00 00 00 0059*   ps_wav_data_size:     blkb 4,0   ; 4 bytes: Size of the audio data in bytes
042D65             0060*   ; Total Header Size: 76 bytes
042D65             0061*   
042D65 FF FF FF FF 0062*       align 256 ; make things nice for indexing into especially ps_dir_fil_list
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF    
042E00             0063*   ; buffer for sound data
042E00             0064*   ps_wav_data_start:    equ $   ; Start of audio data
042E00             0065*   
042E00             0066*   ; this list can grow as large as necessary to hold all the files in the directory
042E00             0067*   ; each entry will be 256 bytes long, the max filename size MOS/FFS supports
042E00             0068*   ps_dir_fil_list: equ ps_wav_data_start+65536 ; max file data we can load in one chunk is 64k
